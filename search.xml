<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python基本语法</title>
      <link href="/2024/06/25/pylearn/"/>
      <url>/2024/06/25/pylearn/</url>
      
        <content type="html"><![CDATA[<h1 id="python基本语法总结"><a class="markdownIt-Anchor" href="#python基本语法总结"></a> Python基本语法总结</h1><p>本文参考《Python 数据之道》，为重温语法制作。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello Python"</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>Hello Python</code></pre><h1 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h1><p><img src="/.io//Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%80%9F%E6%9F%A5%E8%A1%A8.png" alt=""></p><h2 id="创建字符串"><a class="markdownIt-Anchor" href="#创建字符串"></a> 创建字符串</h2><p>在 Python 中处理文本数据是使用 str 对象，也称为字符串。字符串字面值有多种不同的写法：</p><ul><li>单引号: ‘允许包含有 “双” 引号’</li><li>双引号: “允许包含有 ‘单’ 引号”。</li><li>三重引号: ’‘’ 三重单引号” ’, ””“三重双引号”””</li></ul><p>使用三重引号的字符串可以跨越多行 —— 其中所有的空白字符都将包含在该字符串字面值中</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">s1 = <span class="string">'hello'</span></span><br><span class="line">s2 = <span class="string">"world"</span></span><br><span class="line">s3 = <span class="string">'''</span></span><br><span class="line"><span class="string">    my</span></span><br><span class="line"><span class="string">    python</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="built_in">print</span>(s2)</span><br><span class="line"><span class="built_in">print</span>(s3)</span><br></pre></td></tr></tbody></table></figure><pre><code>helloworld    my    python</code></pre><p>​</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">s4 = <span class="string">'''</span></span><br><span class="line"><span class="string">my</span></span><br><span class="line"><span class="string">python</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="built_in">print</span>(s4)</span><br></pre></td></tr></tbody></table></figure><pre><code>mypython</code></pre><p>​</p><h2 id="访问字符串中的值"><a class="markdownIt-Anchor" href="#访问字符串中的值"></a> 访问字符串中的值</h2><p>字符串（string）支持用切片的方式来访问字符串中的值。该功能在 Python 的 <code>list</code> 中经常会用到。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">s1 = <span class="string">"hello world 你好，Python"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(s1[:<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(s1[<span class="number">6</span>:])</span><br></pre></td></tr></tbody></table></figure><pre><code>hhelloworld 你好，Python</code></pre><h2 id="字符串格式化"><a class="markdownIt-Anchor" href="#字符串格式化"></a> 字符串格式化</h2><p>Python 支持格式化字符串的输出，一般有 3 种方式可以实现，包括 <code>format</code> ，<code>%</code> ，<code>f-string</code> 。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">s1 = <span class="string">'hello'</span></span><br><span class="line">s2 = <span class="string">'world'</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">'s1 = {0}, s2 = {1}'</span>.<span class="built_in">format</span>(s1,s2)</span><br><span class="line"><span class="built_in">print</span>(s3)</span><br></pre></td></tr></tbody></table></figure><pre><code>s1 = hello, s2 = world</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">'s1 = %s, s2 = %s'</span> % (s1,s2))</span><br></pre></td></tr></tbody></table></figure><pre><code>s1 = hello, s2 = world</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f's1 = <span class="subst">{s1}</span>, s2 = <span class="subst">{s2}</span>'</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>s1 = hello, s2 = world</code></pre><h3 id="数字格式化"><a class="markdownIt-Anchor" href="#数字格式化"></a> 数字格式化</h3><p>在进行字符串格式化时，经常会遇到需要经<strong>数字</strong>格式化为<strong>字符串</strong>，并且要按某种特定的格式来显示。</p><p>数字格式化为字符串，可以用 format 、% 或 f-string 方法来实现。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">n1 = <span class="number">1.23456789</span></span><br><span class="line">n2 = <span class="number">12345.6789</span></span><br><span class="line">n3 = <span class="number">0.123456789</span></span><br><span class="line">n4 = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保 留 两 位 小 数 的 数 字 格 式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'保留两位小数：%.2f'</span> % n1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'保留两位小数：{0:.2f}, {1:.2f}'</span>.<span class="built_in">format</span>(n1,n2))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f'保留两位小数：<span class="subst">{n1:<span class="number">.2</span>f}</span>'</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>保留两位小数：1.23保留两位小数：1.23, 12345.68保留两位小数：1.23</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 百分比</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f'百分比：<span class="subst">{n1:<span class="number">.2</span>%}</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 既有千分位分隔符又有精度设定的数字格式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f'百分比：<span class="subst">{n2:,<span class="number">.2</span>f}</span>'</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>百分比：123.46%百分比：12,345.68</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#字符串对齐格式，设置默认宽度为8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f'<span class="subst">{n4:&gt;<span class="number">8</span>}</span>'</span>)         <span class="comment">#右对齐</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f'<span class="subst">{n4:&lt;<span class="number">8</span>}</span>'</span>) <span class="comment">#左对齐</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f'<span class="subst">{n4:^<span class="number">8</span>}</span>'</span>) <span class="comment">#居中对齐</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><pre><code>      1212         12   </code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#数字补零，或者补特定符号，比如‘-’</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f'左边补零：<span class="subst">{n4:<span class="number">0</span>&gt;<span class="number">4</span>}</span>'</span>) <span class="comment">#左边补0，宽度为4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f'右边补 -：<span class="subst">{n4:-&lt;<span class="number">4</span>}</span>'</span>) <span class="comment">#右边补x，宽度为4</span></span><br></pre></td></tr></tbody></table></figure><pre><code>左边补零：0012右边补 -：12--</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">n1 = <span class="number">1.23456</span></span><br><span class="line">n2 = -<span class="number">123.456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 带符号保留小数点后两位</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># +</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'正数前加正号，负数前加负号：'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f'<span class="subst">{n1:+<span class="number">.2</span>f}</span>'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f'<span class="subst">{n2:+<span class="number">.2</span>f}</span>\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'正数前无符号，负数前加负号：'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f'<span class="subst">{n1:-<span class="number">.2</span>f}</span>'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f'<span class="subst">{n2:-<span class="number">.2</span>f}</span>\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 空格</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'正数前加空格，负数前加负号：'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f'<span class="subst">{n1: <span class="number">.2</span>f}</span>'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f'<span class="subst">{n2: <span class="number">.2</span>f}</span>'</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>正数前加正号，负数前加负号：+1.23-123.46正数前无符号，负数前加负号：1.23-123.46正数前加空格，负数前加负号： 1.23-123.46</code></pre><p>数字格式化常见的格式整理如下：</p><p><img src="/.io//fig%5C%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E5%8C%96.png" alt=""></p><h2 id="字符串的基本运算"><a class="markdownIt-Anchor" href="#字符串的基本运算"></a> 字符串的基本运算</h2><h3 id="拼接字符串"><a class="markdownIt-Anchor" href="#拼接字符串"></a> 拼接字符串</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">s1 = <span class="string">'hello'</span></span><br><span class="line">s2 = <span class="string">'world'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1+<span class="string">' '</span>+s2+<span class="string">'!'</span>)</span><br><span class="line"><span class="built_in">print</span>(s1 * <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>hello world!hellohello</code></pre><h3 id="字符串的大小写转换"><a class="markdownIt-Anchor" href="#字符串的大小写转换"></a> 字符串的大小写转换</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">s = <span class="string">'Hello, My world!'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个单词的首字母大写，title()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'每个单词的首字母大写：'</span>,s.title())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 段落的首字母大写，capitalize()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'段落的首字母大写：'</span>,s.capitalize())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有字母小写，lower()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'所有字母小写：'</span>,s.lower())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有字母大写，upper()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'所有字母大写：'</span>,s.upper())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大写转小写，小写转大写，swapcase()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'大写转小写，小写转大写：'</span>,s.swapcase())</span><br></pre></td></tr></tbody></table></figure><pre><code>每个单词的首字母大写： Hello, My World!段落的首字母大写： Hello, my world!所有字母小写： hello, my world!所有字母大写： HELLO, MY WORLD!大写转小写，小写转大写： hELLO, mY WORLD!</code></pre><h3 id="使用换行和制表符"><a class="markdownIt-Anchor" href="#使用换行和制表符"></a> 使用换行和制表符</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># \n 换行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'hello\nworld'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># \t 制表符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'hello\tworld'</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>helloworldhelloworld</code></pre><h3 id="字符串分割"><a class="markdownIt-Anchor" href="#字符串分割"></a> 字符串分割</h3><p>字符串的分割，通常有 <code>split</code> 和 <code>partition</code> 系列方法。</p><ol><li><p>split</p><p>split 系列方法包括 split() 、rsplit() 、splitlines() 等。</p><p>split() 将一个字符串分隔成多个字符串组成的列表，不含分隔符；rsplit() 的功能与 split() 类似，只不过是从字符串最后面开始分割；splitlines() 按照 (\n, \r, \r\n 等) 分隔，分割成列表。</p></li></ol><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">s = <span class="string">'''Technology is evolving at a rapid pace, significantly impacting our daily lives.</span></span><br><span class="line"><span class="string">This progress brings both opportunities and challenges that we must navigate carefully.'''</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></tbody></table></figure><pre><code>Technology is evolving at a rapid pace, significantly impacting our daily lives.This progress brings both opportunities and challenges that we must navigate carefully.</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 按空格分割</span></span><br><span class="line">s1 = s.split()</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br></pre></td></tr></tbody></table></figure><pre><code>['Technology', 'is', 'evolving', 'at', 'a', 'rapid', 'pace,', 'significantly', 'impacting', 'our', 'daily', 'lives.', 'This', 'progress', 'brings', 'both', 'opportunities', 'and', 'challenges', 'that', 'we', 'must', 'navigate', 'carefully.']</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 按某个字符分割</span></span><br><span class="line">s2 = s.split(<span class="string">'a'</span>)</span><br><span class="line"><span class="built_in">print</span>(s2)</span><br></pre></td></tr></tbody></table></figure><pre><code>['Technology is evolving ', 't ', ' r', 'pid p', 'ce, signific', 'ntly imp', 'cting our d', 'ily lives.\nThis progress brings both opportunities ', 'nd ch', 'llenges th', 't we must n', 'vig', 'te c', 'refully.']</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 按某个字符分割，只分割一次</span></span><br><span class="line">s3 = s.split(<span class="string">'a'</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(s3)</span><br><span class="line">s4 = s.rsplit(<span class="string">'a'</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(s4)</span><br></pre></td></tr></tbody></table></figure><pre><code>['Technology is evolving ', 't a rapid pace, significantly impacting our daily lives.\nThis progress brings both opportunities and challenges that we must navigate carefully.']['Technology is evolving at a rapid pace, significantly impacting our daily lives.\nThis progress brings both opportunities and challenges that we must navigate c', 'refully.']</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 去掉换行符，以换行符分割成列表</span></span><br><span class="line">s5 = s.splitlines()</span><br><span class="line"><span class="built_in">print</span>(s5)</span><br></pre></td></tr></tbody></table></figure><pre><code>['Technology is evolving at a rapid pace, significantly impacting our daily lives.', 'This progress brings both opportunities and challenges that we must navigate carefully.']</code></pre><ol start="2"><li><p>partition</p><p>partition 系列方法包括 partition() 和 rpartition()</p><p>partition() 根据指定的分隔符 (sep) 将字符串进行分割，从字符串左边开始索引分隔符 sep, 索引到则停止索引，返回的是一个包含三个元素的元组 (tuple)，即 (head, sep, tail)。</p></li></ol><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 遇到第一个分隔符后就停止索引</span></span><br><span class="line"><span class="built_in">print</span>(s.partition(<span class="string">'e'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有遇到分隔符，返回原字符串和两个空字符串</span></span><br><span class="line"><span class="built_in">print</span>(s.partition(<span class="string">'z'</span>))</span><br></pre></td></tr></tbody></table></figure><pre><code>('T', 'e', 'chnology is evolving at a rapid pace, significantly impacting our daily lives.\nThis progress brings both opportunities and challenges that we must navigate carefully.')('Technology is evolving at a rapid pace, significantly impacting our daily lives.\nThis progress brings both opportunities and challenges that we must navigate carefully.', '', '')</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># rpartition() 的功能与 partition() 类似，从字符串最后面开始分割。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s.rpartition(<span class="string">'e'</span>))</span><br><span class="line"><span class="built_in">print</span>(s.rpartition(<span class="string">'z'</span>))</span><br></pre></td></tr></tbody></table></figure><pre><code>('Technology is evolving at a rapid pace, significantly impacting our daily lives.\nThis progress brings both opportunities and challenges that we must navigate car', 'e', 'fully.')('', '', 'Technology is evolving at a rapid pace, significantly impacting our daily lives.\nThis progress brings both opportunities and challenges that we must navigate carefully.')</code></pre><ol start="3"><li>split 和 partition 系列方法的区别</li></ol><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><menclose notation="left right"><mtable rowspacing="0.15999999999999992em" columnalign="center center center" columnspacing="1em" rowlines="solid none"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;方法&nbsp;</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;返回类型&nbsp;</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;是否包含分隔符&nbsp;</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;split&nbsp;系列方法&nbsp;</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">list</mi><mo>⁡</mo><mo stretchy="false">(</mo><mtext>&nbsp;列表)&nbsp;</mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;否&nbsp;</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;partition&nbsp;系列方法&nbsp;</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;tuple(元组)&nbsp;</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;是&nbsp;</mtext></mstyle></mtd></mtr></mtable></menclose></mrow><annotation encoding="application/x-tex">\begin{array}{ccc}\hline \text { 方法 } &amp; \text { 返回类型 } &amp; \text { 是否包含分隔符 } \\\hline \text { split 系列方法 } &amp; \operatorname{list}(\text { 列表) } &amp; \text { 否 } \\\text { partition 系列方法 } &amp; \text { tuple(元组) } &amp; \text { 是 } \\\hline\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6400000000000006em;vertical-align:-1.5500000000000007em;"></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.09em;"><span style="top:-4.05em;"><span class="pstrut" style="height:4.05em;"></span><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">方法</span><span class="mord">&nbsp;</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;split&nbsp;</span><span class="mord cjk_fallback">系列方法</span><span class="mord">&nbsp;</span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;partition&nbsp;</span><span class="mord cjk_fallback">系列方法</span><span class="mord">&nbsp;</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">返回类型</span><span class="mord">&nbsp;</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mord mathrm">l</span><span class="mord mathrm">i</span><span class="mord mathrm">s</span><span class="mord mathrm">t</span></span><span class="mopen">(</span><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">列表</span><span class="mord">)&nbsp;</span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;tuple(</span><span class="mord cjk_fallback">元组</span><span class="mord">)&nbsp;</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">是否包含分隔符</span><span class="mord">&nbsp;</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">否</span><span class="mord">&nbsp;</span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">是</span><span class="mord">&nbsp;</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span style="top:-2.4999999999999996em;"><span class="pstrut" style="height:4.05em;"></span><span class="hline" style="border-bottom-width:0.04em;"></span></span><span style="top:-4.8999999999999995em;"><span class="pstrut" style="height:4.05em;"></span><span class="hline" style="border-bottom-width:0.04em;"></span></span><span style="top:-6.1em;"><span class="pstrut" style="height:4.05em;"></span><span class="hline" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span></span></span></p><h3 id="去除字符串两边的空白"><a class="markdownIt-Anchor" href="#去除字符串两边的空白"></a> 去除字符串两边的空白</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">s = <span class="string">'     hello world   '</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除字符串两端的空白</span></span><br><span class="line">s.strip()</span><br></pre></td></tr></tbody></table></figure><pre><code>'hello world'</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 去除字符串右侧的空白</span></span><br><span class="line">s.rstrip()</span><br></pre></td></tr></tbody></table></figure><pre><code>'     hello world'</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 去除字符串左侧的空白</span></span><br><span class="line">s.lstrip()</span><br></pre></td></tr></tbody></table></figure><pre><code>'hello world   '</code></pre><h3 id="其他一些运算"><a class="markdownIt-Anchor" href="#其他一些运算"></a> 其他一些运算</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">s = <span class="string">'''Technology is evolving at a rapid pace, significantly impacting our daily lives.</span></span><br><span class="line"><span class="string">This progress brings both opportunities and challenges that we must navigate carefully.'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计相同字符的个数</span></span><br><span class="line"><span class="built_in">print</span>(s.count(<span class="string">'a'</span>))</span><br></pre></td></tr></tbody></table></figure><pre><code>13</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 计算字符串的长度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s))</span><br></pre></td></tr></tbody></table></figure><pre><code>168</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 字符替换</span></span><br><span class="line"><span class="built_in">print</span>(s.replace(<span class="string">'a'</span>,<span class="string">'A'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果指定第三个参数max，则替换不超过max次</span></span><br><span class="line"><span class="built_in">print</span>(s.replace(<span class="string">'a'</span>,<span class="string">'A'</span>,<span class="number">1</span>))</span><br></pre></td></tr></tbody></table></figure><pre><code>Technology is evolving At A rApid pAce, significAntly impActing our dAily lives.This progress brings both opportunities And chAllenges thAt we must nAvigAte cArefully.Technology is evolving At a rapid pace, significantly impacting our daily lives.This progress brings both opportunities and challenges that we must navigate carefully.</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 判断是否以某字符开头</span></span><br><span class="line">s.startswith(<span class="string">'a'</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>False</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 判断是否以某字符结尾</span></span><br><span class="line">s.endswith(<span class="string">'.'</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>True</code></pre><h1 id="list"><a class="markdownIt-Anchor" href="#list"></a> List</h1><h2 id="初识-list"><a class="markdownIt-Anchor" href="#初识-list"></a> 初识 list</h2><p>list 是 Python 内置的一种高级数据类型，是一种有序的集合。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">names = [<span class="string">'James'</span>, <span class="string">'Michael'</span>, <span class="string">'Emma'</span>, <span class="string">'Emily'</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(names))</span><br><span class="line"><span class="built_in">print</span>(names)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 len() 可获得 list 的长度，即 list 集合所包含的元素个数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(names))</span><br></pre></td></tr></tbody></table></figure><pre><code>&lt;class 'list'&gt;['James', 'Michael', 'Emma', 'Emily']4</code></pre><h2 id="访问列表中的值"><a class="markdownIt-Anchor" href="#访问列表中的值"></a> 访问列表中的值</h2><p>用索引来访问 list 中的每个元素，请注意索引是从 0 开始，最后一个的索引编号为 n-1，即所有元素的编号依次为(0,1, 2, …, n-1)。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(names[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(names[:<span class="number">3</span>])</span><br></pre></td></tr></tbody></table></figure><pre><code>James['James', 'Michael', 'Emma']</code></pre><p>还可以通过 for 循环来列出所有元素</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br></pre></td></tr></tbody></table></figure><pre><code>JamesMichaelEmmaEmily</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(names)):</span><br><span class="line">    <span class="built_in">print</span>(names[i])</span><br></pre></td></tr></tbody></table></figure><pre><code>JamesMichaelEmmaEmily</code></pre><h2 id="列表的操作-函数及方法"><a class="markdownIt-Anchor" href="#列表的操作-函数及方法"></a> 列表的操作、函数及方法</h2><h3 id="list-中元素的增-改-删等操作"><a class="markdownIt-Anchor" href="#list-中元素的增-改-删等操作"></a> list 中元素的增、改、删等操作</h3><p>list 是一个可变的有序列表，可以通过添加、修改、删除等操作来操作 list 中的元素。</p><p><strong>往 list 中添加元素</strong></p><p>可以通过 append() 和 insert() 方法来往 list 中添加元素。</p><p>其中，append() 方法是在 list 的末尾添加元素；insert() 是在指定位置添加元素。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">names = [<span class="string">'James'</span>, <span class="string">'Michael'</span>, <span class="string">'Emma'</span>, <span class="string">'Emily'</span>]</span><br><span class="line">names.append(<span class="string">'Tom'</span>)</span><br><span class="line"><span class="built_in">print</span>(names)</span><br></pre></td></tr></tbody></table></figure><pre><code>['James', 'Michael', 'Emma', 'Emily', 'Tom']</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">names.insert(<span class="number">1</span>,<span class="string">'Jack'</span>)</span><br><span class="line"><span class="built_in">print</span>(names)</span><br></pre></td></tr></tbody></table></figure><pre><code>['James', 'Jack', 'Michael', 'Emma', 'Emily', 'Tom']</code></pre><p><strong>删除 list 中的元素</strong></p><ul><li>用 pop() 方法删除 list 末尾的元素</li></ul><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">names.pop()</span><br></pre></td></tr></tbody></table></figure><pre><code>'Tom'</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(names)</span><br></pre></td></tr></tbody></table></figure><pre><code>['James', 'Jack', 'Michael', 'Emma', 'Emily']</code></pre><ul><li>删除指定位置的元素，用 pop(i) 方法</li></ul><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">names.pop(<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>'James'</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(names)</span><br></pre></td></tr></tbody></table></figure><pre><code>['Jack', 'Michael', 'Emma', 'Emily']</code></pre><p><strong>修改 list 中的元素</strong></p><p>可以直接通过 list 的索引进行赋值来实现</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">names[<span class="number">1</span>] = <span class="string">'Black'</span></span><br><span class="line"><span class="built_in">print</span>(names)</span><br></pre></td></tr></tbody></table></figure><pre><code>['Jack', 'Black', 'Emma', 'Emily']</code></pre><h3 id="列表操作符"><a class="markdownIt-Anchor" href="#列表操作符"></a> 列表操作符</h3><p>列表可以进行“+”和“*”运算</p><p>“+”相当于拼接链表</p><p>“*”相当于重复列表</p><p>此外，还可以判断元素是否存在于列表中</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">l2 = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表相加</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'列表相加：'</span>,l1+l2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表相乘</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'列表相乘：'</span>,l1*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断元素是否存在于列表中</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'判断元素是否存在于列表中：'</span>,<span class="number">1</span> <span class="keyword">in</span> l1, <span class="string">'a'</span> <span class="keyword">in</span> l1)</span><br></pre></td></tr></tbody></table></figure><pre><code>列表相加： [1, 2, 3, 'a', 'b', 'c']列表相乘： [1, 2, 3, 1, 2, 3]判断元素是否存在于列表中： True False</code></pre><h3 id="列表函数-方法"><a class="markdownIt-Anchor" href="#列表函数-方法"></a> 列表函数 &amp; 方法</h3><p>列表的<strong>常用函数</strong>：</p><ul><li><code>len(list)</code>，列表的长度，即列表元素个数</li><li><code>max(list)</code>，返回列表最大值</li><li><code>min(list)</code>，返回列表最小值</li><li><code>list(sep)</code>，将元组转为列表</li></ul><p>列表的<strong>常用方法</strong>：</p><p>除了前面提到的增、改、删等方法外，还有其他一些常用方法</p><ul><li><code>list.count(obj)</code>，统计某个元素在列表中出现的次数</li><li><code>list.extend(seq)</code>，在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</li><li><code>list.index(obj)</code>，从列表中找出某个值的第一个匹配项的索引位置</li><li><code>list.remove(obj)</code>，移除列表中某个值的第一个匹配项</li><li><code>list.sort()</code>，对列表进行排序</li><li><code>list.reverse()</code>，对列表进行反向排序</li></ul><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">1</span>]</span><br><span class="line">l2 = [<span class="number">7</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">t = (<span class="number">10</span>,<span class="number">100</span>,<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'列表的最大值：'</span>,<span class="built_in">max</span>(l1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'列表的最小值：'</span>,<span class="built_in">min</span>(l1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'将元组转为列表：'</span>,<span class="built_in">list</span>(t))</span><br></pre></td></tr></tbody></table></figure><pre><code>列表的最大值： 9列表的最小值： 1将元组转为列表： [10, 100, 50]</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">'count：'</span>,l1.count(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">l1.extend(l2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'extend：'</span>,l1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'index：'</span>,l1.index(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">l2.remove(<span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'remove：'</span>,l2)</span><br><span class="line"></span><br><span class="line">l2.sort()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'sort：'</span>,l2)</span><br><span class="line"></span><br><span class="line">l2.reverse()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'reverse：'</span>,l2)</span><br></pre></td></tr></tbody></table></figure><pre><code>count： 2extend： [1, 2, 3, 5, 4, 6, 9, 8, 7, 1, 7, 5, 1, 3, 2]index： 1remove： [5, 1, 3, 2]sort： [1, 2, 3, 5]reverse： [5, 3, 2, 1]</code></pre><h2 id="list-中元素的类型"><a class="markdownIt-Anchor" href="#list-中元素的类型"></a> list 中元素的类型</h2><p>同一个 list 中的元素的类型可以是字符串（str）、整型（int）、布尔型（Boolean）、以及嵌套的 list 等等</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">list_1 = [<span class="string">'Tom'</span>, <span class="number">1</span>, <span class="number">2</span>, [<span class="number">1.1</span>, <span class="number">2.2</span>], <span class="literal">True</span>]</span><br><span class="line"><span class="built_in">print</span>(list_1)</span><br><span class="line"><span class="built_in">print</span>(list_1[<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(list_1[<span class="number">3</span>][<span class="number">0</span>])</span><br></pre></td></tr></tbody></table></figure><pre><code>['Tom', 1, 2, [1.1, 2.2], True][1.1, 2.2]1.1</code></pre><h2 id="list-的切片slices"><a class="markdownIt-Anchor" href="#list-的切片slices"></a> list 的切片（slices）</h2><p>可以通过切片 (slices) 的形式来获取 list 部分连续的元素。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">list_1 =  [<span class="string">'James'</span>, <span class="string">'Ava'</span>, <span class="string">'Michael'</span>, <span class="string">'Emma'</span>, <span class="string">'Emily'</span>, <span class="string">'Jacob'</span>]</span><br><span class="line"><span class="built_in">print</span>(list_1)</span><br></pre></td></tr></tbody></table></figure><pre><code>['James', 'Ava', 'Michael', 'Emma', 'Emily', 'Jacob']</code></pre><p>list 中以切片形式使用时，其结构可以参考：<code>new_list[start:end:step]</code></p><p>其中 start 和 end 表示索引位置的开始和结束，选取的元素包括 start ，但是不包含 end</p><p>step 表示步长，默认 step 为1</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(list_1[<span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(list_1[::<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(list_1[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(list_1[::-<span class="number">1</span>])</span><br></pre></td></tr></tbody></table></figure><pre><code>['James', 'Ava']['James', 'Michael', 'Emily']Jacob['Jacob', 'Emily', 'Emma', 'Michael', 'Ava', 'James']</code></pre><p>当 step 为正数时，从左到右以该步长来获取列表中的元素；</p><p>当 step 为负数时，从右到左以该步长的绝对值来获取列表中的元素。</p><h2 id="列表推导式"><a class="markdownIt-Anchor" href="#列表推导式"></a> 列表推导式</h2><p>但是如果想获取<strong>离散的元素</strong>，比如想获取第 1、3、4 个元素</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(list_1[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br></pre></td></tr></tbody></table></figure><pre><code>---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)Cell In[158], line 1----&gt; 1 print(list_1[1,3,4])TypeError: list indices must be integers or slices, not tuple</code></pre><p>可以看到直接报错，直接使用离散的索引是不行的，它提示 list 的索引必须是整数或者 slices。</p><p>此时，则可以使用列表推导式完成任务。</p><h3 id="列表推导式的一般情况"><a class="markdownIt-Anchor" href="#列表推导式的一般情况"></a> 列表推导式的一般情况</h3><p>列表推导式的一般语法结构：</p><p><code>new_list = [x for x in iterable]</code></p><p>其中，<code>iterable</code>表示可迭代的对象，包括字符串（str）、列表（list）、元组（tuple）、字典（dict）、集合（set），以及生成器（generator）等。</p><p>几个简单的示例：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">str_list = [x.lower() <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'Hello, World'</span>]</span><br><span class="line"><span class="built_in">print</span>(str_list)</span><br></pre></td></tr></tbody></table></figure><pre><code>['h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd']</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">list_list = [x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line"><span class="built_in">print</span>(list_list)</span><br></pre></td></tr></tbody></table></figure><pre><code>[2, 4, 6, 8]</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">tuple_list = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)]</span><br><span class="line"><span class="built_in">print</span>(tuple_list)</span><br></pre></td></tr></tbody></table></figure><pre><code>[1, 4, 9, 16]</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">ge_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>)]</span><br><span class="line"><span class="built_in">print</span>(ge_list)</span><br></pre></td></tr></tbody></table></figure><pre><code>[0, 1, 2, 3, 4, 5, 6, 7]</code></pre><h3 id="两层-for-循环的列表推导式"><a class="markdownIt-Anchor" href="#两层-for-循环的列表推导式"></a> 两层 for 循环的列表推导式</h3><p>列表推导式中，可以同时包含多个 for 循环，比如同时两个 for 循环</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">two_for_list = [x**<span class="number">2</span>+y <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>) <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">4</span>,<span class="number">8</span>)]</span><br><span class="line"><span class="built_in">print</span>(two_for_list)</span><br></pre></td></tr></tbody></table></figure><pre><code>[4, 5, 6, 7, 5, 6, 7, 8, 8, 9, 10, 11, 13, 14, 15, 16, 20, 21, 22, 23]</code></pre><p>上述结果跟下面的写法结果是一致的：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">two_for_list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>,<span class="number">8</span>):</span><br><span class="line">        two_for_list.append(x**<span class="number">2</span>+y)</span><br><span class="line"><span class="built_in">print</span>(two_for_list)</span><br></pre></td></tr></tbody></table></figure><pre><code>[4, 5, 6, 7, 5, 6, 7, 8, 8, 9, 10, 11, 13, 14, 15, 16, 20, 21, 22, 23]</code></pre><h3 id="使用两个变量来生成-list"><a class="markdownIt-Anchor" href="#使用两个变量来生成-list"></a> 使用两个变量来生成 list</h3><p>列表推导式也可以使用两个或多个变量来生成 list，结合字典的使用，举例如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">d = {<span class="string">'x'</span>:<span class="string">'1'</span>, <span class="string">'y'</span>:<span class="string">'2'</span>, <span class="string">'z'</span>:<span class="string">'3'</span>}</span><br><span class="line">d_list = [k + <span class="string">'='</span> + v <span class="keyword">for</span> k,v <span class="keyword">in</span> d.items()]</span><br><span class="line"><span class="built_in">print</span>(d_list)</span><br></pre></td></tr></tbody></table></figure><pre><code>['x=1', 'y=2', 'z=3']</code></pre><h3 id="含-if-语句的列表推导式"><a class="markdownIt-Anchor" href="#含-if-语句的列表推导式"></a> 含 if 语句的列表推导式</h3><p>列表推导式中还可以引入 if 条件语句</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">if_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(if_list)</span><br></pre></td></tr></tbody></table></figure><pre><code>[0, 2, 4, 6, 8]</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">if_list = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>):</span><br><span class="line">        if_list.append(x)</span><br><span class="line"><span class="built_in">print</span>(if_list)</span><br></pre></td></tr></tbody></table></figure><pre><code>[0, 2, 4, 6, 8]</code></pre><p>当然，如果仅仅是编写上更简洁，可能不一定能显现出列表推导式的优势，下面我们来对比下上述两种方式的运行效率。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">%%timeit</span><br><span class="line"></span><br><span class="line">if_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">0</span>]</span><br><span class="line">if_list</span><br></pre></td></tr></tbody></table></figure><pre><code>689 ns ± 6.58 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">%%timeit</span><br><span class="line"></span><br><span class="line">if_list = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>):</span><br><span class="line">        if_list.append(x)</span><br><span class="line">if_list</span><br></pre></td></tr></tbody></table></figure><pre><code>729 ns ± 2.9 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)</code></pre><p>从上面的运行结果进行对比，可以看出列表推导式的运行效率要高于普通的 for 循环编写方式。</p><p><strong>包含 if-else 语句的列表推导式</strong></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">[x**<span class="number">2</span> <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">else</span> x+<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br></pre></td></tr></tbody></table></figure><pre><code>[0, 3, 4, 5, 16, 7, 36, 9, 64, 11]</code></pre><p><strong>包含两个 if 语句的列表推导式</strong></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">if</span> x%<span class="number">3</span>==<span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure><pre><code>[0, 36]</code></pre><h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2><p>如果想获取离散的元素：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">list_1 =  [<span class="string">'James'</span>, <span class="string">'Ava'</span>, <span class="string">'Michael'</span>, <span class="string">'Emma'</span>, <span class="string">'Emily'</span>, <span class="string">'Jacob'</span>]</span><br><span class="line">[list_1[i] <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br></pre></td></tr></tbody></table></figure><pre><code>['Ava', 'Emma', 'Emily']</code></pre><h1 id="字典"><a class="markdownIt-Anchor" href="#字典"></a> 字典</h1><p>主要内容包括：</p><ul><li>字典的基本用法</li><li>字典推导式</li><li>字典合并</li><li>嵌套字典</li></ul><h2 id="基本用法"><a class="markdownIt-Anchor" href="#基本用法"></a> 基本用法</h2><p>字典是一种可以将相关的两个信息关联起来的操作，并且字典可存储的信息量几乎不受限制。</p><p>字典用于存放具有映射关系的数据。</p><p>为了保存具有映射关系的数据，Python 提供了字典，字典相当于保存了两组数据，其中一组数据是关键数据，被称为 key；另一组数据可通过 key 来访问，被称为 value。</p><h3 id="创建字典"><a class="markdownIt-Anchor" href="#创建字典"></a> 创建字典</h3><p>字典是以 key、value 的形式创建的。</p><p>字典的每个键值 <code>key=&gt;value</code> 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中, 格式如下所示：<br>d = {key1 : value1, key2 : value2 }</p><p>一般情况下，字典的创建可以有以下几种方式：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个空的字典</span></span><br><span class="line">dic_1 = {}</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建key值为整数的字典</span></span><br><span class="line">dic_2 = {<span class="number">1</span>:<span class="string">'one'</span>, <span class="number">2</span>:<span class="string">'second'</span>}</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建key值为string的字典</span></span><br><span class="line">dic_3 = {<span class="string">'name'</span>:<span class="string">'Tom'</span>, <span class="string">'age'</span>:<span class="string">'22'</span>}</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建key值为数字和string混合的字典</span></span><br><span class="line">dic_4 = {<span class="string">'name'</span>: <span class="string">'Tom'</span>, <span class="number">1</span>: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>]}</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用dict()函数创建字典</span></span><br><span class="line">dic_5 = <span class="built_in">dict</span>({<span class="number">1</span>:<span class="string">'Tom'</span>, <span class="number">2</span>:<span class="string">'Jack'</span>})</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以元组的形式组成序列创建字典</span></span><br><span class="line">dic_6 = <span class="built_in">dict</span>([(<span class="number">1</span>,<span class="string">'apple'</span>), (<span class="number">2</span>,<span class="string">'ball'</span>)])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'dic_1:'</span>,dic_1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'dic_2:'</span>,dic_2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'dic_3:'</span>,dic_3)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'dic_4:'</span>,dic_4)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'dic_5:'</span>,dic_5)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'dic_6:'</span>,dic_6)</span><br></pre></td></tr></tbody></table></figure><pre><code>dic_1: {}dic_2: {1: 'one', 2: 'second'}dic_3: {'name': 'Tom', 'age': '22'}dic_4: {'name': 'Tom', 1: [2, 4, 3]}dic_5: {1: 'Tom', 2: 'Jack'}dic_6: {1: 'apple', 2: 'ball'}</code></pre><h3 id="获取字典中的元素"><a class="markdownIt-Anchor" href="#获取字典中的元素"></a> 获取字典中的元素</h3><p><strong>通过 key 来获取 value</strong></p><p>获取字典中的元素，可以直接通过 key 值来获取对应的 value，如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dic_ = {<span class="string">'name'</span>: <span class="string">'John'</span>, <span class="string">'age'</span>: <span class="number">25</span> , <span class="number">1</span>: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>]}</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dic_[<span class="string">'name'</span>])</span><br><span class="line"><span class="built_in">print</span>(dic_.get(<span class="string">'name'</span>))</span><br></pre></td></tr></tbody></table></figure><pre><code>JohnJohn</code></pre><p>如果字典的 key 值中没有该元素，则不能获取相应的 value，这种情况下产生错误。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(dic_[<span class="string">'name1'</span>])</span><br></pre></td></tr></tbody></table></figure><pre><code>---------------------------------------------------------------------------KeyError                                  Traceback (most recent call last)Cell In[205], line 1----&gt; 1 print(dic_['name1'])KeyError: 'name1'</code></pre><p><strong>通过 value 来获取 key</strong></p><p>通过 value 来获取 key 值，在 Python 中并没有提供直接的方法，但是可以通过自定义函数来实现，如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_keys</span>(<span class="params">d,value</span>):</span><br><span class="line">    <span class="keyword">return</span> [k <span class="keyword">for</span> k,v <span class="keyword">in</span> d.items() <span class="keyword">if</span> v==value]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(get_keys(dic_,<span class="string">'John'</span>))</span><br></pre></td></tr></tbody></table></figure><pre><code>['name']</code></pre><h3 id="在字典中修改或添加元素"><a class="markdownIt-Anchor" href="#在字典中修改或添加元素"></a> 在字典中修改或添加元素</h3><p>在字典中，可以修改已有 key 对应的 value 值，或者添加新的 key-value 键值对数据，如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dic_ = {<span class="string">'name'</span>: <span class="string">'John'</span>, <span class="string">'age'</span>: <span class="number">25</span> , <span class="number">1</span>: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>]}</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改已有key对应的value的值</span></span><br><span class="line">dic_[<span class="string">'age'</span>] = <span class="number">35</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加新的key-value数据组</span></span><br><span class="line">dic_[<span class="string">'gender'</span>] = <span class="string">'man'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dic_)</span><br></pre></td></tr></tbody></table></figure><pre><code>{'name': 'John', 'age': 35, 1: [2, 4, 3], 'gender': 'man'}</code></pre><h3 id="从字典中删除元素"><a class="markdownIt-Anchor" href="#从字典中删除元素"></a> 从字典中删除元素</h3><p><strong>pop()方法</strong></p><p>移除字典数据 pop() 方法的作用是：删除指定给定键所对应的值，返回这个值并从字典中把它移除。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 使用pop()方法来删除</span></span><br><span class="line"></span><br><span class="line">dic_ = {<span class="string">'name'</span>: <span class="string">'John'</span>, <span class="string">'age'</span>: <span class="number">25</span> , <span class="number">1</span>: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>]}</span><br><span class="line"></span><br><span class="line">dic_.pop(<span class="string">'age'</span>)</span><br><span class="line"><span class="built_in">print</span>(dic_)</span><br></pre></td></tr></tbody></table></figure><pre><code>{'name': 'John', 1: [2, 4, 3]}</code></pre><p><strong>del 方法</strong></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 del 方法来删除</span></span><br><span class="line"></span><br><span class="line">dic_ = {<span class="string">'name'</span>: <span class="string">'John'</span>, <span class="string">'age'</span>: <span class="number">25</span> , <span class="number">1</span>: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>]}</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> dic_[<span class="string">'age'</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dic_)</span><br></pre></td></tr></tbody></table></figure><pre><code>{'name': 'John', 1: [2, 4, 3]}</code></pre><p>另外，del 可以删除整个字典</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dic_ = {<span class="string">'name'</span>: <span class="string">'John'</span>, <span class="string">'age'</span>: <span class="number">25</span> , <span class="number">1</span>: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>]}</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> dic_</span><br><span class="line"><span class="built_in">print</span>(dic_)</span><br></pre></td></tr></tbody></table></figure><pre><code>---------------------------------------------------------------------------NameError                                 Traceback (most recent call last)Cell In[214], line 4      1 dic_ = {'name': 'John', 'age': 25 , 1: [2, 4, 3]}      3 del dic_----&gt; 4 print(dic_)NameError: name 'dic_' is not defined</code></pre><p><strong>clear() 方法</strong></p><p>clear() 方法是用来清除字典中的所有数据，因为是原地操作，所以返回 None（也可以理解为没有返回值）</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 clear() 方法来清空字典中的所有数据，返回的是一个空字典</span></span><br><span class="line"></span><br><span class="line">dic_ = {<span class="string">'name'</span>: <span class="string">'John'</span>, <span class="string">'age'</span>: <span class="number">25</span> , <span class="number">1</span>: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>]}</span><br><span class="line"></span><br><span class="line">dic_.clear()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dic_)</span><br></pre></td></tr></tbody></table></figure><pre><code>{}</code></pre><h3 id="字典内置函数-方法"><a class="markdownIt-Anchor" href="#字典内置函数-方法"></a> 字典内置函数 &amp; 方法</h3><p>Python 字典包含了以下内置函数：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><menclose notation="left"><mtable rowspacing="0.15999999999999992em" columnalign="left left" columnspacing="1em" rowlines="solid none none"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;序号&nbsp;</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;函数及描述&nbsp;</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;len(dict)&nbsp;</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;计算字典元素个数,&nbsp;即键的总数&nbsp;</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;str(dict)&nbsp;</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;输出字典可打印的字符串表示&nbsp;</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;type(variable)&nbsp;</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;返回输入的变量类型,&nbsp;如果变量是字典就返回字典类型&nbsp;</mtext></mstyle></mtd></mtr></mtable></menclose></mrow><annotation encoding="application/x-tex">\begin{array}{ll}\hline \text { 序号 } &amp; \text { 函数及描述 } \\\hline \text { len(dict) } &amp; \text { 计算字典元素个数, 即键的总数 } \\\text { str(dict) } &amp; \text { 输出字典可打印的字符串表示 } \\\text { type(variable) } &amp; \text { 返回输入的变量类型, 如果变量是字典就返回字典类型 }\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.840000000000001em;vertical-align:-2.1500000000000004em;"></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6900000000000004em;"><span style="top:-4.65em;"><span class="pstrut" style="height:4.65em;"></span><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">序号</span><span class="mord">&nbsp;</span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;len(dict)&nbsp;</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;str(dict)&nbsp;</span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;type(variable)&nbsp;</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">函数及描述</span><span class="mord">&nbsp;</span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">计算字典元素个数</span><span class="mord">,&nbsp;</span><span class="mord cjk_fallback">即键的总数</span><span class="mord">&nbsp;</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">输出字典可打印的字符串表示</span><span class="mord">&nbsp;</span></span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">返回输入的变量类型</span><span class="mord">,&nbsp;</span><span class="mord cjk_fallback">如果变量是字典就返回字典类型</span><span class="mord">&nbsp;</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span style="top:-6.1000000000000005em;"><span class="pstrut" style="height:4.65em;"></span><span class="hline" style="border-bottom-width:0.04em;"></span></span><span style="top:-7.300000000000001em;"><span class="pstrut" style="height:4.65em;"></span><span class="hline" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span></span></span></p><p><strong>len(), str(), type() 函数</strong>：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dic_ = {<span class="string">'name'</span>: <span class="string">'John'</span>, <span class="string">'age'</span>: <span class="number">25</span> , <span class="number">1</span>: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>]}</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(dic_))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(dic_))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(dic_))</span><br></pre></td></tr></tbody></table></figure><pre><code>3{'name': 'John', 'age': 25, 1: [2, 4, 3]}&lt;class 'dict'&gt;</code></pre><p>Python 字典包含以下一些方法：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><menclose notation="top bottom left right"><mtable rowspacing="0.15999999999999992em" columnalign="center center" columnlines="solid" columnspacing="1em" rowlines="solid solid solid solid solid solid solid solid solid solid solid"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;函数&nbsp;</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;函数描述&nbsp;</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;clear()&nbsp;</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;删除字典内所有元素,&nbsp;返回空字典&nbsp;</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">copy</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;返回一个字典的浅复制&nbsp;</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;fromkeys(seq[,&nbsp;</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;val])&nbsp;</mtext></mstyle></mtd></mtr></mtable></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;创建一个新字典,&nbsp;以序列&nbsp;seq&nbsp;中元素做字典的键,&nbsp;val&nbsp;为字典所有键对应的初始值&nbsp;</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;get(key,&nbsp;</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;default=None)&nbsp;</mtext></mstyle></mtd></mtr></mtable></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;返回指定键的值，如果值不在字典中返回&nbsp;default&nbsp;值&nbsp;</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;items()&nbsp;</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;以列表返回可遍历的&nbsp;(键,&nbsp;值)&nbsp;元组数组&nbsp;</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;keys()&nbsp;</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;以列表返回一个字典所有的键&nbsp;</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;setdefault(key,&nbsp;</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;default=None)&nbsp;</mtext></mstyle></mtd></mtr></mtable></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;和&nbsp;get()&nbsp;类似,&nbsp;但如果键不存在于字典中,&nbsp;将会添加键并将值设为&nbsp;default&nbsp;</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;update(dict2)&nbsp;</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;把字典&nbsp;dict2&nbsp;的键/值对更新到&nbsp;dict&nbsp;里&nbsp;</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;values()&nbsp;</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;以列表返回字典中的所有值&nbsp;</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;pop(key[,default])&nbsp;</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;删除字典给定键&nbsp;key&nbsp;所对应的值，返回值为被删除的值。key&nbsp;值必须给出。否则，返回&nbsp;</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;default&nbsp;值。&nbsp;</mtext></mstyle></mtd></mtr></mtable></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;popitem()&nbsp;</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>&nbsp;随机返回并删除字典中的一对键和值。Python&nbsp;</mtext><mn>3.6</mn><mtext>&nbsp;及以后版本,&nbsp;以&nbsp;LIFO&nbsp;的原则进行删除&nbsp;</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>&nbsp;的,&nbsp;是有序进行删除的。&nbsp;</mtext></mstyle></mtd></mtr></mtable></mstyle></mtd></mtr></mtable></menclose></mrow><annotation encoding="application/x-tex">\begin{array}{|c|c|}\hline \text { 函数 } &amp; \text { 函数描述 } \\\hline \text { clear() } &amp; \text { 删除字典内所有元素, 返回空字典 } \\\hline \operatorname{copy}() &amp; \text { 返回一个字典的浅复制 } \\\hline \begin{array}{l}\text { fromkeys(seq[, } \\\text { val]) }\end{array} &amp; \text { 创建一个新字典, 以序列 seq 中元素做字典的键, val 为字典所有键对应的初始值 } \\\hline \begin{array}{l}\text { get(key, } \\\text { default=None) }\end{array} &amp; \text { 返回指定键的值，如果值不在字典中返回 default 值 } \\\hline \text { items() } &amp; \text { 以列表返回可遍历的 (键, 值) 元组数组 } \\\hline \text { keys() } &amp; \text { 以列表返回一个字典所有的键 } \\\hline \begin{array}{l}\text { setdefault(key, } \\\text { default=None) }\end{array} &amp; \text { 和 get() 类似, 但如果键不存在于字典中, 将会添加键并将值设为 default } \\\hline \text { update(dict2) } &amp; \text { 把字典 dict2 的键/值对更新到 dict 里 } \\\hline \text { values() } &amp; \text { 以列表返回字典中的所有值 } \\\hline \text { pop(key[,default]) } &amp; \begin{array}{l}\text { 删除字典给定键 key 所对应的值，返回值为被删除的值。key 值必须给出。否则，返回 } \\\text { default 值。 }\end{array} \\\hline \text { popitem() } &amp; \begin{array}{l}\text { 随机返回并删除字典中的一对键和值。Python } 3.6 \text { 及以后版本, 以 LIFO 的原则进行删除 } \\\text { 的, 是有序进行删除的。 }\end{array} \\\hline\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:20.43999999999999em;vertical-align:-9.95em;"></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:10.489999999999991em;"><span style="top:-12.45em;"><span class="pstrut" style="height:12.45em;"></span><span class="mtable"><span class="vertical-separator" style="height:20.399999999999995em;border-right-width:0.04em;border-right-style:solid;margin:0 -0.02em;vertical-align:-9.949999999999998em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:10.45em;"><span style="top:-13.059999999999999em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">函数</span><span class="mord">&nbsp;</span></span></span></span><span style="top:-11.859999999999996em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;clear()&nbsp;</span></span></span></span><span style="top:-10.659999999999997em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mop"><span class="mord mathrm">c</span><span class="mord mathrm">o</span><span class="mord mathrm">p</span><span class="mord mathrm" style="margin-right:0.01389em;">y</span></span><span class="mopen">(</span><span class="mclose">)</span></span></span><span style="top:-8.849999999999998em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;fromkeys(seq[,&nbsp;</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;val])&nbsp;</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span><span style="top:-6.4499999999999975em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;get(key,&nbsp;</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;default=None)&nbsp;</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span><span style="top:-4.6599999999999975em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;items()&nbsp;</span></span></span></span><span style="top:-3.4599999999999977em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;keys()&nbsp;</span></span></span></span><span style="top:-1.6499999999999992em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;setdefault(key,&nbsp;</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;default=None)&nbsp;</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span><span style="top:0.14000000000000218em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;update(dict2)&nbsp;</span></span></span></span><span style="top:1.3400000000000019em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;values()&nbsp;</span></span></span></span><span style="top:3.1500000000000004em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;pop(key[,default])&nbsp;</span></span></span></span><span style="top:5.549999999999999em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;popitem()&nbsp;</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:9.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="vertical-separator" style="height:20.399999999999995em;border-right-width:0.04em;border-right-style:solid;margin:0 -0.02em;vertical-align:-9.949999999999998em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:10.45em;"><span style="top:-13.059999999999999em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">函数描述</span><span class="mord">&nbsp;</span></span></span></span><span style="top:-11.859999999999996em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">删除字典内所有元素</span><span class="mord">,&nbsp;</span><span class="mord cjk_fallback">返回空字典</span><span class="mord">&nbsp;</span></span></span></span><span style="top:-10.659999999999997em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">返回一个字典的浅复制</span><span class="mord">&nbsp;</span></span></span></span><span style="top:-8.849999999999998em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">创建一个新字典</span><span class="mord">,&nbsp;</span><span class="mord cjk_fallback">以序列</span><span class="mord">&nbsp;seq&nbsp;</span><span class="mord cjk_fallback">中元素做字典的键</span><span class="mord">,&nbsp;val&nbsp;</span><span class="mord cjk_fallback">为字典所有键对应的初始值</span><span class="mord">&nbsp;</span></span></span></span><span style="top:-6.4499999999999975em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">返回指定键的值，如果值不在字典中返回</span><span class="mord">&nbsp;default&nbsp;</span><span class="mord cjk_fallback">值</span><span class="mord">&nbsp;</span></span></span></span><span style="top:-4.6599999999999975em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">以列表返回可遍历的</span><span class="mord">&nbsp;(</span><span class="mord cjk_fallback">键</span><span class="mord">,&nbsp;</span><span class="mord cjk_fallback">值</span><span class="mord">)&nbsp;</span><span class="mord cjk_fallback">元组数组</span><span class="mord">&nbsp;</span></span></span></span><span style="top:-3.4599999999999977em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">以列表返回一个字典所有的键</span><span class="mord">&nbsp;</span></span></span></span><span style="top:-1.6499999999999992em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">和</span><span class="mord">&nbsp;get()&nbsp;</span><span class="mord cjk_fallback">类似</span><span class="mord">,&nbsp;</span><span class="mord cjk_fallback">但如果键不存在于字典中</span><span class="mord">,&nbsp;</span><span class="mord cjk_fallback">将会添加键并将值设为</span><span class="mord">&nbsp;default&nbsp;</span></span></span></span><span style="top:0.14000000000000218em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">把字典</span><span class="mord">&nbsp;dict2&nbsp;</span><span class="mord cjk_fallback">的键</span><span class="mord">/</span><span class="mord cjk_fallback">值对更新到</span><span class="mord">&nbsp;dict&nbsp;</span><span class="mord cjk_fallback">里</span><span class="mord">&nbsp;</span></span></span></span><span style="top:1.3400000000000019em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">以列表返回字典中的所有值</span><span class="mord">&nbsp;</span></span></span></span><span style="top:3.1500000000000004em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">删除字典给定键</span><span class="mord">&nbsp;key&nbsp;</span><span class="mord cjk_fallback">所对应的值，返回值为被删除的值。</span><span class="mord">key&nbsp;</span><span class="mord cjk_fallback">值必须给出。否则，返回</span><span class="mord">&nbsp;</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;default&nbsp;</span><span class="mord cjk_fallback">值。</span><span class="mord">&nbsp;</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span><span style="top:5.549999999999999em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">随机返回并删除字典中的一对键和值。</span><span class="mord">Python&nbsp;</span></span><span class="mord">3</span><span class="mord">.</span><span class="mord">6</span><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">及以后版本</span><span class="mord">,&nbsp;</span><span class="mord cjk_fallback">以</span><span class="mord">&nbsp;LIFO&nbsp;</span><span class="mord cjk_fallback">的原则进行删除</span><span class="mord">&nbsp;</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">&nbsp;</span><span class="mord cjk_fallback">的</span><span class="mord">,&nbsp;</span><span class="mord cjk_fallback">是有序进行删除的。</span><span class="mord">&nbsp;</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:9.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="vertical-separator" style="height:20.399999999999995em;border-right-width:0.04em;border-right-style:solid;margin:0 -0.02em;vertical-align:-9.949999999999998em;"></span></span></span><span style="top:-2.5em;"><span class="pstrut" style="height:12.45em;"></span><span class="hline" style="border-bottom-width:0.04em;"></span></span><span style="top:-4.899999999999998em;"><span class="pstrut" style="height:12.45em;"></span><span class="hline" style="border-bottom-width:0.04em;"></span></span><span style="top:-7.299999999999996em;"><span class="pstrut" style="height:12.45em;"></span><span class="hline" style="border-bottom-width:0.04em;"></span></span><span style="top:-8.499999999999996em;"><span class="pstrut" style="height:12.45em;"></span><span class="hline" style="border-bottom-width:0.04em;"></span></span><span style="top:-9.699999999999996em;"><span class="pstrut" style="height:12.45em;"></span><span class="hline" style="border-bottom-width:0.04em;"></span></span><span style="top:-12.099999999999994em;"><span class="pstrut" style="height:12.45em;"></span><span class="hline" style="border-bottom-width:0.04em;"></span></span><span style="top:-13.299999999999994em;"><span class="pstrut" style="height:12.45em;"></span><span class="hline" style="border-bottom-width:0.04em;"></span></span><span style="top:-14.499999999999993em;"><span class="pstrut" style="height:12.45em;"></span><span class="hline" style="border-bottom-width:0.04em;"></span></span><span style="top:-16.899999999999995em;"><span class="pstrut" style="height:12.45em;"></span><span class="hline" style="border-bottom-width:0.04em;"></span></span><span style="top:-19.299999999999994em;"><span class="pstrut" style="height:12.45em;"></span><span class="hline" style="border-bottom-width:0.04em;"></span></span><span style="top:-20.499999999999993em;"><span class="pstrut" style="height:12.45em;"></span><span class="hline" style="border-bottom-width:0.04em;"></span></span><span style="top:-21.699999999999992em;"><span class="pstrut" style="height:12.45em;"></span><span class="hline" style="border-bottom-width:0.04em;"></span></span><span style="top:-22.89999999999999em;"><span class="pstrut" style="height:12.45em;"></span><span class="hline" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:9.95em;"><span></span></span></span></span></span></span></span></span></span></p><p><strong>copy, keys, values, items 方法</strong></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dic_ =  {<span class="string">'name'</span>: <span class="string">'John'</span>, <span class="string">'age'</span>: <span class="number">25</span> , <span class="number">1</span>: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>], <span class="string">'gender'</span>: <span class="string">'man'</span>}</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'copy:'</span>,dic_.copy())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'keys:'</span>,dic_.keys())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'values:'</span>,dic_.values())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'items:'</span>,dic_.items())</span><br></pre></td></tr></tbody></table></figure><pre><code>copy: {'name': 'John', 'age': 25, 1: [2, 4, 3], 'gender': 'man'}keys: dict_keys(['name', 'age', 1, 'gender'])values: dict_values(['John', 25, [2, 4, 3], 'man'])items: dict_items([('name', 'John'), ('age', 25), (1, [2, 4, 3]), ('gender', 'man')])</code></pre><p><strong>update 方法</strong></p><p>通过 update 方法，可以更新字典的数据内容：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dic_1 =  {<span class="string">'name'</span>: <span class="string">'Lemon'</span>, <span class="string">'age'</span>: <span class="number">25</span> , <span class="number">1</span>: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>], <span class="string">'gender'</span>: <span class="string">'man'</span>}</span><br><span class="line">dic_2 =  {<span class="string">'name'</span>: <span class="string">'John'</span>, <span class="string">'age'</span>: <span class="number">35</span> , <span class="number">1</span>: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>], <span class="string">'gender'</span>: <span class="string">'man'</span>}</span><br><span class="line"></span><br><span class="line">dic_1.update(dic_2)</span><br><span class="line"><span class="built_in">print</span>(dic_1)</span><br></pre></td></tr></tbody></table></figure><pre><code>{'name': 'John', 'age': 35, 1: [2, 4, 3], 'gender': 'man'}</code></pre><p><strong>fromkeys 方法</strong></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">seq = [<span class="string">'brand'</span>, <span class="string">'model'</span>, <span class="string">'year'</span>]</span><br><span class="line">value = [<span class="string">'Toyota'</span>, <span class="string">'Corolla'</span>, <span class="number">2020</span>]</span><br><span class="line"></span><br><span class="line">dic_ = <span class="built_in">dict</span>.fromkeys(seq, value)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dic_)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><pre><code>{'brand': ['Toyota', 'Corolla', 2020], 'model': ['Toyota', 'Corolla', 2020], 'year': ['Toyota', 'Corolla', 2020]}</code></pre><p><strong>zip（）方法</strong></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">seq = [<span class="string">'brand'</span>, <span class="string">'model'</span>, <span class="string">'year'</span>]</span><br><span class="line">value = [<span class="string">'Toyota'</span>, <span class="string">'Corolla'</span>, <span class="number">2020</span>]</span><br><span class="line"></span><br><span class="line">dic_ = <span class="built_in">dict</span>(<span class="built_in">zip</span>(seq,value))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dic_)</span><br></pre></td></tr></tbody></table></figure><pre><code>{'brand': 'Toyota', 'model': 'Corolla', 'year': 2020}</code></pre><p>注意<code>zip</code>和<code>fromkeys</code>的区别</p><p><strong>setdefault 方法</strong></p><p>dict.setdefault(key, default=None)</p><p>该方法接收两个参数，第一个参数是健的名称，第二个参数是默认值。</p><p>假如字典中不存在给定的键，则把默认值赋值给对应的 value，并返回默认值；</p><p>反之，不修改 value，只返回 value。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dic_ = {</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Alice'</span>,                   <span class="comment"># 字符串</span></span><br><span class="line">    <span class="string">'age'</span>: <span class="number">30</span>,                         <span class="comment"># 整数</span></span><br><span class="line">    <span class="string">'height'</span>: <span class="number">5.5</span>,                     <span class="comment"># 浮点数</span></span><br><span class="line">    <span class="string">'hobbies'</span>: [<span class="string">'reading'</span>, <span class="string">'hiking'</span>],  <span class="comment"># 列表</span></span><br><span class="line">    <span class="string">'address'</span>: (<span class="string">'123 Main St'</span>, <span class="string">'Apt 4'</span>), <span class="comment"># 元组</span></span><br><span class="line">    <span class="string">'skills'</span>: {<span class="string">'Python'</span>, <span class="string">'Data Analysis'</span>}, <span class="comment"># 集合</span></span><br><span class="line">    <span class="string">'job'</span>: {                           <span class="comment"># 嵌套字典</span></span><br><span class="line">        <span class="string">'title'</span>: <span class="string">'Data Scientist'</span>,</span><br><span class="line">        <span class="string">'salary'</span>: <span class="number">120000</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'字典中存在的key，返回对应value：'</span>, dic_.setdefault(<span class="string">'age'</span>,<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'字典中不存在的key，返回默认值： '</span>, dic_.setdefault(<span class="string">'age1'</span>,<span class="number">0</span>))</span><br></pre></td></tr></tbody></table></figure><pre><code>字典中存在的key，返回对应value： 30字典中不存在的key，返回默认值：  0</code></pre><p>此外，还可以用 setdefault() 方法统计一个列表里单词出现的次数：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">words_list = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'banana'</span>, <span class="string">'apple'</span>, <span class="string">'grape'</span>, <span class="string">'orange'</span>, <span class="string">'grape'</span>, <span class="string">'grape'</span>]</span><br><span class="line"></span><br><span class="line">cnts = {}</span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> words_list:</span><br><span class="line">    cnts[w] = cnts.setdefault(w,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(cnts)</span><br></pre></td></tr></tbody></table></figure><pre><code>{'apple': 3, 'banana': 2, 'orange': 2, 'grape': 3}</code></pre><h2 id="字典推导式"><a class="markdownIt-Anchor" href="#字典推导式"></a> 字典推导式</h2><p>字典推导式的一般表达式如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{key: value for (key, value)in iterable}</span><br></pre></td></tr></tbody></table></figure><p>有些用法与列表推导式是类似的。</p><p>用字典推导式的方法创建字典：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dic_ = {x:x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>)}</span><br><span class="line"><span class="built_in">print</span>(dic_)</span><br></pre></td></tr></tbody></table></figure><pre><code>{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}</code></pre><p>通过两个 list 创建字典：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">keys = [<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'city'</span>, <span class="string">'profession'</span>]</span><br><span class="line">values = [<span class="string">'Alice'</span>, <span class="number">30</span>, <span class="string">'New York'</span>, <span class="string">'Engineer'</span>]</span><br><span class="line"></span><br><span class="line">dic_ = {k:v <span class="keyword">for</span> (k,v) <span class="keyword">in</span> <span class="built_in">zip</span>(keys,values)}</span><br><span class="line"><span class="built_in">print</span>(dic_)</span><br><span class="line"></span><br><span class="line"><span class="comment">#也可以直接使用zip</span></span><br><span class="line">dic_1 = <span class="built_in">dict</span>(<span class="built_in">zip</span>(keys,values))</span><br><span class="line"><span class="built_in">print</span>(dic_1)</span><br></pre></td></tr></tbody></table></figure><pre><code>{'name': 'Alice', 'age': 30, 'city': 'New York', 'profession': 'Engineer'}{'name': 'Alice', 'age': 30, 'city': 'New York', 'profession': 'Engineer'}</code></pre><p>在特定条件下，用字典推导式的方法创建字典：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dic_ = {x:x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">0</span>}</span><br><span class="line"><span class="built_in">print</span>(dic_)</span><br></pre></td></tr></tbody></table></figure><pre><code>{0: 0, 2: 4, 4: 8, 6: 12, 8: 16}</code></pre><h2 id="字典合并"><a class="markdownIt-Anchor" href="#字典合并"></a> 字典合并</h2><p>先来看看下面的运行结果</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">x = {<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>}</span><br><span class="line">y = {<span class="string">'b'</span>:<span class="number">4</span>, <span class="string">'c'</span>:<span class="number">5</span>}</span><br><span class="line">z = x.update(y)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br></pre></td></tr></tbody></table></figure><pre><code>None</code></pre><p>发现 z 返回的是 None 值，并不是我们想要的结果。</p><p>再来看一下此时 x 的返回结果，发现 x 已经是合并的结果。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></tbody></table></figure><pre><code>{'a': 1, 'b': 4, 'c': 5}</code></pre><h3 id="1字典解包"><a class="markdownIt-Anchor" href="#1字典解包"></a> 1.字典解包</h3><p>字典解包（dictionary unpacking）是指使用 ** 操作符将一个字典的键值对解包成独立的键值对，可以将它们合并到另一个字典中或传递给一个函数。在Python中，解包操作符 ** 可以用于将字典中的内容展开成关键字参数。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">x = {<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>}</span><br><span class="line">y = {<span class="string">'b'</span>:<span class="number">4</span>, <span class="string">'c'</span>:<span class="number">5</span>}</span><br><span class="line"></span><br><span class="line">z1 = {**x, **y}</span><br><span class="line">z1</span><br></pre></td></tr></tbody></table></figure><pre><code>{'a': 1, 'b': 4, 'c': 5}</code></pre><p>在这个例子中，<code>**x</code> 将字典 x 的内容解包，<code>**y</code> 将字典 y 的内容解包，并且把它们合并到新的字典 z 中。如果两个字典中有相同的键，后一个字典的值会覆盖前一个字典的值。</p><h3 id="2自定义函数"><a class="markdownIt-Anchor" href="#2自定义函数"></a> 2.自定义函数</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">x,y</span>):</span><br><span class="line">    z = x.copy()</span><br><span class="line">    z.update(y)</span><br><span class="line">    <span class="keyword">return</span> z</span><br><span class="line">z2 = merge(x,y)</span><br><span class="line">z2</span><br></pre></td></tr></tbody></table></figure><pre><code>{'a': 1, 'b': 4, 'c': 5}</code></pre><h3 id="3多个-dict-进行合并"><a class="markdownIt-Anchor" href="#3多个-dict-进行合并"></a> 3.多个 dict 进行合并</h3><p>多个 dictionary 合并同样可以通过自定义的形式来实现。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_dicts</span>(<span class="params">*dict_args</span>):</span><br><span class="line">    result = {}</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> dict_args:</span><br><span class="line">        result.update(item)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">x = {<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>}</span><br><span class="line">y = {<span class="string">'b'</span>:<span class="number">4</span>, <span class="string">'c'</span>:<span class="number">5</span>}</span><br><span class="line">z = {<span class="string">'d'</span>:<span class="number">8</span>, <span class="string">'e'</span>:<span class="number">10</span>}</span><br><span class="line"></span><br><span class="line">ans = merge_dicts(x,y,z)</span><br><span class="line">ans</span><br></pre></td></tr></tbody></table></figure><pre><code>{'a': 1, 'b': 4, 'c': 5, 'd': 8, 'e': 10}</code></pre><p>在函数定义中，星号（*）表示将所有位置参数收集到一个元组中。</p><h2 id="嵌套型字典"><a class="markdownIt-Anchor" href="#嵌套型字典"></a> 嵌套型字典</h2><p>字典是以 <code>key</code>,<code>value</code>的形式创建的，而嵌套型的字典有一个特征，就是<code>key</code>对应的<code>value</code>值也可以是一个字典。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">dic_ = {key_1 : {key1:value1},</span><br><span class="line">        key_2 : {key2:value2} }</span><br></pre></td></tr></tbody></table></figure><h3 id="创建一个嵌套型字典"><a class="markdownIt-Anchor" href="#创建一个嵌套型字典"></a> 创建一个嵌套型字典</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dic_ = {</span><br><span class="line">    <span class="string">'student'</span>: {</span><br><span class="line">        <span class="string">'name'</span>: <span class="string">'John'</span>,</span><br><span class="line">        <span class="string">'age'</span>: <span class="number">22</span></span><br><span class="line">    },</span><br><span class="line">    <span class="string">'course'</span>: {</span><br><span class="line">        <span class="string">'title'</span>: <span class="string">'Introduction to Python'</span>,</span><br><span class="line">        <span class="string">'instructor'</span>: <span class="string">'Dr. Smith'</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="built_in">print</span>(dic_)</span><br></pre></td></tr></tbody></table></figure><pre><code>{'student': {'name': 'John', 'age': 22}, 'course': {'title': 'Introduction to Python', 'instructor': 'Dr. Smith'}}</code></pre><h3 id="从嵌套型字典中获取元素"><a class="markdownIt-Anchor" href="#从嵌套型字典中获取元素"></a> 从嵌套型字典中获取元素</h3><p>从嵌套型字典中获取元素，跟从 list，以及数组中获取元素时有些类似的。</p><p>嵌套型字典用 [] 进行不同层级元素的获取。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(dic_[<span class="string">'student'</span>])</span><br><span class="line"><span class="built_in">print</span>(dic_[<span class="string">'student'</span>][<span class="string">'name'</span>])</span><br></pre></td></tr></tbody></table></figure><pre><code>{'name': 'John', 'age': 22}John</code></pre><h3 id="修改嵌套型字典的元素更改-增加或删除元素"><a class="markdownIt-Anchor" href="#修改嵌套型字典的元素更改-增加或删除元素"></a> 修改嵌套型字典的元素（更改、增加或删除元素）</h3><p><strong>增加一个空的字典</strong></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dic_ = {</span><br><span class="line">    <span class="number">1</span>: {</span><br><span class="line">        <span class="string">'product'</span>: <span class="string">'Laptop'</span>,</span><br><span class="line">        <span class="string">'price'</span>: <span class="number">999.99</span></span><br><span class="line">    },</span><br><span class="line">    <span class="number">2</span>: {</span><br><span class="line">        <span class="string">'product'</span>: <span class="string">'Smartphone'</span>,</span><br><span class="line">        <span class="string">'price'</span>: <span class="number">499.99</span></span><br><span class="line">    },</span><br><span class="line">    <span class="number">3</span>: {</span><br><span class="line">        <span class="string">'product'</span>: <span class="string">'Tablet'</span>,</span><br><span class="line">        <span class="string">'price'</span>: <span class="number">299.99</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">dic_[<span class="number">4</span>] = {}</span><br><span class="line">dic_</span><br></pre></td></tr></tbody></table></figure><pre><code>{1: {'product': 'Laptop', 'price': 999.99}, 2: {'product': 'Smartphone', 'price': 499.99}, 3: {'product': 'Tablet', 'price': 299.99}, 4: {}}</code></pre><p><strong>修改或增加新的元素</strong></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 修改</span></span><br><span class="line">dic_[<span class="number">3</span>][<span class="string">'price'</span>] = <span class="number">599.99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#增加</span></span><br><span class="line">dic_[<span class="number">3</span>][<span class="string">'count'</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">dic_</span><br></pre></td></tr></tbody></table></figure><pre><code>{1: {'product': 'Laptop', 'price': 999.99}, 2: {'product': 'Smartphone', 'price': 499.99}, 3: {'product': 'Tablet', 'price': 599.99, 'count': 10}, 4: {}}</code></pre><p><strong>在嵌套型字典中直接添加一个字典</strong></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dic_[<span class="number">5</span>] = {<span class="string">'product'</span>: <span class="string">'Smartwatch'</span>,</span><br><span class="line">           <span class="string">'price'</span>: <span class="number">199.99</span>}</span><br><span class="line"></span><br><span class="line">dic_</span><br></pre></td></tr></tbody></table></figure><pre><code>{1: {'product': 'Laptop', 'price': 999.99}, 2: {'product': 'Smartphone', 'price': 499.99}, 3: {'product': 'Tablet', 'price': 599.99, 'count': 10}, 4: {}, 5: {'product': 'Smartwatch', 'price': 199.99}}</code></pre><p><strong>删除某个具体元素内容</strong></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> dic_[<span class="number">3</span>][<span class="string">'count'</span>]</span><br><span class="line">dic_</span><br></pre></td></tr></tbody></table></figure><pre><code>{1: {'product': 'Laptop', 'price': 999.99}, 2: {'product': 'Smartphone', 'price': 499.99}, 3: {'product': 'Tablet', 'price': 599.99}, 4: {}, 5: {'product': 'Smartwatch', 'price': 199.99}}</code></pre><h3 id="通过-for-循环来获取嵌套字典内的元素"><a class="markdownIt-Anchor" href="#通过-for-循环来获取嵌套字典内的元素"></a> 通过 for 循环来获取嵌套字典内的元素</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> id_,info <span class="keyword">in</span> dic_.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'id='</span>,id_)</span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> info.items():</span><br><span class="line">        <span class="built_in">print</span>(k+<span class="string">':'</span>+<span class="built_in">str</span>(v))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'\n'</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>id= 1product:Laptopprice:999.99</code></pre><p>​<br>​    id= 2<br>​    product:Smartphone<br>​    price:499.99</p><p>​<br>​    id= 3<br>​    product:Tablet<br>​    price:599.99</p><p>​<br>​    id= 4</p><p>​<br>​    id= 5<br>​    product:Smartwatch<br>​    price:199.99</p><p>​<br>​</p><h3 id="用-pprint-输出嵌套型字典"><a class="markdownIt-Anchor" href="#用-pprint-输出嵌套型字典"></a> 用 pprint 输出嵌套型字典</h3><p>用 pprint 可以使字典显示层次更清晰，需要安装 pprint，在jupyter notebook中的安装命令如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">!pip install pprint</span><br></pre></td></tr></tbody></table></figure><p>pprint 可以使字典显示层次更清晰</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#!pip install pprint</span></span><br><span class="line"><span class="keyword">import</span> pprint </span><br><span class="line"></span><br><span class="line">library = {<span class="string">'fiction'</span>: {<span class="string">'fantasy'</span>: {<span class="string">'Harry Potter'</span>: <span class="string">'excellent'</span>,<span class="string">'Lord of the Rings'</span>: <span class="string">'good'</span>},<span class="string">'mystery'</span>: {<span class="string">'Sherlock Holmes'</span>: <span class="string">'excellent'</span>,<span class="string">'Agatha Christie'</span>: {<span class="string">'Poirot'</span>: <span class="string">'good'</span>,<span class="string">'Miss Marple'</span>: <span class="string">'average'</span>}}},<span class="string">'non-fiction'</span>: {<span class="string">'history'</span>: {<span class="string">'Sapiens'</span>: <span class="string">'excellent'</span>,<span class="string">'Guns, Germs, and Steel'</span>: <span class="string">'good'</span>},<span class="string">'science'</span>: {<span class="string">'Cosmos'</span>: <span class="string">'excellent'</span>,<span class="string">'Brief History of Time'</span>: {<span class="string">'Stephen Hawking'</span>: <span class="string">'excellent'</span>,<span class="string">'others'</span>: <span class="string">'average'</span>}}}}</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(library)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'\n'</span>)</span><br><span class="line">pprint.pprint(library)</span><br></pre></td></tr></tbody></table></figure><pre><code>{'fiction': {'fantasy': {'Harry Potter': 'excellent', 'Lord of the Rings': 'good'}, 'mystery': {'Sherlock Holmes': 'excellent', 'Agatha Christie': {'Poirot': 'good', 'Miss Marple': 'average'}}}, 'non-fiction': {'history': {'Sapiens': 'excellent', 'Guns, Germs, and Steel': 'good'}, 'science': {'Cosmos': 'excellent', 'Brief History of Time': {'Stephen Hawking': 'excellent', 'others': 'average'}}}}</code></pre><p>​<br>​    {‘fiction’: {‘fantasy’: {‘Harry Potter’: ‘excellent’,<br>​                             ‘Lord of the Rings’: ‘good’},<br>​                 ‘mystery’: {‘Agatha Christie’: {‘Miss Marple’: ‘average’,<br>​                                                 ‘Poirot’: ‘good’},<br>​                             ‘Sherlock Holmes’: ‘excellent’}},<br>​     ‘non-fiction’: {‘history’: {‘Guns, Germs, and Steel’: ‘good’,<br>​                                 ‘Sapiens’: ‘excellent’},<br>​                     ‘science’: {‘Brief History of Time’: {‘Stephen Hawking’: ‘excellent’,<br>​                                                           ‘others’: ‘average’},<br>​                                 ‘Cosmos’: ‘excellent’}}}</p><h3 id="嵌套型字典的一些用途"><a class="markdownIt-Anchor" href="#嵌套型字典的一些用途"></a> 嵌套型字典的一些用途</h3><p>这里分享一个用途。嵌套型字典，经常在机器学习中的决策树算法中涉及到。</p><p>使用了 scikit-learn 库的内置数据集 load_wine 来加载一个葡萄酒数据集。</p><p>这个数据集包含不同类型的葡萄酒样本及其相关的化学特征，用于分类任务。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier, export_graphviz</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_wine</span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> Image, display</span><br><span class="line"><span class="keyword">from</span> graphviz <span class="keyword">import</span> Source</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据集</span></span><br><span class="line">data = load_wine()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分离特征和标签</span></span><br><span class="line">X = data.data</span><br><span class="line">y = data.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取特征名称</span></span><br><span class="line">labels = data.feature_names</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建决策树分类器</span></span><br><span class="line">estimator = DecisionTreeClassifier()</span><br><span class="line">estimator.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化决策树</span></span><br><span class="line">graph = Source(tree.export_graphviz(estimator, out_file=<span class="literal">None</span>,</span><br><span class="line">                                    feature_names=labels,</span><br><span class="line">                                    class_names=data.target_names,</span><br><span class="line">                                    filled=<span class="literal">True</span>))</span><br><span class="line">png_data = graph.pipe(<span class="built_in">format</span>=<span class="string">'png'</span>)</span><br><span class="line">display(Image(png_data))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>​<br><img src="/.io//output_169_0.png" alt="png"><br>​</p><h1 id="内置时间模块datetime"><a class="markdownIt-Anchor" href="#内置时间模块datetime"></a> 内置时间模块：Datetime</h1><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>Python 内置时间处理模块主要包括：</p><ul><li>Datetime</li><li>Time</li><li>Calendar</li></ul><p>概括来说，时间和日期处理的模块和库，有几个主要的概念都是会涉及的，包括：</p><p><strong>日期，时间，时间戳，时间和字符串的转换，时区</strong>等。</p><p><code>Datetime</code>、<code>Time</code>、<code>Calendar</code>这三个模块中，用的较多的是<code>Datetime</code>。</p><p>针对<code>Datetime</code>模块，从<strong>构建时间对象实例、时间转换、时间对象的运算</strong>三个方面进行了梳理，共涉及 13 个知识<br>点，整理的大纲如下：</p><p><img src="/.io//datetime.png" alt=""></p><p>针对<code>Time</code>模块，从<strong>时间获取和时间转换</strong>两个方面进行了梳理，共涉及 6 个知识点，整理的大纲如下：</p><p><img src="/.io//time.png" alt=""></p><p>首先要介绍的是用的较多的 datetime 模块, 它属于 Python 的内置模块，功能相对较全。</p><h2 id="构建时间对象实例"><a class="markdownIt-Anchor" href="#构建时间对象实例"></a> 构建时间对象实例</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="comment"># from datetime import date, datetime,time,timedelta,tzinfo</span></span><br><span class="line"><span class="keyword">import</span> time</span><br></pre></td></tr></tbody></table></figure><p>时间实例的构造包括日期（如 2024 年 6 月 26 日），时间（如 22 点 28 分 32 秒），</p><p>或者是包含 date 和 time 的datetime （如 2024 年 6 月 26 日 22 点 28 分 32 秒）。</p><h3 id="日期date实例的构造"><a class="markdownIt-Anchor" href="#日期date实例的构造"></a> 日期（date）实例的构造</h3><p>date 是一个理想化的简单型日期，属性有 year , month , day</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 构造日期date</span></span><br><span class="line">d1 = datetime.date(<span class="number">2024</span>,<span class="number">6</span>,<span class="number">26</span>)</span><br><span class="line">d1</span><br></pre></td></tr></tbody></table></figure><pre><code>datetime.date(2024, 6, 26)</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(d1)</span><br></pre></td></tr></tbody></table></figure><pre><code>2024-06-26</code></pre><p>除了上面的构造方式，在 date 实例化的时候，还可以通过 date.today() 来构造当天的日期。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">datetime.date.today()</span><br></pre></td></tr></tbody></table></figure><pre><code>datetime.date(2024, 6, 26)</code></pre><p><code>date</code> 类型的日期，可以通过 <code>.year</code> , <code>.month</code> , <code>.day</code> 来获取日期所属的年份，月份，和具体的日期号。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">'日期所属的年份为：'</span>,d1.year)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'日期所属的月份为：'</span>,d1.month)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'日期具体的日期号为：'</span>,d1.day)</span><br></pre></td></tr></tbody></table></figure><pre><code>日期所属的年份为： 2024日期所属的月份为： 6日期具体的日期号为： 26</code></pre><h3 id="时间-time-实例的构造"><a class="markdownIt-Anchor" href="#时间-time-实例的构造"></a> 时间 time 实例的构造</h3><p><code>time</code> 是一个独立于任何特定日期的理想化时间，其属性有 <code>hour</code>（小时），<code>minute</code>（分钟），<code>second</code>（秒），<code>microsecond</code>（微秒）</p><p>和 <code>tzinfo</code>（时区信息）</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">t1 = datetime.time(<span class="number">22</span>,<span class="number">43</span>,<span class="number">46</span>)</span><br><span class="line">t1</span><br></pre></td></tr></tbody></table></figure><pre><code>datetime.time(22, 43, 46)</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">'time所属的小时为:'</span>,t1.hour)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'time所属的分钟为:'</span>,t1.minute)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'time所属的秒为:'</span>,t1.second)</span><br></pre></td></tr></tbody></table></figure><pre><code>time所属的小时为: 22time所属的分钟为: 43time所属的秒为: 46</code></pre><h3 id="datetime-实例的构造"><a class="markdownIt-Anchor" href="#datetime-实例的构造"></a> datetime 实例的构造</h3><p><code>datetime</code> 是日期和时间的结合，其属性有 <code>year</code>，<code>month</code>，<code>day</code>，<code>hour</code>，<code>minute</code>，<code>second</code> ，<code>microsecond</code> 和<code>tzinfo</code>。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dt1 = datetime.datetime(<span class="number">2024</span>,<span class="number">6</span>,<span class="number">26</span>,<span class="number">22</span>,<span class="number">49</span>,<span class="number">50</span>)</span><br><span class="line">dt1</span><br></pre></td></tr></tbody></table></figure><pre><code>datetime.datetime(2024, 6, 26, 22, 49, 50)</code></pre><p>除了上面的构造方式，在 <code>datetime</code> 实例化的时候，还有其他的一些方式，包括使用 <code>datetime.now()</code> 和<br><code>datetime.today()</code>，以及在 <code>date</code> 的基础上使用 <code>combine</code> 方法等。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dt2 = datetime.datetime.now()</span><br><span class="line">dt2</span><br></pre></td></tr></tbody></table></figure><pre><code>datetime.datetime(2024, 6, 26, 22, 51, 24, 544538)</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dt3 = datetime.datetime.today()</span><br><span class="line">dt3</span><br></pre></td></tr></tbody></table></figure><pre><code>datetime.datetime(2024, 6, 26, 22, 52, 24, 233317)</code></pre><p>区别：</p><ul><li>时区参数：datetime.datetime.now() 可以接受一个 tz 参数，以返回指定时区的当前时间，而 datetime.datetime.today() 则没有此功能，总是返回本地时间。</li><li>功能：在没有提供 tz 参数的情况下，这两个方法的功能实际上是相同的，都是返回本地时间。</li></ul><p><code>datetime.datetime.combine(date, time)</code> 它可以将一个日期对象 (date) 和一个时间对象 (time) 结合起来，创建一个新的 datetime 对象。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dt4 = datetime.datetime.combine(d1,t1)</span><br><span class="line">dt4</span><br></pre></td></tr></tbody></table></figure><pre><code>datetime.datetime(2024, 6, 26, 22, 43, 46)</code></pre><p>通过 datetime 的实例化，是我们使用时间是经常用到的方法，在日常具体使用过程中，可能只需要具体到某天，</p><p>或者只需要具体到某天的某个时间点，这时候，也可以通过 datetime 的一些方法来实现</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dt_ = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从datetime来获取日期</span></span><br><span class="line">dt_.date()</span><br></pre></td></tr></tbody></table></figure><pre><code>datetime.date(2024, 6, 26)</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 从datetime来获取具体的时间点</span></span><br><span class="line">dt_.time()</span><br></pre></td></tr></tbody></table></figure><pre><code>datetime.time(22, 58, 24, 467936)</code></pre><p>同样的 <code>datetime</code> 类型的时间，可以通过 <code>.year</code> , <code>.month</code> , <code>.day</code> 来获取日期所属的年份，月份，和具体的日期号。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f'日期所属的年份为：<span class="subst">{dt_.year}</span>'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f'日期所属的月份为：<span class="subst">{dt_.month}</span>'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f'日期所属的日期为：<span class="subst">{dt_.day}</span>'</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>日期所属的年份为：2024日期所属的月份为：6日期所属的日期为：26</code></pre><p>还有一个可能涉及到的时间是获取某天属于星期几，可以通过<code>weekday()</code> 和 <code>isoweekday()</code> 方法来实现。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 从 datetime 来获取日期是星期几</span></span><br><span class="line"><span class="comment"># 使用 weekday 方法</span></span><br><span class="line"><span class="comment"># 数字从0开始，0代表星期一，1代表星期二，以此类推</span></span><br><span class="line">dt_.weekday()</span><br></pre></td></tr></tbody></table></figure><pre><code>2</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 从 datetime 来获取日期是星期几</span></span><br><span class="line"><span class="comment"># 使用 isoweekday 方法</span></span><br><span class="line"><span class="comment"># 数字从1开始，1代表星期一，2代表星期二，以此类推</span></span><br><span class="line">dt_.isoweekday()</span><br></pre></td></tr></tbody></table></figure><pre><code>3</code></pre><p>datetime 还有一种方法。如果 datetime 的值由于某些原因弄错了，还可以通过 <code>replace()</code> 方法来进行更正。<br>replace 方法的参数如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">datetime.replace(year=self.year, month=self.month, day=self.day, hour=self.hour,</span><br><span class="line">minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.</span><br><span class="line">tzinfo, * fold=0)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dt_new = dt_.replace(month = <span class="number">7</span>)</span><br><span class="line">dt_new</span><br></pre></td></tr></tbody></table></figure><pre><code>datetime.datetime(2024, 7, 26, 22, 58, 24, 467936)</code></pre><h3 id="timedelta-对象的构造"><a class="markdownIt-Anchor" href="#timedelta-对象的构造"></a> timedelta 对象的构造</h3><p>timedelta 对象表示两个 date 或者 time 或者 datetime 的时间间隔。</p> <figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"> class datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0,</span><br><span class="line">minutes=0, hours=0, weeks=0)</span><br></pre></td></tr></tbody></table></figure><p>所有参数都是可选的并且默认为 0。这些参数可以是整数或者浮点数，也可以是正数或者负数。</p><p>只有 <code>days</code>, <code>seconds</code> 和 <code>microseconds</code> 会存储在内部。参数单位的换算规则如下：</p><ul><li>1 毫秒会转换成 1000 微秒。</li><li>1 分钟会转换成 60 秒。</li><li>1 小时会转换成 3600 秒。</li><li>1 星期会转换成 7 天。</li></ul><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">delta = datetime.timedelta(weeks=<span class="number">3</span>,</span><br><span class="line">                           days=<span class="number">10</span>,</span><br><span class="line">                           hours=<span class="number">6</span>,</span><br><span class="line">                           minutes=<span class="number">50</span>,</span><br><span class="line">                           seconds=<span class="number">30</span>,</span><br><span class="line">                           microseconds=<span class="number">1000</span>,</span><br><span class="line">                           milliseconds=<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">delta</span><br></pre></td></tr></tbody></table></figure><pre><code>datetime.timedelta(days=31, seconds=24640, microseconds=1000)</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(delta)</span><br></pre></td></tr></tbody></table></figure><pre><code>31 days, 6:50:40.001000</code></pre><h3 id="tzinfo-介绍"><a class="markdownIt-Anchor" href="#tzinfo-介绍"></a> tzinfo 介绍</h3><p><code>datetime.tzinfo</code> 返回 datetime 对象的时区，前提是在创建 datetime 对象时需传入 tzinfo 参数，如果没有传入则返回值为 None 。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytz</span><br><span class="line"></span><br><span class="line">sh = pytz.timezone(<span class="string">'Asia/Shanghai'</span>)</span><br><span class="line">d_tz = datetime.datetime.now(sh)</span><br><span class="line"></span><br><span class="line">d_tz.tzinfo</span><br></pre></td></tr></tbody></table></figure><pre><code>&lt;DstTzInfo 'Asia/Shanghai' CST+8:00:00 STD&gt;</code></pre><h2 id="时间转换"><a class="markdownIt-Anchor" href="#时间转换"></a> 时间转换</h2><p>时间的三种存在方式：时间对象，时间字符串，时间戳。</p><p>时间对象，比如前面介绍的 date 、datetime 、time 对象等；</p><p>时间字符串，如：“2024-6-27”；</p><p>时间戳，如 <code>time.time()</code> 返回的就是时间戳。</p><p>在数据处理过程中，经常会遇到需要将不同形式的时间进行转换。这里介绍下常用的方法：</p><h3 id="时间对象转字符串"><a class="markdownIt-Anchor" href="#时间对象转字符串"></a> 时间对象转字符串</h3><p>时间对象转换为字符串，可以通过 isoformat 或 strftime 方法来实现。</p><p>isoformat 是 ISO 8601 格式的缩写，ISO 是 International Organization for Standardization（国际标准化组织）的缩写，因此 isoformat 的全称可以解释为 ISO 8601 format，即“国际标准化组织 8601 格式”。</p><p>strftime 的英文全称是 str format time ，根据给定的格式将时间对象转换为字符串</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 将 date 时间对象转换为字符串</span></span><br><span class="line">d_ = datetime.date.today()</span><br><span class="line">d_.isoformat()</span><br></pre></td></tr></tbody></table></figure><pre><code>'2024-06-27'</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#用 srtftime 来转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># YYYY-MM-DD 形式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'YYYY-MM-DD:'</span>,d_.strftime(<span class="string">'%Y-%m-%d'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#MM DD, YYYY 形 式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'MM DD,YYYY:'</span>,d_.strftime(<span class="string">'%b %d, %Y'</span>))</span><br></pre></td></tr></tbody></table></figure><pre><code>YYYY-MM-DD: 2024-06-27MM DD,YYYY: Jun 27, 2024</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 将 time 时间对象转换为字符串</span></span><br><span class="line">t_ = datetime.datetime.now().time()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(t_.strftime(<span class="string">'%H:%M:%S'</span>))</span><br></pre></td></tr></tbody></table></figure><pre><code>00:17:02</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 将 datetime 时间对象转换为字符串</span></span><br><span class="line">dt_ = datetime.datetime.now()</span><br><span class="line">dt_.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>'2024-06-27 00:17:11'</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dt_.isoformat()</span><br></pre></td></tr></tbody></table></figure><pre><code>'2024-06-27T00:17:11.564718'</code></pre><p>python 中常见的时间日期格式化符号：</p><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">意义</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center">%a</td><td style="text-align:center">当地工作日的缩写。</td><td style="text-align:center">Sun, Mon, …, Sat (en_US); So, Mo, …, Sa (de_DE)</td></tr><tr><td style="text-align:center">%A</td><td style="text-align:center">本地化的星期中每日的完整名称。</td><td style="text-align:center">Sunday, Monday, …, Saturday (en_US); Sonntag, Montag, …, Samstag (de_DE)</td></tr><tr><td style="text-align:center">%w</td><td style="text-align:center">以十进制数显示的工作日，其中 0 表示星期日，6 表示星期六。</td><td style="text-align:center">0, 1, …, 6</td></tr><tr><td style="text-align:center">%d</td><td style="text-align:center">补零后，以十进制数显示的月份中的一天。</td><td style="text-align:center">01, 02, …, 31</td></tr><tr><td style="text-align:center">%b</td><td style="text-align:center">当地月份的缩写。</td><td style="text-align:center">Jan, Feb, …, Dec (en_US); Jan, Feb, …, Dez (de_DE)</td></tr><tr><td style="text-align:center">%B</td><td style="text-align:center">本地化的月份全名。</td><td style="text-align:center">January, February, …, December (en_US); Januar, Februar, …, Dezember (de_DE)</td></tr><tr><td style="text-align:center">%m</td><td style="text-align:center">补零后，以十进制数显示的月份。</td><td style="text-align:center">01, 02, …, 12</td></tr><tr><td style="text-align:center">%y</td><td style="text-align:center">补零后，以十进制数表示的，不带世纪的年份。</td><td style="text-align:center">00, 01, …, 99</td></tr><tr><td style="text-align:center">%Y</td><td style="text-align:center">十进制数表示的带世纪的年份。</td><td style="text-align:center">0001, 0002, …, 2013, 2014, …, 9998, 9999</td></tr><tr><td style="text-align:center">%H</td><td style="text-align:center">以补零后的十进制数表示的小时 (24 小时制)。</td><td style="text-align:center">00, 01, …, 23</td></tr><tr><td style="text-align:center">%I</td><td style="text-align:center">以补零后的十进制数表示的小时（12 小时制）。</td><td style="text-align:center">01, 02, …, 12</td></tr><tr><td style="text-align:center">%p</td><td style="text-align:center">本地化的 AM 或 PM。</td><td style="text-align:center">AM, PM (en_US); am, pm (de_DE)</td></tr><tr><td style="text-align:center">%M</td><td style="text-align:center">补零后，以十进制数显示的分钟。</td><td style="text-align:center">00, 01, …, 59</td></tr><tr><td style="text-align:center">%S</td><td style="text-align:center">补零后，以十进制数显示的秒。</td><td style="text-align:center">00, 01, …, 59</td></tr><tr><td style="text-align:center">%f</td><td style="text-align:center">以十进制数表示的微秒，在左侧补零。</td><td style="text-align:center">000000, 000001, …, 999999</td></tr><tr><td style="text-align:center">%z</td><td style="text-align:center">UTC 偏移量，格式为 ±HHMM [SS[.ffffff]]（如果是简单型对象则为空字符串）。</td><td style="text-align:center">(空), +0000, -0400, +1030, +063415, -030712.345216</td></tr><tr><td style="text-align:center">%Z</td><td style="text-align:center">时区名称（如果对象为简单型则为空字符串）。</td><td style="text-align:center">(空), UTC, GMT</td></tr><tr><td style="text-align:center">%j</td><td style="text-align:center">以补零后的十进制数表示的一年中的日序号。</td><td style="text-align:center">001, 002, …, 366</td></tr><tr><td style="text-align:center">%U</td><td style="text-align:center">以补零后的十进制数表示的一年中的周序号（星期日作为每周的第一天）。在新的一年中第一个星期日之前的所有日子都被视为是在第 0 周。</td><td style="text-align:center">00, 01, …, 53</td></tr><tr><td style="text-align:center">%W</td><td style="text-align:center">以十进制数表示的一年中的周序号（星期一作为每周的第一天）。在新的一年中第一个星期一之前的所有日子都被视为是在第 0 周。</td><td style="text-align:center">00, 01, …, 53</td></tr><tr><td style="text-align:center">%c</td><td style="text-align:center">本地化的适当日期和时间表示。</td><td style="text-align:center">Tue Aug 16 21:30:00 1988 (en_US); Di 16 Aug 21:30:00 1988 (de_DE)</td></tr><tr><td style="text-align:center">%x</td><td style="text-align:center">本地化的适当日期表示。</td><td style="text-align:center">08/16/88 (None); 08/16/1988 (en_US); 16.08.1988 (de_DE)</td></tr><tr><td style="text-align:center">%X</td><td style="text-align:center">本地化的适当时间表示。</td><td style="text-align:center">21:30:00 (en_US); 21:30:00 (de_DE)</td></tr><tr><td style="text-align:center">%%</td><td style="text-align:center">字面的 ‘%’ 字符。</td><td style="text-align:center">%</td></tr></tbody></table><h3 id="字符串转时间对象"><a class="markdownIt-Anchor" href="#字符串转时间对象"></a> 字符串转时间对象</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Python基本使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python可视化</title>
      <link href="/2024/06/01/hua-tu/"/>
      <url>/2024/06/01/hua-tu/</url>
      
        <content type="html"><![CDATA[<h1 id="python可视化教程">Python可视化教程</h1><p>本文章将使用matplotlib,seaborn进行可视化教程。</p><h1 id="seaborn简介">1.Seaborn简介</h1><h2 id="seaborn快速上手">1.1Seaborn快速上手</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略所有 UserWarning 警告</span></span><br><span class="line">warnings.filterwarnings(<span class="string">"ignore"</span>, category=UserWarning)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置绘图风格</span></span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span></span><br><span class="line">custom_set = {</span><br><span class="line">    <span class="string">"font.family"</span>: <span class="string">"SimHei"</span>,</span><br><span class="line">    <span class="string">"axes.spines.left"</span>: <span class="literal">True</span>, <span class="comment"># y坐标轴开启</span></span><br><span class="line">    <span class="string">"axes.spines.bottom"</span>: <span class="literal">True</span>, <span class="comment"># x坐标轴开启</span></span><br><span class="line">    <span class="string">"axes.spines.top"</span>: <span class="literal">False</span>, <span class="comment"># 上方坐标轴关闭</span></span><br><span class="line">    <span class="string">"axes.spines.right"</span>: <span class="literal">False</span>, <span class="comment"># 右侧坐标轴关闭</span></span><br><span class="line">    <span class="string">"axes.edgecolor"</span>: <span class="string">"gray"</span>, <span class="comment"># 坐标轴颜色</span></span><br><span class="line">    <span class="string">"axes.linewidth"</span>: <span class="number">0.4</span>, <span class="comment"># 坐标轴宽度</span></span><br><span class="line">    <span class="string">"grid.linewidth"</span>: <span class="number">0.3</span>, <span class="comment"># 网格线宽度</span></span><br><span class="line">    <span class="string">"grid.alpha"</span>: <span class="number">1</span>, <span class="comment"># 网格线透明度</span></span><br><span class="line">    <span class="string">"legend.frameon"</span>: <span class="literal">True</span>, <span class="comment"># 图例边框开启</span></span><br><span class="line">    <span class="string">"legend.framealpha"</span>: <span class="number">0.5</span> <span class="comment"># 图例边框透明度</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sns.set_theme(</span><br><span class="line">    style=<span class="string">'whitegrid'</span>, <span class="comment"># 设置图表的风格为“Whitegrid"</span></span><br><span class="line">    rc=custom_set, <span class="comment"># 其他设置</span></span><br><span class="line">    font_scale=<span class="number">0.8</span>, <span class="comment"># 文本字号</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备绘图数据</span></span><br><span class="line">tips = pd.read_csv(<span class="string">'数据/tips.csv'</span>) <span class="comment"># 使用pandas读取数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># seaborn绘图</span></span><br><span class="line">g = sns.relplot( <span class="comment"># 使用seaborn.relplot函数制作相关关系图</span></span><br><span class="line">    data=tips, <span class="comment"># 指定绘图数据tips</span></span><br><span class="line">    x=<span class="string">"消费金额 ($)"</span>, <span class="comment"># 指定x轴变量"消费金额($)"</span></span><br><span class="line">    y=<span class="string">"小费金额 ($)"</span>, <span class="comment"># 指定y轴变量"小费金额($)"</span></span><br><span class="line">    col=<span class="string">"就餐时间"</span>, <span class="comment"># 设置通过"就餐时间"种类,按照列分面(facets)绘图</span></span><br><span class="line">    hue=<span class="string">"是否吸烟"</span>, <span class="comment"># 设置散点颜色按照"是否吸烟"种类变化</span></span><br><span class="line">    style=<span class="string">"客人性别"</span>, <span class="comment"># 设置散点形状按照"客人性别"变化</span></span><br><span class="line">    palette=[<span class="string">"#b1283a"</span>, <span class="string">"#006a8e"</span>], <span class="comment"># 设置点颜色</span></span><br><span class="line">    s=<span class="number">200</span> <span class="comment"># 设置点大小</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="../../../../images/seaborn/output_3_0.png"></p><h2 id="可视化步骤">1.2可视化步骤</h2><p>从上面的示例可以看到，使用Seaborn进行可视化主要有4个主要步骤。 1.导入依赖包 导入seaborn包并简写为sns。 2. 设置绘图风格设置绘图风格，例如，“whitegrid"；对坐标轴、图例、网格线等图表属性个性化设置。3. 准备绘图数据seaborn支持多种数据集格式，可根据可视化数据集的格式灵活准备数据。 4.挑选seaborn函数绘图 挑选符合数据的函数进行绘图。</p><h2 id="绘图函数">1.2绘图函数</h2><p>从架构层面，seaborn主要有两大类绘图函数，图级别绘图函数（figure-level）、轴级别绘图函数（axes-level）。从功能层面，seaborn绘图函数可以划分为以下几类: - 美化函数（aesthetics）美化图形比例尺度（the scaling of plot elements）、图形风格（the generalstyle of the plots）、图形配色（the color palette/colormap)。 -单个图函数 绘制相关关系图（Relational plots）、分布关系图（Distributionplots）、分类关系图 (Categorical plots)、回归关系图（Regressionplots）、矩阵关系图 (Matrix plots) 、统计估计和误差棒 (Statisticalestimation and error bars) 。 - 组合图函数同时展示多个子图表或图形，以便进行比较或展示相关信息。包含分面图 (Facetgrids)、配对关系图 (Pair grids) 、组合关系图 (Joint grids)。</p><h1 id="seaborn图形美化">2.Seaborn图形美化</h1><p>seaborn中从3个方面美化图形: - 比例尺度 (context)，设置the scaling ofplot elements，例如，图中文字大小、标记marker大小、线条宽度等； -风格（style），设置the general style of theplots，例如，图中网格线是否开启、颜色、线宽等； -配色（palette），设置colorpalette，例如，Set1、#a1c9f4、red等。（使用多巴胺配色能使得图片更加清晰、美观）</p><h2 id="context设置图形比例">2.1context设置图形比例</h2><p>查看<code>context</code>内容可以使用：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">sns.plotting_context()</span><br></pre></td></tr></tbody></table></figure><pre><code>{'font.size': 9.600000000000001, 'axes.labelsize': 9.600000000000001, 'axes.titlesize': 9.600000000000001, 'xtick.labelsize': 8.8, 'ytick.labelsize': 8.8, 'legend.fontsize': 8.8, 'legend.title_fontsize': 9.600000000000001, 'axes.linewidth': 0.4, 'grid.linewidth': 0.3, 'lines.linewidth': 1.5, 'lines.markersize': 6.0, 'patch.linewidth': 1.0, 'xtick.major.width': 1.25, 'ytick.major.width': 1.25, 'xtick.minor.width': 1.0, 'ytick.minor.width': 1.0, 'xtick.major.size': 6.0, 'ytick.major.size': 6.0, 'xtick.minor.size': 4.0, 'ytick.minor.size': 4.0}</code></pre><p>即： </p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">'font.size': 12.0,         # 字体大小</span><br><span class="line">'axes.labelsize': 12.0,      # 坐标轴标签大小</span><br><span class="line">'axes.titlesize': 12.0,      # 坐标轴标题大小</span><br><span class="line">'xtick.labelsize': 11.0,     # x轴刻度标签大小</span><br><span class="line">'ytick.labelsize': 11.0,     # y轴刻度标签大小</span><br><span class="line">'legend.fontsize': 11.0,     # 图例字体大小</span><br><span class="line">'legend.title_fontsize': 12.0, # 图例标题字体大小</span><br><span class="line">'axes.linewidth': 1.25,      # 坐标轴线宽度</span><br><span class="line">'grid.linewidth': 1.0，      # 网格线宽度</span><br><span class="line">'lines.linewidth': 1.5,      # 线条宽度</span><br><span class="line">'lines.markersize': 6.0,     # 线条标记大小</span><br><span class="line">'patch.linewidth': 1.0,      # 图形patch线宽度</span><br><span class="line">'xtick.major.width': 1.25,    # x轴主刻度线宽度</span><br><span class="line">'ytick.major.width': 1.25,    # y轴主刻度线宽度</span><br><span class="line">'xtick.minor.width': 1.0，    # x轴次刻度线宽度</span><br><span class="line">'ytick.minor.width': 1.0，    # y轴次刻度线宽度</span><br><span class="line">'xtick.major.size': 6.0,     # x轴主刻度线长度</span><br><span class="line">'ytick.major.size': 6.0,     # y轴主刻度线长度</span><br><span class="line">'xtick.minor.size': 4.0,     # x轴次刻度线长度</span><br><span class="line">'ytick.minor.size': 4.0      # y轴次刻度线长度</span><br></pre></td></tr></tbody></table></figure><p></p><p>设置<code>context</code>内容:可以使用<code>set_context</code>设置，但是不会改变图标整体的样式。</p><p>seaboen内置了四套context设置，分别为<code>paper</code>,<code>notebook</code>,<code>talk</code>,<code>poster</code>。</p><p>下面进行展示。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">8</span>))</span><br><span class="line">contexts = [<span class="string">'notebook'</span>, <span class="string">'paper'</span>, <span class="string">'talk'</span>, <span class="string">'poster'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, context <span class="keyword">in</span> <span class="built_in">enumerate</span>(contexts):</span><br><span class="line">    sns.set_context(context) <span class="comment">#设置context</span></span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">2</span>, i + <span class="number">1</span>)</span><br><span class="line">    x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">    y = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">    sns.lineplot(x=x, y=y, color=<span class="string">"#b1283a"</span>)</span><br><span class="line">    plt.title(<span class="string">f"context: \"<span class="subst">{context}</span>\""</span>, color=<span class="string">"#006a8e"</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p>​<br><img src="../../../../images/seaborn/output_7_0.png"> ​</p><p>上图可清晰的展示context变化，图形中字体、线宽等属性的变化。</p><p>在使用某个已经内置的context方案时，还可以通过rc单独设置context中的任意参数，</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#痛过rc独立设置xtick.labelsize</span></span><br><span class="line">sns.set_context(<span class="string">'poster'</span>, rc={<span class="string">"xtick.labelsize"</span>: <span class="number">50</span>})</span><br><span class="line">sns.lineplot(x=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], y=[<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>])</span><br></pre></td></tr></tbody></table></figure><pre><code>&lt;Axes: &gt;</code></pre><p>​<br><img src="../../../../images/seaborn/output_9_1.png"> ​</p><p>此外，可通过<code>font_scale</code>设置整个图的字体缩放</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过font_scale设置整个图的字体缩放</span></span><br><span class="line">sns.set_context(<span class="string">'poster'</span>,font_scale=<span class="number">2</span>) </span><br><span class="line">sns.lineplot(x=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], y=[<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>])</span><br></pre></td></tr></tbody></table></figure><pre><code>&lt;Axes: &gt;</code></pre><p>​<br><img src="../../../../images/seaborn/output_11_1.png"> ​</p><h2 id="style设置图形通用样式">2.2style设置图形通用样式</h2><p>查看style内容：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">sns.axes_style()</span><br></pre></td></tr></tbody></table></figure><pre><code>{'axes.facecolor': 'white', 'axes.edgecolor': 'black', 'axes.grid': False, 'axes.axisbelow': 'line', 'axes.labelcolor': 'black', 'figure.facecolor': 'white', 'grid.color': '#b0b0b0', 'grid.linestyle': '-', 'text.color': 'black', 'xtick.color': 'black', 'ytick.color': 'black', 'xtick.direction': 'out', 'ytick.direction': 'out', 'lines.solid_capstyle': &lt;CapStyle.projecting: 'projecting'&gt;, 'patch.edgecolor': 'black', 'patch.force_edgecolor': False, 'image.cmap': 'viridis', 'font.family': ['sans-serif'], 'font.sans-serif': ['DejaVu Sans',  'Bitstream Vera Sans',  'Computer Modern Sans Serif',  'Lucida Grande',  'Verdana',  'Geneva',  'Lucid',  'Arial',  'Helvetica',  'Avant Garde',  'sans-serif'], 'xtick.bottom': True, 'xtick.top': False, 'ytick.left': True, 'ytick.right': False, 'axes.spines.left': True, 'axes.spines.bottom': True, 'axes.spines.right': True, 'axes.spines.top': True}</code></pre><p>即： </p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">'axes.facecolor': '#EAEAF2',                # 坐标轴背景颜色</span><br><span class="line">'axes.edgecolor': 'white',                  # 坐标轴边框颜色</span><br><span class="line">'axes.grid': True,                          # 是否显示网格线</span><br><span class="line">'axes.axisbelow': True,                     # 网格线是否在图形下方</span><br><span class="line">'axes.labelcolor': '.15',                   # 坐标轴标签颜色</span><br><span class="line">'figure.facecolor': 'white',                # 图形背景颜色</span><br><span class="line">'grid.color': 'white',                      # 网格线颜色</span><br><span class="line">'grid.linestyle': '-',                      # 网格线样式</span><br><span class="line">'text.color': '.15',                        # 文本颜色</span><br><span class="line">'xtick.color': '.15',                       # x轴刻度颜色</span><br><span class="line">'ytick.color': '.15',                       # y轴刻度颜色</span><br><span class="line">'xtick.direction': 'out',                  # x轴刻度线方向</span><br><span class="line">'ytick.direction': 'out',                  # y轴刻度线方向</span><br><span class="line">'lines.solid_capstyle': 'round',           # 线条末端样式</span><br><span class="line">'patch.edgecolor': 'w',                    # 图形patch边框颜色</span><br><span class="line">'patch.force_edgecolor': True,             # 强制指定图形patch边框颜色</span><br><span class="line">'image.cmap': 'rocket',                    # 图像的色彩映射</span><br><span class="line">'font.family': ['sans-serif'],             # 字体家族</span><br><span class="line">'font.sans-serif': ['Arial',               # 无衬线字体</span><br><span class="line">                    'DejaVu Sans',</span><br><span class="line">                    'Liberation Sans',</span><br><span class="line">                    'Bitstream Vera Sans',</span><br><span class="line">                    'sans-serif'],</span><br><span class="line">'xtick.bottom': False,                     # x轴刻度是否显示在底部</span><br><span class="line">'xtick.top': False,                        # x轴刻度是否显示在顶部</span><br><span class="line">'ytick.left': False,                       # y轴刻度是否显示在左侧</span><br><span class="line">'ytick.right': False,                      # y轴刻度是否显示在右侧</span><br><span class="line">'axes.spines.left': True,                  # 左侧坐标轴边框是否显示</span><br><span class="line">'axes.spines.bottom': True,                # 底部坐标轴边框是否显示</span><br><span class="line">'axes.spines.right': True,                 # 右侧坐标轴边框是否显示</span><br><span class="line">'axes.spines.top': True                    # 顶部坐标轴边框是否显示</span><br></pre></td></tr></tbody></table></figure><p></p><p>设置style内容:</p><p>set_style()可设置style，seanborn内置了五套style设置，分别为darkgrid,whitegrid, dark, white, ticks，效果如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">8</span>))</span><br><span class="line">sns.set_theme()</span><br><span class="line">styles = [<span class="string">'darkgrid'</span>, <span class="string">'whitegrid'</span>, <span class="string">'dark'</span>, <span class="string">'white'</span>, <span class="string">'ticks'</span>]</span><br><span class="line"><span class="keyword">for</span> i, style <span class="keyword">in</span> <span class="built_in">enumerate</span>(styles):</span><br><span class="line">    sns.set_style(style)  <span class="comment">#设置style</span></span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">3</span>, i + <span class="number">1</span>)</span><br><span class="line">    sns.lineplot(x=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], y=[<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>], color=<span class="string">"#b1283a"</span>)</span><br><span class="line">    plt.title(<span class="string">f"style: \"<span class="subst">{style}</span>\""</span>, color=<span class="string">"#006a8e"</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p>​<br><img src="../../../../images/seaborn/output_15_0.png"> ​</p><p>同理，也可以使用<code>rc</code>进行独立设置某个参数：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># rc独立设置某个参数</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#rc设置网格线的颜色为绿色</span></span><br><span class="line">sns.set_style(<span class="string">'whitegrid'</span>, rc={<span class="string">'grid.color'</span>: <span class="string">'#6ccea3'</span>})</span><br><span class="line">sns.lineplot(x=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], y=[<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>], color=<span class="string">"#b1283a"</span>)</span><br><span class="line">plt.title(<span class="string">'set_style with \"rc\"'</span>, color=<span class="string">"#006a8e"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p>​<br><img src="../../../../images/seaborn/output_17_0.png"> ​</p><h2 id="palette设置图形配色">2.3palette设置图形配色</h2><p>设置图形配色palette目的在于有效地展示数据、让图表吸引人，seaborn调色板palette可分为3大类：</p><p><strong>定性调色板</strong>（qualitativepalettes）：适用于分类数据（categoricaldata），例如，一项调查中的满意度评级（“非常不满意”，“不满意”，“中立”，“满意”，“非常满意”）中人员占比数据。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">current_palette = sns.color_palette()</span><br><span class="line">sns.palplot(current_palette)</span><br></pre></td></tr></tbody></table></figure><p>​<br><img src="../../../../images/seaborn/output_19_0.png"> ​</p><p><strong>顺序调色板</strong>（sequentialpalettes）：适用于数值数据（numericdata），例如，一周中每天温度值数据。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">sns.palplot(sns.color_palette(<span class="string">"Reds"</span>, <span class="number">10</span>))</span><br><span class="line">sns.palplot(sns.color_palette(<span class="string">"Blues"</span>, <span class="number">10</span>))</span><br></pre></td></tr></tbody></table></figure><p>​<br><img src="../../../../images/seaborn/output_21_0.png"> ​</p><p><img src="../../../../images/seaborn/output_21_1.png"></p><p><strong>离散调色板</strong>（divergingpalettes）：适用于在数值数据中表示具有分类边界的情况（numeric data witha categoricalboundary），例如，人群中中12-18岁、19-24岁、25-35岁各区间人员占比数据。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">sns.palplot(sns.color_palette(<span class="string">"coolwarm"</span>, <span class="number">10</span>))</span><br></pre></td></tr></tbody></table></figure><p>​<br><img src="../../../../images/seaborn/output_23_0.png"> ​</p><p>seaborn提供了多种配色设置函数。</p><h3 id="构建颜色">2.3.1构建颜色</h3><h4 id="cubehelix_palette">cubehelix_palette</h4><p>基于cubehelix系统使用<code>cubehelix_palette</code>函数构建<code>sequential palettes</code>，生成一个亮度线性递减（或递增）的<code>colormap</code>，使用该颜色生成的图形无论是打印成黑白图像或被色盲者观看时都依然能够清晰展现数据的不同特征。cubehelix_palette使用方法:</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">cubehelix_palette_test = sns.cubehelix_palette(</span><br><span class="line">    n_colors=<span class="number">6</span>,  <span class="comment">#颜色数量</span></span><br><span class="line">    start=<span class="number">0</span>,  <span class="comment">#设置颜色的起始值（0 &lt;= start &lt;= 3）</span></span><br><span class="line">    rot=<span class="number">0.4</span>,  <span class="comment">#设置颜色轮上的旋转值</span></span><br><span class="line">    gamma=<span class="number">1.0</span>,  <span class="comment">#调整颜色的非线性以突出暗色（gamma &lt; 1）或亮色（gamma &gt; 1）</span></span><br><span class="line">    hue=<span class="number">0.8</span>,  <span class="comment">#设置颜色的饱和度（0 &lt;= hue &lt;= 1）</span></span><br><span class="line">    light=<span class="number">0.85</span>,  <span class="comment">#设置颜色的最暗颜色的强度（0 &lt;= light &lt;= 1）</span></span><br><span class="line">    dark=<span class="number">0.15</span>,  <span class="comment">#设置颜色的最亮颜色的强度0 &lt;= dark &lt;= 1</span></span><br><span class="line">    reverse=<span class="literal">False</span>,  <span class="comment">#默颜色顺序，False为从亮到暗，True为从暗到亮</span></span><br><span class="line">    as_cmap=<span class="literal">False</span>  <span class="comment">##False返回元组格式颜色，如[0.9312692223325372, 0.8201921796082118, 0.7971480974663592]；#True则返回matplotlib.colors.ListedColormap</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(cubehelix_palette_test) <span class="comment">#输出cubehelix_palette返回值</span></span><br><span class="line">cubehelix_palette_test</span><br></pre></td></tr></tbody></table></figure><pre><code>[[0.9312692223325372, 0.8201921796082118, 0.7971480974663592], [0.8559578605899612, 0.6418993116910497, 0.6754191211563135], [0.739734329496642, 0.4765280683170713, 0.5959617419736206], [0.57916573903086, 0.33934576125314425, 0.5219003947563425], [0.37894937987024996, 0.2224702044652721, 0.41140014301575434], [0.1750865648952205, 0.11840023306916837, 0.24215989137836502]]</code></pre><svg width="330" height="55"><rect x="0" y="0" width="55" height="55" style="fill:#edd1cb;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="55" y="0" width="55" height="55" style="fill:#daa4ac;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="110" y="0" width="55" height="55" style="fill:#bd7a98;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="165" y="0" width="55" height="55" style="fill:#945785;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="220" y="0" width="55" height="55" style="fill:#613969;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="275" y="0" width="55" height="55" style="fill:#2d1e3e;stroke-width:2;stroke:rgb(255,255,255)"></rect></svg><p>当参数as_cmap设置为False时，同时输出6种元组格式颜色</p><p>上面的例子为了介绍cubehelix_palette的各个参数，参数全部列出。其实，实际使用时，只需要修改个别参数，大部分都可以直接使用默认值。例如:</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#输出cubehelix_palette默认colormap</span></span><br><span class="line">sns.cubehelix_palette()</span><br></pre></td></tr></tbody></table></figure><svg width="330" height="55"><rect x="0" y="0" width="55" height="55" style="fill:#edd1cb;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="55" y="0" width="55" height="55" style="fill:#daa4ac;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="110" y="0" width="55" height="55" style="fill:#bd7a98;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="165" y="0" width="55" height="55" style="fill:#945785;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="220" y="0" width="55" height="55" style="fill:#613969;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="275" y="0" width="55" height="55" style="fill:#2d1e3e;stroke-width:2;stroke:rgb(255,255,255)"></rect></svg><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#修改n_colors，输出10中颜色</span></span><br><span class="line">sns.cubehelix_palette(n_colors=<span class="number">10</span>)</span><br></pre></td></tr></tbody></table></figure><svg width="550" height="55"><rect x="0" y="0" width="55" height="55" style="fill:#edd1cb;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="55" y="0" width="55" height="55" style="fill:#e4b8b8;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="110" y="0" width="55" height="55" style="fill:#d89faa;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="165" y="0" width="55" height="55" style="fill:#c8879e;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="220" y="0" width="55" height="55" style="fill:#b47194;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="275" y="0" width="55" height="55" style="fill:#9e5e8a;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="330" y="0" width="55" height="55" style="fill:#834c7d;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="385" y="0" width="55" height="55" style="fill:#673c6d;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="440" y="0" width="55" height="55" style="fill:#492d58;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="495" y="0" width="55" height="55" style="fill:#2d1e3e;stroke-width:2;stroke:rgb(255,255,255)"></rect></svg><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#修改rot</span></span><br><span class="line">sns.cubehelix_palette(rot=<span class="number">0.1</span>)</span><br></pre></td></tr></tbody></table></figure><svg width="330" height="55"><rect x="0" y="0" width="55" height="55" style="fill:#e3d0ef;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="55" y="0" width="55" height="55" style="fill:#c2a7da;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="110" y="0" width="55" height="55" style="fill:#9d82bf;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="165" y="0" width="55" height="55" style="fill:#76619e;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="220" y="0" width="55" height="55" style="fill:#4e4173;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="275" y="0" width="55" height="55" style="fill:#26213f;stroke-width:2;stroke:rgb(255,255,255)"></rect></svg><h4 id="dark_palette">dark_palette</h4><p>混合深色和指定颜色，使用<code>dark_palette</code>函数构建<code>sequential palettes</code>，生成一个深色到指定色的<code>colormap</code>。</p><p>适用场景：适用于数据的范围在感兴趣的高值数据～不感兴趣的低值数据之间的变化情况。</p><p>dark_palette使用方法:</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.dark_palette(</span><br><span class="line">    color=<span class="string">'white'</span>,  <span class="comment">#传入一个颜色字符串或者颜色的RGB值，作为生成渐变色的终点</span></span><br><span class="line">    n_colors=<span class="number">10</span>,  <span class="comment">#colormap数量</span></span><br><span class="line">    reverse=<span class="literal">False</span>,  <span class="comment">#设置颜色顺序，False为从暗到亮，True为从亮到暗</span></span><br><span class="line">    as_cmap=<span class="literal">False</span>  <span class="comment">#False返回元组格式颜色，如[0.9312692223325372, 0.8201921796082118, 0.7971480974663592]；#True则返回matplotlib.colors.ListedColormapinput='rgb')  #设置color中输入颜色的系统，可选‘rgb’, ‘hls’, ‘husl’, xkcd’</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><svg width="550" height="55"><rect x="0" y="0" width="55" height="55" style="fill:#262626;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="55" y="0" width="55" height="55" style="fill:#3e3e3e;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="110" y="0" width="55" height="55" style="fill:#555555;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="165" y="0" width="55" height="55" style="fill:#6e6e6e;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="220" y="0" width="55" height="55" style="fill:#868686;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="275" y="0" width="55" height="55" style="fill:#9f9f9f;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="330" y="0" width="55" height="55" style="fill:#b7b7b7;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="385" y="0" width="55" height="55" style="fill:#cfcfcf;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="440" y="0" width="55" height="55" style="fill:#e7e7e7;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="495" y="0" width="55" height="55" style="fill:#ffffff;stroke-width:2;stroke:rgb(255,255,255)"></rect></svg><p>同<code>cubehelix_palette</code>，<code>dark_palette</code>实际使用时，只需要修改个别参数，大部分都可以直接使用默认值。</p><p>例如；</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#修改终止颜色</span></span><br><span class="line">sns.dark_palette(color=<span class="string">"#b1283a"</span>)</span><br></pre></td></tr></tbody></table></figure><svg width="330" height="55"><rect x="0" y="0" width="55" height="55" style="fill:#2f2323;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="55" y="0" width="55" height="55" style="fill:#492428;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="110" y="0" width="55" height="55" style="fill:#63252c;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="165" y="0" width="55" height="55" style="fill:#7d2631;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="220" y="0" width="55" height="55" style="fill:#972735;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="275" y="0" width="55" height="55" style="fill:#b1283a;stroke-width:2;stroke:rgb(255,255,255)"></rect></svg><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#修改reverse</span></span><br><span class="line">sns.dark_palette(color=<span class="string">"#b1283a"</span>, reverse=<span class="literal">True</span>)</span><br></pre></td></tr></tbody></table></figure><svg width="330" height="55"><rect x="0" y="0" width="55" height="55" style="fill:#b1283a;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="55" y="0" width="55" height="55" style="fill:#972735;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="110" y="0" width="55" height="55" style="fill:#7d2631;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="165" y="0" width="55" height="55" style="fill:#63252c;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="220" y="0" width="55" height="55" style="fill:#492428;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="275" y="0" width="55" height="55" style="fill:#2f2323;stroke-width:2;stroke:rgb(255,255,255)"></rect></svg><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#修改input为husl颜色系统</span></span><br><span class="line">sns.dark_palette(color=(<span class="number">20</span>, <span class="number">60</span>, <span class="number">50</span>), <span class="built_in">input</span>=<span class="string">"husl"</span>)</span><br></pre></td></tr></tbody></table></figure><svg width="330" height="55"><rect x="0" y="0" width="55" height="55" style="fill:#2b2423;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="55" y="0" width="55" height="55" style="fill:#47302b;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="110" y="0" width="55" height="55" style="fill:#633b33;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="165" y="0" width="55" height="55" style="fill:#7f463a;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="220" y="0" width="55" height="55" style="fill:#9b5142;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="275" y="0" width="55" height="55" style="fill:#b85d4a;stroke-width:2;stroke:rgb(255,255,255)"></rect></svg><p><code>color</code> 参数</p><p>color 参数是一个元组，用于指定生成调色板的基础颜色。在 HUSL颜色空间中，这个元组包含三个值：</p><ol type="1"><li>色调（Hue），取值范围为 0 到360，表示颜色的基本类型，如红色、绿色、蓝色等。</li><li>饱和度（Saturation），取值范围为 0 到100，表示颜色的强度或纯度。值越高，颜色越饱和。</li><li>亮度（Lightness），取值范围为 0 到100，表示颜色的明暗程度。值越高，颜色越亮。</li></ol><p><code>input</code> 参数</p><p>input 参数是一个字符串，用于指定输入颜色的颜色空间。</p><p>在上面这个例子中，<code>input="husl"</code> 表示使用<code>HUSL</code> 颜色空间来解释 <code>color</code>参数的值。HUSL（Human-friendlyHSL）是一种颜色空间系统，旨在使颜色选择和调色更加直观。</p><h4 id="mpl_palette">mpl_palette</h4><p>基于<code>matplotlib</code>的<code>colormap</code>，使用<code>mpl_palette</code>函数构建<code>diverging/sequential palettes</code>，生成一个离散或者连续的<code>colormap</code>。mpl_palette使用方法：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.mpl_palette(</span><br><span class="line">    name=<span class="string">'Paired_r'</span>,  <span class="comment">#设置matplotlib中colormap的名称为'Paired_r'</span></span><br><span class="line">    n_colors=<span class="number">10</span>,  <span class="comment">##colormap颜色数量</span></span><br><span class="line">    as_cmap=<span class="literal">False</span></span><br><span class="line">)  <span class="comment">#False返回元组格式颜色，如[0.9312692223325372, 0.8201921796082118, 0.7971480974663592]；#True则返回matplotlib.colors.ListedColormap</span></span><br></pre></td></tr></tbody></table></figure><svg width="550" height="55"><rect x="0" y="0" width="55" height="55" style="fill:#ffff99;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="55" y="0" width="55" height="55" style="fill:#6a3d9a;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="110" y="0" width="55" height="55" style="fill:#cab2d6;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="165" y="0" width="55" height="55" style="fill:#ff7f00;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="220" y="0" width="55" height="55" style="fill:#fdbf6f;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="275" y="0" width="55" height="55" style="fill:#e31a1c;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="330" y="0" width="55" height="55" style="fill:#fb9a99;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="385" y="0" width="55" height="55" style="fill:#33a02c;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="440" y="0" width="55" height="55" style="fill:#b2df8a;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="495" y="0" width="55" height="55" style="fill:#1f78b4;stroke-width:2;stroke:rgb(255,255,255)"></rect></svg><p><strong>重点强调name参数</strong>：</p><p>当name选择matplotlib中diverging型调色盘时，如Paired_r，生成也为diverging型（离散型）颜色；</p><p>当name选择matplotlib中sequential型调色盘时，如Greens，生成也为sequential型（顺序型）颜色；</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#修改name为sequential型调色盘 Greens</span></span><br><span class="line">sns.mpl_palette(name=<span class="string">"Greens"</span>, n_colors=<span class="number">10</span>)</span><br></pre></td></tr></tbody></table></figure><svg width="550" height="55"><rect x="0" y="0" width="55" height="55" style="fill:#eaf7e6;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="55" y="0" width="55" height="55" style="fill:#d8f0d2;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="110" y="0" width="55" height="55" style="fill:#c1e6ba;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="165" y="0" width="55" height="55" style="fill:#a4da9e;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="220" y="0" width="55" height="55" style="fill:#84cc83;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="275" y="0" width="55" height="55" style="fill:#62bb6d;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="330" y="0" width="55" height="55" style="fill:#3fa85b;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="385" y="0" width="55" height="55" style="fill:#289049;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="440" y="0" width="55" height="55" style="fill:#107a37;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="495" y="0" width="55" height="55" style="fill:#006227;stroke-width:2;stroke:rgb(255,255,255)"></rect></svg><p>name可选的参数如下，其中包含GraphPadPrism、tableau等软件的colormap。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有可用的调色板名称</span></span><br><span class="line">palette_names = plt.colormaps()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印所有调色板名称</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> palette_names:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br></pre></td></tr></tbody></table></figure><pre><code>magmainfernoplasmaviridiscividistwilighttwilight_shiftedturboBluesBrBGBuGnBuPuCMRmapGnBuGreensGreysOrRdOrangesPRGnPiYGPuBuPuBuGnPuOrPuRdPurplesRdBuRdGyRdPuRdYlBuRdYlGnRedsSpectralWistiaYlGnYlGnBuYlOrBrYlOrRdafmhotautumnbinarybonebrgbwrcoolcoolwarmcoppercubehelixflaggist_earthgist_graygist_heatgist_ncargist_rainbowgist_sterngist_yarggnuplotgnuplot2grayhothsvjetnipy_spectraloceanpinkprismrainbowseismicspringsummerterrainwinterAccentDark2PairedPastel1Pastel2Set1Set2Set3tab10tab20tab20btab20cmagma_rinferno_rplasma_rviridis_rcividis_rtwilight_rtwilight_shifted_rturbo_rBlues_rBrBG_rBuGn_rBuPu_rCMRmap_rGnBu_rGreens_rGreys_rOrRd_rOranges_rPRGn_rPiYG_rPuBu_rPuBuGn_rPuOr_rPuRd_rPurples_rRdBu_rRdGy_rRdPu_rRdYlBu_rRdYlGn_rReds_rSpectral_rWistia_rYlGn_rYlGnBu_rYlOrBr_rYlOrRd_rafmhot_rautumn_rbinary_rbone_rbrg_rbwr_rcool_rcoolwarm_rcopper_rcubehelix_rflag_rgist_earth_rgist_gray_rgist_heat_rgist_ncar_rgist_rainbow_rgist_stern_rgist_yarg_rgnuplot_rgnuplot2_rgray_rhot_rhsv_rjet_rnipy_spectral_rocean_rpink_rprism_rrainbow_rseismic_rspring_rsummer_rterrain_rwinter_rAccent_rDark2_rPaired_rPastel1_rPastel2_rSet1_rSet2_rSet3_rtab10_rtab20_rtab20b_rtab20c_rrocketrocket_rmakomako_ricefireicefire_rvlagvlag_rflareflare_rcrestcrest_r</code></pre><p>每种colormap效果如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有可用的调色板名称</span></span><br><span class="line">palette_names = plt.colormaps()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置画布大小</span></span><br><span class="line">plt.figure(figsize=(<span class="number">15</span>, <span class="number">30</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历所有调色板名称，并生成相应的调色板</span></span><br><span class="line"><span class="keyword">for</span> i, name <span class="keyword">in</span> <span class="built_in">enumerate</span>(palette_names):</span><br><span class="line">    <span class="comment"># 生成调色板</span></span><br><span class="line">    palette = sns.mpl_palette(name=name, n_colors=<span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建子图</span></span><br><span class="line">    plt.subplot(<span class="built_in">len</span>(palette_names)//<span class="number">5</span> + <span class="number">1</span>, <span class="number">5</span>, i + <span class="number">1</span>)</span><br><span class="line">    sns.heatmap(np.arange(<span class="number">10</span>).reshape(<span class="number">1</span>, -<span class="number">1</span>), cmap=palette, cbar=<span class="literal">False</span>, annot=<span class="literal">True</span>)</span><br><span class="line">    plt.title(name, fontsize=<span class="number">8</span>)</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整布局</span></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>​<br><img src="../../../../images/seaborn/output_44_0.png"> ​</p><h4 id="hls_palette">hls_palette</h4><p>用HLS颜色系统使用hls_palette函数构建恒定亮度和饱和度的palettes，生成适用于categoricalor cyclical类数据的colormap。</p><p>HSL颜色系统由色相（Hue）、饱和度（Saturation）和亮度（Lightness）三个要素组成。</p><p>色相H表示颜色的种类或者说是色彩的名称（比如红色、绿色、蓝色等），饱和度S表示颜色的纯度或者说是灰度的程度，而亮度L则表示颜色的明暗程度。</p><p>hls_palette使用方法：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.hls_palette(</span><br><span class="line">    n_colors=<span class="number">10</span>,  <span class="comment">#colormap颜色数量</span></span><br><span class="line">    h=<span class="number">0.67</span>,  <span class="comment">#设置颜色色相，h沿着一个圆形路径均匀采样，0.67（120/360度）代表蓝色</span></span><br><span class="line">    l=<span class="number">0.4</span>,  <span class="comment">#设置颜色亮度</span></span><br><span class="line">    s=<span class="number">0.8</span>,  <span class="comment">#设置颜色饱和度</span></span><br><span class="line">    as_cmap=<span class="literal">False</span>) <span class="comment">#同前文</span></span><br></pre></td></tr></tbody></table></figure><svg width="550" height="55"><rect x="0" y="0" width="55" height="55" style="fill:#1814b8;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="55" y="0" width="55" height="55" style="fill:#7a14b8;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="110" y="0" width="55" height="55" style="fill:#b81494;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="165" y="0" width="55" height="55" style="fill:#b81432;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="220" y="0" width="55" height="55" style="fill:#b85914;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="275" y="0" width="55" height="55" style="fill:#b4b814;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="330" y="0" width="55" height="55" style="fill:#52b814;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="385" y="0" width="55" height="55" style="fill:#14b838;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="440" y="0" width="55" height="55" style="fill:#14b89a;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="495" y="0" width="55" height="55" style="fill:#1473b8;stroke-width:2;stroke:rgb(255,255,255)"></rect></svg><h4 id="husl_palette">husl_palette</h4><p>用HUSL颜色系统使用husl_palette函数构建恒定亮度和饱和度的palettes，生成适用于categoricalor cyclical类数据的colormap。</p><p>HUSL（Human-friendlyHSL）颜色系统是HSL的改进版本，提供更加人类友好的颜色。</p><p>HUSL考虑了人眼对颜色的感知方式，更好地平衡了色相、饱和度和亮度之间的关系，这使得在图形和数据可视化中使用HUSL配色更吸引人。</p><p>husl_palette使用方法，和hsl_palette使用方法完全一样</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.husl_palette(</span><br><span class="line">    n_colors=<span class="number">10</span>,  <span class="comment">#colormap颜色数量</span></span><br><span class="line">    h=<span class="number">0.67</span>,  <span class="comment">#设置颜色色相，h沿着一个圆形路径均匀采样，0.67（120/360度）代表蓝色</span></span><br><span class="line">    l=<span class="number">0.4</span>,  <span class="comment">#设置颜色亮度</span></span><br><span class="line">    s=<span class="number">0.8</span>,  <span class="comment">#设置颜色饱和度</span></span><br><span class="line">    as_cmap=<span class="literal">False</span>) <span class="comment">#同前文</span></span><br></pre></td></tr></tbody></table></figure><svg width="550" height="55"><rect x="0" y="0" width="55" height="55" style="fill:#2e6287;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="55" y="0" width="55" height="55" style="fill:#7638cc;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="110" y="0" width="55" height="55" style="fill:#9a3092;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="165" y="0" width="55" height="55" style="fill:#a82b67;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="220" y="0" width="55" height="55" style="fill:#944827;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="275" y="0" width="55" height="55" style="fill:#715a27;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="330" y="0" width="55" height="55" style="fill:#576227;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="385" y="0" width="55" height="55" style="fill:#276a36;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="440" y="0" width="55" height="55" style="fill:#29675a;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="495" y="0" width="55" height="55" style="fill:#2b666c;stroke-width:2;stroke:rgb(255,255,255)"></rect></svg><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.husl_palette(</span><br><span class="line">    n_colors=<span class="number">10</span>,  <span class="comment">#colormap颜色数量</span></span><br><span class="line">    h=<span class="number">0</span>,  <span class="comment">#设置颜色色相</span></span><br><span class="line">    l=<span class="number">0.8</span>,  <span class="comment">#设置颜色亮度</span></span><br><span class="line">    s=<span class="number">0.8</span>,  <span class="comment">#设置颜色饱和度</span></span><br><span class="line">    as_cmap=<span class="literal">False</span>) <span class="comment">#同前文</span></span><br></pre></td></tr></tbody></table></figure><svg width="550" height="55"><rect x="0" y="0" width="55" height="55" style="fill:#f4b3bf;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="55" y="0" width="55" height="55" style="fill:#f5b795;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="110" y="0" width="55" height="55" style="fill:#ddc359;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="165" y="0" width="55" height="55" style="fill:#a4d359;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="220" y="0" width="55" height="55" style="fill:#5cdb98;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="275" y="0" width="55" height="55" style="fill:#5fd7ca;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="330" y="0" width="55" height="55" style="fill:#62d3ed;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="385" y="0" width="55" height="55" style="fill:#aec5f3;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="440" y="0" width="55" height="55" style="fill:#d8b8f3;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="495" y="0" width="55" height="55" style="fill:#f4afe0;stroke-width:2;stroke:rgb(255,255,255)"></rect></svg><h4 id="diverging_palette">diverging_palette</h4><p>用HUSL颜色系统使用diverging_palette函数构建divergingpalettes，生成适用于diverging类数据的colormap。</p><p>diverging_palette使用方法：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.diverging_palette(</span><br><span class="line">    h_neg=<span class="number">0</span>,  <span class="comment">#设置左端颜色色相（0 &lt;= h_neg &lt;= 359）</span></span><br><span class="line">    h_pos=<span class="number">120</span>,  <span class="comment">#设置右端颜色色相（0 &lt;= h_pos &lt;= 359）</span></span><br><span class="line">    s=<span class="number">75</span>,  <span class="comment">#设置颜色饱和度（0 &lt;= l &lt;= 100）</span></span><br><span class="line">    l=<span class="number">50</span>,  <span class="comment">#设置颜色亮度（0 &lt;= l &lt;= 100）</span></span><br><span class="line">    sep=<span class="number">1</span>,  <span class="comment">#介于h_neg和h_pos之间区域大小</span></span><br><span class="line">    n=<span class="number">10</span>,  <span class="comment">#colormap颜色数量</span></span><br><span class="line">    center=<span class="string">'light'</span>,  <span class="comment">#构建的colormap中间色调，“light”, “dark”可选</span></span><br><span class="line">    as_cmap=<span class="literal">False</span>)  <span class="comment">#同上文</span></span><br></pre></td></tr></tbody></table></figure><svg width="550" height="55"><rect x="0" y="0" width="55" height="55" style="fill:#d53d69;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="55" y="0" width="55" height="55" style="fill:#db6487;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="110" y="0" width="55" height="55" style="fill:#e28ca5;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="165" y="0" width="55" height="55" style="fill:#e9b5c4;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="220" y="0" width="55" height="55" style="fill:#efdde2;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="275" y="0" width="55" height="55" style="fill:#dce7d8;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="330" y="0" width="55" height="55" style="fill:#b9ceb1;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="385" y="0" width="55" height="55" style="fill:#95b587;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="440" y="0" width="55" height="55" style="fill:#729c60;stroke-width:2;stroke:rgb(255,255,255)"></rect><rect x="495" y="0" width="55" height="55" style="fill:#4f8438;stroke-width:2;stroke:rgb(255,255,255)"></rect></svg><h3 id="交互式选色器">2.3.2交互式选色器</h3><p>seaborn提供了交互式选色器，帮助预览各种colormap。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.choose_colorbrewer_palette(</span><br><span class="line">    data_type=<span class="string">'sequential'</span>,  <span class="comment">#data_type有‘sequential’, ‘diverging’, ‘qualitative’三种可选</span></span><br><span class="line">    as_cmap=<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>interactive(children=(Dropdown(description='name', options=('Greys', 'Reds', 'Greens', 'Blues', 'Oranges', 'Pu…[(0.9575547866205305, 0.9575547866205305, 0.9575547866205305), (0.9012072279892349, 0.9012072279892349, 0.9012072279892349), (0.8328950403690888, 0.8328950403690888, 0.8328950403690888), (0.7502191464821223, 0.7502191464821223, 0.7502191464821223), (0.6434140715109573, 0.6434140715109573, 0.6434140715109573), (0.5387158785082661, 0.5387158785082661, 0.5387158785082661), (0.440322952710496, 0.440322952710496, 0.440322952710496), (0.342883506343714, 0.342883506343714, 0.342883506343714), (0.22329873125720878, 0.22329873125720878, 0.22329873125720878), (0.10469819300269129, 0.10469819300269129, 0.10469819300269129)]</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">sns.choose_cubehelix_palette()</span><br></pre></td></tr></tbody></table></figure><pre><code>interactive(children=(IntSlider(value=9, description='n_colors', max=16, min=2), FloatSlider(value=0.0, descri…[[0.9312692223325372, 0.8201921796082118, 0.7971480974663592], [0.8888663743660877, 0.7106793139856472, 0.7158661451411206], [0.8314793143949643, 0.5987041921652179, 0.6530062709235388], [0.7588951019517731, 0.49817117746394224, 0.6058723814510268], [0.6672565752652589, 0.40671838146419587, 0.5620016466433286], [0.5529215689527474, 0.3217924564263954, 0.5093718054521851], [0.43082755198027817, 0.24984535814964698, 0.44393960899639856], [0.29794615023641036, 0.18145907625614888, 0.35317781405034754], [0.1750865648952205, 0.11840023306916837, 0.24215989137836502]]</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">sns.choose_light_palette()</span><br></pre></td></tr></tbody></table></figure><pre><code>interactive(children=(IntSlider(value=179, description='h', max=359), IntSlider(value=49, description='s', max…[(0.928400678190116, 0.9478103788759907, 0.944453036504835), (0.8628220913788363, 0.8970612077691371, 0.8916872171349329), (0.7972435045675565, 0.8463120366622834, 0.8389213977650309), (0.7293228253701598, 0.7937503951587563, 0.7842710848462038), (0.6637442385588801, 0.7430012240519027, 0.7315052654763018), (0.5958235593614833, 0.6904395825483758, 0.6768549525574746), (0.5302449725502036, 0.639690411441522, 0.6240891331875726), (0.46232429335280684, 0.587128769937995, 0.5694388202687455), (0.3967457065415272, 0.5363795988311414, 0.5166730008988434), (0.33116711973024743, 0.4856304277242877, 0.46390718152894134)]</code></pre><h3 id="section">2.3.3</h3><h4 id="绘图函数中palette设置">绘图函数中palette设置</h4><p>如sns.boxplot(palette=palette)中的palette参数：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(<span class="number">2</span>, <span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">data = {<span class="string">f'Group <span class="subst">{i}</span>'</span>: np.random.normal(i, <span class="number">1</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>)}</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置不同的调色板</span></span><br><span class="line"></span><br><span class="line">palettes = [</span><br><span class="line">    <span class="string">"bright"</span>,  <span class="comment">#使用color_palette方法</span></span><br><span class="line">    [<span class="string">"#efefef"</span>, <span class="string">"#e9f3ea"</span>, <span class="string">"#d4dee7"</span>, <span class="string">"#f8f2e4"</span>],  <span class="comment">#直接传入颜色</span></span><br><span class="line">    <span class="string">"Blues_r"</span>,  <span class="comment">#使用mpl_palette中的调色盘</span></span><br><span class="line">    sns.light_palette(<span class="string">"red"</span>).as_hex()  <span class="comment">#使用light_palette方法</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ax, palette <span class="keyword">in</span> <span class="built_in">zip</span>(axs.flatten(), palettes):</span><br><span class="line">    sns.boxplot(data=df, palette=palette, ax=ax)  <span class="comment">#boxplot绘图函数中palette设置不同调色盘</span></span><br><span class="line">    ax.set_title(<span class="string">f'Palette=: <span class="subst">{palette}</span>'</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p>​<br><img src="../../../../images/seaborn/output_57_0.png"> ​</p><h4 id="set_palette设置颜色">set_palette设置颜色</h4><p>可以通过<code>set_palette</code>设置颜色</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成模拟数据</span></span><br><span class="line">data = {<span class="string">f'Group <span class="subst">{i}</span>'</span>: np.random.normal(i, <span class="number">1</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>)}</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(<span class="number">2</span>, <span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义不同的调色板</span></span><br><span class="line">palettes = [</span><br><span class="line">    <span class="string">"bright"</span>,  <span class="comment">#使用 color_palette方法</span></span><br><span class="line">    [<span class="string">"#efefef"</span>, <span class="string">"#e9f3ea"</span>, <span class="string">"#d4dee7"</span>, <span class="string">"#f8f2e4"</span>],  <span class="comment">#直接传入颜色</span></span><br><span class="line">    <span class="string">"Blues_r"</span>,  <span class="comment">#使用章节5.3.1.4&nbsp;mpl_palette中的调色盘</span></span><br><span class="line">    sns.light_palette(<span class="string">"red"</span>).as_hex()  <span class="comment">#使用 light_palette方法</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制四个子图的箱线图，并设置不同的调色板</span></span><br><span class="line"><span class="keyword">for</span> ax, palette <span class="keyword">in</span> <span class="built_in">zip</span>(axs.flatten(), palettes):</span><br><span class="line">    sns.set_palette(palette)  <span class="comment">#set_palette设置不同的调色板</span></span><br><span class="line">    sns.boxplot(data=df, ax=ax)</span><br><span class="line">    ax.set_title(<span class="string">f'Palette: <span class="subst">{palette}</span>'</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p>​<br><img src="../../../../images/seaborn/output_59_0.png"> ​</p><h2 id="联合美化">2.4联合美化</h2><p>seaborn提供了一个set_theme函数，可同时联合<code>context</code>,<code>style</code>,<code>palette</code>美化图表。</p><p>set_theme使用方法</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">sns.set_theme(</span><br><span class="line">    context=<span class="string">'notebook'</span>,  <span class="comment">#效果同 set_context设置context内容</span></span><br><span class="line">    style=<span class="string">'darkgrid'</span>,  <span class="comment">#效果同 set_style()设置style内容</span></span><br><span class="line">    palette=<span class="string">'deep'</span>,  <span class="comment">#效果同 palette设置图形配色</span></span><br><span class="line">    font=<span class="string">'sans-serif'</span>,  <span class="comment">#设置字体</span></span><br><span class="line">    font_scale=<span class="number">1</span>,  <span class="comment">#设置文字缩放</span></span><br><span class="line">    color_codes=</span><br><span class="line">    <span class="literal">True</span>,  <span class="comment">#如果为True，并且调色板是一个seaborn的调色板，</span></span><br><span class="line"><span class="comment">#则重新映射简写的颜色代码（例如：“b”、“g”、“r”等）为该调色板中的颜色</span></span><br><span class="line">    rc=<span class="literal">None</span>)  <span class="comment"># 自定义matplotlib rcParams中任意参数</span></span><br></pre></td></tr></tbody></table></figure><p>以上是set_theme的默认参数，如果要调用默认设置，sns.set_theme()即可。</p><p>以下实例介绍set_theme参数修改对图形外观的影响，</p><h3 id="不使用set_theme">2.4.1 不使用set_theme</h3><p>当seaborn不使用set_theme时，将会直接使用set_theme中的默认参数绘制图</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'SimHei'</span>]</span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟数据</span></span><br><span class="line">np.random.seed(<span class="number">42</span>)</span><br><span class="line">data = {<span class="string">f'组 <span class="subst">{i}</span>'</span>: np.random.normal(i, <span class="number">1</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>)}</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">sns.boxplot(data=df).set_title(<span class="string">'Seaborn 默认参数'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>​<br><img src="../../../../images/seaborn/output_65_0.png"> ​</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟数据</span></span><br><span class="line">np.random.seed(<span class="number">42</span>)</span><br><span class="line">data = {<span class="string">f'Group <span class="subst">{i}</span>'</span>: np.random.normal(i, <span class="number">1</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>)}</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line">sns.set_theme()  <span class="comment">#使用set_theme默认配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 绘图</span></span><br><span class="line">sns.boxplot(data=df).set_title(<span class="string">'Theme: set_theme()'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p>​<br><img src="../../../../images/seaborn/output_66_0.png"> ​</p><h3 id="set_theme设置context">2.4.2 set_theme设置context</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟数据</span></span><br><span class="line">np.random.seed(<span class="number">42</span>)</span><br><span class="line">data = {<span class="string">f'Group <span class="subst">{i}</span>'</span>: np.random.normal(i, <span class="number">1</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>)}</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line">sns.set_theme(context=<span class="string">'poster'</span>)  <span class="comment">#使用set_theme设置context 。内置：`paper`,`notebook`,`talk`,`poster`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 绘图</span></span><br><span class="line">sns.boxplot(data=df).set_title(<span class="string">'Theme: context'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p>​<br><img src="../../../../images/seaborn/output_68_0.png"> ​</p><h3 id="set_theme设置style">2.4.3 set_theme设置style</h3><p>五套style内置，分别为darkgrid, whitegrid, dark, white, ticks。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟数据</span></span><br><span class="line">np.random.seed(<span class="number">42</span>)</span><br><span class="line">data = {<span class="string">f'Group <span class="subst">{i}</span>'</span>: np.random.normal(i, <span class="number">1</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>)}</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line">sns.set_theme(style=<span class="string">'white'</span>)  <span class="comment">#使用set_theme设置style</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 绘图</span></span><br><span class="line">sns.boxplot(data=df).set_title(<span class="string">'Theme: style'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p>​<br><img src="../../../../images/seaborn/output_70_0.png"> ​</p><h3 id="set_theme设置palette">2.4.4 set_theme设置palette</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟数据</span></span><br><span class="line">np.random.seed(<span class="number">42</span>)</span><br><span class="line">data = {<span class="string">f'Group <span class="subst">{i}</span>'</span>: np.random.normal(i, <span class="number">1</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>)}</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line">sns.set_theme(palette=<span class="string">'Pastel2'</span>)  <span class="comment">#使用set_theme设置palette</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">sns.boxplot(data=df).set_title(<span class="string">'Theme: palette'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p>​<br><img src="../../../../images/seaborn/output_72_0.png"> ​</p><h3 id="set_theme设置rc">2.4.5 set_theme设置rc</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 重置 Matplotlib 的默认设置</span></span><br><span class="line">mpl.rc_file_defaults()</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'SimHei'</span>]  <span class="comment"># 设置字体为黑体</span></span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span>    <span class="comment"># 解决负号显示问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置模拟数据</span></span><br><span class="line">np.random.seed(<span class="number">42</span>)</span><br><span class="line">data = {<span class="string">f'Group <span class="subst">{i}</span>'</span>: np.random.normal(i, <span class="number">1</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>)}</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改rc参数</span></span><br><span class="line">custom_set = {</span><br><span class="line">    <span class="string">"font.family"</span>: <span class="string">"SimHei"</span>,</span><br><span class="line">    <span class="string">"axes.spines.left"</span>: <span class="literal">True</span>,  <span class="comment">#y坐标轴开启</span></span><br><span class="line">    <span class="string">"axes.spines.bottom"</span>: <span class="literal">True</span>,  <span class="comment">#x坐标轴开启</span></span><br><span class="line">    <span class="string">"axes.spines.top"</span>: <span class="literal">False</span>,  <span class="comment">#上方坐标轴关闭</span></span><br><span class="line">    <span class="string">"axes.spines.right"</span>: <span class="literal">False</span>,  <span class="comment">#右侧坐标轴关闭</span></span><br><span class="line">    <span class="string">"axes.edgecolor"</span>: <span class="string">"gray"</span>,  <span class="comment">#坐标轴颜色</span></span><br><span class="line">    <span class="string">"axes.linewidth"</span>: <span class="number">0.4</span>,  <span class="comment">#坐标轴宽度</span></span><br><span class="line">    <span class="string">"grid.linewidth"</span>: <span class="number">0.3</span>,  <span class="comment">#网格线宽度</span></span><br><span class="line">    <span class="string">"grid.alpha"</span>: <span class="number">1</span>,  <span class="comment">#网格线透明度</span></span><br><span class="line">    <span class="string">"legend.frameon"</span>: <span class="literal">True</span>,  <span class="comment">#图例边框开启</span></span><br><span class="line">    <span class="string">"legend.framealpha"</span>: <span class="number">0.5</span>  <span class="comment">##图例边框透明度</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sns.set_theme(rc=custom_set)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制箱线图</span></span><br><span class="line">sns.boxplot(data=df)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p>​<br><img src="../../../../images/seaborn/output_74_0.png"> ​</p><h3 id="set_theme同时设置contextstylepaletterc">2.4.6set_theme同时设置context、style、palette、rc</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 重置 Matplotlib 的默认设置</span></span><br><span class="line">mpl.rc_file_defaults()</span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span>    <span class="comment"># 解决负号显示问题</span></span><br><span class="line"><span class="comment"># 设置模拟数据</span></span><br><span class="line">np.random.seed(<span class="number">42</span>)</span><br><span class="line">data = {<span class="string">f'Group <span class="subst">{i}</span>'</span>: np.random.normal(i, <span class="number">1</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>)}</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时设置</span></span><br><span class="line">sns.set_theme(context=<span class="string">'notebook'</span>, style=<span class="string">'white'</span>, palette=<span class="string">'Pastel2'</span>, rc=custom_set)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制箱线图</span></span><br><span class="line">sns.boxplot(data=df)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p>​<br><img src="../../../../images/seaborn/output_76_0.png"> ​</p><h1 id="seaborn两大类绘图函数">3.seaborn两大类绘图函数</h1><p>seaborn两大类绘图函数<code>figure-level</code>,<code>axes-level</code></p><p>本章节主要是介绍这两大类绘图函数的区别：</p><ul><li>坐标轴级别（axes-level）绘图函数</li><li>图形级别（figure-level）绘图函数</li></ul><h2 id="axes-level">3.1 axes-level</h2><p>axes-level绘图函数是将数据绘制在<code>matplotlib.pyplot.Axes</code>对象上，</p><p>此类函数可以直接使用matplotlib rcParams中的参数。</p><p>例如，使用penguins数据集，直方图展示不同“企鹅的种类”的"喙长(毫米)"分布关系时，可直接使用axes-level绘图函数histplot</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"></span><br><span class="line">penguins = pd.read_csv(<span class="string">'数据/penguins.csv'</span>)  <span class="comment">#使用pandas读取 penguins数据集数据</span></span><br><span class="line">g = sns.histplot(</span><br><span class="line">    data=penguins,  <span class="comment">#使用axes-level函数histplot</span></span><br><span class="line">    x=<span class="string">"喙长 (毫米)"</span>,</span><br><span class="line">    hue=<span class="string">"企鹅的种类"</span>,</span><br><span class="line">    palette=<span class="string">"Set2"</span>,</span><br><span class="line">    multiple=<span class="string">"stack"</span>)   <span class="comment">#使用堆叠柱状图</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(g))</span><br></pre></td></tr></tbody></table></figure><pre><code>&lt;class 'matplotlib.axes._axes.Axes'&gt;</code></pre><p><img src="../../../../images/seaborn/output_78_1.png"></p><p>可以看到g是一个<code>matplotlib.pyplot.Axes</code>对象</p><p>axes-level绘图函数还有<code>scatterplot</code>,<code>lineplot</code>,<code>stripplot</code>,<code>swarmplot</code>等。</p><h2 id="figure-level绘图函数">3.2 figure-level绘图函数</h2><p>figure-level绘图函数将数据绘制在<code>seaborn.axisgrid.FacetGrid</code>对象上，</p><p>此类函数拥有区别于<code>matplotlib rcParams</code>中的参数，</p><p>每个figure-level绘图函数都提供了统一的axes-level接口，kind参数设置。</p><p>例如，3.1节的图也可以使用figure-level绘图函数displot，只需要指定<code>kind="hist"</code></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">"ignore"</span>, category=UserWarning)   <span class="comment">#忽略警告</span></span><br><span class="line"></span><br><span class="line">g = sns.displot(</span><br><span class="line">    data=penguins,  <span class="comment">#使用figure-level函数displot</span></span><br><span class="line">    x=<span class="string">"喙长 (毫米)"</span>,</span><br><span class="line">    hue=<span class="string">"企鹅的种类"</span>,</span><br><span class="line">    multiple=<span class="string">"stack"</span>,</span><br><span class="line">    palette=<span class="string">"Set2"</span>,</span><br><span class="line">    kind=<span class="string">"hist"</span>)  <span class="comment">#kind="hist"等价于axes-level函数histplotprint(type(g))</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(g))</span><br></pre></td></tr></tbody></table></figure><pre><code>&lt;class 'seaborn.axisgrid.FacetGrid'&gt;</code></pre><p><img src="../../../../images/seaborn/output_81_1.png"></p><p>可以看到g是一个<code>seaborn.axisgrid.FacetGrid</code>对象。</p><p>figure-level绘图函数还有<code>jointplot</code>,<code>relplot</code>,<code>displot</code>等。</p><h2 id="figure-levelaxes-level比较">3.3figure-level、axes-level比较</h2><p>大部分情况下，figure-level和axes-level函数功能非常相似，但也存在一些差异。</p><p>例如，figure-level中图例被放置在图形之外，axes-level中则将图例被放置在图形之内（<strong>注意比较3.1节和3.2节</strong>）。</p><p>下文详细介绍figure-level和axes-level的差异。</p><h3 id="figure-level多子图">3.3.1 figure-level多子图</h3><p>figure-level最擅长多子图（subplot）绘制。</p><p>例如，3.1节和3.2节中的堆叠直方图不容易直观看出每一种企鹅的“喙长(毫米)”分布。</p><p>解决该问题，可以尝试多子图。</p><p>每一种企鹅绘制一个“喙长(毫米)”分布直方图，figure-level函数一行代码实现多子图：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">sns.displot(</span><br><span class="line">    data=penguins,</span><br><span class="line">    x=<span class="string">"喙长 (毫米)"</span>,</span><br><span class="line">    hue=<span class="string">"企鹅的种类"</span>,  <span class="comment">#按照"企鹅的种类"绘制子图</span></span><br><span class="line">    col=<span class="string">"企鹅的种类"</span>,  <span class="comment">#图形按照"企鹅的种类"按行绘制</span></span><br><span class="line">    palette=<span class="string">"Set2"</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>&lt;seaborn.axisgrid.FacetGrid at 0x20e09a27810&gt;</code></pre><p>​<br><img src="../../../../images/seaborn/output_85_1.png"> ​</p><p>虽然figure-level多子图绘制很便捷，但是，如果想单独设置某个子图就不够灵活，例如:</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">sns.displot(</span><br><span class="line">    data=penguins,</span><br><span class="line">    x=<span class="string">"喙长 (毫米)"</span>,</span><br><span class="line">    hue=<span class="string">"企鹅的种类"</span>,</span><br><span class="line">    col=<span class="string">"企鹅的种类"</span>,</span><br><span class="line">    binwidth=<span class="number">1</span>,  <span class="comment">#设置柱子的宽度</span></span><br><span class="line">    palette=<span class="string">"Set2"</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>&lt;seaborn.axisgrid.FacetGrid at 0x20e088daf90&gt;</code></pre><p>​<br><img src="../../../../images/seaborn/output_87_1.png"> ​</p><p><code>binwidth</code>可以高效设置所有子图的bin宽度，但是并不能设置某一个子图。</p><h3 id="axes-level多子图个性化">3.3.2 axes-level多子图个性化</h3><p>axes-level也可以绘制多子图，需要通过参数ax指定子图。</p><p>seaborn内部调用<code>matplotlib.pyplot.gca()</code>激活当前子图为需要绘图的对象，例如：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">fig, axs = plt.subplots(  <span class="comment">#subplots添加3个子图</span></span><br><span class="line">    <span class="number">1</span>,<span class="number">3</span>,figsize=(<span class="number">10</span>, <span class="number">4</span>),</span><br><span class="line">    gridspec_kw=<span class="built_in">dict</span>(width_ratios=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取Set2调色板的颜色</span></span><br><span class="line">colormaps = sns.color_palette(<span class="string">"Set2"</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, species <span class="keyword">in</span> <span class="built_in">enumerate</span>(penguins[<span class="string">'企鹅的种类'</span>].unique()):</span><br><span class="line">    data = penguins[penguins[<span class="string">'企鹅的种类'</span>] == species]</span><br><span class="line">    sns.histplot(</span><br><span class="line">        data=data,</span><br><span class="line">        x=<span class="string">'喙长 (毫米)'</span>,</span><br><span class="line">        ax=axs[i],  <span class="comment"># 参数ax激活当前子图axs[i]为需要绘图的对象</span></span><br><span class="line">        color=colormaps[i])</span><br><span class="line">    axs[i].set_title(<span class="string">"企鹅的种类=%s"</span> % species)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br></pre></td></tr></tbody></table></figure><p>​<br><img src="../../../../images/seaborn/output_90_0.png"> ​</p><p>效果类似figure-level绘制多子图，但是axes-level代码量明显增多。</p><p>不过相比于figure-level，axes-level显然更擅长每个子图的个性化。例如：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">f, axs = plt.subplots(  <span class="comment">#subplots添加两个子图1,2,</span></span><br><span class="line">    ncols=<span class="number">2</span>,</span><br><span class="line">    figsize=(<span class="number">8</span>, <span class="number">4</span>),</span><br><span class="line">    gridspec_kw=<span class="built_in">dict</span>(width_ratios=[<span class="number">4</span>, <span class="number">3</span>]))</span><br><span class="line">sns.scatterplot(data=penguins,</span><br><span class="line">                x=<span class="string">"喙深 (毫米)"</span>,</span><br><span class="line">                y=<span class="string">"喙长 (毫米)"</span>,</span><br><span class="line">                palette=<span class="string">"Set2"</span>,</span><br><span class="line">                hue=<span class="string">"企鹅的种类"</span>,</span><br><span class="line">                ax=axs[<span class="number">0</span>])  <span class="comment">#参数ax激活当前子图axs[0]为需要绘图的对象</span></span><br><span class="line"></span><br><span class="line">sns.histplot(data=penguins,</span><br><span class="line">             x=<span class="string">"企鹅的种类"</span>,</span><br><span class="line">             hue=<span class="string">"企鹅的种类"</span>,</span><br><span class="line">             palette=<span class="string">"Set2"</span>,</span><br><span class="line">             shrink=<span class="number">.7</span>,  <span class="comment">#缩小柱的宽度，缩小到 70%</span></span><br><span class="line">             alpha=<span class="number">.8</span>,  <span class="comment">#设置柱的透明度， 80% 不透明，20% 透明。</span></span><br><span class="line">             legend=<span class="number">0</span>,  <span class="comment">#禁用图例显示</span></span><br><span class="line">             ax=axs[<span class="number">1</span>])  <span class="comment">#参数ax激活当前子图axs[1]为需要绘图的对象</span></span><br><span class="line"></span><br><span class="line">f.tight_layout()</span><br></pre></td></tr></tbody></table></figure><p>​<br><img src="../../../../images/seaborn/output_92_0.png"> ​</p><h1 id="未完待续">未完待续！！！</h1><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">g = sns.PairGrid(</span><br><span class="line">    penguins,</span><br><span class="line">    layout_pad=<span class="number">1</span>,  <span class="comment">#子图间距</span></span><br><span class="line">    hue=<span class="string">"性别"</span>,</span><br><span class="line">    palette=<span class="string">"Set2"</span>,</span><br><span class="line">    diag_sharey=<span class="literal">False</span>)</span><br><span class="line">g.map_upper(sns.scatterplot)</span><br><span class="line">g.map_diag(sns.histplot)</span><br><span class="line">g.map_lower(sns.kdeplot)</span><br><span class="line">g.add_legend()</span><br><span class="line">g.fig.set_dpi(<span class="number">150</span>)</span><br></pre></td></tr></tbody></table></figure><p>​<br><img src="../../../../images/seaborn/output_94_0.png"> ​</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 可视化 </category>
          
          <category> Python可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python可视化 </tag>
            
            <tag> seaborn </tag>
            
            <tag> matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习概论</title>
      <link href="/2024/05/28/ji-qi-xue-xi-gai-lun/"/>
      <url>/2024/05/28/ji-qi-xue-xi-gai-lun/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习概论">机器学习概论</h1><p>本文章将把机器学习大致内容梳理一遍，可以快速了解机器学习的大致框架及大致内容。</p><h1 id="一线性回归">一、线性回归</h1><h2 id="线性回归模型的基本原理和假设">1.线性回归模型的基本原理和假设</h2><p>线性回归是⼀种⼴泛⽤于统计学和机器学习中的回归分析⽅法，⽤于建⽴⾃变量（特征）与因变量（⽬标）之间的线性关系模型。线性回归的基本原理是寻找⼀条直线（或者在多维情况下是⼀个超平⾯），以最佳地拟合训练数据，使得模型的预测与真实观测值之间的误差最⼩化。下⾯我们来详细解释线性回归的基本原理和假设。</p><p><strong>简单线性回归模型</strong>： <span class="math display">\[y=b_0+b_1\cdot x\]</span> <strong>多元线性回归模型</strong>： <span class="math display">\[y=b_0+b_1\cdot x_1+b_2\cdot x_2+\ldots+b_p\cdot x_p\]</span></p><p>其中：</p><ul><li><span class="math inline">\(y\)</span>是因变量 (需要预测的值)。</li><li><span class="math inline">\(x_1, x_2, \ldots , x_p\)</span>是自变量(特征),可以是一个或多个。</li><li><span class="math inline">\(b_0\)</span>是截距(模型在自变量都为0时的预测值)。</li><li><span class="math inline">\(b_1,b_2,\ldots,b_p\)</span>是回归系数，表示自变量对因变量的影响程度。</li></ul><p><strong>最优解</strong></p><ul><li><code>Actual value</code>: 真实值,即已知的</li><li><code>Predicted value</code>:预测值，是把已知的<code>x</code>带入到公式里面和猜出来的参数<code>a,b</code> 计算得到的</li><li><code>Error</code>:误差，预测值和真实值的差距</li><li><code>最优解</code>：尽可能的找到一个模型使得整体的误差最小，整体的误差通常叫做损失<code>Loss</code></li><li><code>Loss</code>:整体的误差，<code>loss</code> 通过损失函数<code>Ioss function</code> 计算得到</li></ul><p>线性回归的目标是找到合适的回归系数<span class="math inline">\(b_0,b_1,\ldots,b_p\)</span>,以最小化模型的预测误差。通常采用最小二乘法来估计这些系数，即使得观测值与模型预测值之间的残差平方和最小。</p><p>线性回归模型的有效性基于以下⼀些关键假设：</p><ol type="1"><li><strong>线性关系假设</strong>：线性回归假设因变量和自变量之间存在线性关系。这意味着模型试图用一条直线(或超平面)来拟合数据，以描述自变量与因变量之间的关系。</li><li><strong>独立性假设</strong>：线性回归假设每个观测值之间是相互独立的。这意味看一个观测值的误差不受其他观测值的影响。</li><li><strong>常数方差假设</strong>：线性回归假设在自变量的每个取值点上，观测值的误差方差都是常数。这被称为同方差性或等方差性。</li><li><strong>正态性假设</strong>：线性回归假设观测值的误差服从正态分布。这意味着在不同自变量取值点上的误差应该接近正态分布。</li></ol><p>如果这些假设不满⾜，线性回归模型的结果可能不可靠。</p><p><strong>⼀个简单示例</strong>：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(y\)</span></th><th style="text-align: center;">2</th><th style="text-align: center;">4</th><th style="text-align: center;">5</th><th style="text-align: center;">4</th><th style="text-align: center;">5</th><th style="text-align: center;">8</th><th style="text-align: center;">7</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(x\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">4</td><td style="text-align: center;">5</td><td style="text-align: center;">6</td><td style="text-align: center;">7</td></tr></tbody></table><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.font_manager <span class="keyword">as</span> fm</span><br><span class="line">font_path = <span class="string">'C:\\Windows\\Fonts\\simsun.ttc'</span>  </span><br><span class="line">font_prop = fm.FontProperties(fname=font_path)</span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'SimSun'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建示例数据</span></span><br><span class="line">X = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]).reshape(-<span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># 自变量</span></span><br><span class="line">y = np.array([<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>])  <span class="comment"># 因变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线性回归模型</span></span><br><span class="line">model = LinearRegression()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拟合模型</span></span><br><span class="line">model.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印回归系数和截距</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"回归系数 (b1):"</span>, model.coef_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"截距 (b0):"</span>, model.intercept_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测新数据点</span></span><br><span class="line">new_x = np.array([<span class="number">6</span>]).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">predicted_y = model.predict(new_x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"新数据点的预测值:"</span>, predicted_y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制数据点和拟合结果</span></span><br><span class="line">plt.scatter(X, y, color=<span class="string">'blue'</span>, label=<span class="string">'实际值'</span>)</span><br><span class="line">plt.plot(X, model.predict(X), color=<span class="string">'red'</span>, linewidth=<span class="number">2</span>, label=<span class="string">'拟合线'</span>)</span><br><span class="line">plt.scatter(new_x, predicted_y, color=<span class="string">'green'</span>, marker=<span class="string">'x'</span>, s=<span class="number">100</span>, label=<span class="string">'新数据点'</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">'线性回归示例'</span>, fontproperties=font_prop)</span><br><span class="line">plt.xlabel(<span class="string">'自变量 (X)'</span>, fontproperties=font_prop)</span><br><span class="line">plt.ylabel(<span class="string">'因变量 (y)'</span>, fontproperties=font_prop)</span><br><span class="line">plt.legend(prop=font_prop)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><pre><code>回归系数 (b1): [0.82142857]截距 (b0): 1.7142857142857149新数据点的预测值: [6.64285714]</code></pre><p><img src="../../../../images/机器学习概论/output_1_1.png"></p><h2 id="参数估计">2.参数估计</h2><p>使用最小二乘法求解线性回归模型的参数通常包括以下步骤：</p><ul><li>定义模型：首先，需要定义线性回归模型的数学形式，即<span class="math display">\[Y=\beta_0+\beta_1X_1+\beta_2X_2+\ldots+\beta_nX_n+\epsilon\]</span>其中<span class="math inline">\(Y\)</span>是因变量，<span class="math inline">\(X_1,X_2,\ldots,X_n\)</span>是自变量，<span class="math inline">\(\beta_0,\beta_1,\ldots,\beta_n\)</span>是模型的参数，<span class="math inline">\(\epsilon\)</span>是误差项。</li><li>确定损失函数：损失函数是用来衡量模型预测值与实际观测值之间的差异的函数。在最小二乘法中，通常使用残差平方和作为损失函数。</li><li>最小化损失函数：使用优化算法(通常是梯度下降法或闭式解)来最小化损失函数。在最小二乘法中，要找到使得残差平方和最小的参数值。对于线性回归模型，可以通过求解以下正规方程来得</li></ul><p>到闭式解： <span class="math display">\[\beta=(X^TX)^{-1}X^TY\]</span> 其中<span class="math inline">\(X\)</span>是自变量的设计矩阵，<span class="math inline">\(Y\)</span> 是因变量的观测值，<span class="math inline">\(\beta\)</span> 是参数向量。</p><h3 id="最小二乘法的原理">最小二乘法的原理</h3><p>在线性回归中, 我们假设自变量 <span class="math inline">\(x\)</span>和因变量 <span class="math inline">\(y\)</span> 之间存在线性关系,可以用以下模型表示： <span class="math display">\[y=\beta_0+\beta_1 \cdot x+\varepsilon\]</span></p><p>其中: - <span class="math inline">\(y\)</span>是因变量（需要预测的值）。 - <span class="math inline">\(x\)</span>是自变量（特征）。 - <span class="math inline">\(\beta_0\)</span>是截距（模型在自变量为 0 时的预测值）。 - <span class="math inline">\(\beta_1\)</span> 是斜率（自变量 <span class="math inline">\(x\)</span> 对因变量 <span class="math inline">\(y\)</span> 的影响程度）。 - <span class="math inline">\(\varepsilon\)</span> 是误差项,表示模型无法完美拟合真实数据的部分。</p><p>最小二乘法的目标是找到最佳的 <span class="math inline">\(\beta_0\)</span> 和 <span class="math inline">\(\beta_1\)</span>, 使得观测值 <span class="math inline">\(y_i\)</span> 和对应的模型预测值 <span class="math inline">\(\hat{y}_i\)</span>之间的残差（差值）的平方和最小化: <span class="math display">\[\min _{\beta_0, \beta_1} \sum_{i=1}^n\left(y_i-\hat{y}_i\right)^2\]</span> 其中, <span class="math inline">\(n\)</span> 是样本数量, <span class="math inline">\(\hat{y}_i\)</span> 是根据模型预测的值。<strong>最小二乘法的公式</strong></p><p>最小二乘法可以通过以下公式来估计参数 <span class="math inline">\(\beta_0\)</span> 和 <span class="math inline">\(\beta_1\)</span> : <span class="math display">\[\begin{aligned}\beta_1 &amp;=\frac{\sum_{i=1}^n\left(x_i-\bar{x}\right)\left(y_i-\bar{y}\right)}{\sum_{i=1}^n\left(x_i-\bar{x}\right)^2}\\\beta_0 &amp;= \bar{y}-\beta_1 \cdot \bar{x}\end{aligned}\]</span></p><p>其中, <span class="math inline">\(\bar{x}\)</span> 和 <span class="math inline">\(\bar{y}\)</span> 分别是自变量 <span class="math inline">\(x\)</span> 和因变量 <span class="math inline">\(y\)</span> 的均值。</p><p><strong>最⼩⼆乘法的代码示例</strong>使用常见的线性回归数据集加州房价数据集。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_california_housing</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error, mean_absolute_error</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.font_manager <span class="keyword">as</span> fm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载加州房价数据集</span></span><br><span class="line">california = fetch_california_housing()</span><br><span class="line">X = california.data[:, [<span class="number">0</span>]]  <span class="comment"># 使用第一个特征（房间数均值）作为自变量</span></span><br><span class="line">y = california.target        <span class="comment"># 房价中位数作为因变量</span></span><br><span class="line"></span><br><span class="line">X = X[:<span class="number">200</span>]</span><br><span class="line">y = y[:<span class="number">200</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线性回归模型</span></span><br><span class="line">model = LinearRegression()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拟合模型</span></span><br><span class="line">model.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取回归系数和截距</span></span><br><span class="line">beta_1 = model.coef_[<span class="number">0</span>]</span><br><span class="line">beta_0 = model.intercept_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印回归系数和截距</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"斜率 (beta_1):"</span>, beta_1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"截距 (beta_0):"</span>, beta_0)</span><br><span class="line"></span><br><span class="line">font_path = <span class="string">'C:\\Windows\\Fonts\\simsun.ttc'</span></span><br><span class="line">font_prop = fm.FontProperties(fname=font_path)</span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'SimSun'</span>]</span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span>  <span class="comment"># 解决负号显示问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制数据点和拟合结果</span></span><br><span class="line">plt.scatter(X, y, color=<span class="string">'blue'</span>, label=<span class="string">'实际值'</span>)</span><br><span class="line">plt.plot(X, model.predict(X), color=<span class="string">'red'</span>, linewidth=<span class="number">2</span>, label=<span class="string">'拟合线'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加标题和标签</span></span><br><span class="line">plt.title(<span class="string">'线性回归示例'</span>, fontproperties=font_prop)</span><br><span class="line">plt.xlabel(<span class="string">'房间数均值'</span>, fontproperties=font_prop)</span><br><span class="line">plt.ylabel(<span class="string">'房价中位数'</span>, fontproperties=font_prop)</span><br><span class="line">plt.legend(prop=font_prop)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图形</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><pre><code>斜率 (beta_1): 0.3849371126330091截距 (beta_0): 0.7464519437859625</code></pre><p><img src="../../../../images/机器学习概论/output_4_1.png"></p><p>代码中, 使用<code>Scikit-Learn</code>的 <code>LinearRegression</code>类来创建并拟合线性回归模型。 最小二乘法的原理被内部自动应用,从而估计出最佳的回归系数 <span class="math inline">\(\beta_0\)</span> 和<span class="math inline">\(\beta_1\)</span>。这些系数将用于构建最佳拟合线性模型,以最小化观测值和模型预测值之间的残差平方和。</p><h2 id="评估指标">3.评估指标</h2><p>在进⾏参数估计后，通常需要对估计结果进⾏评价，以确保模型的可靠性和有效性。</p><p>评价参数估计的常用方法包括: -残差分析：分析残差的分布和模式，检验模型的拟合效果和误差项的假设是否成立。- 参数显著性检验：使用统计检验方法（如t检验）来检验参数估计的显著性,判断自变量与因变量之间是否存在显著的线性关系。 -模型拟合度评估：使用拟合度指标（如<code>R-squared</code>、调整<code>R-squared</code>等）来评估模型的拟合程度,判断模型对数据的解释能力。</p><p>参数估计决定了模型对数据的拟合程度和预测能力。通过最小二乘法,可以有效地估计模型的参数, 并通过各种评价方法来验证模型的有效性。然而,在应用中需要注意参数估计的局限性, 并结合实际情况进行适当的调整和处理,确保模型的准确性和可靠性。</p><p>用于评估模型性能的指标包括: - 均方误差（Mean Squared Error, MSE） -均方根误差（Root Mean Squared Error, RMSE) - 平均绝对误差 (Mean AbsoluteError, MAE) 等</p><p>评估指标是用来衡量模型预测结果与真实观测值之间的差异程度，从而评估模型的性能。在线性回归中,常用的评估指标包括均方误差（MSE）、均方根误差（RMSE）和平均绝对误差（MAE）。</p><h3 id="均方误差-mse">均方误差 (MSE)</h3><p>均方误差是预测值与真实值之间差异的平方的平均值： <span class="math display">\[M S E=\frac{1}{n} \sum_{i=1}^n\left(y_i-\hat{y}_i\right)^2\]</span></p><p>其中: - <span class="math inline">\(n\)</span> 是样本数量; - <span class="math inline">\(y_i\)</span> 是第 <span class="math inline">\(i\)</span> 个观测值的真实值; - <span class="math inline">\(\hat{y}_i\)</span> 是第 <span class="math inline">\(i\)</span> 个观测值的预测值。</p><h3 id="均方根误差rmse">均方根误差（RMSE）</h3><p>均方根误差是均方误差的平方根, 用来衡量预测值与真实值之间的平均偏差:<span class="math display">\[R M S E=\sqrt{M S E}=\sqrt{\frac{1}{n}\sum_{i=1}^n\left(y_i-\hat{y}_i\right)^2}\]</span></p><h3 id="平均绝对误差-mae">平均绝对误差 (MAE)</h3><p>平均绝对误差是预测值与真实值之间差异的绝对值的平均值:</p><p><span class="math display">\[M A E=\frac{1}{n} \sum_{i=1}^n\left|y_i-\hat{y}_i\right|\]</span></p><p>上述举例的方误差（MSE）、均方根误差（RMSE）和平均绝对误差（MAE）计算：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 预测值</span></span><br><span class="line">y_pred = model.predict(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算均方误差（MSE）</span></span><br><span class="line">mse = mean_squared_error(y, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"均方误差 (MSE):"</span>, mse)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算均方根误差（RMSE）</span></span><br><span class="line">rmse = np.sqrt(mse)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"均方根误差 (RMSE):"</span>, rmse)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算平均绝对误差（MAE）</span></span><br><span class="line">mae = mean_absolute_error(y, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"平均绝对误差 (MAE):"</span>, mae)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><pre><code>均方误差 (MSE): 0.36395228249940537均方根误差 (RMSE): 0.603284578370279平均绝对误差 (MAE): 0.4390690780172787</code></pre><h3 id="推导过程">推导过程</h3><p>这些评估指标的推导过程可以通过最小化某些损失函数来实现。以均方误差为例,可以通过最小化残差平方和来得到参数的估计值。</p><p>具体地, 在线性回归中, 的目标是最小化残差平方和: <span class="math display">\[\text { Residual Sum of Squares (RSS)}=\sum_{i=1}^n\left(y_i-\hat{y}_i\right)^2\]</span></p><p>其中 <span class="math inline">\(y_i\)</span> 是真实值, <span class="math inline">\(\hat{y}_i\)</span> 是预测值。通过最小化RSS，可以得到最优的模型参数估计值。</p><h3 id="应用场景">应用场景</h3><ul><li>均方误差（MSE）：适用于评估模型对异常值的敏感程度。由于MSE计算了预测值与真实值之间的平方差,因此对大的误差给予较大的惩罚,使得模型更加关注这些大误差, 适用于需要关注所有预测误差的场景。</li><li>均方根误差（RMSE）：将均方误差进行平方根处理后得到的指标,具有与原始数据相同的量纲, 更直观地反映了预测值与真实值的平均偏差,常用于解释模型的预测误差的平均水平。</li><li>平均绝对误差 (MAE) : 对预测值与真实值之间的绝对差值进行求平均,不考虑差值的正负, 因此更加稳健, 不受异常值的影响,适用于对异常值敏感的场景。</li></ul><p>总的来说, 均方误差、均方根误差和平均绝对误差都是常用的评估指标,各有优缺点, 实际情况中, 要选择合适的指标来评估模型的性能。</p><h3 id="r平方r-squared">R平方（R-squared）</h3><p><span class="math inline">\(\mathrm{R}\)</span> 平方是一个介于 0 和 1之间的值,用来衡量线性回归模型对观测数据的拟合程度。它表示因变量（目标变量）的变异程度中有多少能够被自变量（特征）解释。<span class="math inline">\(\mathrm{R}\)</span> 平方的计算公式: <span class="math display">\[R^2=1-\frac{\sum_{i=1}^n\left(y_i-\hat{y}_i\right)^2}{\sum_{i=1}^n\left(y_i-\bar{y}\right)^2}\]</span></p><p>其中: - <span class="math inline">\(y_i\)</span> 是第 <span class="math inline">\(i\)</span> 个观测值的真实值（因变量的实际值）。 -<span class="math inline">\(\hat{y}_i\)</span> 是模型预测的值,即根据回归模型估计得出的值。 - <span class="math inline">\(\bar{y}\)</span> 是因变量 <span class="math inline">\(y\)</span> 的均值。 <span class="math inline">\(R\)</span> 平方的取值范围为 0 到 1 , 当 <span class="math inline">\(R\)</span> 平方接近 1 时,表示模型能够很好地解释因变量的变异性, 拟合优度较高。当 <span class="math inline">\(R\)</span> 平方接近 0 时,表示模型对因变量的解释力较差, 拟合优度较低。</p><h3 id="调整后的r平方adjusted-r-squared">调整后的R平方（AdjustedR-squared）</h3><p>调整后的R平方是对 <span class="math inline">\(R\)</span>平方的一种修正, 考虑了自变量的数量。它用于避免过度拟合问题,因为增加自变量可能会导致R平方增加, 但也不一定意味着模型更好。</p><p>调整后的R平方的计算公式: <span class="math display">\[\text { Adjusted } R^2=1-\frac{\left(1-R^2\right)(n-1)}{n-p-1}\]</span></p><p>其中: - <span class="math inline">\(R^2\)</span> 是未经调整的 <span class="math inline">\(\mathrm{R}\)</span> 平方。 - <span class="math inline">\(n\)</span> 是样本数量。 - <span class="math inline">\(p\)</span> 是自变量的数量。</p><p>调整后的 <span class="math inline">\(R\)</span>平方通常小于未经调整的 <span class="math inline">\(R\)</span> 平方,因为它考虑了自变量数量的惩罚。当模型中的自变量不增加解释力时, 调整后的<span class="math inline">\(R\)</span> 平方值较低。</p><p>含义总结： - R平方 表示模型对因变量变异性的解释程度,数值范围在0到1之间。较高的R平方表示较好的拟合优度,但高R平方并不一定代表模型的可靠性。 - 调整后的R平方在R平方的基础上进行修正, 考虑了自变量数量。它通常小于未经调整的R平方,用于避免过度拟合问题。更高的调整后的R平方表示模型更可靠,尤其在自变量较多时, 对模型的评估更有帮助。</p><p>总而言之, <span class="math inline">\(R\)</span> 平方和调整后的 <span class="math inline">\(R\)</span>平方是用于评估线性回归模型拟合优度的重要指标,可以帮助我们了解模型对数据的解释力和可靠性。</p><p>上述举例的<code>R-squared</code>、<code>Adjusted R-squared</code>计算代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 R²</span></span><br><span class="line">r2 = r2_score(y, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"决定系数 (R²):"</span>, r2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 Adjusted R²</span></span><br><span class="line">n = <span class="built_in">len</span>(y)  <span class="comment"># 样本数量</span></span><br><span class="line">p = X.shape[<span class="number">1</span>]  <span class="comment"># 自变量数量</span></span><br><span class="line">adj_r2 = <span class="number">1</span> - (<span class="number">1</span> - r2) * (n - <span class="number">1</span>) / (n - p - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"调整决定系数 (Adjusted R²):"</span>, adj_r2)</span><br></pre></td></tr></tbody></table></figure><pre><code>决定系数 (R²): 0.6366981026928232调整决定系数 (Adjusted R²): 0.6348632446256153</code></pre><p>上述举例为简单线性回归模型，现在对多元线性回归模型进行说明。</p><h2 id="多元线性回归">4.多元线性回归</h2><p>多元线性回归是一种扩展了简单线性回归的模型，在考虑多个自变量的情况下建立与因变量之间的线性关系。</p><h3 id="公式推导">公式推导</h3><p>多元线性回归模型的数学表达式为: <span class="math display">\[y=\beta_0+\beta_1 x_1+\beta_2 x_2+\ldots+\beta_r x_r+\epsilon\]</span></p><p>其中: - <span class="math inline">\(y\)</span>是因变量（要预测的变量）; - <span class="math inline">\(x_1, x_2,\ldots, x_r\)</span> 是自变量（特征或解释变量）; - <span class="math inline">\(\beta_0\)</span> 是截距（模型的偏置）; - <span class="math inline">\(\beta_1, \beta_2, \ldots, \beta_r\)</span>是自变量的系数（模型的斜率）; - <span class="math inline">\(\epsilon\)</span> 是误差项,表示模型无法解释的随机误差。</p><h3 id="参数估计过程">参数估计过程</h3><p>为了估计多元线性回归模型的参数，可以使用最小二乘法。首先,将模型的公式写成矩阵形式: <span class="math display">\[Y=X \beta+\epsilon\]</span></p><p>其中: - <span class="math inline">\(Y\)</span> 是因变量的观测值 <span class="math inline">\((n \times 1\)</span> 的列向量 <span class="math inline">\()\)</span>; - <span class="math inline">\(X\)</span> 是自变量的设计矩阵 <span class="math inline">\((n \times(r+1)\)</span> 的矩阵）,其中第一列是全1向量, 用来对应截距项; - <span class="math inline">\(\beta\)</span> 是参数向量 <span class="math inline">\(((r+1) \times 1\)</span> 的列向量 <span class="math inline">\()\)</span>; - <span class="math inline">\(\epsilon\)</span> 是误差项 <span class="math inline">\((n \times 1\)</span> 的列向量）。</p><p>接下来, 的目标是最小化残差平方和 <span class="math inline">\(\sum_{i=1}^n \epsilon_i^2\)</span>。将残差向量表示为 <span class="math inline">\(\epsilon=Y-X\beta\)</span>, 可以得到最小二乘估计为: <span class="math display">\[\hat{\beta}=\left(X^T X\right)^{-1} X^T Y\]</span></p><p>下面进行代码举例：使用<code>Iris</code>数据集的前两个特征进行回归，并将第三个特征作为因变量。- 蓝色点表示实际数据。 - 红色点表示模型预测的数据。 -黄色平面表示回归模型拟合的平面。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error, r2_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载Iris数据集</span></span><br><span class="line">iris = load_iris()</span><br><span class="line">X = iris.data[:, :<span class="number">2</span>]  <span class="comment"># 使用前2个特征</span></span><br><span class="line">y = iris.data[:, <span class="number">2</span>].reshape(-<span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># 使用第3个特征作为因变量</span></span><br><span class="line"></span><br><span class="line">X = X[:<span class="number">150</span>]</span><br><span class="line">y = y[:<span class="number">150</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线性回归模型</span></span><br><span class="line">model = LinearRegression()</span><br><span class="line">model.fit(X, y)</span><br><span class="line">y_pred = model.predict(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算均方误差</span></span><br><span class="line">mse = mean_squared_error(y, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"均方误差 (MSE):"</span>, mse)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算均方根误差（RMSE）</span></span><br><span class="line">rmse = np.sqrt(mse)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"均方根误差 (RMSE):"</span>, rmse)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算平均绝对误差（MAE）</span></span><br><span class="line">mae = mean_absolute_error(y, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"平均绝对误差 (MAE):"</span>, mae)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 R²</span></span><br><span class="line">r2 = r2_score(y, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"决定系数 (R²):"</span>, r2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算调整后的 R²</span></span><br><span class="line">n = y.shape[<span class="number">0</span>]  <span class="comment"># 样本数量</span></span><br><span class="line">p = X.shape[<span class="number">1</span>]  <span class="comment"># 自变量数量</span></span><br><span class="line">adj_r2 = <span class="number">1</span> - (<span class="number">1</span> - r2) * (n - <span class="number">1</span>) / (n - p - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"调整决定系数 (Adjusted R²):"</span>, adj_r2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">15</span>, <span class="number">15</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>, projection=<span class="string">'3d'</span>)</span><br><span class="line">ax.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], y, color=<span class="string">'b'</span>, label=<span class="string">'实际值'</span>)</span><br><span class="line">ax.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], y_pred, color=<span class="string">'r'</span>, label=<span class="string">'预测值'</span>)</span><br><span class="line"></span><br><span class="line">xx1, xx2 = np.meshgrid(np.linspace(X[:, <span class="number">0</span>].<span class="built_in">min</span>(), X[:, <span class="number">0</span>].<span class="built_in">max</span>(), <span class="number">100</span>), np.linspace(X[:, <span class="number">1</span>].<span class="built_in">min</span>(), X[:, <span class="number">1</span>].<span class="built_in">max</span>(), <span class="number">100</span>))</span><br><span class="line">yy = model.intercept_ + model.coef_[<span class="number">0</span>][<span class="number">0</span>]*xx1 + model.coef_[<span class="number">0</span>][<span class="number">1</span>]*xx2</span><br><span class="line">ax.plot_surface(xx1, xx2, yy, alpha=<span class="number">0.5</span>, color=<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">'花萼长度 (cm)'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'花萼宽度 (cm)'</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">'花瓣长度 (cm)'</span>)</span><br><span class="line">ax.set_title(<span class="string">'多元线性回归的3D图'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><pre><code>均方误差 (MSE): 0.40957831218050467均方根误差 (RMSE): 0.6399830561667275平均绝对误差 (MAE): 0.5162246726456129决定系数 (R²): 0.8676860089345194调整决定系数 (Adjusted R²): 0.865885818579887</code></pre><p><img src="../../../../images/机器学习概论/output_13_1.png"></p><h2 id="特征选择">5.特征选择</h2><p>特征选择可以帮助从⼤量的⾃变量中挑选出最具影响⼒的变量，以提⾼模型的预测性能、减少过拟合的⻛险并简化模型的解释。 ### 多重共线性（Multicollinearity）多重共线性是指⾃变量之间存在⾼度相关性或线性依赖关系的情况。</p><p><strong>多重共线性可能会导致以下问题</strong> 1.不稳定的估计：多重共线性会导致回归系数估计变得不稳定。这意味着⼩的数据变动或微⼩的变量选择变化都可能导致回归系数的⼤幅度变化，使得参数估计不可靠。2.难以解释效果：多重共线性使得很难分离各⾃⾃变量对因变量的独⽴效应，因为它们之间的效应不再明确。这会降低模型的解释能⼒。3.统计检验不准确：多重共线性会导致回归模型的统计检验不准确，如t检验和F检验。这可能会导致错误的结论，例如错误地认为某些⾃变量对因变量没有显著影响。4.过度拟合：多重共线性可以导致过度拟合，因为模型可能会在⾃变量之间寻找微⼩的变化，从⽽试图解释由于共线性引起的噪声。</p><p><strong>检测多重共线性</strong> 1.相关系数分析：通过计算⾃变量之间的相关系数矩阵，可以初步了解⾃变量之间是否存在⾼度相关性。相关系数接近于1表示⾼度相关。2.⽅差膨胀因⼦（VIF）：VIF⽤于衡量每个⾃变量与其他⾃变量的相关性程度。VIF越⼤，表示共线性越严重。通常，VIF⼤于10或更⾼的⾃变量可能需要考虑去除或合并。3.主成分分析（PCA）：PCA可以将相关的⾃变量合并成新的⽆关⾃变量，从⽽减少共线性的影响。但这会导致模型的解释变得更加复杂。4.逐步回归：逐步回归⽅法允许逐渐添加或删除⾃变量，以找到最佳模型。在逐步回归中，会考虑每个⾃变量的贡献，从⽽减少共线性引起的问题。5.合并⾃变量：如果多个⾃变量之间⾼度相关，可以考虑将它们合并成⼀个新的⾃变量或使⽤其平均值来代替。这样可以减少模型中的共线性。</p><p>下面我们使用<code>Iris</code>的4个特征作为自变量、种类作为因变量进行多重共线性分析。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载Iris数据集</span></span><br><span class="line">iris = load_iris()</span><br><span class="line">X = iris.data[:<span class="number">150</span>, :<span class="number">4</span>]  </span><br><span class="line">y = iris.target[:<span class="number">150</span>]  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建DataFrame</span></span><br><span class="line">df = pd.DataFrame(X, columns=iris.feature_names)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算相关系数矩阵</span></span><br><span class="line">correlation_matrix = df.corr()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"相关系数矩阵："</span>)</span><br><span class="line"><span class="built_in">print</span>(correlation_matrix)</span><br></pre></td></tr></tbody></table></figure><pre><code>相关系数矩阵：                   sepal length (cm)  sepal width (cm)  petal length (cm)  \sepal length (cm)           1.000000         -0.117570           0.871754   sepal width (cm)           -0.117570          1.000000          -0.428440   petal length (cm)           0.871754         -0.428440           1.000000   petal width (cm)            0.817941         -0.366126           0.962865                      petal width (cm)  sepal length (cm)          0.817941  sepal width (cm)          -0.366126  petal length (cm)          0.962865  petal width (cm)           1.000000  </code></pre><p><strong>⽅差膨胀因⼦（VIF）</strong></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> statsmodels.stats.outliers_influence <span class="keyword">import</span> variance_inflation_factor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算VIF</span></span><br><span class="line">vif_data = pd.DataFrame()</span><br><span class="line">vif_data[<span class="string">'特征'</span>] = df.columns</span><br><span class="line">vif_data[<span class="string">'VIF'</span>] = [variance_inflation_factor(df.values, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(df.shape[<span class="number">1</span>])]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n方差膨胀因子（VIF）："</span>)</span><br><span class="line"><span class="built_in">print</span>(vif_data)</span><br></pre></td></tr></tbody></table></figure><pre><code>方差膨胀因子（VIF）：                  特征         VIF0  sepal length (cm)  262.9693481   sepal width (cm)   96.3532922  petal length (cm)  172.9609623   petal width (cm)   55.502060</code></pre><p><strong>主成分分析（PCA）</strong></p><ol type="1"><li>数据标准化和中心化</li></ol><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 对每个特征求平均值</span></span><br><span class="line">mean_vec = np.mean(X, axis=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"特征均值："</span>, mean_vec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原来的数据减去平均值得到新的中心化之后的数据</span></span><br><span class="line">centered_X = X - mean_vec</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n中心化后的数据：\n"</span>, centered_X[:<span class="number">5</span>])  <span class="comment"># 只显示前5行</span></span><br></pre></td></tr></tbody></table></figure><pre><code>特征均值： [5.84333333 3.05733333 3.758      1.19933333]中心化后的数据： [[-0.74333333  0.44266667 -2.358      -0.99933333] [-0.94333333 -0.05733333 -2.358      -0.99933333] [-1.14333333  0.14266667 -2.458      -0.99933333] [-1.24333333  0.04266667 -2.258      -0.99933333] [-0.84333333  0.54266667 -2.358      -0.99933333]]</code></pre><ol start="2" type="1"><li>计算协方差矩阵</li></ol><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 计算协方差矩阵</span></span><br><span class="line">cov_matrix = np.cov(centered_X.T)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n协方差矩阵：\n"</span>, cov_matrix)</span><br></pre></td></tr></tbody></table></figure><pre><code>协方差矩阵： [[ 0.68569351 -0.042434    1.27431544  0.51627069] [-0.042434    0.18997942 -0.32965638 -0.12163937] [ 1.27431544 -0.32965638  3.11627785  1.2956094 ] [ 0.51627069 -0.12163937  1.2956094   0.58100626]]</code></pre><ol start="3" type="1"><li>计算特征值和特征向量</li></ol><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 计算协方差矩阵的特征值和特征向量</span></span><br><span class="line">eig_vals, eig_vecs = np.linalg.eig(cov_matrix)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n特征值：\n"</span>, eig_vals)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n特征向量：\n"</span>, eig_vecs)</span><br></pre></td></tr></tbody></table></figure><pre><code>特征值： [4.22824171 0.24267075 0.0782095  0.02383509]特征向量： [[ 0.36138659 -0.65658877 -0.58202985  0.31548719] [-0.08452251 -0.73016143  0.59791083 -0.3197231 ] [ 0.85667061  0.17337266  0.07623608 -0.47983899] [ 0.3582892   0.07548102  0.54583143  0.75365743]]</code></pre><ol start="4" type="1"><li>选择主成分和投影矩阵</li></ol><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 对特征值按照降序排列，并选择前两个主成分</span></span><br><span class="line">sorted_indices = np.argsort(eig_vals)[::-<span class="number">1</span>]</span><br><span class="line">sorted_eig_vals = eig_vals[sorted_indices]</span><br><span class="line">sorted_eig_vecs = eig_vecs[:, sorted_indices]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择前两个主成分</span></span><br><span class="line">n_components = <span class="number">2</span></span><br><span class="line">selected_eig_vecs = sorted_eig_vecs[:, :n_components]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n选择的特征向量（投影矩阵）：\n"</span>, selected_eig_vecs)</span><br></pre></td></tr></tbody></table></figure><pre><code>选择的特征向量（投影矩阵）： [[ 0.36138659 -0.65658877] [-0.08452251 -0.73016143] [ 0.85667061  0.17337266] [ 0.3582892   0.07548102]]</code></pre><ol start="5" type="1"><li>求出降维后的数据</li></ol><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 根据投影矩阵求出降维后的数据</span></span><br><span class="line">X_pca = centered_X.dot(selected_eig_vecs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n降维后的数据：\n"</span>, X_pca[:<span class="number">5</span>])  <span class="comment"># 只显示前5行</span></span><br></pre></td></tr></tbody></table></figure><pre><code>降维后的数据： [[-2.68412563 -0.31939725] [-2.71414169  0.17700123] [-2.88899057  0.14494943] [-2.74534286  0.31829898] [-2.72871654 -0.32675451]]</code></pre><p><strong>也可直接使用<code>Scikit-Learn</code></strong></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行PCA</span></span><br><span class="line">pca = PCA(n_components=<span class="number">2</span>)  <span class="comment">#降到2维</span></span><br><span class="line">X_pca = pca.fit_transform(X)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n主成分分析结果："</span>)</span><br><span class="line"><span class="built_in">print</span>(X_pca[:<span class="number">5</span>])  <span class="comment"># 只显示前5行</span></span><br></pre></td></tr></tbody></table></figure><pre><code>主成分分析结果：[[-2.68412563  0.31939725] [-2.71414169 -0.17700123] [-2.88899057 -0.14494943] [-2.74534286 -0.31829898] [-2.72871654  0.32675451]]</code></pre><p>数据本身是4维的，降维后为2维</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> sklearn.decomposition <span class="keyword">as</span> dp</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载Iris数据集，x表示数据集中的属性数据，y表示数据标签</span></span><br><span class="line">x, y = load_iris(return_X_y=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载PCA算法，设置降维后主成分数目为2</span></span><br><span class="line">pca = dp.PCA(n_components=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对原始数据进行降维，保存在reduced_x中</span></span><br><span class="line">reduced_x = pca.fit_transform(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建不同类别的列表来保存降维后的数据点</span></span><br><span class="line">red_x, red_y = [], []</span><br><span class="line">blue_x, blue_y = [], []</span><br><span class="line">green_x, green_y = [], []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按鸢尾花的类别将降维后的数据点保存在不同的列表中</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(reduced_x)):</span><br><span class="line">    <span class="keyword">if</span> y[i] == <span class="number">0</span>:</span><br><span class="line">        red_x.append(reduced_x[i][<span class="number">0</span>])</span><br><span class="line">        red_y.append(reduced_x[i][<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">elif</span> y[i] == <span class="number">1</span>:</span><br><span class="line">        blue_x.append(reduced_x[i][<span class="number">0</span>])</span><br><span class="line">        blue_y.append(reduced_x[i][<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        green_x.append(reduced_x[i][<span class="number">0</span>])</span><br><span class="line">        green_y.append(reduced_x[i][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">plt.scatter(red_x, red_y, c=<span class="string">'r'</span>, marker=<span class="string">'x'</span>, label=<span class="string">'类别 0'</span>)</span><br><span class="line">plt.scatter(blue_x, blue_y, c=<span class="string">'b'</span>, marker=<span class="string">'D'</span>, label=<span class="string">'类别 1'</span>)</span><br><span class="line">plt.scatter(green_x, green_y, c=<span class="string">'g'</span>, marker=<span class="string">'.'</span>, label=<span class="string">'类别 2'</span>)</span><br><span class="line">plt.title(<span class="string">'Iris数据集PCA降维'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'主成分 1'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'主成分 2'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p>​<br><img src="../../../../images/机器学习概论/output_32_0.png"> ​</p><p><strong>通过观察图中不同颜色点的分布，可以发现</strong>： -Iris-setosa (类别 0 )与其他两类在降维后的空间中分布较为独立，显示出明显的分离。 -Iris-versicolor (类别1) 和Iris-virginica (类别2)有部分重叠，表明这两类在原始特征空间中的某些属性比较接近。</p><p>下面使用加州房价数据集进行再一次尝试。使用不同的特征组合进行比较。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_california_housing</span><br><span class="line"></span><br><span class="line">housing = fetch_california_housing()</span><br><span class="line">X = housing.data</span><br><span class="line">Y = housing.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割训练集和测试集</span></span><br><span class="line">X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数，用于评估模型的性能</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate_model</span>(<span class="params">X_train, X_test, Y_train, Y_test</span>):</span><br><span class="line">    model = LinearRegression()</span><br><span class="line">    model.fit(X_train, Y_train)</span><br><span class="line">    Y_pred = model.predict(X_test)</span><br><span class="line">    mse = mean_squared_error(Y_test, Y_pred)</span><br><span class="line">    <span class="keyword">return</span> mse, Y_pred</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型评估</span></span><br><span class="line">all_features_mse, _ = evaluate_model(X_train, X_test, Y_train, Y_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"使用所有特征的MSE:"</span>, all_features_mse)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择不同的自变量组合进行建模</span></span><br><span class="line">selected_features = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>]]  <span class="comment"># 不同的自变量组合</span></span><br><span class="line">mse_values = []</span><br><span class="line"><span class="keyword">for</span> i, features <span class="keyword">in</span> <span class="built_in">enumerate</span>(selected_features):</span><br><span class="line">    X_train_selected = X_train[:, features]</span><br><span class="line">    X_test_selected = X_test[:, features]</span><br><span class="line">    mse, Y_pred = evaluate_model(X_train_selected, X_test_selected, Y_train, Y_test)</span><br><span class="line">    mse_values.append(mse)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 可视化预测结果</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">    plt.scatter(Y_test, Y_pred, label=<span class="string">f'特征组合: <span class="subst">{features}</span>'</span>, s=<span class="number">1</span>)</span><br><span class="line">    plt.plot([Y_test.<span class="built_in">min</span>(), Y_test.<span class="built_in">max</span>()], [Y_test.<span class="built_in">min</span>(), Y_test.<span class="built_in">max</span>()], <span class="string">'k--'</span>, lw=<span class="number">2</span>)  <span class="comment"># 对角线</span></span><br><span class="line">    plt.xlabel(<span class="string">'真实值'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'预测值'</span>)</span><br><span class="line">    plt.title(<span class="string">f'真实值 vs 预测值 使用特征组合: <span class="subst">{features}</span>'</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印不同自变量组合的 MSE 值</span></span><br><span class="line"><span class="keyword">for</span> i, features <span class="keyword">in</span> <span class="built_in">enumerate</span>(selected_features):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"使用特征组合 <span class="subst">{features}</span> 的MSE: <span class="subst">{mse_values[i]}</span>"</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><pre><code>使用所有特征的MSE: 0.5558915986952422</code></pre><p><img src="../../../../images/机器学习概论/output_35_1.png"></p><p><img src="../../../../images/机器学习概论/output_35_2.png"></p><p><img src="../../../../images/机器学习概论/output_35_3.png"></p><p><img src="../../../../images/机器学习概论/output_35_4.png"></p><pre><code>使用特征组合 [0, 1] 的MSE: 0.6629874283048177使用特征组合 [1, 2, 3] 的MSE: 1.1293479456543194使用特征组合 [2, 3, 4] 的MSE: 1.1724183557562893使用特征组合 [0, 4, 5] 的MSE: 0.7070316559271143</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行PCA</span></span><br><span class="line">pca = PCA(n_components=<span class="number">3</span>)</span><br><span class="line">X_pca = pca.fit_transform(X)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n主成分分析结果："</span>)</span><br><span class="line"><span class="built_in">print</span>(X_pca[:<span class="number">5</span>])  <span class="comment"># 只显示前5行</span></span><br></pre></td></tr></tbody></table></figure><pre><code>主成分分析结果：[[-1.10351265e+03  8.56663624e+00 -7.74104267e-01] [ 9.75541244e+02 -4.67041774e+00 -1.02568060e+00] [-9.29549908e+02  2.00346509e+01 -1.97273701e+00] [-8.67550048e+02  2.03314414e+01 -2.31492872e+00] [-8.60550411e+02  2.03288266e+01 -2.69515779e+00]]</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 计算VIF</span></span><br><span class="line">X_df = pd.DataFrame(X, columns=housing.feature_names)</span><br><span class="line">vif_data = pd.DataFrame()</span><br><span class="line">vif_data[<span class="string">'特征'</span>] = X_df.columns</span><br><span class="line">vif_data[<span class="string">'VIF'</span>] = [variance_inflation_factor(X_df.values, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(X_df.shape[<span class="number">1</span>])]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"方差膨胀因子（VIF）："</span>)</span><br><span class="line"><span class="built_in">print</span>(vif_data)</span><br></pre></td></tr></tbody></table></figure><pre><code>方差膨胀因子（VIF）：           特征         VIF0      MedInc   11.5111401    HouseAge    7.1959172    AveRooms   45.9936013   AveBedrms   43.5903144  Population    2.9357455    AveOccup    1.0952436    Latitude  559.8740717   Longitude  633.711654</code></pre><h2 id="正则化技术">6.正则化技术</h2><p>正则化技术在机器学习中被广泛应用于控制模型的复杂度,避免过拟合问题。L1正则化（也称为Lasso回归）和L2正则化（也称为岭回归）是常用的正则化方法,它们分别通过添加L1范数和L2范数的惩罚项来限制模型参数的大小。</p><h3 id="l1正则化lasso回归">L1正则化（Lasso回归）</h3><p>L1正则化通过添加参数向量的L1范数作为惩罚项, 其优化目标可以表示为:<span class="math display">\[\operatorname{minimize} \quad \mathrm{MSE}+\lambda\sum_{j=1}^p\left|\beta_j\right|\]</span></p><p>其中, MSE 是均方误差（Mean Squared Error）， <span class="math inline">\(\lambda\)</span> 是正则化参数,控制正则化项的影响力, 较⼤的 <span class="math inline">\(\lambda\)</span> 值会导致更多的系数变为零，<span class="math inline">\(\beta_j\)</span> 是模型的第 <span class="math inline">\(j\)</span>个参数。</p><h3 id="l2正则化岭回归">L2正则化（岭回归）</h3><p>L2正则化通过添加参数向量的L2范数的平方作为惩罚项,其优化目标可以表示为: <span class="math display">\[\operatorname{minimize} \quad \mathrm{MSE}+\lambda \sum_{j=1}^p\beta_j^2\]</span></p><p>其中, MSE 是均方误差（Mean Squared Error）， <span class="math inline">\(\lambda\)</span> 是正则化参数,控制正则化项的影响力, 较⼤的 <span class="math inline">\(\lambda\)</span> 值会导致系数趋向于零，<span class="math inline">\(\beta_j\)</span> 是模型的第 <span class="math inline">\(j\)</span>个参数。</p><p>下面举例使用一个多项式函数作为目标函数,然后分别演示不使用正则化、使用L1正则化（Lasso回归）和使用L2正则化（Ridge回归）的情况。</p><p>代码中, 生成一个具有噪声的多项式数据集,并拟合三种不同类型的模型。</p><p>最后，绘制一个拟合曲线以及观察它们之间的差异。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures, StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression, Lasso, Ridge</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> make_pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成多项式数据集</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">X = np.sort(<span class="number">5</span> * np.random.rand(<span class="number">70</span>, <span class="number">1</span>), axis=<span class="number">0</span>)</span><br><span class="line">y = np.sin(X).ravel() + np.random.normal(<span class="number">0</span>, <span class="number">0.1</span>, X.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义不同的多项式阶数</span></span><br><span class="line">degrees = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">15</span>]  </span><br><span class="line">models = [(<span class="string">'无正则化'</span>, <span class="string">'r'</span>, <span class="string">'-'</span>), </span><br><span class="line">          (<span class="string">'L1 正则化 (Lasso)'</span>, <span class="string">'g'</span>, <span class="string">'--'</span>), </span><br><span class="line">          (<span class="string">'L2 正则化 (Ridge)'</span>, <span class="string">'b'</span>, <span class="string">'-.'</span>)]</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">14</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, (name, color, linestyle) <span class="keyword">in</span> <span class="built_in">enumerate</span>(models):</span><br><span class="line">    ax = plt.subplot(<span class="number">1</span>, <span class="built_in">len</span>(models), i + <span class="number">1</span>)</span><br><span class="line">    plt.setp(ax, xticks=(), yticks=())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将特征进行多项式转换并标准化</span></span><br><span class="line">    polynomial_features = PolynomialFeatures(degree=degrees[i], include_bias=<span class="literal">False</span>)</span><br><span class="line">    scaler = StandardScaler()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">'L1 正则化 (Lasso)'</span>:</span><br><span class="line">        model = make_pipeline(polynomial_features, scaler, Lasso(alpha=<span class="number">0.001</span>, max_iter=<span class="number">10000</span>))</span><br><span class="line">    <span class="keyword">elif</span> name == <span class="string">'L2 正则化 (Ridge)'</span>:</span><br><span class="line">        model = make_pipeline(polynomial_features, scaler, Ridge(alpha=<span class="number">1.0</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        model = make_pipeline(polynomial_features, scaler, LinearRegression())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 拟合模型</span></span><br><span class="line">    model.fit(X, y)</span><br><span class="line">    y_pred = model.predict(X)</span><br><span class="line">    mse = mean_squared_error(y, y_pred)</span><br><span class="line">    </span><br><span class="line">    plt.plot(X, y, <span class="string">'o'</span>, color=<span class="string">'cornflowerblue'</span>, label=<span class="string">"实际值"</span>)</span><br><span class="line">    plt.plot(X, y_pred, color=color, linestyle=linestyle, linewidth=<span class="number">2</span>,</span><br><span class="line">             label=<span class="string">"{} (均方误差: {:.2f})"</span>.<span class="built_in">format</span>(name, mse))</span><br><span class="line">    </span><br><span class="line">    plt.title(<span class="string">"多项式阶数 {}\n均方误差 = {:.2e}"</span>.<span class="built_in">format</span>(degrees[i], mse), fontsize=<span class="number">14</span>)</span><br><span class="line">    plt.xlabel(<span class="string">"x"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">    plt.ylabel(<span class="string">"y"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">"best"</span>, fontsize=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p>​<br><img src="../../../../images/机器学习概论/output_39_0.png"> ​</p><h3 id="lasso回归岭回归与普通线性回归之间的区别">Lasso回归、岭回归与普通线性回归之间的区别</h3><ol type="1"><li>正则化类型:<ul><li>普通线性回归没有正则化项，其目标是最小化残差平方和，不对回归系数进行任何约束。</li><li>岭回归引入了 <span class="math inline">\(L 2\)</span> 正则化项,其目标是最小化残差平方和与回归系数的平方和之和,以限制回归系数的大小。</li><li>Lasso回归引入了 L1 正则化项,其目标是最小化残差平方和与回归系数的绝对值之和,以促使一些回归系数变为零, 实现特征选择。</li></ul></li><li>系数的性质：<ul><li>普通线性回归的系数可以是任意实数, 没有限制。</li><li>岭回归的系数趋向于缩小但不会变为零, 因此不会进行特征选择。</li><li>Lasso回归的系数可以变为零, 从而实现了自动特征选择,使模型更稀疏。</li></ul></li><li>解决的问题：<ul><li>普通线性回归通常用于建模和预测,但在存在多重共线性时容易过拟合。</li><li>岭回归主要用于解决多重共线性问题, 可以稳定估计,但不进行特征选择。</li><li>Lasso 回归用于解决多重共线性问题, 并且可以进行特征选择,有助于提取最重要的特征。</li></ul></li><li>正则化参数:<ul><li>在岭回归和Lasso回归中, 正则化参数 (a) 用于控制正则化的强度。较大的a值会导致更强的正则化, 推动回归系数向零缩小。</li><li>普通线性回归没有正则化参数。</li></ul></li><li>特征选择:<ul><li>普通线性回归不进行特征选择，使用所有特征。</li><li>岭回归倾向于减小回归系数但不会消除它们, 不进行特征选择。</li><li>Lasso 回归可以将某些系数压缩为零, 实现特征选择, 使模型更稀疏。</li></ul></li></ol><h1 id="二梯度下降法">二、梯度下降法</h1><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义目标函数及其梯度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.1</span>*x*y+np.sin(x)+np.sin(y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grad_f</span>(<span class="params">x, y</span>):</span><br><span class="line">    grad_x = <span class="number">2</span> * x + <span class="number">50</span> * np.sin(x) * np.cos(x)</span><br><span class="line">    grad_y = <span class="number">2</span> * y + <span class="number">50</span> * np.sin(y) * np.cos(y)</span><br><span class="line">    <span class="keyword">return</span> np.array([grad_x, grad_y])</span><br><span class="line">alpha = <span class="number">0.1</span>  </span><br><span class="line">start_point = np.array([<span class="number">5.0</span>, <span class="number">5.0</span>])  </span><br><span class="line">epochs = <span class="number">20</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度下降过程</span></span><br><span class="line">point = start_point</span><br><span class="line">points = [point]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">    point = point - alpha * grad_f(point[<span class="number">0</span>], point[<span class="number">1</span>])</span><br><span class="line">    points.append(point)</span><br><span class="line">x_range = np.linspace(-<span class="number">7</span>, <span class="number">7</span>, <span class="number">400</span>)</span><br><span class="line">y_range = np.linspace(-<span class="number">7</span>, <span class="number">7</span>, <span class="number">400</span>)</span><br><span class="line">X, Y = np.meshgrid(x_range, y_range)</span><br><span class="line">Z = f(X, Y)</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">12</span>, <span class="number">8</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>, projection=<span class="string">'3d'</span>)</span><br><span class="line">ax.plot_surface(X, Y, Z, cmap=<span class="string">'viridis'</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line">points = np.array(points)</span><br><span class="line">Z_points = f(points[:, <span class="number">0</span>], points[:, <span class="number">1</span>])</span><br><span class="line">ax.plot(points[:, <span class="number">0</span>], points[:, <span class="number">1</span>], Z_points, color=<span class="string">'red'</span>, marker=<span class="string">'o'</span>, linestyle=<span class="string">'-'</span>, label=<span class="string">'梯度下降过程'</span>)</span><br><span class="line"><span class="keyword">for</span> i, (x, y, z) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(points[:, <span class="number">0</span>], points[:, <span class="number">1</span>], Z_points)):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">5</span> == <span class="number">0</span> <span class="keyword">or</span> i == epochs:</span><br><span class="line">        ax.text(x, y, z, <span class="string">f'<span class="subst">{i}</span>'</span>, fontsize=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">'$x$'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'$y$'</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">'$f(x, y)$'</span>)</span><br><span class="line">ax.set_title(<span class="string">'梯度下降法示意图'</span>)</span><br><span class="line">ax.legend()</span><br><span class="line">ax.view_init(elev=<span class="number">50</span>, azim=-<span class="number">60</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p>​<br><img src="../../../../images/机器学习概论/output_42_0.png"> ​</p><p>梯度下降法(GradientDescent)是一种算法，但不是像多元线性回归那样是一个具体做回归任务的算法，而是一个非常通用的优化算法来帮助一些机器学习算法求解出最优解的，所谓的通用就是很多机器学习算法都是用它，甚至深度学习也是用它来求解最优解。</p><h2 id="梯度下降法的思想">1.梯度下降法的思想</h2><ol type="1"><li><p>初始随机猜测在梯度下降法中，首先需要对模型参数进行初始化。通常，参数向量 <span class="math inline">\(\theta=\left[W_1, W_2, \ldots, W_n\right]\)</span>是通过随机选择的初始值。这个过程类似于在一个高维空间中随机选择一个起点。</p></li><li><p>计算预测值与损失 通过当前的参数向量 <span class="math inline">\(\theta\)</span> ，可以计算模型的预测值 <span class="math inline">\(\hat{y}\)</span>。例如，对于线性回归模型，可以通过公式 <span class="math inline">\(\hat{y}=\)</span> <span class="math inline">\(X\theta\)</span> 计算预测值。接着，将预测值 <span class="math inline">\(\hat{y}\)</span> 与真实值 <span class="math inline">\(y\)</span> 进行比较，计算损失函数（如均方误差MSE），以衡量模型的预测性能。</p></li><li><p>计算梯度 梯度是损失函数相对于参数向量 <span class="math inline">\(\theta\)</span>的一阶导数，表示在当前点上损失函数的最陡上升方向。通过计算梯度，可以确定如何调整参数以使损失函数减小。对于均方误差损失函数，其梯度可以表示为:<span class="math display">\[\nabla_\theta L(\theta)=\frac{\partial L(\theta)}{\partial \theta}\]</span></p></li><li><p>参数更新 根据计算得到的梯度，更新参数向量 <span class="math inline">\(\theta\)</span> 。更新公式为: <span class="math display">\[  \theta_{t+1}=\theta_t-\alpha \nabla_\theta L\left(\theta_t\right)  \]</span> 其中， <span class="math inline">\(\alpha\)</span>是学习率，控制每次参数更新的步长。</p></li><li><p>迭代重复上述步骤，逐步调整参数，使得损失函数值不断减小。这个过程持续进行，直到损失函数收玫到一个极小值（或达到预定的迭代次数）。</p></li></ol><p>梯度下降法的直观类比可以将梯度下降法类比为一个人在山谷中行走，试图找到最低点。在每一步中，这个人会评估当前所在位置的坡度，并朝着坡度最陡的下坡方向前进。通过不断地调整方向和步伐，这个人最终会到达谷底，即找到最小损失的参数组合。</p><h1 id="未完待续...">未完待续...</h1>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
          <category> 机器学习概论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四节 贝叶斯估计</title>
      <link href="/2024/05/18/shu-li-tong-ji-6-4-bei-xie-si-gu-ji/"/>
      <url>/2024/05/18/shu-li-tong-ji-6-4-bei-xie-si-gu-ji/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/isVbi1z1wzza">下载PDF点这里</a></p><p><img src="../../../../images/数理统计6-4贝叶斯估计/数理统计6.4-46.jpg"></p><p><img src="../../../../images/数理统计6-4贝叶斯估计/数理统计6.4-47.jpg"></p><p><img src="../../../../images/数理统计6-4贝叶斯估计/数理统计6.4-48.jpg"></p><p><img src="../../../../images/数理统计6-4贝叶斯估计/数理统计6.4-49.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数理统计 </category>
          
          <category> 第二章 参数估计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总体信息 </tag>
            
            <tag> 样本信息 </tag>
            
            <tag> 先验信息 </tag>
            
            <tag> 先验分布 </tag>
            
            <tag> 后验分布 </tag>
            
            <tag> 贝叶斯公式 </tag>
            
            <tag> 贝叶斯估计 </tag>
            
            <tag> 共轭先验分布族 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>税收征收管理法概述</title>
      <link href="/2024/05/18/jing-ji-fa-ji-chu-4-1-shui-shou-zheng-guan-fa-lu-zhi-du-chen-wei/"/>
      <url>/2024/05/18/jing-ji-fa-ji-chu-4-1-shui-shou-zheng-guan-fa-lu-zhi-du-chen-wei/</url>
      
        <content type="html"><![CDATA[<blockquote><p>投稿自宸溦</p></blockquote><h1 id="第四章-税收征管法律制度">第四章 税收征管法律制度</h1><h2 id="第一节-税收征收管理法概述">第一节 税收征收管理法概述</h2><p>《中华人民共和国税收征收管理法》（以下简称“税收征管法”）是我国税收程序法中的基本法。</p><h3 id="一适用范围">一、适用范围</h3><p>（1）由税务机关负责征收的税种，适用于税收征管法。</p><p>（2）由海关负责征收及代征的税种，依照其他法律法规规定执行，不直接适用税收征管法。</p><p>（3）国际税收条约、协定同税收征管法有不同规定的，依照条约、协定的规定办理。</p><h3 id="二征纳双方的权利和义务">二、征纳双方的权利和义务</h3><h4 id="征税主体的权利义务">1.征税主体的权利义务</h4><h5 id="权利">（1）权利</h5><p>税收立法权：参与起草税收法律法规草案，提出税收政策建议，在职权范围内制定、发布关于税收征管的部门规章等</p><p>税务管理权：税务登记管理、账簿和凭证管理、发票管理、纳税申报管理等</p><p>税款征收权：（1）最基本、最主要的职权；（2）包括依法计征权、核定税款权、税收保全和强制执行权、追征税款权等</p><p>税务检查权：查账权、场地检查权、询问权、责成提供资料权、存款账户核查权等</p><p>税务行政处罚权：依照法定标准对税收违法行为予以行政制裁，如罚款等</p><p>其他权利：在权限内，对纳税人的减、免、退、延期缴纳的申请予以审批的权利；阻止欠税纳税人离境的权利；定期对纳税人欠缴税款情况予以公告的权利；委托代征权；估税权；代位权与撤销权；上诉权等</p><h5 id="义务">（2）义务</h5><p>（1）宣传税收法律、行政法规，普及纳税知识，无偿为纳税人提供纳税咨询服务</p><p>（2）依法为纳税人、扣缴义务人的情况保密，为检举违反税法行为者保密</p><p>提示：纳税人、扣缴义务人的税收违法行为不属于保密范围</p><p>（3）加强队伍建设，提高税务人员的政治业务素质</p><p>（4）秉公执法，忠于职守，清正廉洁，礼貌待人，文明服务，尊重和保护纳税人、扣缴义务人的权利，依法接受监督</p><p>（5）税务人员不得索贿受贿、徇私舞弊、玩忽职守、不征或少征应征税款；不得滥用职权多征税款或者故意刁难纳税人和扣缴义务人</p><p>（6）税务人员在核定应纳税额、调整税收定额、进行税务检查、实施税务行政处罚、办理税务行政复议时，与纳税人、扣缴义务人或者其法定代表人、直接责任人有夫妻关系、直系血亲关系、三代以内旁系血亲关系、近姻亲关系及可能影响公正执法的其他利害关系的，应当回避</p><p>（7）建立、健全内部制约和监督管理制度</p><h4 id="纳税主体的权利义务">2.纳税主体的权利义务</h4><h5 id="权利-1">（1）权利</h5><p>（1）知情权、要求保密权</p><p>（2）纳税申报方式选择权、申请延期申报权、申请延期缴纳税款权、申请退还多缴税款权、依法享受税收优惠权、委托税务代理权</p><p>（3）税收监督权</p><p>（4）陈述权、申辩权</p><p>（5）其他：对未出示税务检查证和税务检查通知书的拒绝检查权、税收法律救济权、依法要求听证权、索取有关税收凭证权</p><h5 id="义务-1">（2）义务</h5><p>（1）按期办理税务登记，及时核定应纳税种、税目；依法设置账簿、保管账簿和有关资料以及依法开具、使用、取得和保管发票；财务会计制度和会计核算软件备案；按照规定安装、使用税控装置；按期、如实办理纳税申报</p><p>（2）按期缴纳或解缴税款；代扣、代收税款</p><p>（3）接受税务检查；及时提供信息；报告其他涉税信息</p>]]></content>
      
      
      <categories>
          
          <category> 经济法基础 </category>
          
          <category> 第四章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>其他税收法律制度</title>
      <link href="/2024/05/18/jing-ji-fa-ji-chu-3-4-qi-ta-shui-shou-fa-lu-zhi-du-chen-wei/"/>
      <url>/2024/05/18/jing-ji-fa-ji-chu-3-4-qi-ta-shui-shou-fa-lu-zhi-du-chen-wei/</url>
      
        <content type="html"><![CDATA[<blockquote><p>投稿自宸溦</p></blockquote><h2 id="第四节-其他税收法律制度">第四节 其他税收法律制度</h2><h3 id="一资源税">一、资源税</h3><h4 id="一征税范围和税目">（一）征税范围和税目</h4><h4 id="二纳税人和纳税环节">（二）纳税人和纳税环节</h4><p>1.纳税人</p><p>（1）资源税的纳税人，是指在中华人民共和国领域和其他海域开发应税资源的单位和个人。</p><p>（2）中外合作开采陆上、海上石油资源的企业应依法缴纳资源税。</p><p>2.纳税环节</p><p>（1）资源税在应税资源产品（以下简称“应税产品”）的销售环节计算缴纳。</p><h4 id="三应纳税额的计算">（三）应纳税额的计算</h4><p>1.计税规则和计算公式</p><p>（1）资源税实行从价计征或者从量计征。以纳税人开发应税产品的销售额或者销售数量为计税依据。</p><h3 id="二烟叶税">二、烟叶税</h3><h4 id="一征税对象及计征规则">（一）征税对象及计征规则</h4><p>征税对象 晾晒烟叶、烤烟叶</p><p>纳税人 在中华人民共和国境内收购烟叶的单位（烟草公司）</p><p>计税依据收购烟叶实际支付的价款总额=收购价款+价外补贴（收购价款×10%）</p><p>适用税率 比例税率为 20%</p><p>应纳税额 应纳税额=价款总额×税率=收购价款×（1+10%）×20%</p><h4 id="二征收管理">（二）征收管理</h4><p>（1）纳税义务发生时间为纳税人收购烟叶的当日。</p><p>（2）纳税人向烟叶收购地的主管税务机关申报纳税。</p>]]></content>
      
      
      <categories>
          
          <category> 经济法基础 </category>
          
          <category> 第三章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>行为类税收法律制度</title>
      <link href="/2024/05/18/jing-ji-fa-ji-chu-3-3-xing-wei-lei-shui-shou-fa-lu-zhi-du-chen-wei/"/>
      <url>/2024/05/18/jing-ji-fa-ji-chu-3-3-xing-wei-lei-shui-shou-fa-lu-zhi-du-chen-wei/</url>
      
        <content type="html"><![CDATA[<blockquote><p>投稿自宸溦</p></blockquote><h2 id="第三节-行为类税收法律制度">第三节 行为类税收法律制度</h2><h3 id="一印花税">一、印花税</h3><h4 id="一纳税义务人">（一）纳税义务人</h4><p>（1）在我国境内书立应税凭证、进行证券交易的单位和个人，为印花税的纳税人。</p><p>（2）在境外书立但在境内使用的应税凭证的单位和个人，应当缴纳印花税。</p><h4 id="二征税范围和税目">（二）征税范围和税目</h4><p>1.征税范围分类</p><p>采取正列举方式列举了 14个明细税目。列入税目的就要征税，未列入税目的就不征税。</p><p>2.征税范围特殊提示</p><p>（1）技术合同征税范围：包括技术开发、转让、咨询、服务等合同。</p><p>（2）买卖合同征税范围：</p><p>①包括：出版单位与发行单位（不包括订阅单位和个人）之间订立的图书、报纸、音像制品的应税凭证、发电厂与电网之间、电网与电网之间签订的购售电合同。</p><p>提示：对纳税人以电子形式签订的各类应税凭证按规定征收印花税。</p><p>②不包括：个人书立的动产买卖合同、电网与用户之间签订的供用电合同。</p><p>（3）借款合同征税范围：</p><p>①包括：银行业金融机构、经批准设立的其他金融机构与借款人所签订的借款合同。</p><p>②不包括：同业拆借合同和企业与非金融机构之间（企业与企业 /个人之间）所签订的借款合同。</p><p>（4）运输合同征税范围：不包括：管道运输合同和客运合同。</p><p>（5）财产保险合同征税范围：</p><p>①包括：财产、责任、保证、信用保险合同。</p><p>②不包括：再保险合同、人身保险合同。</p><p>（6）产权转移书据征税范围：“转移”书据包括：买卖（出售）、继承、赠与、互换、分割所签订的书据。</p><p>（7）营业账簿征税范围：仅包括：记载资金（即反映“实收资本”和“资本公积”金额增减变化的账簿）的营业账簿。提示：其他营业账簿不征收印花税。</p><p>3.不属于印花税征税范围的项目</p><p>（1）人民法院的生效法律文书，仲裁机构的仲裁文书，监察机关的监察文书。</p><p>（2）县级以上人民政府及其所属部门按照行政管理权限征收、收回或者补偿安置房地产书立的合同、协议或者行政类文书。</p><p>（3）总公司与分公司、分公司与分公司之间书立的作为执行计划使用的凭证。</p><h4 id="三计税依据和应纳税额的计算">（三）计税依据和应纳税额的计算</h4><p>1.计算公式</p><p>应纳税额=计税依据×税率</p><p>2.税率</p><p>0.05‰、0.25‰、0.3‰、0.5‰、1‰共五档。</p><p>提示：印花税的税率不要求同学们记忆，考试中会作为已知条件给出。</p><p>3.计税依据的确定</p><p>（1）合同及产权转移书据类：</p><p>①“价”和“税”的处理：应税合同及产权转移书据的计税依据，均不包括单独列明的增值税税款。</p><p>提示：如果合同、产权转移书据的价款和增值税“未分别列明”的，按价税合计金额计税贴花。</p><p>（2）营业账簿——“只征一次”。实收资本、资本公积没有变动时，不再缴纳印花税；以后年度实收资本（股本）、资本公积合计金额增加的，按照增加部分纳税。</p><p>（3）同一应税凭证载有两个以上税目事项并分别列明金额的，按照各自适用的税目税率分别计算应纳税额；未分别列明金额的，从高适用税率。</p><p>（4）未履行的应税合同、产权转移书据，已缴税不予退还。多贴税票，不予退税。</p><h4 id="四税收优惠">（四）税收优惠</h4><h5 id="法定凭证免税">1.法定凭证免税</h5><p>（1）应税凭证的副本或者抄本。</p><p>（2）农民、家庭农场、农民专业合作社、农村集体经济组织、村民委员会购买农业生产资料或者销售农产品书立的买卖合同和农业保险合同。</p><p>（3）无息或者贴息借款合同、国际金融组织向中国提供优惠贷款书立的借款合同。</p><p>（4）财产所有权人将财产赠与政府、学校、社会福利机构、慈善组织书立的产权转移书据。</p><p>（5）非营利性医疗卫生机构采购药品或者卫生材料书立的买卖合同。</p><p>（6）个人与电子商务经营者订立的电子订单。</p><p>（7）依照法律规定应当予以免税的外国驻华使馆、领事馆和国际组织驻华代表机构为获得馆舍书立的应税凭证。</p><p>（8）中国人民解放军、中国人民武装警察部队书立的应税凭证。</p><h5 id="特定情形免税">2.特定情形免税</h5><p>（1）单据免税。对运输、仓储、保管、财产保险、银行借款等，办理一项业务，既书立合同，又开立单据的，只就合同贴花。所开立的各类单据，不再贴花。</p><p>（2）军事物资运输，凡附有军事运输命令或使用专用的军事物资运费结算凭证，免纳印花税。</p><p>（3）抢险救灾物资运输，凡附有县级以上（含县级）人民政府抢险救灾物资运输证明文件的运费结算凭证，免纳印花税。</p><p>（4）企业因改制签订的产权转移书据免予贴花。证券化业务而专门设立的资金账簿暂免征收印花税。</p><p>（5）同业拆借合同免税。</p><p>（6）对个人出租、承租住房签订的租赁合同，免征印花税。对个人销售或购买住房暂免征收印花税。</p><p>（7）在融资性售后回租业务中，对承租人、出租人因出售租赁资产及购回租赁资产所签订的合同，不征收印花税。</p><p>（8）借款展期合同免税。委托代理合同免税。</p><p>（9）对与高校学生签订的高校学生公寓租赁合同，免征印花税。</p><h3 id="二环境保护税">二、环境保护税</h3><h4 id="一征税范围及纳税人">（一）征税范围及纳税人</h4><p>1.纳税人</p><p>在境内直接向环境排放应税污染物的企业事业单位和其他生产经营者为环境保护税的纳税人。</p><h4 id="二税目及应纳税额的计算">（二）税目及应纳税额的计算</h4><p>1.税目及计税规则</p><p>环境保护税采用“从量计征”方式。</p><p>提示：噪声应纳税额计算的特别规定：昼、夜均超标的环境噪声，昼、夜分别计算应纳税额，累计计征；声源一个月内超标不足15 天的，减半计算应纳税额。</p>]]></content>
      
      
      <categories>
          
          <category> 经济法基础 </category>
          
          <category> 第三章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>车船类税收法律制度</title>
      <link href="/2024/05/18/jing-ji-fa-ji-chu-3-2-che-chuan-lei-shui-shou-fa-lu-zhi-du-chen-wei/"/>
      <url>/2024/05/18/jing-ji-fa-ji-chu-3-2-che-chuan-lei-shui-shou-fa-lu-zhi-du-chen-wei/</url>
      
        <content type="html"><![CDATA[<blockquote><p>投稿自宸溦</p></blockquote><h2 id="第二节-车船类税收法律制度">第二节 车船类税收法律制度</h2><h3 id="一车船税">一、车船税</h3><h4 id="一征税范围及纳税人">（一）征税范围及纳税人</h4><p>1.征税范围</p><p>在中华人民共和国境内的车辆、船舶。具体包括：</p><p>（1）依法应当在车船登记管理部门登记的机动车辆和船舶；</p><p>（2）依法不需要在车船登记管理部门登记的在单位内部场所行驶或者作业的机动车辆和船舶。</p><p>2.纳税人及扣缴义务人</p><p>（1）纳税人为应税车辆、船舶（以下简称“车船”）的所有人或者管理人。</p><p>（2）从事机动车第三者责任强制保险业务（“交强险”）的保险机构为机动车车船税的扣缴义务人，应当在收取保险费时依法代收车船税，并出具代收税款凭证。</p><h4 id="二应税车辆船舶">（二）应税车辆、船舶</h4><p>1.六大类税目</p><p>（1）乘用车。</p><p>（2）商用车，分为客车和货车。其中货车包括半挂牵引车、三轮汽车和低速载货汽车。</p><p>（3）挂车。</p><p>（4）其他车辆，是指专用作业车和轮式专用机械车。提示：征税范围不包括拖拉机。</p><p>（5）摩托车。</p><p>（6）船舶，包括机动船舶和游艇。</p><h4 id="三应纳税额的计算">（三）应纳税额的计算</h4><p>当年应纳税额=适用年基准税额÷12×应纳税的月份数</p><h4 id="四税收优惠">（四）税收优惠</h4><p>1.免税车船</p><p>（1）捕捞、养殖渔船。</p><p>（2）军队、武装警察部队专用的车船；警用车船；悬挂应急救援专用号牌的国家综合性消防救援车辆和国家综合性消防救援船舶。</p><p>（3）依法免税的外国驻华使领馆、国际组织驻华代表机构及其有关人员的车船。</p><p>（4）对使用新能源车船（纯电动商用车、燃料电池商用车、插电式混合动力汽车），免征车船税；纯电动乘用车和燃料电池乘用车不属于车船税征税范围，不征车船税。</p><p>（5）临时入境的外国车船和香港特别行政区、澳门特别行政区、台湾地区的车船，不征收车船税。</p><p>2.对节约能源车船，减半征收车船税</p><p>符合标准的乘用车辆，指获得许可在中国境内销售的排量为 1.6 升以下（含1.6升）的燃用汽油、柴油的乘用车（含非插电式混合动力、双燃料和两用燃料乘用车）。</p><h4 id="五征收管理">（五）征收管理</h4><p>1.纳税义务发生时间</p><p>取得车船所有权或者管理权的当月。</p><p>2.纳税申报</p><p>（1）分月计算，按年申报，一次性缴纳。</p><h3 id="二船舶吨税">二、船舶吨税</h3><h4 id="一征税范围纳税人及纳税义务发生时间">（一）征税范围、纳税人及纳税义务发生时间</h4><p>（1）船舶吨税（以下简称吨税）是对自中国境外港口进入境内港口的船舶征收的一种税。</p><p>（2）纳税人为应税船舶负责人。</p><p>（3）纳税义务发生时间为应税船舶进入境内港口的当日。</p><h4 id="二免税船舶">（二）免税船舶</h4><p>（1）捕捞、养殖渔船。</p><p>（2）军队、武装警察部队专用或者征用的船舶，警用船舶。</p><p>（3）依法免税的外国驻华使领馆、国际组织驻华代表机构及其有关人员的船舶。</p><p>（4）应纳税额在人民币 50 元以下的船舶。</p><p>（5）自境外以购买、受赠、继承等方式取得船舶所有权的初次进口到港的空载船舶。</p><p>（6）吨税执照期满后 24 小时内不上下客货的船舶。</p><p>（7）非机动船舶（不包括非机动驳船）。</p><p>（8）避难、防疫隔离、修理、终止运营或者拆解，并不上下客货的船舶。</p><h4 id="三应纳税额的计算-1">（三）应纳税额的计算</h4><p>1.税率</p><p>从“量”计征，采用定额税率（元 /净吨），又分为普通税率和优惠税率。适用优惠税率的船舶包括：</p><p>（1）我国国籍的应税船舶</p><p>（2）船籍国（地区）与我国签订互惠待遇条约或协定的应税船舶</p><p>2.计税依据和计算公式</p><p>（1）计税依据为船舶“净吨位”。</p><p>（2）计算公式：</p><p>一般船舶应纳税额=净吨位×适用税率</p><p>拖船和非机动驳船应纳税额=净吨位×适用税率×50%</p>]]></content>
      
      
      <categories>
          
          <category> 经济法基础 </category>
          
          <category> 第三章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>房产土地类税收法律制度</title>
      <link href="/2024/05/18/jing-ji-fa-ji-chu-3-1-cai-chan-he-xing-wei-shui-fa-lu-zhi-du-chen-wei/"/>
      <url>/2024/05/18/jing-ji-fa-ji-chu-3-1-cai-chan-he-xing-wei-shui-fa-lu-zhi-du-chen-wei/</url>
      
        <content type="html"><![CDATA[<blockquote><p>投稿自宸溦</p></blockquote><h1 id="第三章-财产和行为税法律制度">第三章 财产和行为税法律制度</h1><h2 id="第一节-房产土地类税收法律制度">第一节 房产土地类税收法律制度</h2><h3 id="一房产税">一、房产税</h3><h4 id="一征税范围">（一）征税范围</h4><p>（1）基本征税范围：在城市、县城、建制镇和工矿区的房屋。</p><p>（2）下列不属于征税范围，不征收房产税：</p><p>①独立于房屋之外的建筑物，如围墙、烟囱、水塔、菜窖、室外游泳池等。</p><p>②农村的房屋。</p><h4 id="二纳税人">（二）纳税人</h4><p>（1）房产税的纳税人是指拥有房屋产权的单位和个人。</p><p>产权出典指产权所有人（出典人）将自己房屋的产权，在一定期限内转让（出典）给他人（承典人）使用而取得出典价款的一种融资行为。承典人支付现金或实物，在房屋出典期间取得房屋支配权，产权所有人已无权支配房屋，因此纳税人为房屋的实际占用人或使用人，即承典人。</p><h4 id="三应纳税额的计算">（三）应纳税额的计算</h4><p>自用 从价计征 房产原值一次减除 10％～30％后的余值 税率1.2％应纳税额=应税房产原值×（1-扣除比例）×1.2％</p><p>出租 从租计征不含增值税租金收入（或取得的各种经济利益）税率12％（优惠税率4％）应纳税额=（不含增值税）租金收入×12％（或 4%）</p><p>提示：</p><p>4% 优惠税率适用的情形：</p><p>（1）个人出租住房，不区分用途，按 4％的税率征收</p><p>（2）对企事业单位、社会团体以及其他组织按市场价格向个人出租用于居住的住房，减按4％的税率征收</p><p>（3）自2021年 10月1日起，对企事业单位、社会团体以及其他组织向个人、专业化规模化住房租赁企业出租住房的，减按4％的税率征收</p><p>“房产原值”即为房产原价，不得扣除任何折旧等项目。</p><p>“房产余值”是用以计算房产税的计税依据，“房产原值”扣除 10%-30%比例之后就是“房产余值”。这个比例是省级政府规定的比例，与折旧无关。</p><h3 id="二城镇土地使用税">二、城镇土地使用税</h3><h4 id="一征税范围-1">（一）征税范围</h4><p>在城市、县城、建制镇、工矿区范围内的土地。</p><p>提示：</p><p>（1）不论是属于国家所有的土地，还是集体所有的土地，都属于城镇土地使用税的征税范围</p><p>（2）与房产税类似，征税范围也不包括农村的土地</p><h4 id="二纳税人-1">（二）纳税人</h4><p>1.一般规定</p><p>在规定的征税范围内使用土地的单位和个人为纳税人，即由拥有土地使用权的单位或个人缴纳。</p><h4 id="三应纳税额的计算-1">（三）应纳税额的计算</h4><h5 id="计征方法和计算公式">1.计征方法和计算公式</h5><p>（1）从“量”计征，税率为定额税率（元 / 平方米）</p><p>（2）计算公式：</p><p>年应纳税额=实际占用应税土地面积（平方米）×适用税额</p><p>提示：上述公式计算出来的是“年”应纳税额，如果实际占用不到一年，需要换算为实际占用月份计算应纳税额。</p><h5 id="实际占用土地面积的确定按如下顺序确定">2.实际占用土地面积的确定按如下顺序确定：</h5><p>（1）凡由省级人民政府确定的单位组织测定土地面积的，以测定的土地面积为准</p><p>（2）尚未组织测定，但纳税人持有政府部门核发的土地使用证书的，以证书确定的土地面积为准</p><p>（3）尚未核发土地使用证书的，应由纳税人据实申报土地面积，并据以纳税，待核发土地使用证书后再作调整。</p><h4 id="四税收优惠">（四）税收优惠</h4><h5 id="非经营性土地免征">1.“非经营性”土地免征</h5><p>（1）国家机关、人民团体、军队自用的土地</p><p>（2）由国家财政部门拨付事业经费的单位自用的土地；（3）宗教寺庙、公园、名胜古迹自用的土地</p><p>（4）市政街道、广场、绿化地带等公共用地</p><p>（5）老年服务机构自用的土地（主要包括老年社会福利院、敬老院、养老院、老年服务中心、老年公寓、老年护理院、康复中心、托老所等）</p><h5 id="农业免征">2.“农业”免征</h5><p>直接用于农、林、牧、渔业的生产用地免征城镇土地使用税。</p><p>提示：这部分土地是指直接从事于种植、养殖、饲养的专业用地，不包括农副产品加工厂占地和从事农、林、牧、渔业生产单位的生活、办公用地。</p><p>3.免税单位与纳税单位之间无偿使用的土地</p><p>（1）免税单位无偿使用纳税单位的土地，免税</p><p>（2）纳税单位无偿使用免税单位的土地，纳税</p><h3 id="三耕地占用税">三、耕地占用税</h3><h4 id="一征税范围-2">（一）征税范围</h4><p>占用国家所有和集体所有的耕地建设建筑物、构筑物或从事其他非农业建设，属于耕地占用税的征税范围。</p><p>提示：建设直接为农业生产服务的生产设施占用农用地的，不缴纳耕地占用税。具体包括：储存农用机具和种子、苗木、木材等农业产品的仓储设施；培育、生产种子、种苗的设施；畜禽养殖设施；木材集材道、运材道；农业科研、试验、示范基地；野生动植物保护、护林、森林病虫害防治、森林防火、木材检疫的设施；专为农业生产服务的灌溉排水、供水、供电、供热、供气、通信基础设施；农业生产者从事农业生产必需的食宿和管理设施；其他直接为农业生产服务的生产设施。</p><h4 id="二纳税人-2">（二）纳税人</h4><p>1.一般规定</p><p>纳税人是在我国境内占用耕地建设建筑物、构筑物或者从事非农业建设的单位和个人。</p><h4 id="三应纳税额的计算-2">（三）应纳税额的计算</h4><p>1.计征方式</p><p>（1）计征方式：从“量”计征，按纳税人实际占用的耕地面积（平方米）；税率形式为单位税额（元/ 平方米）。</p><p>提示：耕地面积包括经批准占用及未经批准占用的面积。</p><p>（2）计算公式：</p><p>应纳税额=实际占用耕地面积（平方米）×单位税额</p><p>2.单位税额的特殊规定</p><p>（1）在人均耕地低于 0.5 亩的地区，可适当提高，提高的部分不得超过50%</p><p>（2）占用基本农田的，按 150% 征收</p><p>（3）占用非基本农田，单位税额可以适当降低，降低的部分不得超过50%。提示：耕地占用税的适用税额，由省、自治区、直辖市人民政府在规定的税额幅度内提出，报同级人民代表大会常务委员会决定，并报全国人民代表大会常务委员会和国务院备案。</p><h4 id="四税收优惠-1">（四）税收优惠</h4><p>1.“非经营”免税军事设施、学校、幼儿园、社会福利机构、医疗机构占用耕地，免征耕地占用税。</p><p>提示：学校内经营性场所、教职工住房和医院内职工住房不免征。</p><h4 id="五征收管理">（五）征收管理</h4><p>1.纳税义务发生时间收到自然资源主管部门办理占用耕地手续的书面通知的当日。</p><p>2.纳税期限自纳税义务发生之日起 30 日内申报缴纳耕地占用税。</p><p>3.纳税地点耕地或其他农用地所在地。</p><h3 id="四契税">四、契税</h3><h4 id="一纳税人和征税范围">（一）纳税人和征税范围</h4><p>契税是以在中华人民共和国境内转移土地、房屋权属为征税对象，向产权承受人征收的一种财产税。</p><p>1.纳税人</p><p>在我国境内转移土地、房屋权属，承受的单位和个人为契税的纳税人。</p><p>提示：契税的纳税人非常特殊，是承受权属的一方，也就是俗称的“买方”。</p><p>2.不属于征税范围的情形</p><p>（1）土地、房屋典当、抵押以及出租等行为</p><p>（2）土地承包经营权和土地经营权转移</p><h4 id="二应纳税额的计算">（二）应纳税额的计算</h4><p>1.计算公式</p><p>应纳税额=计税依据×税率</p><p>提示：契税实行 3% ～5%的幅度比例税率。具体税率由省、自治区、直辖市人民政府在幅度内提出，报同级人大常委会决定，并报全国人大常委会和国务院备案。</p><h4 id="三税收优惠">（三）税收优惠</h4><p>1.“非经营自用”——免税</p><p>（1）国家机关、事业单位、社会团体、军事单位承受土地、房屋权属用于办公、教学、医疗、科研、军事设施</p><p>（2）非营利性的学校、医疗机构、社会福利机构承受土地、房屋权属用于办公、教学、医疗、科研、养老、救助。</p><p>提示：上述两项“非经营自用”仅限于上述单位在其办公、教学、医疗、科研、军事的范围内直接用于该用途的土地和房屋。</p><p>2.农业生产——免税承受荒山、荒地、荒滩土地使用权用于农、林、牧、渔业生产。</p><p>3.“婚姻家庭”——免税</p><p>（1）婚姻关系存续期间夫妻之间变更土地、房屋权属；夫妻因离婚分割共同财产发生土地、房屋权属变更的，也免征契税。</p><p>（2）法定继承人通过继承承受土地、房屋权属。</p><p>4.“外交”——免税</p><p>依照规定应予以免税的外国驻华使馆、领事馆和国际组织驻华代表机构承受土地、房屋权属；外国银行分行改制为外商独资银行，改制后的外商独资银行承受原外国银行分行的房屋权属的，免征契税。</p><p>5.地方酌定减免税情形</p><p>省、自治区、直辖市可以决定对下列情形免征或者减征契税：</p><p>（1）因土地、房屋被县级以上人民政府征收、征用，重新承受土地、房屋权属</p><p>（2）因不可抗力灭失住房，重新承受住房权属。</p><p>提示：经批准减征、免征契税的纳税人，改变用途，或者有其他不再属于减免税情形的，应当补缴已经减免的税款。</p>]]></content>
      
      
      <categories>
          
          <category> 经济法基础 </category>
          
          <category> 第三章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>个人所得税法律制度</title>
      <link href="/2024/05/18/jing-ji-fa-ji-chu-2-2-ge-ren-suo-de-shui-fa-lu-zhi-du-chen-wei/"/>
      <url>/2024/05/18/jing-ji-fa-ji-chu-2-2-ge-ren-suo-de-shui-fa-lu-zhi-du-chen-wei/</url>
      
        <content type="html"><![CDATA[<blockquote><p>投稿自宸溦</p></blockquote><h2 id="第二节-个人所得税法律制度">第二节 个人所得税法律制度</h2><h3 id="一纳税人和征税对象">一、纳税人和征税对象</h3><h4 id="一纳税人">（一）纳税人</h4><p>包括中国公民（含香港、澳门、台湾同胞）、个体工商户、个人独资企业投资者和合伙企业自然人合伙人等。</p><h4 id="二纳税人的分类及纳税义务">（二）纳税人的分类及纳税义务</h4><p>依据在我国境内有无住所和居住时间两个标准，分为居民个人和非居民个人。</p><p>提示：</p><p>（1）住所，指因户籍、家庭、经济利益关系而在中国境内习惯性居住。</p><p>（2）纳税年度：公历 1 月1日起至 12 月31日止。</p><h4 id="三所得来源地的确定">（三）所得来源地的确定</h4><p>在确定“非居民个人”的纳税义务时，需要先确定哪些收入属于“来源于我国境内的所得”，再对这部分来源于我国境内的所得征收个人所得税。</p><h3 id="二征税项目税率及纳税方式概览">二、征税项目、税率及纳税方式概览</h3><p>我国现行个人所得税共有 1 个综合所得项目（3% ～45%七级超额累进税率）和 5 个分类所得项目，其中“综合所得”中又包含 4个子项目。</p><h3 id="三综合所得征税项目">三、综合所得——征税项目</h3><h4 id="一工资薪金所得">（一）工资、薪金所得</h4><p>包括</p><p>因任职或者受雇而取得的各类所得：工资、薪金、奖金、年终加薪、劳动分红、津贴、补贴以及与任职或者受雇有关的其他所得</p><p>不包括</p><p>（1）独生子女补贴</p><p>（2）托儿补助费</p><p>（3）差旅费津贴、误餐补助</p><p>（4）执行公务员工资制度未纳入基本工资总额的补贴、津贴差额和家属成员的副食补贴</p><h4 id="二劳务报酬所得">（二）劳务报酬所得</h4><p>指个人从事劳务取得的所得。</p><h4 id="三稿酬所得">（三）稿酬所得</h4><p>（1）指个人因其作品以图书、报刊形式出版、发表而取得的所得。</p><p>（2）作者去世后，财产继承人取得的遗作稿酬，也应按“稿酬所得”征收个人所得税。</p><h4 id="四特许权使用费所得">（四）特许权使用费所得</h4><p>指个人提供专利权、商标权、著作权、非专利技术以及其他特许权的使用权取得的所得；提供著作权的使用权取得的所得，不包括稿酬所得。</p><p>提示：下列特殊项目属于“特许权使用费所得”：</p><p>（1）文字作品手稿原件或复印件的拍卖所得</p><p>（2）个人取得的专利赔偿所得</p><p>（3）剧本使用费：剧本作者从电影、电视剧的制作单位取得的剧本使用费不区分是否从本单位取得，一律按特许权使用费计入所得。</p><h3 id="四综合所得应纳税额计算方式概述">四、综合所得应纳税额计算方式概述</h3><p>1.年中应扣缴税额——预扣预缴</p><p>支付所得的一方即为“扣缴义务人”。扣缴义务人在向纳税人支付各项所得时，要先“预扣预缴”个人所得税。</p><p>2.年度应纳税额——汇算清缴</p><p>纳税年度结束后，应于次年 3 月 1 日至 6 月30日办理综合所得年度汇算清缴（视情况办理），税款多退少补。</p><h3 id="五综合所得全年应纳税额的计算">五、综合所得——全年应纳税额的计算</h3><h4 id="一计算公式">（一）计算公式</h4><p>应纳税额=应纳税所得额×适用税率-速算扣除数</p><p>应纳税所得额=收入额-费用 6万元-专项扣除-专项附加扣除-依法确定的其他扣除</p><h4 id="二适用税率及速算扣除数">（二）适用税率及速算扣除数</h4><p>综合所得适用 3％～ 45％的七级超额累进税率。</p><p>提示：在考试时，个人所得税的税率表会作为已知条件给出。</p><h3 id="六综合所得预扣预缴税额的计算">六、综合所得——预扣预缴税额的计算</h3><h4 id="一工资薪金所得预扣预缴税额的计算累计预扣法">（一）工资、薪金所得预扣预缴税额的计算——“累计预扣法”</h4><p>“累计预扣法”的思路——“轧差”。即先计算截至本月末的所有月份累计应缴纳的税额，减去之前月份已经预缴过的部分，差额就是当月应预扣预缴的税额。</p><p>提示：接受全日制学历教育的学生因实习取得劳务报酬所得，扣缴义务人也比照此“累计预扣法”计算并扣缴税款。</p><p>1.计算步骤</p><p>累计预扣预缴应纳税所得额=累计收入-累计免税收入-累计减除费用-累计专项扣除-累计专项附加扣除-累计依法确定的其他扣除</p><p>本期应预扣预缴税额=（累计预扣预缴应纳税所得额×预扣率-速算扣除数）-累计已预扣预缴税额</p><p>2.“累计减除费用”的具体规定</p><p>（1）一般规定：累计减除费用=5000元 /月×纳税人当年截至本月在本单位的任职受雇月份数</p><p>（2）对一个纳税年度内首次取得工资、薪金所得的居民个人：</p><p>累计减除费用=5000元 / 月×纳税人当年截至本月的累计月份数</p><p>提示：“首次取得工资、薪金所得的居民个人”，是指自纳税年度首月起至新入职时未取得工资、薪金所得或者未按照累计预扣法预扣预缴过连续性劳务报酬所得个人所得税的居民个人。</p><p>（3）对于上一完整纳税年度内均在同一单位预扣预缴工资、薪金所得个人所得税，且全年累计工资、薪金收入（含奖金，不扣任何费用）不超过6 万元的居民个人：</p><p>累计减除费用（从 1 月起）=60000元</p><p>即：在纳税人累计收入不超过 6 万元的月份，暂不预扣预缴个人所得税。</p><p>3.“累计专项附加扣除”的确定</p><p>“累计专项附加扣除”为该员工在本单位截止当前月份符合政策条件的扣除金额。</p><h4 id="二劳务报酬所得稿酬所得特许权使用费所得预扣预缴税额的计算">（二）劳务报酬所得、稿酬所得、特许权使用费所得预扣预缴税额的计算</h4><p>1.扣缴方式</p><p>扣缴义务人向居民个人支付劳务报酬所得、稿酬所得、特许权使用费所得，按次或者按月预扣预缴个人所得税。</p><p>其中，“一次收入”的确定方式：</p><p>（1）属于一次性收入的，以取得该项收入为一次。</p><p>例如：小陈应邀开展一场讲座，取得讲座收入。</p><p>（2）属于同一项目连续性收入的，以一个月内取得的收入为一次。</p><p>例如：小夏在某杂志上连载漫画，每周更新一次，每周支付一次报酬，以一个月取得的收入合计为一次。</p><p>2.应纳税所得额的确定</p><p>提示：</p><p>（1）劳务报酬、稿酬、特许权使用费所得的费用减除方法，在预扣预缴时与计算年度应纳税额时的方法不一致，一定要注意辨析，不要混淆。</p><p>（2）转让专利权等无形资产取得的收入属于特许权使用费所得，预扣预缴时可减除的费用仍然为800 元或收入的 20%，与无形资产净值无关，无形资产净值不可减除。</p><p>3.预扣预缴税额的计算</p><p>（1）劳动报酬所得。</p><p>应预扣预缴税额=预扣预缴应纳税所得额×预扣率-速算扣除数</p><p>提示：其中预扣率为 20％～ 40％的 3级超额累进预扣率。在题目中会作为已知条件给出。</p><h3 id="七居民个人综合所得综合所得中的特殊计税规定">七、居民个人综合所得——综合所得中的特殊计税规定</h3><h4 id="一个人取得全年一次性奖金的征税规定">（一）个人取得全年一次性奖金的征税规定</h4><p>在 2027 年 12 月31日前，不并入当年综合所得，以全年一次性奖金收入除以12个月得到的数额，按照综合所得税率表（月度）确定适用税率和速算扣除数，单独计算纳税。</p><p>计算公式为：</p><p>应纳税额=全年一次性奖金收入×适用税率-速算扣除数</p><h4 id="二解除劳动关系一次性补偿收入">（二）解除劳动关系一次性补偿收入</h4><p>解除劳动关系取得的一次性补偿收入，在当地上年职工平均工资 3倍数额以内的部分，免征个人所得税，超出的部分，不并入当年综合所得，单独适用综合所得税率表，计算纳税。</p><h4 id="三离退休所得年金提前退休所得与内部退养">（三）离退休所得、年金、提前退休所得与内部退养</h4><p>离退休再任职收入、在退休工资之外从原单位取得补贴、奖金、实物：按“工资、薪金”缴纳个人所得税</p><h4 id="四从任职单位取得的其他形式所得">（四）从任职单位取得的其他形式所得</h4><h5 id="超标的三险一金及其他保险按工资薪金纳税">1.超标的“三险一金”及其他保险——按“工资、薪金”纳税</h5><p>（1）超标缴纳的“三险一金”，超过部分应并入个人当期的工资、薪金收入，计征个人所得税。</p><p>（2）企业为员工支付的各项免税项目之外的保险金，应在企业向保险公司缴付时并入员工当期的工资，按工资、薪金所得计征个人所得税，税款由企业负责代扣代缴。</p><h5 id="公务交通通信补贴收入">2.公务交通、通信补贴收入</h5><p>个人从单位取得公务性质的交通、通信补贴收入，在扣除一定标准的公务费用后，按工资、薪金所得计征个人所得税。</p><h5 id="单位低价向职工售房">3.单位低价向职工售房</h5><p>单位按低于购置或建造成本价格出售住房给职工，职工因此而少支出的差价部分，不并入当年综合所得。以差价收入除以12个月得到的数额，按照月度税率表确定适用税率和速算扣除数，单独计算纳税。</p><h3 id="八非居民个人取得工资薪金劳务报酬稿酬特许权使用费所得">八、非居民个人取得工资薪金、劳务报酬、稿酬、特许权使用费所得</h3><p>非居民个人取得工资薪金、劳务报酬、稿酬、特许权使用费无需汇总，分别按月或按次缴纳个人所得税，因此对于非居民个人也没有“综合所得”的概念。</p><p>计算公式</p><p>应纳税额=应纳税所得额×税率-速算扣除数</p><h3 id="九经营所得">九、经营所得</h3><h4 id="一范围">（一）范围</h4><p>基本范围包括：</p><p>（1）个体工商户从事生产、经营活动取得的所得</p><p>（2）境内注册的个人独资企业、合伙企业的个人合伙人取得的生产、经营所得</p><p>（3）个人依法从事下列经营活动取得的所得：</p><p>①依法从事办学、医疗、咨询以及其他有偿服务活动取得的所得</p><p>②对企业、事业单位承包经营、承租经营以及转包、转租取得的所得</p><h4 id="二应纳税所得额的确定">（二）应纳税所得额的确定</h4><p>1.一般情形——查账征收</p><p>应纳税所得额=收入总额-成本-费用-损失-亏损弥补</p><p>提示：个人所得税中经营所得“应纳税所得额”的计算方法，与企业所得税中“应纳税所得额”的计算方法原理基本一致。</p><h4 id="三个体工商户经营所得应纳税额的计算">（三）个体工商户经营所得应纳税额的计算</h4><p>1.费用减除、专项扣除和专项附加扣除</p><p>取得经营所得的个人，没有综合所得的，计算其每一纳税年度的应纳税所得额时，应当减除费用6万元、专项扣除、专项附加扣除以及依法确定的其他扣除。专项附加扣除在办理汇算清缴时减除。</p><p>2.应纳税额的计算</p><p>（1）按年计征。计算公式：</p><p>每个纳税年度应纳税额=应纳税所得额×适用税率-速算扣除数</p><p>其中：经营所得适用 5% ～ 35% 的五级超额累进税率。</p><p>（2）自2023 年 1月 1 日至 2027 年 12月31日，对个体工商户经营所得年应纳税所得额不超过 200万元的部分，在现行优惠政策基础上，再减半征收个人所得税。</p><p>提示：个体工商户不论查账征收或核定征收，均可享受此优惠。</p><h3 id="十利息股息红利所得">十、利息、股息、红利所得</h3><h4 id="一范围-1">（一）范围</h4><p>1.概念</p><p>指个人拥有债权、股权而取得的利息、股息、红利所得。</p><p>2.免税情形</p><p>（1）国债、国家发行的金融债券利息免税。</p><p>（2）储蓄存款利息所得暂免征收。</p><p>提示：个人取得储蓄存款利息所得暂免征收个人所得税，但企业取得存款利息收入需要征收企业所得税，勿混淆。</p><h4 id="二应纳税额的计算">（二）应纳税额的计算</h4><p>（1）按次计征，以支付利息、股息、红利时取得的收入为一次。</p><p>（2）计算公式及适用税率：</p><p>应纳税额=应纳税所得额×适用税率=每次收入×适用税率（20%）</p><h3 id="十一财产租赁所得">十一、财产租赁所得</h3><h4 id="一范围-2">（一）范围</h4><p>指个人出租不动产、机器设备、车船以及其他财产取得的所得。部分特殊项目规定如下：</p><p>（1）个人取得的房屋转租收入，属于“财产租赁所得”项目。</p><p>（2）房地产开发企业以优惠价格出售其商店给购买者个人，购买者个人在一定期限内必须将购买的商店无偿提供给房地产开发企业对外出租使用。对购买者个人少支出的购房价款，应视同个人财产租赁所得，按照“财产租赁所得”项目征收个人所得税。</p><h4 id="二应纳税额的计算-1">（二）应纳税额的计算</h4><h5 id="按次计征">1.按次计征</h5><p>以一个月内取得的收入为一次。</p><h5 id="计算公式">2.计算公式</h5><p>应按税额=应纳税所得额×适用税率</p><h5 id="税率">3.税率</h5><p>（1）一般情形：比例税率 20%。</p><p>（2）个人出租住房取得的所得暂减按 10% 的税率征收。</p><h5 id="应纳税所得额的确定">4.应纳税所得额的确定</h5><p>（1）每次（月）收入不超过 4 000元的：应纳税所得额=［每次（月）收入额-允许扣除的税费-修缮费用（800元为限）］-800 元（2）每次（月）收入在 4 000元以上的：应纳税所得额=［每次（月）收入额-允许扣除的税费-修缮费用（800元为限）］×（1-20%）其中：</p><p>①允许扣除的税费：包括出租房屋时缴纳的城市维护建设税、教育费附加以及房产税、印花税等相关税费。</p><p>提示：个人出租房屋的收入额应为不含增值税的收入，所以计算应纳税所得额时可扣除的税费自然也不包括增值税。</p><p>②修缮费用：必须是由纳税人负担且实际开支的修缮费用，每次的扣除额以 800元为限，在一个月中扣除不完的，可以向以后期间结转扣除。</p><h3 id="十二财产转让所得">十二、财产转让所得</h3><h4 id="一税目所包含的具体项目">（一）税目所包含的具体项目</h4><p>1.基本规定</p><p>指个人转让有价证券、股权、合伙企业中的财产份额、不动产、机器设备、车船以及其他财产取得的所得。</p><p>2.属于财产转让所得的特殊项目</p><p>（1）个人通过招标、竞拍或其他方式购置债权以后，通过相关司法或行政程序主张债权而取得的所得，按照“财产转让所得”项目征税。</p><p>（2）个人收购网络虚拟货币，加价后向他人出售的所得，按照“财产转让所得”项目征税。</p><p>（3）以非货币性资产投资，属于个人转让非货币性资产和投资同时发生，对个人转让非货币性资产的所得，按“财产转让所得”项目征税。</p><h4 id="二应纳税额的计算-2">（二）应纳税额的计算</h4><p>（1）按次计征。</p><p>（2）计算公式：</p><p>应纳税额=应纳税所得额×税率（20%）</p><p>应纳税所得额=转让财产的收入额-财产原值-合理费用</p><p>合理费用是指卖出财产时按照规定支付的有关税费。转让限售股过程中发生合理费用包括印花税、佣金、过户费等与交易相关的税费。</p><p>（3）个人转让房屋相关规定：</p><p>①应税收入不含增值税，转让所得时可扣除的税费不包括本次转让缴纳的增值税。</p><p>②个人转让自用 5年以上、唯一家庭生活用房取得的所得，暂免征收个人所得税。</p><h3 id="十三偶然所得">十三、偶然所得</h3><h4 id="一税目所包含的具体项目-1">（一）税目所包含的具体项目</h4><p>指个人得奖、中奖、中彩以及其他偶然性质的所得。</p><h4 id="二应纳税额计算">（二）应纳税额计算</h4><p>（1）按次计征。</p><p>（2）计算公式：</p><p>应纳税额=应纳税所得额×适用税率（20%）。</p><p>（3）应纳税所得额：以“每次收入”为应纳税所得额，不扣减任何费用。</p>]]></content>
      
      
      <categories>
          
          <category> 经济法基础 </category>
          
          <category> 第二章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>企业所得税法律制度</title>
      <link href="/2024/05/18/jing-ji-fa-ji-chu-2-1-qi-ye-suo-de-shui-fa-lu-zhi-du-chen-wei/"/>
      <url>/2024/05/18/jing-ji-fa-ji-chu-2-1-qi-ye-suo-de-shui-fa-lu-zhi-du-chen-wei/</url>
      
        <content type="html"><![CDATA[<blockquote><p>投稿自宸溦</p></blockquote><h1 id="第二章-所得税法律制度">第二章 所得税法律制度</h1><h2 id="第一节-企业所得税法律制度">第一节 企业所得税法律制度</h2><h3 id="一纳税人">一、纳税人</h3><p>在中华人民共和国境内，企业和其他取得收入的组织（以下统称“企业”）为企业所得税的纳税人。具体包括：各类企业、事业单位、社会团体、民办非企业单位和从事经营活动的其他组织。</p><p>提示：个体工商户、个人独资企业、合伙企业不属于企业所得税纳税人，不缴纳企业所得税。</p><h3 id="二征税对象及税率">二、征税对象及税率</h3><h4 id="一纳税人的分类和对应的征税对象及税率">（一）纳税人的分类和对应的征税对象及税率</h4><p>我国采用收入来源地管辖权和居民管辖权相结合的双重管辖权，把企业分为居民企业和非居民企业：</p><p>居民企业</p><p>（1）依法在中国境内成立的企业</p><p>（2）依照外国（地区）法律成立但实际管理机构在中国境内的企业</p><p>征税对象：来源于中国境内、境外的所得</p><p>税率：25％</p><p>非居民企业（依照外国法律成立，且实际管理机构不在中国境内）</p><p>（1）在中国境内设立机构、场所的来源于中国境内的所得和</p><p>征税对象：来源于境外但与该机构、场所有实际联系的所得</p><p>税率：25%</p><p>（2）在中国境内未设立机构、场所的，或虽设立机构、场所取得的所得与其机构、场所没有实际联系的</p><p>征税对象：仅就来源于中国境内的所得</p><p>税率：20％（实际减按 10%）</p><h4 id="二境内外所得的界定">（二）境内外所得的界定</h4><p>销售货物、提供劳务来源交易活动或劳务发生地</p><p>股息、红利等权益性投资来源分配所得的企业所在地</p><p>利息、租金、特许权使用费来源负担、支付所得的企业或者机构、场所所在地、个人的住所地</p><h3 id="三应纳税额与应纳税所得额的计算公式">三、应纳税额与应纳税所得额的计算公式</h3><h4 id="应纳税额的计算公式">1.应纳税额的计算公式</h4><p>应纳税额=应纳税所得额×适用税率-减免 / 抵免税额</p><p>（1）应纳税所得额可理解为按税法规定计算出的“税法口径的利润”，基于“税法口径的利润”再计算出应纳税额。</p><p>（2）既然是“税法口径的利润”，可以严格按照税法规定，将税法口径收入减去税法上允许扣除的项目，得到“税法口径的利润”，这叫“直接法”；也可以从“会计利润”出发，针对各项会计与税法的差异进行调整，得到调整后的“税法口径的利润”，这就是“间接法”。</p><h4 id="应纳税所得额的计算公式">2.应纳税所得额的计算公式</h4><p>应纳税所得额是企业所得税的计税依据，可采用“直接法”及“间接法”计算：</p><p>（1）直接法：应纳税所得额=收入总额-不征税收入-免税收入-各项扣除-以前年度亏损</p><p>（2）间接法：应纳税所得额=会计利润+纳税调整增加项-纳税调整减少项</p><h3 id="四应纳税所得额收入总额和应税收入">四、应纳税所得额——收入总额和应税收入</h3><h4 id="一收入的形式和范围">（一）收入的形式和范围</h4><p>（1）收入总额包括以货币形式和非货币形式从各种来源取得的收入。</p><p>（2）各类收入的具体范围：</p><p>销售货物收入：销售各类货物取得的收入</p><p>提供劳务收入：提供各类服务和劳务取得的收入</p><p>股息、红利等权益性投资收益：因权益性投资从被投资方取得的收入</p><p>利息收入：存款利息、贷款利息、债券利息、欠款利息等收入</p><p>租金收入：提供固定资产、包装物或者其他有形资产（包括房产）的使用权取得的收入</p><p>特许权使用费收入：提供专利权、非专利技术、商标权、著作权以及其他特许权的使用权取得的收入</p><p>转让财产收入：转让固定资产、生物资产、无形资产、股权、债权等财产的所有权取得的收入</p><p>接受捐赠收入：接受的来自其他企业、组织或者个人无偿给予的货币性资产、非货币性资产</p><p>其他收入：企业资产溢余收入、逾期未退包装物押金收入、确实无法偿付的应付款项、已作坏账损失处理后又收回的应收款项、债务重组收入、补贴收入、违约金收入、汇兑收益等</p><p>视同销售收入：企业发生非货币性资产交换，以及将货物、财产、劳务用于捐赠、偿债、赞助、集资、广告、样品、职工福利或者利润分配等用途的，应当视同销售货物、转让财产或者提供劳务</p><p>问题：企业所得税的收入中是否包含增值税？</p><p>答：企业所得税中的收入金额为不含增值税金额，因为增值税为价外税，收取后不会计入企业的收入，而计入资产负债表中的“应交税费——应交增值税”科目。</p><h4 id="二各类收入的具体规定">（二）各类收入的具体规定</h4><p>1.特殊销售方式下收入的确定</p><p>商业折扣 为促进商品销售而在商品价格上给予的价格扣除按照扣除商业折扣后的金额确定</p><p>现金折扣 为鼓励在规定的期限内及早付款（偿还货款）而提供的债务扣除按扣除现金折扣前的金额确定</p><p>销售折让和销售退回因售出商品的质量不合格等原因而在售价上给予的减让或发生的退货在发生当期冲减当期销售收入</p><p>买一赠一 以买一赠一等方式组合销售本企业商品将总的销售金额按各项商品的公允价值的比例来分摊确认各项的销售收入</p><p>2.各类收入确认的时点</p><p>提示：关注利息、租金、特许权使用费是按照“合同约定应付”日期；而捐赠收入是按照“实际收到”日期。</p><h3 id="五应纳税所得额不征税收入与免税收入">五、应纳税所得额——不征税收入与免税收入</h3><h4 id="一不征税收入">（一）不征税收入</h4><p>“财政拨款”各级人民政府对纳入预算管理的事业单位、社会团体等组织拨付的财政资金</p><p>“政府收费”依法收取并纳入财政管理的行政事业性收费、政府性基金</p><p>“专项用途财政资金”企业从县级以上人民政府无偿取得的，由政府部门指定专门用途，并按照规定进行管理的，可作为企业的不征税收入进行处理</p><p>“社保基金”社保基金管理机构运用社保基金取得的投资收入；社保基金取得的直接股权和股权基金投资收益</p><h4 id="二免税收入">（二）免税收入</h4><p>1.下列列举范围内的债券利息收入</p><p>（1）国债利息收入。</p><p>（2）符合条件的地方政府债券利息收入。</p><p>提示：对企业取得的 2012年及以后年度发行的地方政府债券利息收入，免征企业所得税。</p><p>（3）境外机构投资境内债券市场取得的债券利息收入。</p><p>提示：对企业投资者持有 2019 ～ 2023年发行的铁路债券取得的利息收入，减半征收企业所得税。</p><p>（4）外国政府、国际金融组织向中国政府和居民企业提供优惠贷款取得的利息收入。</p><p>2.符合条件的股息、红利等权益性投资收益</p><p>3.符合条件的非营利组织的收入</p><p>对非营利组织从事非营利性活动取得的收入给予免税。</p><p>提示：非营利组织从事营利性活动取得的收入，照常征税。</p><p>问题：不征税收入和免税收入有什么区别？</p><p>答：不征税收入，不属于企业所得税的征税范围，同时不征税收入形成的对应的支出，也不允许在税前扣除。免税收入，属于征税范围内，但在税法上给予税收优惠，收入无需交税，同时对应的支出也允许扣除。</p><h3 id="六应纳税所得额扣除项目及其标准">六、应纳税所得额——扣除项目及其标准</h3><p>企业实际发生的与取得收入有关的、合理的支出，包括成本、费用、税金、损失和其他支出，准予在计算应纳税所得额时扣除。</p><h4 id="一工资工薪支出及人工相关费用">（一）工资、工薪支出及人工相关费用</h4><h5 id="工资薪金支出">1.工资、薪金支出</h5><p>合理的工资、薪金支出准予扣除。工资、薪金，是指企业每一纳税年度支付给本企业任职或受雇的员工的，所有现金形式或者非现金形式的劳动报酬。</p><p>提示：各类奖金、津贴、补贴、绩效、加班费等与员工任职受雇有关的都属于工资、薪金支出。</p><h5 id="职工福利费工会经费职工教育经费三项经费">2.职工福利费、工会经费、职工教育经费（“三项经费”）</h5><p>扣除方式：限额扣除。</p><p>提示：“三项经费”的扣除限额一定要分别计算，千万不可将三项经费合并在一起计算。</p><h5 id="社会保险费和其他保险费">3.社会保险费和其他保险费</h5><p>提示：补充养老保险、补充医疗保险，仅限于为公司全体员工缴纳的才可以扣除。为部分员工，例如“为部分高层管理人员缴纳的”则不允许税前扣除。</p><h5 id="其他">4.其他</h5><p>（1）党组织工作经费：不超过工资薪金总额 1％的部分，据实扣除。</p><p>（2）劳动保护费准予据实扣除。</p><h4 id="二业务招待费">（二）业务招待费</h4><p>扣除方式：限额扣除。</p><p>1.一般情形下的扣除标准和限额</p><p>下列两个标准取孰低，作为税前扣除的限额：</p><p>（1）实际发生额的 60％</p><p>（2）不得超过当年销售（营业）收入的 5‰。其中“销售（营业）收入”=主营业务收入 + 其他业务收入 + 视同销售收入</p><p>提示：从事股权投资业务的企业有特殊规定，销售（营业）收入=主营业务收入+其他业务收入+视同销售收入+“投资收益”（即从被投资企业所分配的股息、红利以及股权转让收入）。</p><p>2.筹建期业务招待费的扣除按实际发生额的 60％计入筹办费在税前扣除。</p><h4 id="三广告费和业务宣传费">（三）广告费和业务宣传费</h4><p>扣除方式：限额扣除。</p><p>计算限额的基数仍然是“销售（营业）收入”，其范围同业务招待费部分。</p><p>提示：“广告费”“业务宣传费”金额如果是分别给出的，那就必须合并计算扣除限额。</p><h4 id="四公益性捐赠">（四）公益性捐赠</h4><p>扣除方式：一般公益性捐赠限额扣除；目标脱贫地区公益性捐赠据实扣除。</p><h5 id="公益性捐赠的界定">1.公益性捐赠的界定</h5><p>公益性捐赠是指企业通过公益性社会组织或者县级以上人民政府及其部门，用于符合法律规定的慈善活动、公益事业的捐赠。</p><p>提示：一般情况下，未通过规定单位，直接向受赠人的捐赠不允许扣除。</p><h5 id="扣除标准">2.扣除标准</h5><p>一般公益性捐赠 限额扣除：</p><p>（1）不超过年度利润总额 12% 的部分，准予扣除</p><p>（2）超过年度利润总额 12%的部分，准予向在未来三年内结转扣除。提示：年度利润总额，指企业按照会计准则核算的“会计利润”</p><p>目标脱贫地区公益性捐赠 据实扣除：</p><p>通过公益性社会组织或者县级（含县级）以上人民政府及其组成部门，用于目标脱贫地区的扶贫捐赠支出，准予据实扣除。</p><p>提示：仍然需要符合一般公益性捐赠中“通过规定单位”的规定</p><h5 id="捐赠支出金额的确定">3.捐赠支出金额的确定</h5><p>（1）捐赠住房作为廉租房，符合公益性捐赠规定的，同样适用上述扣除政策</p><p>（2）在非货币性资产捐赠过程中发生的运费、保险费、人工费用等相关支出，凡包含在公益捐赠票据金额中的，允许按上述规定扣除；未包含在票据金额中的，作为企业的相关费用在税前扣除</p><h4 id="五租赁费用借款和利息费用">（五）租赁费用、借款和利息费用</h4><h5 id="租赁费用">1.租赁费用</h5><p>经营租赁方式 按照租赁期限均匀扣除</p><p>融资租赁方式构成融资租入固定资产价值的部分应当提取折旧费用分期扣除</p><h5 id="借款费用">2.借款费用</h5><p>合理的不需要资本化的借款费用 准予在当期扣除</p><p>符合资本化条件的借款费用应作为资本性支出计入有关资产的成本；不得在当期扣除</p><h5 id="利息支出">3.利息支出</h5><p>（1）借款利息支出向金融企业借款的利息支出据实扣除</p><p>（2）企业经批准发行债券的利息支出据实扣除</p><p>（3）金融企业各项存款利息支出和同业拆借利息支出据实扣除</p><p>（4）股东未尽出资义务时，对应的借款利息不予扣除。</p><p>投资者在规定期限内未缴足其应缴资本额的，该企业对外借款所发生的利息，相当于投资者实缴资本额与在规定期限内应缴资本额的差额应计付的利息，应由投资者负担，不得扣除</p><h4 id="六其他扣除项目">（六）其他扣除项目</h4><h5 id="税金">1.税金</h5><p>企业所得税和允许抵扣或缴纳的增值税不可扣除，其余各项税金及其附加均可按规定扣除。</p><p>提示：增值税是价外税，所以购进货物、服务等时所支付的允许抵扣的增值税（即进项税），也不会影响企业的会计利润或应纳税所得额，而应计入“应交税费——应交增值税”科目核算。</p><h5 id="损失">2.损失</h5><p>（1）扣除范围：生产经营活动中发生的、与取得应税收入有关的各类资产损失，包括固定资产和存货的盘亏、毁损、报废损失、转让财产损失、呆账、坏账损失、自然灾害等不可抗力因素造成的损失等。提示：企业因违法、违规、犯罪等行为造成的罚金、罚款、没收、拆除等造成的损失不得扣除。</p><p>（2）扣除金额：减除责任人赔偿和保险赔款后的余额。</p><p>（3）追补扣除：以前年度发生的资产损失未能在当年税前扣除的，可按规定向税务机关说明并进行专项申报扣除。其中，属于实际资产损失的，准予追补至该项损失发生年度扣除，追补期限一般不得超过5 年。</p><p>（4）已经作为损失处理的资产，在以后年度又全部收回或者部分收回时，应计入当期收入。</p><h5 id="汇兑损失">3.汇兑损失</h5><p>准予扣除。</p><h5 id="资产的相关费用">4.资产的相关费用</h5><p>折旧摊销、转让各类固定资产发生的费用，允许扣除。</p><h5 id="专项资金">5.专项资金</h5><p>按规定提取的用于环境保护、生态恢复等方面的专项资金，准予扣除。提取后改变用途的，不得扣除。</p><h5 id="总分机构分摊的费用">6.总分机构分摊的费用</h5><p>非居民企业在中国境内设立的机构、场所，就其中国境外总机构发生的与该机构、场所生产经营有关的费用，能够提供费用汇集范围、定额、分配依据和方法等证明文件，并合理分摊的，准予扣除。</p><h5 id="手续费及佣金支出">7.手续费及佣金支出</h5><p>提示：企业为发行权益性证券支付给有关证券承销机构的手续费及佣金不得在税前扣除。</p><h5 id="其他准予扣除项目">8.其他准予扣除项目</h5><p>如会员费、合理的会议费、差旅费、违约金、诉讼费用、劳动保护费等。</p><h3 id="七应纳税所得额不得扣除的项目">七、应纳税所得额——不得扣除的项目</h3><p>“所得税及税后分配”企业所得税税款向投资者支付的股息、红利等权益性投资收益款</p><p>“处罚”税收滞纳金罚金、罚款和被没收财物的损失提示：包括没收违法所得、没收财产、拆除违章建筑等造成的损失</p><p>“赞助赠与”超标的捐赠支出赞助支出（与生产经营活动无关的各种非广告性质支出）</p><p>“准备金”未经核定的准备金支出（各类资产减值准备、风险准备等准备金支出）</p><p>“利、租、特、管”非银行企业内营业机构之间支付的利息企业内营业机构之间支付的租金和特许权使用费企业之间支付的管理费</p><p>“无关”与取得收入无关的其他支出</p><h3 id="八应纳税所得额亏损弥补">八、应纳税所得额——亏损弥补</h3><h4 id="一税务上亏损的概念">（一）税务上“亏损”的概念</h4><p>税务上亏损的概念，即为“税法口径利润”——应纳税所得额计算为负数时的金额（取绝对值）。</p><p>“收入总额 - 不征税收入 - 免税收入 -各项扣除”后计算出的结果，若大于零，为“应纳税所得额”；若小于零，则为税务口径的“亏损”。</p><h4 id="二亏损弥补的规定">（二）亏损弥补的规定</h4><h5 id="结转弥补年限">1.结转弥补年限</h5><p>一般企业最长不得超过 5 年</p><h5 id="境外亏损不得境内弥补">2.境外亏损不得境内弥补</h5><p>企业境外营业机构的亏损不得抵减境内营业机构的盈利。</p><h3 id="九资产的税务处理">九、资产的税务处理</h3><h4 id="一固定资产">（一）固定资产</h4><h5 id="不得扣除的情形">1.不得扣除的情形</h5><p>（1）除房屋、建筑物以外未投入使用的固定资产</p><p>提示：仅限于未投入使用的机器设备等固定资产不得扣除，房屋、建筑物可计算折旧扣除。</p><p>（2）已足额提取折旧仍继续使用的固定资产</p><p>（3）以经营租赁方式租入的固定资产、以融资租赁方式租出的固定资产</p><p>（4）与经营活动无关的固定资产</p><p>（5）单独估价作为固定资产入账的土地</p><h5 id="计税基础">2.计税基础</h5><p>提示：外购、捐赠、投资、非货币性资产交换、债务重组取得的生产性生物资产、无形资产的计税基础与固定资产类似，后续不再赘述。</p><h5 id="扣除方式">3.扣除方式</h5><p>（1）折旧计算方法：直线法。</p><p>提示：针对符合条件的企业还允许采用加速折旧方法计算扣除折旧，见“税收优惠”部分。</p><p>（2）折旧开始时间——“次月”：固定资产投入使用月份的次月起开始计算折旧；停止使用的固定资产，应当自停止使用月份的次月起停止计算折旧。</p><p>（3）税法规定的最低折旧年限：</p><p>房屋、建筑物 20</p><p>飞机、火车、轮船、机器、机械和其他生产设备 10</p><p>与生产经营活动有关的器具、工具、家具等 5</p><p>飞机、火车、轮船以外的运输工具 4</p><p>电子设备 3</p><p>（4）企业应合理确定资产的预计净残值，预计净残值一经确定，不得变更。</p><h4 id="二生产性生物资产">（二）生产性生物资产</h4><h5 id="概念">1.概念</h5><p>包括经济林、薪炭林、产畜和役畜等。</p><h5 id="扣除方法">2.扣除方法</h5><p>（1）按照直线法计算的折旧，准予扣除。</p><p>（2）企业应当自生产性生物资产投入使用月份的次月起计算折旧；停止使用的生产性生物资产，应当自停止使用月份的次月起停止计算折旧。</p><p>（3）最低折旧年限规定：林木类生产性生物资产，为 10年；畜类生产性生物资产，为 3 年。</p><h4 id="三无形资产">（三）无形资产</h4><h5 id="不得扣除的情况">1.不得扣除的情况</h5><p>（1）自行开发的支出已扣除的无形资产（不得重复扣除）</p><p>（2）自创商誉</p><p>（3）与经营活动无关的无形资产</p><h5 id="计税基础-1">2.计税基础</h5><p>自行开发 符合资本化条件后至达到预定用途前发生的支出</p><h5 id="扣除方式-1">3.扣除方式</h5><p>（1）摊销计算方法：直线法。</p><p>（2）摊销年限：一般情况不得低于 10年。作为投资或者受让的无形资产，有关法律规定或者合同约定了使用年限的，可以按照规定或者约定的使用年限分期摊销。</p><h4 id="四长期待摊费用">（四）长期待摊费用</h4><p>企业发生的下列支出作为长期待摊费用，按照规定摊销扣除</p><h4 id="五投资资产">（五）投资资产</h4><p>对外投资期间 不得扣除（不得计提摊销和折旧等）</p><p>转让或者处置投资资产时 准予扣除投资资产的成本。</p><p>成本的确定方式：</p><p>（1）以支付现金方式取得的，为购买价款</p><p>（2）非支付现金方式取得的，为公允价值+支付的相关税费</p><h3 id="十境外税额的抵免">十、境外税额的抵免</h3><p>境外许多国家 /地区与我国缔结了避免双重征税的税收协定，我国居民企业在境外投资，在境外国家已经缴纳过的境外所得税，可在我国的应纳税额中进行抵免。但抵免是有限额的，这个限额就是由境外的所得（即应纳税所得额），按照我国的企业所得税法的税率和规定而计算出来的应纳税额。</p><h3 id="十一税收优惠">十一、税收优惠</h3><p>提示：其中“免税收入”已在第二部分——收入的确认中的“不征税收入与免税收入”中学习，此处不予赘述。</p><h4 id="一减计收入">（一）减计收入</h4><p>减按 90％计入收入总额</p><p>（1）以规定的目录范围内的资源作为主要原材料，生产国家非限制和禁止并符合相关标准的产品取得的资源综合利用收入</p><p>（2）2019 年 6 月1日至 2025 年 12月31日，提供社区养老、托育、家政等服务取得的收入</p><h4 id="二所得的减免">（二）“所得”的减免</h4><h5 id="享受所得减免的项目">1.享受所得减免的项目</h5><p>免税</p><p>（1）农、林、牧、渔项目，包括：蔬菜、谷物、薯类、油料、豆类、棉花、麻类、糖料、水果、坚果的种植；农作物新品种的选育；中药材的种植；林木的培育和种植；牲畜、家禽的饲养；林产品的采集；灌溉、农产品初加工、兽医、农技推广、农机作业和维修等农、林、牧、渔服务业项目；远洋捕捞。</p><p>（2）“合格境外投资者”投资于境内股权、债权投资所得：</p><p>①取得来源于中国境内的股票等权益性投资资产转让所得。</p><p>②境外机构投资境内债券市场取得的债券利息收入。</p><p>（3）2012 年及以后年度发行的地方政府债券的利息收入。</p><p>（4）对符合条件的生产和装配伤残人员专门用品的居民企业的所得。</p><p>（5）海南自由贸易港设立的旅游业、现代服务业、高新技术产业企业新增符合条件的境外直接投资取得的所得。</p><h5 id="软件产业和集成电路产业减免税政策">2.软件产业和集成电路产业减免税政策</h5><p>（1）集成电路线宽小于 130 纳米（含）、65 纳米（含）、28纳米的集成电路生产企业或项目，分别享受“两免三减半”“五免五减半”“十年免税”。</p><p>（2）国家鼓励的重点集成电路设计企业和软件企业，自获利年度起 5年免税，接续年度减按 10% 的税率征收企业所得税。</p><h4 id="三多扣扣除额">（三）“多扣”扣除额</h4><p>提示：多扣扣除方式的税收优惠属于整个税收优惠部分的重点，在考试中会经常出现。</p><h5 id="加计扣除">1.加计扣除</h5><p>a.研发费用</p><p>在按规定据实扣除的基础上，自 2023 年 1月1日起按照下列方式加计扣除：</p><p>（1）计入当期损益的：按 100% 加计扣除</p><p>（2）形成无形资产的：按无形资产成本的 200% 摊销扣除。</p><p>提示：下列行业不适用研发费用加计扣除政策：烟草制造业、住宿和餐饮业、批发和零售业、房地产业、租赁和商务服务业、娱乐业</p><p>b.安置残疾人工资</p><p>加计扣除 100％</p><p>c.基础研究投入</p><p>（1）自 2022 年 1月1日起，对企业出资给非营利性科学技术研究开发机构（简称为“科研机构”）、高等学校和政府性自然科学基金用于基础研究的支出，允许按100% 加计扣除。</p><p>（2）对非营利性科研机构、高等学校接收基础研究的资金收入，免税。</p><p>提示：上述基础研究不包括在境外开展的研究，不包括社会科学、艺术或人文学方面的研究。企业应在签订的协议或合同中明确资金用于基础研究领域</p><h5 id="固定资产一次性税前扣除">2.固定资产一次性税前扣除</h5><p>所有类型企业新购进（包括自行建造）的设备、器具，单位价值不超过 500万元的，允许一次性计入当期成本费用扣除，不再分年度计算折旧。</p><p>提示：本政策适用范围不包括房屋、建筑物</p><h5 id="固定资产加速折旧">3.固定资产加速折旧</h5><p>目前适用于全部制造业领域企业。可采用下列方法加速折旧：</p><p>（1）缩短折旧年限：最低折旧年限不得低于税法规定折旧年限的 60％</p><p>（2）采用加速折旧方法：可以采取双倍余额递减法或者年数总和法</p><h4 id="四抵扣应纳税所得额">（四）抵扣“应纳税所得额”</h4><p>适用情形 :创业投资企业投资未上市的中小高新技术企业两年以上的</p><p>抵多少 :按照其投资额的“70％”抵扣应纳税所得额</p><p>在什么时点抵扣 :在股权持有满“2年”的当年抵扣该创业投资企业的应纳税所得额；当年不足抵扣的，可以在以后纳税年度结转抵扣</p><h4 id="五抵免应纳税额">（五）抵免“应纳税额”</h4><p>适用情形:企业实际购置并自身实际投入使用的规定范围内的环境保护、节能节水、安全生产等专用设备</p><p>抵多少 :该专用设备的投资额的10％从当年的应纳税额中抵免；当年不足抵免的，可以在以后 5个纳税年度结转抵免</p><h4 id="六税率的优惠">（六）税率的优惠</h4><h5 id="小型微利企业">1.小型微利企业</h5><p>（1）符合条件的小型微利企业，减按 20% 的税率征收企业所得税。</p><p>提示：小型微利企业需同时满足三个条件：年度应纳税所得额不超过 300万元、从业人数不超过 300 人、资产总额不超过 5000万元。其中的从业人数，包括与企业建立劳动关系的职工人数和企业接受的劳务派遣用工人数。</p><p>（2）对小型微利企业应纳税所得额的减计规定（自 2023 年 1 月 1日起新政策）：年应纳税所得额不超过 300 万元的部分，减按 25%计入应纳税所得额，再适用 20% 的税率计算应纳税额。</p><h5 id="其他特殊类型企业">2.其他特殊类型企业</h5><p>高新技术企业、技术先进型服务企业 :15％</p><p>设在西部地区的鼓励类产业企业（“西部大开发”） :15％</p><h3 id="十二应纳所得税额的计算练习">十二、应纳所得税额的计算练习</h3><p>基本公式：</p><h4 id="应纳税所得额的计算">（1）应纳税所得额的计算：</h4><p>①直接法。应纳税所得额=收入总额-不征税收入-免税收入-各项扣除-以前年度亏损</p><p>②间接法：应纳税所得额=会计利润+纳税调整增加项-纳税调整减少项-以前年度亏损</p><h4 id="应纳税额的计算">（2）应纳税额的计算：</h4><p>应纳税额=应纳税所得额×适用税率-减免 / 抵免税额。</p><h3 id="十三征收管理">十三、征收管理</h3><h4 id="一纳税地点">（一）纳税地点</h4><p>居民企业</p><p>登记注册地在境内:登记注册地</p><p>登记注册地在境外:实际管理机构所在地</p><h4 id="二纳税期限及纳税年度">（二）纳税期限及纳税年度</h4><h5 id="预缴与汇算清缴">1.预缴与汇算清缴</h5><p>企业所得税按年计征，分月或者分季预缴，年终汇算清缴，多退少补。</p><p>提示：预缴方法一经确定，该纳税年度内不得随意变更。</p><h5 id="纳税年度">2.纳税年度</h5><p>（1）一般情况：为公历 1 月1日至 12 月31日。</p><p>（2）年中开业、终止经营的情况：实际经营期不足 12个月，以实际经营期为一个纳税年度。企业清算的，以清算期间作为一个纳税年度。</p><p>提示：企业在报送企业所得税纳税申报表时，应当按照规定附送财务会计报告和其他有关资料。</p><h4 id="三非居民企业的源泉扣缴">（三）非居民企业的源泉扣缴</h4><p>在中国境内未设立机构、场所的，或者虽设立机构、场所但取得的所得与其所设机构、场所没有实际联系的非居民企业，就其取得的来源于中国境内的所得应缴纳的所得税，实行源泉扣缴，以支付人为扣缴义务人。</p><p>提示：无机构场所或有机构场所但所得与机构场所无联系的非居民企业，实行源泉扣缴。</p><p>1.计算公式</p><p>应纳税所得税额=应纳税所得额×预提税率（10％）</p><p>2.应纳税所得额的确定</p><p>股息红利等权益性投资收益、利息、租金、特许权使用费所得:以收入全额作为应纳税所得额</p><p>转让财产所得:以收入全额减除财产净值后的余额，作为应纳税所得额</p><h3 id="十四企业重组业务的所得税处理">十四、企业重组业务的所得税处理</h3><p>企业重组，指企业在日常经营活动以外发生的法律结构或经济结构重大改变的交易，范围比较广泛，包括企业法律形式的改变、债务重组、股权收购、资产收购、合并、分立等。在重组行为中一定会涉及企业所得税的处理。从所得税角度，为各类重组行为设定了两个最基本处理原则，即“一般性税务处理”和“特殊性税务处理”。</p><h3 id="十五企业所得税的特别纳税调整">十五、企业所得税的特别纳税调整</h3><h4 id="一关联方">（一）关联方</h4><h5 id="关联方定义">1.关联方定义</h5><p>关联方是指与企业有下列关联关系之一的企业、其他组织或者个人：</p><p>（1）在资金、经营、购销等方面存在直接或者间接的控制关系</p><p>（2）直接或者间接地同为第三者控制</p><p>（3）在利益上具有相关联的其他关系。</p><h5 id="独立交易原则">2.独立交易原则</h5><p>独立交易原则是指没有关联关系的交易各方，按照公平成交价格和营业常规进行业务往来遵循的原则。关联方交易，应按照下列合理的方法进行：</p><p>（1）可比非受控价格法，是指按照没有关联关系的交易各方进行相同或者类似业务往来的价格进行定价的方法</p><p>（2）再销售价格法，是指按照从关联方购进商品再销售给没有关联关系的交易方的价格，减除相同或者类似业务的销售毛利进行定价的方法</p><p>（3）成本加成法，是指按照成本加合理的费用和利润进行定价的方法</p><p>（4）交易净利润法，是指按照没有关联关系的交易各方进行相同或者类似业务往来取得的净利润水平确定利润的方法</p><p>（5）利润分割法，是指将企业与其关联方的合并利润或者亏损在各方之间采用合理标准进行分配的方法</p><p>（6）其他符合独立交易原则的方法</p><h4 id="二其他特别纳税调整制度">（二）其他特别纳税调整制度</h4><h5 id="受控外国企业税制">1.受控外国企业税制</h5><p>由居民企业，或者由居民企业和中国居民控制的设立在实际税负低于 12.5%的国家（地区）的企业，并非由于合理的经营需要而对利润不作分配或者减少分配的，上述利润中应归属于该居民企业的部分，应当计入该居民企业的当期收入。</p><h5 id="资本弱化税制">2.资本弱化税制</h5><p>企业从其关联方接受的债权性投资与权益性投资的比例超过规定标准而发生的利息支出，不得在计算应纳税所得额时扣除。企业实际支付给关联方的利息支出，其接受关联方债权性投资与其权益性投资比例为：</p><p>（1）金融企业，为 5∶1</p><p>（2）其他企业，为 2∶1</p><p>企业如果能够按照《企业所得税法》及其实施条例的有关规定提供相关资料，并证明相关交易活动符合独立交易原则的；或者该企业的实际税负不高于境内关联方的，其实际支付给境内关联方的利息支出，在计算应纳税所得额时准予扣除</p><h5 id="一般反避税制度">3.一般反避税制度</h5><p>企业实施其他不具有合理商业目的的安排而减少其应纳税收入或者所得额的，税务机关有权按照合理方法调整。</p><h4 id="三关联方交易业务的基本原则和调整时效">（三）关联方交易业务的基本原则和调整时效</h4><p>（1）企业与其关联方之间的业务往来，应遵循独立交易原则。不符合独立交易原则，或者企业实施其他不具有合理商业目的安排的，税务机关有权按合理方法调整。</p><p>（2）调整时限：10 年内。</p><h4 id="四补征税款和加收利息">（四）补征税款和加收利息</h4><p>（1）税务机关作出特别纳税调整的，应当对补征的税款，自税款所属纳税年度的次年6月 1 日起至补缴税款之日止的期间，按日加收利息。</p><p>（2）加收的利息，按照贷款基准利率加 5 个百分点计算。</p><p>（3）加收的利息，不得在计算应纳税所得额时扣除。</p><h3 id="十六企业所得税实战篇">十六、企业所得税实战篇</h3><p>企业所得税汇算清缴申报表共有 37张表单，分为主表、一级附表、二级附表，填写表格时从最末级的表单开始依次往上填写。例如在调整工资薪金相关的成本费用时，首先要填写二级附表A105050《职工薪酬纳税调整明细表》，将企业计提并发放的工资薪金、社会保险费、公积金、职工福利费、职工教育经费、工会经费、补充医疗和养老保险等明细费用填进表格，并与税法规定可以扣除的金额做对比，将账载金额、税收金额和最终得出的调整金额数据填在一级附表A105000《纳税调整明细表》中。《纳税调整明细表》用来汇总企业收入、成本费用等事项的调整结果，并将最终的结论性数据汇总至主表中。主表通过表格间内嵌的公式计算出纳税人“应纳税所得额”“实际应纳所得税额”“本年应补（退）所得税额”等数据。</p>]]></content>
      
      
      <categories>
          
          <category> 经济法基础 </category>
          
          <category> 第二章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关税法律制度</title>
      <link href="/2024/05/18/jing-ji-fa-ji-chu-1-6-guan-shui-fa-lu-zhi-du-chen-wei/"/>
      <url>/2024/05/18/jing-ji-fa-ji-chu-1-6-guan-shui-fa-lu-zhi-du-chen-wei/</url>
      
        <content type="html"><![CDATA[<blockquote><p>投稿自宸溦</p></blockquote><h2 id="第六节-关税法律制度">第六节 关税法律制度</h2><h3 id="一关税的概念征税范围及纳税人">一、关税的概念、征税范围及纳税人</h3><p>我国目前对进出境货物征收的关税分为进口关税和出口关税两类。</p><h4 id="一征税对象及征税范围">（一）征税对象及征税范围</h4><p>征税对象是进出境的货物、物品。对从境外采购进口的原产于中国境内的货物，也应按规定征收进口关税。</p><p>海关负责征收进口关税或出口关税。</p><p>提示：关税和船舶吨税一样，征税范围只看是否进出“关境”，而不分“国籍”。</p><h4 id="二纳税人及扣缴义务人">（二）纳税人及扣缴义务人</h4><p>提示：接受纳税人委托办理货物报关等有关手续的符合条件的代理人，可以代办纳税手续，但代理人不是纳税人，也不是扣缴义务人。</p><h3 id="二进口关税的计算">二、进口关税的计算</h3><h4 id="一计税规则">（一）计税规则</h4><p>提示：在比例税率从价计征的方式中，有一种特殊类型的比例税率叫做“滑准税”，滑准税本质上仍然是比例税率，但进口货物价格越高，滑准税税率就越低，反之亦然。</p><p>本质上仍然是比例税率，但进口货物价格越高，滑准税税率就越低，反之亦然。</p><h4 id="二进口货物的关税完税价格">（二）进口货物的关税完税价格</h4><p>一般贸易项下进口的货物以海关审定的以成交价格为基础确定的到岸价格作为关税完税价格。</p><p>提示：进口货物的到岸价格不能确定时，海关可以采用其他方法估定完税价格。</p><p>提示：卖方违反合同规定延期交货，买方从货价中扣除的罚款，不得从关税完税价格中扣除。但卖方支付给买方的正常回扣，允许从关税完税价格中扣除</p><p>特殊情形下关税完税价格的确定：</p><p>运往境外加工的货物复运回国：境外加工费、料件费、复运进境的运输及其相关费用和保险费</p><p>运往境外修理复运回国：修理费和料件费</p><p>租借和租赁进口货物：海关审定的租金</p><p>国内单位留购的进口货样、展览品和广告陈列品：留购价格</p><h4 id="三进口关税的税率">（三）进口关税的税率</h4><p>进口货物适用何种关税税率类型以进口货物的原产地为标准判断。分为以下 6类：</p><h5 id="最惠国税率">1.最惠国税率</h5><p>（1）共同适用最惠国条款的世贸组织成员</p><p>（2）与我国签订最惠国待遇双边协定的国家</p><p>（3）原产于我国</p><h5 id="协定税率">2.协定税率</h5><p>与我国签订含有“关税优惠条款”的区域性贸易协定的国家或地区</p><h5 id="特惠税率">3.特惠税率</h5><p>与我国签订含有“特殊关税优惠条款”的国家</p><h5 id="普通税率">4.普通税率</h5><p>（1）原产于未与我国共同适用或订立最惠国税率、特惠税率或协定税率的国家或地区</p><p>（2）原产地不明的货物</p><h5 id="关税配额税率">5.关税配额税率</h5><p>关税配额是进口国限制进口货物数量的措施，配额与税率结合，配额内税率较低，配额外税率较高</p><h5 id="暂定税率">6.暂定税率</h5><p>在最惠国税率的基础上，对特殊货物可执行暂定税率</p><h3 id="三出口关税的计算">三、出口关税的计算</h3><p>从价计征 出口货物完税价格=离岸价格÷（1+出口税率） 比例税率应纳税额=出口货物完税价格×出口税率</p><h3 id="四税收优惠">四、税收优惠</h3><p>关税的减税、免税分为法定性减免税、政策性减免税和临时性减免税。</p><h4 id="一法定性减免税">（一）法定性减免税</h4><p>（1）关税税额在人民币 50 元以下的一票货物</p><p>（2）无商业价值的广告品及货样</p><p>（3）国际组织、外国政府无偿赠送的物资</p><p>（4）进出境运输工具装载的途中必需的燃料、物料和饮食用品</p><p>（5）因故退还的中国出口货物，可以免征进口关税，但已征收的出口关税，不予退还；因故退还的境外进口货物，可以免征出口关税，但已征收的进口关税不予退还</p><h4 id="二政策性减免税酌情减免税">（二）政策性减免税（酌情减免税）</h4><p>（1）境外运输途中或者在起卸时，遭受到损坏或者损失的</p><p>（2）起卸后海关放行前，因不可抗力遭受损坏或者损失的</p><p>（3）海关查验时已经破漏、损坏或者腐烂，经证明不是保管不慎造成的</p><h3 id="五征收管理">五、征收管理</h3><h4 id="一纳税期限">（一）纳税期限</h4><p>进出口货物的收发货人或者代理人应当在海关填发税款缴款书之日起 15日内，向指定银行缴纳税款。</p><h4 id="二进出境物品暂不予放行的情形">（二）进出境物品暂不予放行的情形</h4><p>（1）旅客不能当场缴纳进境物品税款的</p><p>（2）进出境的物品属于许可证件管理的范围，但旅客不能当场提交的</p><p>（3）进出境的物品超出自用合理数量，按规定应当办理货物报关手续或者其他海关手续，尚未办理的</p><p>（4）对进出境物品的属性、内容存疑，需要由有关主管部门进行认定、鉴定、验核的</p><p>（5）按规定暂不予放行的其他行李物品</p>]]></content>
      
      
      <categories>
          
          <category> 经济法基础 </category>
          
          <category> 第一章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>车辆购置税法律制度</title>
      <link href="/2024/05/18/jing-ji-fa-ji-chu-1-5-che-liang-gou-zhi-shui-fa-lu-zhi-du-chen-wei/"/>
      <url>/2024/05/18/jing-ji-fa-ji-chu-1-5-che-liang-gou-zhi-shui-fa-lu-zhi-du-chen-wei/</url>
      
        <content type="html"><![CDATA[<blockquote><p>投稿自宸溦</p></blockquote><h2 id="第五节-车辆购置税法律制度">第五节 车辆购置税法律制度</h2><h3 id="一征税范围及纳税人">一、征税范围及纳税人</h3><p>车辆购置税是对在中国境内购置应税车辆的单位和个人征收的一种税。</p><h4 id="一征税范围">（一）征税范围</h4><p>汽车、有轨电车、汽车挂车、排气量超过 150 毫升的摩托车。</p><h4 id="二纳税人">（二）纳税人</h4><p>在我国境内购置应税车辆的单位和个人。</p><p>购置，是指以购买、进口、自产、受赠、获奖或者其他方式取得并自用。</p><p>提示：不仅仅“购买”要交车辆购置税，所有购置并自用的行为都要缴纳车辆购置税。</p><h3 id="二计税依据">二、计税依据</h3><h4 id="购买自用">购买自用</h4><p>（1）电子发票信息中的不含增值税价格。</p><p>（2）有多条电子发票信息或者没有电子发票信息的，按照购置应税车辆实际支付给销售方的全部价款（不含增值税）申报纳税</p><h4 id="进口自用">进口自用</h4><p>进口环节组成计税价格。</p><p>公式为：组成计税价格=关税完税价格+关税+消费税</p><h4 id="自产自用">自产自用</h4><p>（1）纳税人生产的同类应税车辆的销售价格（不含增值税）</p><p>（2）没有同类应税车辆销售价格的，按照组成计税价格确定。</p><p>组成计税价格=成本×（1+成本利润率）（属于应征消费税的应税车辆，其组成计税价格中应加计消费税税额）</p><h4 id="受赠获奖或其他方式取得并自用">受赠、获奖或其他方式取得并自用</h4><p>（1）按照购置应税车辆时相关凭证载明的价格确定（不包括增值税税款）；购置应税车辆时相关凭证，指原车辆所有人购置或者以其他方式取得应税车辆时载明价格的凭证。</p><p>（2）无法提供相关凭证的，参照同类应税车辆市场平均交易价格确定其计税价格。</p><p>（3）无同类应税车辆销售价格的，按照组成计税价格确定计税价格。</p><h3 id="三应纳税额的计算">三、应纳税额的计算</h3><p>税率为比例税率 10%。</p><p>应纳税额=计税依据×税率</p><h3 id="四税收优惠">四、税收优惠</h3><p>下列车辆免征车辆购置税：</p><p>（1）依照法律规定应当予以免税的外国驻华使馆、领事馆和国际组织驻华机构及其有关人员自用的车辆。</p><p>（2）军队、武警列入装备订货计划的车辆。</p><p>（3）悬挂应急救援专用号牌的国家综合性消防救援车辆。</p><p>（4）设有固定装置的非运输专用作业车辆。</p><p>（5）城市公交企业购置的公共汽电车辆。</p><p>（6）购置新能源汽车，免征车辆购置税。</p><h3 id="五征收管理">五、征收管理</h3><h4 id="一纳税环节与纳税义务发生时间">（一）纳税环节与纳税义务发生时间</h4><p>纳税环节：在购置自用环节一次性征收</p><p>纳税义务发生时间：纳税人购置应税车辆的当日</p><p>纳税期限：</p><p>（1）应当自纳税义务发生之日起 60 日内申报缴纳车辆购置税。</p><p>（2）纳税人应当在向公安机关交通管理部门办理车辆注册登记前，缴纳车辆购置税。</p><h4 id="二退税及补税">（二）退税及补税</h4><p>将已征车辆购置税的车辆退回车辆生产或销售企业的，申请退还车辆购置税：退税额以已缴税款为基准，自缴纳税款之日至申请退税之日，每满1 年扣减 10%</p><p>免减税车辆因转让、改变用途等原因不再属于免税、减税范围的，应当在办理车辆转移登记或者变更登记前缴纳车辆购置税：以免税、减税车辆初次办理纳税申报时确定的计税价格为基准，每满1 年扣减 10%</p><h4 id="三纳税地点">（三）纳税地点</h4><p>按照是否需要办理车辆登记区分：</p><p>是）车辆登记地的主管税务机关。</p><p>否）纳税人所在地的主管税务机关。</p>]]></content>
      
      
      <categories>
          
          <category> 经济法基础 </category>
          
          <category> 第一章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>城市维护建设税、教育费附加和地方教育附加法律制度</title>
      <link href="/2024/05/18/jing-ji-fa-ji-chu-1-4-cheng-shi-wei-hu-jian-she-shui-jiao-yu-fei-fu-jia-he-di-fang-jiao-yu-fu-jia-fa-lu-zhi-du-chen-wei/"/>
      <url>/2024/05/18/jing-ji-fa-ji-chu-1-4-cheng-shi-wei-hu-jian-she-shui-jiao-yu-fei-fu-jia-he-di-fang-jiao-yu-fu-jia-fa-lu-zhi-du-chen-wei/</url>
      
        <content type="html"><![CDATA[<blockquote><p>投稿自宸溦</p></blockquote><h2 id="第四节-城市维护建设税教育费附加和地方教育附加法律制度">第四节 城市维护建设税、教育费附加和地方教育附加法律制度</h2><h3 id="一纳税义务人">一、纳税义务人</h3><p>（1）纳税人：在我国境内缴纳增值税、消费税（以下简称为“两税”）的单位和个人</p><p>（2）扣缴义务人：负有两税扣缴义务的单位和个人，在扣缴两税的同时扣缴城市维护建设税、教育费附加和地方教育附加</p><h3 id="二税率">二、税率</h3><p>提示：城市维护建设税、教育费附加和地方教育附加的征收比率一般也不要求记忆，题目中会作为已知条件给出。</p><h4 id="一城市维护建设税税率">（一）城市维护建设税税率</h4><p>按照纳税人所在地的不同，设置了三档地区差别比例税率。</p><p>（1）纳税人所在地为市区的，税率为 7%；所在地为县城和镇的，税率为5%；不在市区、县城或者镇的，税率为 1%。</p><p>（2）由受托方代扣代缴、代收代缴增值税、消费税的单位和个人，其代扣代缴、代收代缴的城市维护建设税按受托方所在地的适用税率执行。</p><h4 id="二教育费附加和地方教育附加征收比率">（二）教育费附加和地方教育附加征收比率</h4><p>不区分地区，教育费附加征收比率为 3%，地方教育附加征收比率为 2%。</p><h3 id="三应纳税额的计算">三、应纳税额的计算</h3><p>1.计税依据和计算公式</p><p>城市维护建设税，教育费附加、地方教育附加 依法实际缴纳的两税税额应纳税额=计税依据×税率 / 征收比率</p><p>2.计税依据的特殊规定</p><p>（1）进口、出口业务对计税依据的影响：</p><p>进口货物、境外单位和个人向境内销售劳务、服务、无形资产缴纳的增值税、消费税的不征收</p><p>出口业务计算的增值税免抵税额 应计入计税依据，征收</p><p>对出口货物、劳务和跨境销售服务、无形资产退还增值税、消费税的已缴纳的不予退还</p><p>（2）计税依据中不包括直接减免的两税</p><p>（3）计税依据中允许扣除实行增值税期末留抵退税的纳税人收到的留抵退税。</p><p>提示：根据上述特殊规定，计税依据的公式应变形为：城建税的计税依据=实际缴纳的两税（不含进口货物或进口劳务、服务、无形资产缴纳的两税）+增值税免抵税额-直接减免的两税税额-期末留抵退税退还的增值税税额</p><h3 id="四征收管理">四、征收管理</h3><p>城市维护建设税、教育费附加和地方教育附加的纳税义务发生时间、纳税地点均同增值税、消费税保持一致。</p>]]></content>
      
      
      <categories>
          
          <category> 经济法基础 </category>
          
          <category> 第一章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>消费税法律制度</title>
      <link href="/2024/05/18/jing-ji-fa-ji-chu-1-3-xiao-fei-shui-fa-lu-zhi-du-chen-wei/"/>
      <url>/2024/05/18/jing-ji-fa-ji-chu-1-3-xiao-fei-shui-fa-lu-zhi-du-chen-wei/</url>
      
        <content type="html"><![CDATA[<blockquote><p>投稿自宸溦</p></blockquote><h2 id="第三节-消费税法律制度">第三节 消费税法律制度</h2><p>学完普遍征收、环环征收的增值税，接下来要学习仅选择少数消费品且仅在单一环节征收的一个税种——消费税。消费税征收的目的主要是为了调节产品结构、引导消费方向、抑制部分商品的消费。因此，除了学习消费税的计算以外，哪些商品要交消费税，要在哪个环节征税，是需要解决的两大问题。</p><h3 id="一税目">一、税目</h3><h4 id="现行15个消费税税目">1.现行15个消费税税目</h4><p>（1）烟</p><p>（2）酒</p><p>（3）高尔夫球及球具</p><p>（4）高档化妆品</p><p>（5）贵重首饰及珠宝玉石</p><p>（6）高档手表</p><p>（7）小汽车</p><p>（8）摩托车</p><p>（9）游艇</p><p>（10）鞭炮和焰火</p><p>（11）成品油</p><p>（12）木制一次性筷子</p><p>（13）实木地板</p><p>（14）涂料</p><p>（15）电池</p><h3 id="二税目和纳税义务人">二、税目和纳税义务人</h3><h4 id="一纳税义务人">（一）纳税义务人</h4><p>在中华人民共和国境内生产、委托加工和进口《消费税暂行条例》规定的消费品的单位和个人，以及国务院确定的销售《消费税暂行条例》规定的消费品的其他单位和个人，为消费税的纳税人。</p><h4 id="二一般征税环节生产进口委托加工环节">（二）一般征税环节——生产、进口、委托加工环节</h4><p>除在零售、批发环节纳税的消费品外，一般消费品在生产销售环节、进口环节及委托加工环节征收消费税。</p><p>1.生产和进口环节</p><p>（1）生产的应税消费品，于对外销售时纳税</p><p>（2）进口应税消费品，于报关进口时缴纳消费税</p><p>2.委托加工环节</p><p>（1）委托加工应税消费品的概念</p><p>提示：以下三种情形，不属于委托加工，受托方按销售自产产品处理：</p><p>a 由受托方提供原材料生产的应税消费品</p><p>b 受托方先将原材料卖给委托方，然后再接受加工的应税消费品</p><p>c 由受托方以委托方名义购进原材料生产的应税消费品</p><p>（2）（受托方代收代缴消费税后）委托方收回的后续税务处理</p><h4 id="三特殊征税环节零售环节">（三）特殊征税环节——零售环节</h4><p>1.金银首饰——“仅”在零售环节征收消费税</p><p>（1）金银首饰具体包括：金基、银基合金首饰以及金、银和金基、银基合金的镶嵌首饰（不含镀金和包金首饰）、铂金首饰、钻石及钻石饰品。</p><p>提示：将金银首饰用于馈赠、赞助、集资、广告样品、职工福利、奖励等方面，应视同发生零售情况，缴纳消费税。</p><p>（2）具体核算要求：既销售金银首饰，又销售非金银首饰的生产、经营单位，应将两类商品划分清楚，分别核算销售额；凡划分不清楚或不能分别核算的，在零售环节销售的，一律按金银首饰征收消费税；在生产环节销售的，一律从高适用税率征收消费税。</p><p>提示：例如，某商店既销售“金银首饰”又销售“镀金首饰”，未分别核算，按全部销售额计征消费税。</p><p>2.超豪华小汽车——在零售环节“加”征一道消费税</p><p>（1）超豪华小汽车的定义：每辆不含增值税零售价格 130 万元及以上。</p><p>提示：超豪华小汽车在生产、进口、委托加工环节仍然正常缴纳消费税。</p><p>（2）纳税人为直接将超豪华小汽车零售给消费者的单位和个人为纳税人。</p><h4 id="四特殊征税环节批发环节">（四）特殊征税环节——批发环节</h4><p>1.卷烟——在批发环节“加”征一道消费税</p><p>（1）卷烟在生产、进口、委托加工环节仍然正常缴纳消费税。</p><p>（2）批发企业将卷烟销售给其他批发企业的，属于批发环节内调拨，不征收消费税。只有批发企业将卷烟销售给零售企业，才加征批发环节的消费税。</p><p>2.电子烟——在批发环节“加”征一道消费税</p><p>电子烟在批发环节加征一道从价计征的消费税。</p><h3 id="三消费税税率和计征方式">三、消费税税率和计征方式</h3><p>两种税率形式（比例税率和定额税率）对应三种计征方式（从价计征、从量计征、从价从量复合计征）。</p><p>比例税率 绝大多数应税消费品 从价计征 应纳税额=销售额×比例税率</p><p>定额税率 黄酒、啤酒、成品油 从量计征 应纳税额=销售数量×定额税率</p><p>复合征收 卷烟、白酒 复合计征应纳税额=销售额×比例税率+销售数量×定额税率</p><p>提示：</p><p>（1）纳税人兼营不同税率的应税消费品，应分别核算，未分别核算的，从高适用税率。</p><p>（2）将不同税率的应税消费品组成成套消费品销售的，从高适用税率。</p><h3 id="四消费税应纳税额的计算">四、消费税应纳税额的计算</h3><h4 id="一一般情况下销售额的确定">（一）一般情况下销售额的确定</h4><h5 id="从价计征">1.从价计征</h5><p>应纳税额=销售额×比例税率</p><p>（1）销售额：销售额为纳税人销售应税消费品向购买方收取的全部价款和价外费用，不包括向购买方收取的增值税税款。</p><p>（2）价外费用：与增值税中价外费用的规定相一致，除个别除外项目外，以各种名目向买方收取的价外费用均应计入销售额。</p><p>提示：白酒生产企业向商业销售单位收取的“品牌使用费”，应并入白酒的销售额中缴纳消费税。</p><h5 id="从量计征">2.从量计征</h5><p>应纳税额=应税消费品的销售数量×定额税率（单位税额）</p><h5 id="复合计征">3.复合计征</h5><p>应纳税额=从价计征的部分+从量计征的部分</p><h4 id="二特殊情形下销售额的确定">（二）特殊情形下销售额的确定</h4><p>1.计税价格明显偏低且无正当理由</p><p>纳税人应税消费品的计税价格明显偏低并无正当理由的，由税务机关核定计税价格。其核定权限规定如下：</p><p>卷烟、白酒和小汽车 国家税务总局核定，送财政部备案</p><p>其他应税消费品 省、自治区和直辖市税务局核定</p><p>进口的应税消费品 海关核定</p><p>2.“换、投、抵”</p><p>纳税人用于以下用途的应税消费品，应以纳税人同类应税消费品的最高销售价格作为计税依据计算消费税：</p><p>（1）换取生产资料和消费资料</p><p>（2）投资入股</p><p>（3）抵偿债务</p><p>3.非独立核算门市部对外销售</p><p>纳税人通过自设非独立核算门市部销售的自产应税消费品，应当按照门市部对外销售额或者销售数量征收消费税。</p><p>4.以旧换新</p><p>（1）金银首饰以旧换新：按实际收取的不含增值税的全部价款确定计税依据征收消费税。提示：同增值税中金银首饰以旧换新的销售额的规定一致。</p><p>（2）其他消费品以旧换新——按新货的销售额征收消费税。</p><h4 id="三特殊情形下应纳消费税的计算">（三）特殊情形下应纳消费税的计算</h4><p>对于应税消费品的自产自用、委托加工、进口等环节，如果没有“销售额”，也没有可以参考的价格，则需要按照一定标准组成出来一个销售额，这就是消费税中的“组成计税价格”。组成计税价格的公式虽然在在增值税部分已经讲述过，但是在消费税中，自产自用、进口、委托加工三个情形的组成计税价格公式却略有不同。</p><h5 id="自产自用应税消费品">1.自产自用应税消费品</h5><p>自产的应税消费品，如果用于连续生产应税消费品的，移送时不纳税；用于其他方面的（消费税的“非应税”方面），于移送使用时纳税。</p><p>自产自用情形应缴纳消费税的，按照如下顺序确定销售额：</p><p>（1）纳税人生产的同类消费品的销售价格</p><p>（2）组成计税价格。公式为：</p><p>①从价计征组成计税价格：组成计税价格=（成本+利润）÷（1-比例税率）</p><p>应纳税额=组成计税价格×比例税率</p><p>②复合计征的组成计税价格：组成计税价格=（成本+利润+自产自用的数量×定额税率）÷（1-比例税率）</p><p>应纳税额=组成计税价格×比例税率+自产自用数量×定额税率</p><h5 id="委托加工应税消费品">2.委托加工应税消费品</h5><p>委托加工的应税消费品，应按照如下顺序确定销售额：</p><p>（1）按照受托方的同类消费品的销售价格</p><p>（2）组成计税价格。公式为：</p><p>①从价计征。组成计税价格=（材料成本+加工费）÷（1-比例税率）</p><p>应纳税额=组成计税价格×比例税率</p><p>②复合计征。组成计税价格=（材料成本+加工费+委托加工数量×定额税率）÷（1-比例税率）</p><p>应纳税额=组成计税价格×比例税率+委托加工数量×定额税率</p><p>提示：加工费是指受托方加工应税消费品向委托方所收取的全部费用（包括代垫辅助材料的实际成本），不包括增值税税款。如果题目中给出的是加工费的价税合计或者含税价，需要进行价税分离。</p><h5 id="进口应税消费品">3.进口应税消费品</h5><p>进口应税消费品，直接按照组成计税价格计算应纳税额。</p><p>提示：自产自用、委托加工都需要按照顺序确定销售额，但是进口环节无须按顺序，直接找“组价”，但是此“组价”非彼“组价”。这里应该是用进口环节组成计税价格。</p><p>（1）从价计征。组成计税价格=（关税完税价格+关税）÷（1-消费税比例税率）</p><p>应纳税额=组成计税价格×消费税比例税率</p><p>（2）复合计征。组成计税价格=（关税完税价格+关税+进口数量×定额税率）÷（1-消费税比例税率）</p><p>应纳税额=组成计税价格×消费税比例税率+进口数量×定额税率</p><h4 id="四已纳消费税的扣除">（四）已纳消费税的扣除</h4><p>为了避免造成重复征税，现行消费税规定，已经缴纳消费税的外购应税消费品和委托加工收回的应税消费品，如果用于连续生产应税消费品的，外购应税消费品和委托加工收回应税消费品已缴纳的消费税额在特定范围内允许扣除，但仅限于特定范围内，不在下列范围内的不允许扣除。</p><h5 id="扣除范围">1.扣除范围</h5><p>（1）外购应税消费品用于连续生产应税消费品已纳税款扣除的范围：</p><p>①外购已税烟丝生产的卷烟</p><p>②外购已税高档化妆品原料生产的高档化妆品</p><p>③外购已税珠宝、玉石原料生产的贵重首饰及珠宝、玉石</p><p>④外购已税鞭炮、焰火原料生产的鞭炮、焰火</p><p>⑤外购已税杆头、杆身和握把为原料生产的高尔夫球杆</p><p>⑥外购已税木制一次性筷子原料生产的木制一次性筷子</p><p>⑦外购已税实木地板原料生产的实木地板</p><p>⑧外购已税石脑油、润滑油、燃料油为原料生产的成品油</p><p>⑨外购已税汽油、柴油为原料生产的汽油、柴油</p><p>（2）委托加工收回的应税消费品已纳税款的扣除范围与外购基本一致，此处不再重复。</p><h5 id="扣除金额">2.扣除金额</h5><p>（1）外购应税消费品：按当期生产领用数量计算准予扣除的已纳消费税款。</p><p>（2）委托加工收回的应税消费品：按照当期生产领用的应税消费品所对应的已纳税款进行扣除。</p><h3 id="五消费税征收管理">五、消费税征收管理</h3><h4 id="一纳税义务发生时间">（一）纳税义务发生时间</h4><p>提示：除委托加工情形之外，消费税纳税义务发生时间与增值税纳税义务发生时间基本一致。</p><h4 id="二纳税地点">（二）纳税地点</h4><p>一般销售纳税人 机构所在地或者居住地</p><h4 id="三纳税申报表">（三）纳税申报表</h4><p>自2021年 8月1日起，消费税与城市维护建设税、教育费附加、地方教育附加申报表整合，启用《消费税及附加税费申报表》。</p>]]></content>
      
      
      <categories>
          
          <category> 经济法基础 </category>
          
          <category> 第一章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第三节 最小方差无偏估计</title>
      <link href="/2024/05/17/shu-li-tong-ji-6-3-zui-xiao-fang-chai-wu-pian-gu-ji/"/>
      <url>/2024/05/17/shu-li-tong-ji-6-3-zui-xiao-fang-chai-wu-pian-gu-ji/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/i7PVK1yyziqj">下载PDF点这里</a></p><p><img src="../../../../images/数理统计6-3最小方差无偏估计/数理统计6.3-40.jpg"></p><p><img src="../../../../images/数理统计6-3最小方差无偏估计/数理统计6.3-41.jpg"></p><p><img src="../../../../images/数理统计6-3最小方差无偏估计/数理统计6.3-42.jpg"></p><p><img src="../../../../images/数理统计6-3最小方差无偏估计/数理统计6.3-43.jpg"></p><p><img src="../../../../images/数理统计6-3最小方差无偏估计/数理统计6.3-44.jpg"></p><p><img src="../../../../images/数理统计6-3最小方差无偏估计/数理统计6.3-45.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数理统计 </category>
          
          <category> 第二章 参数估计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 均方误差 </tag>
            
            <tag> 一致最小均方误差估计 </tag>
            
            <tag> 一致最小方差无偏估计 </tag>
            
            <tag> 充分性原则 </tag>
            
            <tag> 费希尔信息量 </tag>
            
            <tag> 克拉默-拉奥不等式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二节 点估计的评价标准</title>
      <link href="/2024/05/16/shu-li-tong-ji-6-2-dian-gu-ji-de-ping-jie-biao-zhun/"/>
      <url>/2024/05/16/shu-li-tong-ji-6-2-dian-gu-ji-de-ping-jie-biao-zhun/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/ipraj1ytuuch">下载PDF点这里</a></p><p><img src="../../../../images/数理统计6-2点估计的评价标准/数理统计6.2-35.jpg"></p><p><img src="../../../../images/数理统计6-2点估计的评价标准/数理统计6.2-36.jpg"></p><p><img src="../../../../images/数理统计6-2点估计的评价标准/数理统计6.2-37.jpg"></p><p><img src="../../../../images/数理统计6-2点估计的评价标准/数理统计6.2-38.jpg"></p><p><img src="../../../../images/数理统计6-2点估计的评价标准/数理统计6.2-39.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数理统计 </category>
          
          <category> 第二章 参数估计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 点估计 </tag>
            
            <tag> 相合性 </tag>
            
            <tag> 无偏性 </tag>
            
            <tag> 有效性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一节 点估计</title>
      <link href="/2024/05/16/shu-li-tong-ji-6-1-dian-gu-ji/"/>
      <url>/2024/05/16/shu-li-tong-ji-6-1-dian-gu-ji/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/ibD5O1ytuo0j">下载PDF点这里</a></p><p><img src="../../../../images/数理统计6-1点估计/数理统计6.1-25.jpg"></p><p><img src="../../../../images/数理统计6-1点估计/数理统计6.1-26.jpg"></p><p><img src="../../../../images/数理统计6-1点估计/数理统计6.1-27.jpg"></p><p><img src="../../../../images/数理统计6-1点估计/数理统计6.1-28.jpg"></p><p><img src="../../../../images/数理统计6-1点估计/数理统计6.1-29.jpg"></p><p><img src="../../../../images/数理统计6-1点估计/数理统计6.1-30.jpg"></p><p><img src="../../../../images/数理统计6-1点估计/数理统计6.1-31.jpg"></p><p><img src="../../../../images/数理统计6-1点估计/数理统计6.1-32.jpg"></p><p><img src="../../../../images/数理统计6-1点估计/数理统计6.1-33.jpg"></p><p><img src="../../../../images/数理统计6-1点估计/数理统计6.1-34.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数理统计 </category>
          
          <category> 第二章 参数估计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 点估计 </tag>
            
            <tag> 矩估计 </tag>
            
            <tag> 最大似然估计 </tag>
            
            <tag> EM算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>税法概述及货物和劳务税法律制度(下)</title>
      <link href="/2024/05/16/jing-ji-fa-ji-chu-1-2-chen-wei/"/>
      <url>/2024/05/16/jing-ji-fa-ji-chu-1-2-chen-wei/</url>
      
        <content type="html"><![CDATA[<blockquote><p>投稿自宸溦</p></blockquote><h4 id="六按差额确定销售的项目差额征税">(六）按差额确定销售的项目（“差额征税”）</h4><p>金融商品转让:允许扣除买入价。销售额 = 卖出价 -买入价.提示：若相抵后出现负差，可结转下一纳税期与下一期转让金融商品销售额相抵，但年末仍出现负差的，不得转入下一个会计年度.</p><p>旅游服务:允许扣除向购买方收取并支付给其他单位或者个人的住宿费、餐饮费、交通费、签证费、门票费和支付给其他接团旅游企业的旅游费用。</p><p>房地产开发企业销售不动产：允许扣除受让土地时向政府部门支付的土地价款。（适用于一般计税的土地价款方法的）</p><p>提供建筑服务：允许扣除支付的分包款。（适用于简易计税）</p><p>经纪代理服务：允许扣除收取并代为支付的政府性基金或者行政事业性收费。</p><p>航空运输：不包括（允许扣除）代收的民航发展基金、代售其他航空运输企业客票而代收转付的价款。</p><p>一般纳税人提供客运场站服务：允许扣除支付给承运方运费。</p><p>提示：“金融服务”中的贷款服务和直接收费金融服务，均应以收取的全部收入（贷款服务中为收取的全部利息及利息性质的收入）作为销售额，无任何扣减的规定。</p><h3 id="七一般计税方法下进项税额的计算">七、一般计税方法下进项税额的计算</h3><h4 id="一准予抵扣的进项税额">（一）准予抵扣的进项税额</h4><p>进项税额是指纳税人购进货物、劳务、服务、无形资产或者不动产时，支付或者负担的增值税额。</p><h5 id="凭扣税凭证抵扣进项税">1.凭“扣税凭证”抵扣进项税</h5><h5 id="增值税扣税凭证是指增值税专用发票海关进口增值税专用缴款书农产品收购发票农产品销售发票完税凭证和符合规定的国内旅客运输发票和道路通行费发票">增值税扣税凭证，是指增值税专用发票、海关进口增值税专用缴款书、农产品收购发票、农产品销售发票、完税凭证和符合规定的国内旅客运输发票和道路通行费发票。</h5><p>提示：购进农产品取得农产品收购发票、农产品销售的抵扣规定见下面“购进农产品的特殊规定”。</p><h5 id="允许抵扣进项税的特殊规定">2.允许抵扣进项税的特殊规定</h5><h5 id="航空运输电子客票行程单进项税额票价燃油附加费199">航空运输电子客票行程单进项税额=（票价+燃油附加费）÷（1+9%）×9%</h5><h5 id="铁路车票进项税额票面金额199">铁路车票进项税额=票面金额/（1+9%）×9%</h5><h5 id="公路水路等其他客票进项税额票面金额133">公路、水路等其他客票进项税额=票面金额÷（1+3%）×3%</h5><p>提示：航空运输电子客票行程单、铁路车票、公路水路客票上需注明旅客身份信息。</p><h5 id="从适用简易计税方法的小规模纳税人处购进农产品增值税专用发票3-征收率的专票允许抵扣的进项税额买价或金额扣除率扣除率一般情况下为-9">从适用简易计税方法的小规模纳税人处购进农产品：增值税专用发票（3%征收率的专票）允许抵扣的进项税额=买价（或金额）×扣除率扣除率一般情况下为9%</h5><p>问题：从小规模纳税人处购进农产品，取得增值税专用发票，应该如何抵扣进项税？</p><p>解答：从小规模纳税人处购进农产品，即使取得的是增值税专用发票，也不按照发票上注明的税额抵扣，而应该采用计算抵扣的方法，用专用发票上的金额（不含税），乘以扣除率9%（或 10%）。</p><p>例题：2023 年 9月，甲食品零售商店（一般纳税人）从农户处收购玉米，取得农产品收购发票上注明买价1000元。收购后将其加工成包装精美的即食型精细玉米早餐粉对外出售。已知玉米适用9% 增值税税率，玉米早餐粉适用 13%增值税税率。计算甲商店收购玉米允许抵扣的进项税额。</p><p>解析：可抵扣的进项税=1000×10%=100（元）</p><h4 id="二不得抵扣的进项税额">（二）不得抵扣的进项税额</h4><h5 id="因用途不可抵">1.因“用途”不可抵</h5><h5 id="用于这些项目在下一个环节不会产生相应的销项税额或是增值税抵扣链条终结根据增值税环环抵扣的特点相对应的进项税额也不能抵扣">用于这些项目，在下一个环节不会产生相应的销项税额，或是增值税抵扣链条终结，根据增值税环环抵扣的特点，相对应的进项税额也不能抵扣。</h5><h5 id="因非正常损失不可抵">2.因“非正常损失”不可抵</h5><h5 id="非正常损失是指因管理不善造成货物被盗丢失霉烂变质以及因违反法律法规造成货物或者不动产被依法没收销毁拆除的情形">非正常损失，是指因管理不善造成货物被盗、丢失、霉烂变质，以及因违反法律法规造成货物或者不动产被依法没收、销毁、拆除的情形。</h5><h5 id="非正常损失的购进货物以及相关的劳务和交通运输服务">（1）非正常损失的购进货物，以及相关的劳务和交通运输服务</h5><h5 id="非正常损失的在产品产成品所耗用的购进货物不包括固定资产劳务和交通运输服务">（2）非正常损失的在产品、产成品所耗用的购进货物（不包括固定资产）、劳务和交通运输服务</h5><h5 id="非正常损失的不动产不动产在建工程和该不动产或在建工程所耗用的购进货物设计服务和建筑服务">（3）非正常损失的不动产、不动产在建工程和该不动产或在建工程所耗用的购进货物、设计服务和建筑服务</h5><p>需要特别注意的是：自然灾害和正常生产损耗不属于非正常损失，进项税额准予抵扣。</p><h4 id="三进项税额转出">（三）进项税额转出</h4><p>已抵扣进项税的项目发生了不可抵扣的情形，之前已经抵扣的进项税额已不再能够抵扣，须从当月进项税额中扣减，这就是“进项税额转出”。</p><h5 id="购进货物或劳务购进服务已知已经抵扣的进项税额则将应转出部分直接转出无法确定已经抵扣的进项税额的按当期外购项目的实际成本乘以适用税率计算进项税额转出金额">（1）购进货物或劳务、购进服务，已知已经抵扣的进项税额，则将应转出部分直接转出；无法确定已经抵扣的进项税额的，按当期外购项目的实际成本乘以适用税率计算进项税额转出金额</h5><h5 id="购进固定资产无形资产不动产已经抵扣的进项税额发生了转出按照下列公式计算转出金额不得抵扣的进项税额已抵扣的进项税额资产净值率资产净值率资产净值资产原值公式变形后得出不得抵扣的进项税额资产净值适用税率">（2）购进固定资产、无形资产、不动产已经抵扣的进项税额，发生了“转出”按照下列公式计算“转出”金额：不得抵扣的进项税额=已抵扣的进项税额×资产净值率（资产净值率=资产净值÷资产原值）公式变形后得出：不得抵扣的进项税额=资产净值×适用税率</h5><h3 id="八一般计税方法下应纳税额的计算">八、一般计税方法下应纳税额的计算</h3><p>1.基本计算公式应纳税额=当期销项税额-当期进项税额</p><p>其中：当期销项税额=销售额×适用税率</p><p>其中，当期进项税额需要考虑进项税额的转出。</p><p>2.上期末留抵税额的处理</p><p>上期末留抵税额，指的是上期“销项税额 -进项税额”为负数的部分（绝对值）。上期留抵税额可结转到下一期间继续抵扣。</p><h3 id="九增值税留抵退税政策">九、增值税留抵退税政策</h3><p>自2019 年 4 月1日起，我国开始实行增值税期末留抵税额退税制度。自2022年 4 月1日，我国开始实行大规模增值税留抵退税政策。</p><h3 id="十简易计税方法">十、简易计税方法</h3><h4 id="一一般情形3-征收率">（一）一般情形——3% 征收率</h4><p>小规模纳税人以及一般纳税人选择适用简易办法计税的，一般情况下征收率为3%。</p><p>提示：小规模纳税人发生应税行为还有免税政策</p><h4 id="二特殊情形3-征收率减按-2-征收">（二）特殊情形——3% 征收率减按 2%征收</h4><p>适用于下列情形：</p><p>（1）一般纳税人销售自己使用过的不得抵扣且未抵扣进项税额的固定资产</p><p>（2）小规模纳税人（不含其他个人）销售自己使用过的固定资产</p><p>提示：在上述两种情形中，纳税人也可以放弃减税，按照 3%征收率缴纳增值税，并可以开具增值税专用发票。</p><p>（3）纳税人（一般纳税人和小规模纳税人均适用）销售旧货</p><p>提示：销售旧货的情形下不得放弃减税，也不得开具增值税专用发票。旧货，是指进入二次流通的具有部分使用价值的货物（含旧汽车、旧摩托车和旧游艇），但不包括自己使用过的物品。</p><p>例题：甲公司是增值税一般纳税人，2022 年 8月销售一批自己使用过的不得抵扣且未抵扣过进项税额的设备（按固定资产核算），取得含税收入2.06万元。甲公司应买方要求开具了增值税专用发票。计算甲公司此业务应纳增值税额。</p><p>解析：此题考查一般纳税人销售使用过的固定资产简易计税下应纳税额的计算。甲公司销售自己使用过的不得抵扣且未抵扣进项税额的固定资产，应适用3% 的征收率，减按 2%征收。但题目给出已知条件，甲公司开具了增值税专用发票，代表着甲公司放弃了减税，正常按照3%的征收率缴纳增值税。那么甲公司应缴纳的增值税税额=2.06÷（1+3%）×3%=0.06（万元）。</p><h4 id="三其他特殊情形">（三）其他特殊情形</h4><p>1.适用于5%征收率的情形</p><p>（1）一般纳税人和小规模纳税人：“卖房”“租房”“劳务派遣”。</p><p>（2）其他个人出售住房</p><p>购买年限＜2年：全额</p><p>购买年限≥2 年：北、上、广、深的非普通住房，差额。其他情形，免征。</p><p>提示：深圳市自 2020 年 7 月15日起、上海市自 2021 年 1月22日起、广州市 9 个区自2021年 4月21日起，将个人住房转让增值税征免年限由 2 年调整到 5 年。</p><p>2.适用于0.5%征收率的情形</p><p>自2020 年 5月 1 日至 2023 年 12月31日，从事二手车经销的纳税人销售其收购的二手车，改为按 0.5%征收增值税。并按照下列公式计算</p><p>销售额：销售额=含税销售额÷（1+0.5%）</p><p>纳税人应当开具二手车销售统一发票。购买方索取增值税专用发票的，应当再开具征收率为0.5% 的增值税专用发票。</p><h4 id="四应纳税额的计算">（四）应纳税额的计算</h4><p>应纳税额=（不含税的）销售额×征收率</p><p>应纳税额=含税销售额÷（1+征收率）×征收率</p><p>提示：</p><p>（1）简易计税方法不得抵扣进项税。</p><p>（2）纳税人适用简易计税方法计税的，因销售折让、中止或者退回而退还给购买方的销售额，应当从当期销售额中扣减。扣减当期销售额后仍有余额造成多缴的税款，可以从以后的应纳税额中扣减。</p><h3 id="十一进口货物和扣缴计税应纳税额的计算">十一、进口货物和扣缴计税应纳税额的计算</h3><h4 id="一进口货物应纳增值税的计算">（一）进口货物应纳增值税的计算</h4><p>（1）无论是一般纳税人还是小规模纳税人，均应按照组成计税价格和适用税率计算应纳税额。</p><p>（2）进口货物向海关缴纳的进口环节增值税，取得了海关进口专用缴款书后，允许作为国内内销环节的进项税额进行抵扣。</p><p>（3）计算公式进口环节增值税应纳税额=进口环节组成计税价格×税率其中：进口环节组成计税价格（简称为“进口组价”）</p><p>①不征收消费税的一般货物：进口组成计税价格=关税完税价格+关税</p><p>②征收消费税的应税消费品（以从价消费税为例）：进口组成计税价格=关税完税价格+关税+消费税=（关税完税价格+关税）÷（1-消费税比例税率）</p><h4 id="二扣缴计税方式应纳税额的计算">（二）扣缴计税方式应纳税额的计算</h4><p>我国境外的单位或者个人在境内销售劳务，在境内未设有经营机构的，以购买方为扣缴义务人。</p><p>应扣缴增值税税额=购买方支付的价款÷（1+适用税率）×适用税率</p><h3 id="十二增值税出口退免税制度">十二、增值税出口退（免）税制度</h3><h4 id="一出口免税并退税">（一）出口免税并退税</h4><p>具体包括“免抵退税”和“免退税”两种处理。</p><p>免抵退税和免退税计税依据</p><p>（1）出口货物劳务：出口发票（外销发票）、其他普通发票或购进出口货物劳务的增值税专用发票、海关进口增值税专用缴款书确定</p><p>（2）跨境应税行为：</p><p>①免抵退的计税依据：</p><p>a.以铁路运输方式载运旅客的，为按照铁路合作组织清算规则清算后的实际运输收入</p><p>b.以铁路运输方式载运货物的，为实际运输收入</p><p>c.以航空运输方式载运货物或旅客的，如果国际运输或港澳台运输各航段由多个承运人承运的，为中国航空结算有限责任公司清算后的实际收入；如果国际运输或港澳台运输各航段由一个承运人承运的，为提供航空运输服务取得的收入</p><p>②免退的计税依据：</p><p>购进应税服务的增值税专用发票或解缴税款凭证上注明的金额</p><h4 id="二出口免税但不退税">（二）出口免税但不退税</h4><p>部分企业出口货物，对外销售（出口）跨境应税服务免税但不退税。</p><h4 id="三出口既不免税也不退税即出口需要征税">（三）出口既不免税也不退税（即出口需要征税）</h4><p>部分企业适用出口既不免税也不征税。</p><h4 id="四出口退税率">（四）出口退税率</h4><p>出口退税率基本出口企业应将不同税率的货物分开核算和申报，未分开报关、核算或划分不清的，一律从低适用退税率计算退免税。</p><h3 id="十三增值税税收优惠">十三、增值税税收优惠</h3><h4 id="一免税货物">（一）免税货物</h4><p>（1）农业生产者销售的自产农产品。</p><p>（2）避孕药品和用具。</p><p>（3）古旧图书（向社会收购的古书和旧书）。</p><p>（4）直接用于科学研究、科学试验和教学的进口仪器和设备。</p><p>（5）外国政府、国际组织无偿援助的进口物资和设备。</p><p>（6）由残疾人的组织直接进口供残疾人专用的物品。</p><p>（7）其他个人销售自己使用过的物品。</p><h4 id="二免税服务无形资产不动产项">（二）免税服务、无形资产、不动产项</h4><p>（1）托儿所、幼儿园提供的保育和教育服务。</p><p>（2）养老机构提供的养老服务。</p><p>（3）提供社区养老、托育、家政等服务取得的收入。</p><p>（4）婚姻介绍服务。</p><p>（5）殡葬服务。</p><p>（6）家政服务企业由员工制家政服务员提供家政服务取得的收入。</p><p>（7）医疗机构提供的医疗服务。</p><p>（8）从事学历教育的学校（不包括职业培训机构）提供的教育服务。</p><p>（9）政府举办的从事学历教育的高等、中等和初等学校（不含下属单位），举办进修班、培训班取得的全部归该学校所有的收入。</p><p>（10）残疾人本人为社会提供的服务。</p><p>（11）残疾人福利机构提供的育养服务。</p><p>（12）学生勤工俭学提供的服务。</p><p>（13）农业机耕、排灌、病虫害防治、植物保护、农牧保险以及相关技术培训业务，家禽、牲畜、水生动物的配种和疾病防治。</p><p>（14）将土地使用权转让给农业生产者用于农业生产。</p><p>（15）土地所有者出让土地使用权和土地使用者将土地使用权归还给土地所有者。</p><p>（16）纪念馆、博物馆、文化馆、文物保护单位管理机构、美术馆、展览馆、书画院、图书馆在自己的场所提供文化体育服务取得的第一道门票收入。</p><p>（17）寺院、宫观、清真寺和教堂举办文化、宗教活动的门票收入。</p><p>（18）福利彩票、体育彩票的发行收入。</p><p>（19）金融同业往来利息收入。</p><p>（20）行政单位之外的其他单位收取的符合规定的政府性基金和行政事业性收费。</p><p>（21）个人转让著作权。</p><p>（22）个人销售自建自用住房。</p><p>（23）纳税人提供技术转让、技术开发和与之相关的技术咨询、技术服务。</p><p>（24）涉及家庭财产分割的个人无偿转让不动产、土地使用权。</p><p>（25）对法律援助人员按照《中华人民共和国法律援助法》规定获得的法律援助补贴。</p><h4 id="三增值税即征即退项目">（三）增值税即征即退项目</h4><p>一般纳税人提供下列服务，对实际税负超过 3%的部分实行增值税即征即退政策：</p><p>（1）管道运输服务。</p><p>（2）经批准从事融资租赁业务的一般纳税人，提供有形动产融资租赁服务和有形动产融资性售后回租服务。</p><p>（3）软件企业。</p><h4 id="四小规模纳税人免税政策">（四）小规模纳税人免税政策</h4><p>1.小规模纳税人销售额未达标准的免税政策</p><p>小规模纳税人合计月销售额未超过 10 万元（以 1 个季度为 1个纳税期的，季度销售额未超过 30 万元）的，免征增值税。具体规定如下：</p><p>（1）小规模纳税人合计月销售额超过 10万元，但扣除本期发生的销售不动产销售额后未超过 10万元的，其销售货物、劳务、服务、无形资产取得的销售额免征增值税。</p><p>（2）适用增值税差额征税政策的小规模纳税人，以差额后的销售额确定是否可以享受上述规定的免征增值税政策。</p><p>（3）按规定应当预缴增值税的小规模纳税人，凡在预缴地实现的月销售额未超过10 万元的，无须预缴税款。</p><p>（4）适用于上述免税政策的，可就该笔销售收入选择放弃免税，并开具增值税专用发票。</p><p>2.小规模纳税人适用3%征收率项目的减税政策小规模纳税人适用 3%征收率的应税销售收入，减按 1% 征收率征税；适用 3%预征率的预缴增值税项目，减按 1% 预征率预缴。</p><h4 id="五扣减税款规定">（五）扣减税款规定</h4><p>（1）自 2023 年 1月 1 日至 2027 年 12月31日，自主就业退役士兵从事个体经营的，自办理个体工商户登记当月起，在 3年（36 个月）内按每户每年 20 000元为限额依次扣减其当年实际应缴纳的增值税、城市维护建设税、教育费附加、地方教育附加和个人所得税。限额标准最高可上浮20%，各省、自治区、直辖市人民政府可根据本地区实际情况在此幅度内确定具体限额标准。</p><p>（2）自 2023 年 1月 1 日至 2027 年 12月31日，企业招用自主就业退役士兵，与其签订1年以上期限劳动合同并依法缴纳社会保险费的，自签订劳动合同并缴纳社会保险当月起，在3年内按实际招用人数予以定额依次扣减增值税、城市维护建设税、教育费附加、地方教育附加和企业所得税优惠。定额标准为每人每年6 000 元，最高可上浮50%，各省、自治区、直辖市人民政府可根据本地区实际情况在此幅度内确定具体定额标准。</p><p>（3）对建档立卡贫困人口、持《就业创业证》或《就业失业登记证》的人员从事个体经营的，自办理个体工商户登记当月起，在3 年内按每户每年 12 000元为限额依次扣减其当年实际应缴纳的增值税、城市维护建设税、教育费附加、地方教育附加和个人所得税，最高可上浮20%。</p><h3 id="十四增值税的征收管理">十四、增值税的征收管理</h3><h4 id="一纳税义务发生时间">（一）纳税义务发生时间</h4><p>1.销售行为</p><p>一般规定：收讫销售款项或者取得索取销售款项凭据的当天。</p><p>特别注意：先开具发票的，为开具发票的当天。</p><p>2.进口货物</p><p>纳税义务发生时间为报关进口的当天。</p><p>3.扣缴义务</p><p>扣缴义务发生时间即为增值税纳税义务发生的当天。</p><h4 id="二纳税期限">（二）纳税期限</h4><p>1.申报期限</p><p>（1）增值税的纳税期限分别为 1 日、3日、5日、10 日、15日、1个月或者 1个季度</p><p>（2）不能按照固定期限纳税的，可以按次纳税</p><p>（3）小规模纳税人、银行、财务公司、信托投资公司、信用社以 1个季度为纳税期限</p><p>2.税款缴纳时限</p><p>（1）以 1个月或者 1 个季度为 1 个纳税期的，自期满之日起 15日内申报纳税</p><p>（2）以 1日、3日、5日、10 日或者 15 日为 1 个纳税期的，自期满之日起 5日内预缴税款，于次月 1 日起 15 日内申报纳税并结清上月税款</p><p>（3）进口货物，应当自海关填发进口增值税专用缴款书之日起 15日内缴纳税款</p><p>（三）增值税起征点</p><p>增值税的起征点的适用范围仅限于个人（包括个体工商户和其他个人）。</p><p>不适用于登记为一般纳税人的个体工商户。</p><p>按期纳税的：月销售额 5 000 ～20 000 元（含本数）。</p><p>按次纳税的：每次（日）销售额 300 ～ 500 元（含本数）。</p><p>提示：达到起征点之后仍然可以享受小规模纳税人的免税政策。</p><h3 id="十五增值税专用发票使用规定">十五、增值税专用发票使用规定</h3><p>在新办纳税人中实行增值税电子专用发票的规定</p><p>1.适用范围自2021年 1月21日起，在部分地区新办纳税人中实行专票电子化，受票方范围为全国。2.增值税专用发票电子化（以下简称为“电子专票”）</p><p>（1）电子专票由各省税务局监制，采用电子签名代替发票专用章，属于增值税专用发票，其法律效力、基本用途、基本使用规定等与增值税纸质专用发票相同。</p><p>（2）电子专票的发票代码为 12位。3.电子专票与纸质专票的衔接自各地专票电子化实行之日起，本地区需要开具增值税纸质普通发票、增值税电子普通发票（以下简称电子普票）、纸质专票、电子专票、纸质机动车销售统一发票和纸质二手车销售统一发票的新办纳税人，统一领取税务UKey 开具发票（免费发放）。</p><p>4.电子专票和纸质专票的领用和开具</p><p>（1）税务机关按照电子专票和纸质专票的合计数，为纳税人核定增值税专用发票领用数量。电子专票和纸质专票的增值税专用发票（增值税税控系统）最高开票限额应当相同。</p><p>（2）纳税人开票时，既可以开具电子专票，也可以开具纸质专票。受票方索取纸质专票的，开票方应当开具纸质专票。</p><p>（3）发生销货退回、开票有误、应税服务中止、销售折让，应开具红字电子专票。</p><h3 id="十六增值税实战篇">十六、增值税实战篇</h3><h4 id="一办税服务平台">（一）办税服务平台</h4><p>在实务中，纳税人开具发票、抵扣进项税额等行为都是通过金税系统完成的，金税系统由各类子系统构成，其中最主要的监管系统包括增值税发票开票软件、增值税发票综合服务平台、电子税务局申报系统。</p><p>“计算抵扣”进项税额是指有部分进项税额需由纳税人自主计算并记账，在申报时根据计算金额填写相应表格，电子税务局不会在申报时“验证”这类进项税额，例如公司员工因公出差取得的火车票，其进项税额由财务人员自行计算，纳税申报时填入“附列资料二”8b栏次。</p><h4 id="二增值税纳税申报表概览">（二）增值税纳税申报表概览</h4><p>一般纳税人增值税纳税申报表合并附加税费申报表后共有 7张申报表，其中纳税人必须填写的申报表共 4张，主要采集纳税人销售额、销项税额、进项税额相关的数据，并由此计算出纳税人本期应当缴纳的增值税及附加税费金额，若纳税人有加计抵减等特殊事项则按需选填其余3 张申报表。</p>]]></content>
      
      
      <categories>
          
          <category> 经济法基础 </category>
          
          <category> 第一章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 税法 </tag>
            
            <tag> 增值税 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Human类</title>
      <link href="/2024/05/15/human-lei/"/>
      <url>/2024/05/15/human-lei/</url>
      
        <content type="html"><![CDATA[<h1 id="功能说明">功能说明</h1><h2 id="类设计">类设计</h2><h3 id="human"><code>Human</code></h3><ul><li>基类，包含姓名、年龄、性别和类型属性。</li><li>提供显示函数 <code>show</code> 和重载的输出操作符<code>&lt;&lt;</code>。</li><li>提供比较操作符 <code>&lt;</code> 和 <code>&gt;</code>。</li><li>提供获取姓名、年龄、性别和类型的函数<code>getName</code>、<code>getAge</code>、<code>getGender</code> 和<code>getType</code>。</li><li>提供虚函数<code>getOrg</code>，子类需重写以返回具体机构（学校或公司）。</li></ul><h3 id="student"><code>Student</code></h3><ul><li>继承自 <code>Human</code> 类，增加学校属性。</li><li>重写 <code>show</code> 函数和 <code>getOrg</code>函数以显示和返回学校信息。</li></ul><h3 id="worker"><code>Worker</code></h3><ul><li>继承自 <code>Human</code> 类，增加公司属性。</li><li>重写 <code>show</code> 函数和 <code>getOrg</code>函数以显示和返回公司信息。</li></ul><h3 id="vectort"><code>Vector&lt;T&gt;</code></h3><ul><li>自定义的链表实现，用于存储 <code>Human</code> 类型指针。</li><li>提供添加元素 <code>add</code>、显示所有元素<code>dspAll</code>、转换为标准向量<code>tovec</code>、从标准向量添加元素 <code>addVec</code>、清空链表<code>clear</code> 和删除特定元素 <code>remove</code> 函数。</li></ul><h2 id="函数说明">函数说明</h2><h3 id="addhuman"><code>addHuman</code></h3><ul><li>添加信息，支持学生和打工人。</li><li>根据输入添加相应的 <code>Student</code> 或 <code>Worker</code>对象。</li></ul><h3 id="dsp"><code>Dsp</code></h3><ul><li>显示所有人的信息。</li></ul><h3 id="dspsorted"><code>dspsorted</code></h3><ul><li>按年龄排序后显示所有人的信息。</li></ul><h3 id="deletehuman"><code>DeleteHuman</code></h3><ul><li>删除指定姓名的人的信息。</li></ul><h3 id="savedata"><code>savedata</code></h3><ul><li>将所有人的数据保存到文件 <code>text.txt</code>。</li></ul><h3 id="loaddate"><code>loaddate</code></h3><ul><li>从文件 <code>text.txt</code> 加载数据。</li></ul><p>测试数据下载<a href="https://wwl.lanzoue.com/iXnjd1ytf3zi">链接</a></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> string filename = <span class="string">"text.txt"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span> {</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string gender;</span><br><span class="line">    string Type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Human</span>(string&amp; name, <span class="type">int</span> age, string&amp; gender, string&amp; type)</span><br><span class="line">        : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age), <span class="built_in">gender</span>(gender), <span class="built_in">Type</span>(type) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">(ostream&amp; cout)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; name &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; age &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; gender;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Human&amp; human) {</span><br><span class="line">        human.<span class="built_in">show</span>(cout);</span><br><span class="line">        <span class="keyword">return</span> cout;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(Human&amp; other) {</span><br><span class="line">        <span class="keyword">return</span> age &lt; other.age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(Human&amp; other) {</span><br><span class="line">        <span class="keyword">return</span> age &gt; other.age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getGender</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">getOrg</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">string <span class="title">getType</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Type;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Human {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string school;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(string&amp; name, <span class="type">int</span> age, string&amp; gender, string&amp; type, string&amp; school)</span><br><span class="line">        : <span class="built_in">Human</span>(name, age, gender, type), <span class="built_in">school</span>(school) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(ostream&amp; cout)</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        Human::<span class="built_in">show</span>(cout);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">15</span>) &lt;&lt; school;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Student&amp; student) {</span><br><span class="line">        student.<span class="built_in">show</span>(cout);</span><br><span class="line">        <span class="keyword">return</span> cout;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getOrg</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> school;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> : <span class="keyword">public</span> Human {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Worker</span>(string&amp; name, <span class="type">int</span> age, string&amp; gender, string&amp; type, string&amp; company)</span><br><span class="line">        : <span class="built_in">Human</span>(name, age, gender, type), <span class="built_in">company</span>(company) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(ostream&amp; cout)</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        Human::<span class="built_in">show</span>(cout);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">15</span>) &lt;&lt; company;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Worker&amp; worker) {</span><br><span class="line">        worker.<span class="built_in">show</span>(cout);</span><br><span class="line">        <span class="keyword">return</span> cout;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getOrg</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> company;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> {</span><br><span class="line">        T data;</span><br><span class="line">        Node* next;</span><br><span class="line">        <span class="built_in">Node</span>(T&amp; data) : <span class="built_in">data</span>(data), <span class="built_in">next</span>(<span class="literal">nullptr</span>) {}</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    Node* head;</span><br><span class="line">    Node* tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>() : <span class="built_in">head</span>(<span class="literal">nullptr</span>), <span class="built_in">tail</span>(<span class="literal">nullptr</span>) {}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(T element)</span> </span>{</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(element);</span><br><span class="line">        <span class="keyword">if</span> (tail != <span class="literal">nullptr</span>) {</span><br><span class="line">            tail-&gt;next = newNode;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            head = newNode;</span><br><span class="line">        }</span><br><span class="line">        tail = newNode;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dspAll</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"姓名"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"年龄"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"性别"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">15</span>) &lt;&lt; <span class="string">"学校/公司"</span> &lt;&lt; endl;</span><br><span class="line">        Node* Now = head;</span><br><span class="line">        <span class="keyword">while</span> (Now != <span class="literal">nullptr</span>) {</span><br><span class="line">            cout &lt;&lt; *(Now-&gt;data) &lt;&lt; endl;</span><br><span class="line">            Now = Now-&gt;next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;T&gt; <span class="title">tovec</span><span class="params">()</span> </span>{</span><br><span class="line">        vector&lt;T&gt; vec;</span><br><span class="line">        Node* Now = head;</span><br><span class="line">        <span class="keyword">while</span> (Now != <span class="literal">nullptr</span>) {</span><br><span class="line">            vec.<span class="built_in">push_back</span>(Now-&gt;data);</span><br><span class="line">            Now = Now-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addVec</span><span class="params">(vector&lt;T&gt;&amp; vec)</span> </span>{</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "cleared" &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : vec) {</span><br><span class="line">            <span class="built_in">add</span>(it);</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "add" &lt;&lt; endl;</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>{</span><br><span class="line">        Node* Now = head;</span><br><span class="line">        <span class="keyword">while</span> (Now != <span class="literal">nullptr</span>) {</span><br><span class="line">            Node* next = Now-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> Now;</span><br><span class="line">            Now = next;</span><br><span class="line">        }</span><br><span class="line">        head = <span class="literal">nullptr</span>;</span><br><span class="line">        tail = <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(string&amp; name)</span> </span>{</span><br><span class="line">        Node* Now = head;</span><br><span class="line">        Node* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (Now != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">if</span> (Now-&gt;data-&gt;<span class="built_in">getName</span>() == name) {</span><br><span class="line">                <span class="keyword">if</span> (pre != <span class="literal">nullptr</span>) {</span><br><span class="line">                    pre-&gt;next = Now-&gt;next;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    head = Now-&gt;next;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (Now == tail) {</span><br><span class="line">                    tail = pre;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">delete</span> Now-&gt;data;</span><br><span class="line">                <span class="keyword">delete</span> Now;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            pre = Now;</span><br><span class="line">            Now = Now-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addHuman</span><span class="params">(Vector&lt;Human*&gt;&amp; humans)</span> </span>{</span><br><span class="line">    string type;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"输入 s 添加 学生, w 添加 打工人, -1结束添加: "</span>;</span><br><span class="line">        cin &gt;&gt; type;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="string">"-1"</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type != <span class="string">"s"</span> &amp;&amp; type != <span class="string">"w"</span>) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"无效的选择，请重新输入。"</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        string name, gender, school, company;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        cout &lt;&lt; <span class="string">"输入姓名: "</span>;</span><br><span class="line">        cin &gt;&gt; name;</span><br><span class="line">        cout &lt;&lt; <span class="string">"输入年龄: "</span>;</span><br><span class="line">        cin &gt;&gt; age;</span><br><span class="line">        cout &lt;&lt; <span class="string">"输入性别: "</span>;</span><br><span class="line">        cin &gt;&gt; gender;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type == <span class="string">"s"</span>) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"输入学校: "</span>;</span><br><span class="line">            cin &gt;&gt; school;</span><br><span class="line">            humans.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">Student</span>(name, age, gender, type, school));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            cout &lt;&lt; <span class="string">"输入公司: "</span>;</span><br><span class="line">            cin &gt;&gt; company;</span><br><span class="line">            humans.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">Worker</span>(name, age, gender, type, company));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dsp</span><span class="params">(Vector&lt;Human*&gt;&amp; humans)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n所有人信息:\n"</span>;</span><br><span class="line">    humans.<span class="built_in">dspAll</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dspsorted</span><span class="params">(Vector&lt;Human*&gt;&amp; humans)</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> vec = humans.<span class="built_in">tovec</span>();</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](Human* a, Human* b) { <span class="keyword">return</span> *a &lt; *b; } );</span><br><span class="line">    Vector&lt;Human*&gt; sortedHumans;</span><br><span class="line">    sortedHumans.<span class="built_in">addVec</span>(vec);</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n按年龄排序后的人信息:\n"</span>;</span><br><span class="line">    sortedHumans.<span class="built_in">dspAll</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteHuman</span><span class="params">(Vector&lt;Human*&gt;&amp; humans)</span> </span>{</span><br><span class="line">    string dname;</span><br><span class="line">    cout &lt;&lt; <span class="string">"\n输入要删除的人的姓名: "</span>;</span><br><span class="line">    cin &gt;&gt; dname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (humans.<span class="built_in">remove</span>(dname)) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"\n删除后的人信息:\n"</span>;</span><br><span class="line">        humans.<span class="built_in">dspAll</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"未找到该人!"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">savedata</span><span class="params">(Vector&lt;Human*&gt;&amp; humans)</span> </span>{</span><br><span class="line">    <span class="function">ofstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) {</span><br><span class="line">        <span class="comment">/*Node* Now = head;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        while (Now != nullptr) {</span></span><br><span class="line"><span class="comment">            file &lt;&lt; Now-&gt;getType() &lt;&lt; ' ' &lt;&lt; human-&gt;getName() &lt;&lt; ' ' &lt;&lt; human-&gt;getAge() &lt;&lt; ' ' &lt;&lt; human-&gt;getGender() &lt;&lt; ' ' &lt;&lt; human-&gt;getOrg() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">            Now = Now-&gt;next;</span></span><br><span class="line"><span class="comment">        }*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> vec = humans.<span class="built_in">tovec</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; human : vec) {</span><br><span class="line">            file &lt;&lt; human-&gt;<span class="built_in">getType</span>() &lt;&lt; <span class="string">' '</span> &lt;&lt; human-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">' '</span> &lt;&lt; human-&gt;<span class="built_in">getAge</span>() &lt;&lt; <span class="string">' '</span> &lt;&lt; human-&gt;<span class="built_in">getGender</span>() &lt;&lt; <span class="string">' '</span> &lt;&lt; human-&gt;<span class="built_in">getOrg</span>() &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">"数据已保存到 "</span> &lt;&lt; filename &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"无法打开文件 "</span> &lt;&lt; filename &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loaddate</span><span class="params">(Vector&lt;Human*&gt;&amp; humans)</span> </span>{</span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) {</span><br><span class="line">        humans.<span class="built_in">clear</span>();</span><br><span class="line">        string type, name, gender, Org;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        <span class="keyword">while</span> (file &gt;&gt; type &gt;&gt; name &gt;&gt; age &gt;&gt; gender &gt;&gt; ws) {</span><br><span class="line">            <span class="built_in">getline</span>(file, Org);</span><br><span class="line">            <span class="keyword">if</span> (type == <span class="string">"s"</span>) {</span><br><span class="line">                humans.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">Student</span>(name, age, gender, type, Org));</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">"w"</span>) {</span><br><span class="line">                humans.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">Worker</span>(name, age, gender, type, Org));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">"数据已从 "</span> &lt;&lt; filename &lt;&lt; <span class="string">" 读取"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"无法打开文件 "</span> &lt;&lt; filename &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Vector&lt;Human*&gt; humans;</span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"-----------------------------------------------\n"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"选择操作:\n"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"1. 添加人\n"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"2. 打印所有信息\n"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"3. 按年龄排序后输出信息\n"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"4. 删除一个人的信息\n"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"5. 从文件加载数据\n"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"6. 保存数据到文件\n"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"7. 退出\n"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"输入选择: "</span>;</span><br><span class="line">        cin &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (choice) {</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">addHuman</span>(humans);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">Dsp</span>(humans);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">dspsorted</span>(humans);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">DeleteHuman</span>(humans);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="built_in">loaddate</span>(humans);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="built_in">savedata</span>(humans);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">"无效的选择，请重新输入。"</span> &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> c/c++ </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第五节 充分统计量</title>
      <link href="/2024/05/13/shu-li-tong-ji-5-5-chong-fen-tong-ji-liang/"/>
      <url>/2024/05/13/shu-li-tong-ji-5-5-chong-fen-tong-ji-liang/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iIc031ymoyri">下载PDF点这里</a></p><p><img src="../../../../images/数理统计5-5充分统计量/数理统计5.5-22.jpg"></p><p><img src="../../../../images/数理统计5-5充分统计量/数理统计5.5-23.jpg"></p><p><img src="../../../../images/数理统计5-5充分统计量/数理统计5.5-24.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数理统计 </category>
          
          <category> 第一章 统计量及其分布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 充分统计量 </tag>
            
            <tag> 因子分解定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四节 三大抽样分布</title>
      <link href="/2024/05/13/shu-li-tong-ji-5-4-san-da-chou-yang-fen-bu/"/>
      <url>/2024/05/13/shu-li-tong-ji-5-4-san-da-chou-yang-fen-bu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iFxIk1ymnw3g">下载PDF点这里</a></p><p><img src="../../../../images/数理统计5-4三大抽样分布/数理统计5.4-16.jpg"></p><p><img src="../../../../images/数理统计5-4三大抽样分布/数理统计5.4-17.jpg"></p><p><img src="../../../../images/数理统计5-4三大抽样分布/数理统计5.4-18.jpg"></p><p><img src="../../../../images/数理统计5-4三大抽样分布/数理统计5.4-19.jpg"></p><p><img src="../../../../images/数理统计5-4三大抽样分布/数理统计5.4-20.jpg"></p><p><img src="../../../../images/数理统计5-4三大抽样分布/数理统计5.4-21.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数理统计 </category>
          
          <category> 第一章 统计量及其分布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 卡方分布 </tag>
            
            <tag> F分布 </tag>
            
            <tag> t分布 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可行解、基本解、基本可行解</title>
      <link href="/2024/05/13/tu-you-hua-xian-xing-gui-hua-ke-xing-jie-ji-ben-jie-ji-ben-ke-xing-jie/"/>
      <url>/2024/05/13/tu-you-hua-xian-xing-gui-hua-ke-xing-jie-ji-ben-jie-ji-ben-ke-xing-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="可行解">可行解</h2><p><strong>可行解</strong>按字面意义就可以理解：可行的解。</p><p>什么是可行？符合所有约束条件就可行，否则不可行。</p><h2 id="基本解与基本可行解">基本解与基本可行解</h2><p><strong>基本解</strong>和<strong>基本可行解</strong>，都可以认为是为了求解线性规划问题而发明的概念。</p><p>对于简单的线性规划问题，可以通过做图的方式来进行求解（就像高中的线性规划问题一样）。那线性规划不画图应该怎么求解呢？答案是按多元一次方程组来求。</p><h3 id="基本解">基本解</h3><p>线性规划的标准形式为： <span class="math display">\[\begin{aligned}\min \quad&amp; \boldsymbol{c}^{\top} \boldsymbol{x} \\\text { s.t. }\quad &amp; \boldsymbol{A x}=\boldsymbol{b} \\&amp; \boldsymbol{x} \geqslant \mathbf{0}\end{aligned}\]</span></p><p>其中, <span class="math inline">\(\boldsymbol{c} \in \mathbb{R}^n,\boldsymbol{b} \in \mathbb{R}^m, \boldsymbol{b} \geqslant \mathbf{0},\boldsymbol{A} \in \mathbb{R}^{m \times n}, m \leqslant n\)</span>。</p><p>线性规划都可以转化为标准型来进行求解（<a href="https://studyincau.github.io/2024/05/13/tu-you-hua-xian-xing-gui-hua-xian-xing-gui-hua-de-biao-zhun-xing-shi-ji-ji-ben-gai-nian/">不知道的看这篇文章</a>）</p><p>约束条件中 <span class="math inline">\(\boldsymbol{Ax}=\boldsymbol{b}\)</span> 是资源约束条件，假如有 <span class="math inline">\(m\)</span> 个约束条件，那 <span class="math inline">\(\boldsymbol{A x}=\boldsymbol{b}\)</span> 就有<span class="math inline">\(m\)</span> 个方程。为了求 <span class="math inline">\(\boldsymbol{x}\)</span>中各未知量的值，我们只要能求解这个方程组就可以了。多元一次方程组用消元法就可以求解，有唯一解的条件是未知量的个数刚好等于方程组的个数( <span class="math inline">\(n=m\)</span> )。</p><p>可实际情况往往是 <span class="math inline">\(n&gt;m\)</span>的。这种情况怎么做呢? 很简单，想办法让 <span class="math inline">\(n=m\)</span> ，这就用到了基 <span class="math inline">\(\boldsymbol{B}\)</span> 的概念。把 <span class="math inline">\(\boldsymbol{A}\)</span> 分成 <span class="math inline">\(n\)</span> 个列向量，从中任意取出了 <span class="math inline">\(m\)</span> 个，当然这 <span class="math inline">\(m\)</span>个列向量必须是线性无关的，就是说不能有哪一个可以用剩下的 <span class="math inline">\(m-1\)</span> 个表示出来，要不相当于少取了一个。这<span class="math inline">\(m\)</span> 个列向量就是一个基 <span class="math inline">\(\boldsymbol{B}\)</span> ，也叫作基矩阵 。从 <span class="math inline">\(\boldsymbol{A}\)</span> 中去除 <span class="math inline">\(\boldsymbol{B}\)</span> ，剩下的 <span class="math inline">\(n-m\)</span> 个列向量组成的矩阵就是非基 <span class="math inline">\(\boldsymbol{N}\)</span> ，或者叫非基矩阵。基 <span class="math inline">\(\boldsymbol{B}\)</span> 对应的变量 <span class="math inline">\(\boldsymbol{x_B}\)</span> 叫作基变量 ，非基 <span class="math inline">\(\boldsymbol{N}\)</span> 对应的变量 <span class="math inline">\(\boldsymbol{x_N}\)</span> 叫作非基变量。第一个约束条件也就写成了: <span class="math display">\[[\boldsymbol{B}, \boldsymbol{N}]\left[\begin{array}{l}\boldsymbol{x_B} \\\boldsymbol{x_N}\end{array}\right]=\boldsymbol{b}\]</span> 只要把 <span class="math inline">\(\boldsymbol{x_N}\)</span>中的变量都设为 <span class="math inline">\(0\)</span> 上式就变成了 <span class="math inline">\(\boldsymbol{B}\boldsymbol{x_B}=\boldsymbol{b}\)</span>, 这是 <span class="math inline">\(m\)</span> 个线性无关的 <span class="math inline">\(m\)</span> 元一次方程组，消元法就可以解出来 <span class="math inline">\(\boldsymbol{x_B}\)</span> , 再带上 <span class="math inline">\(\boldsymbol{x_N}=\boldsymbol{0}\)</span> 得出的<span class="math inline">\([\boldsymbol{B}^{-1}\boldsymbol{b},\boldsymbol{0}]^{\top}\)</span>就是原约束条件 <span class="math inline">\(\boldsymbol{A}\boldsymbol{x}=\boldsymbol{b}\)</span>的解，这个解就是一个<strong>基本解</strong>。</p><h3 id="基本可行解">基本可行解</h3><p>基本解不一定是可行解，因为它只满足了第一个约束，不一定满足第二个约束。基本解中所有变量均非负（满足第二个约束条件）的才能满足所有约束，这种基本解叫作<strong>基本可行解</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 最优化方法 </category>
          
          <category> 线性规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性规划 </tag>
            
            <tag> 可行解 </tag>
            
            <tag> 基本解 </tag>
            
            <tag> 基本可行解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性规划的标准形式及基本概念</title>
      <link href="/2024/05/13/tu-you-hua-xian-xing-gui-hua-xian-xing-gui-hua-de-biao-zhun-xing-shi-ji-ji-ben-gai-nian/"/>
      <url>/2024/05/13/tu-you-hua-xian-xing-gui-hua-xian-xing-gui-hua-de-biao-zhun-xing-shi-ji-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<p>正在努力码字中~</p>]]></content>
      
      
      <categories>
          
          <category> 最优化方法 </category>
          
          <category> 线性规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性规划 </tag>
            
            <tag> 可行解 </tag>
            
            <tag> 基本解 </tag>
            
            <tag> 基本可行解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论习题(4)</title>
      <link href="/2024/05/10/gai-lu-lun-5-2-gai-lu-lun-qi-mo-fu-xi-xi-ti-4/"/>
      <url>/2024/05/10/gai-lu-lun-5-2-gai-lu-lun-qi-mo-fu-xi-xi-ti-4/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/igWDk1yeq05g">下载完整PDF点这里</a></p><h2 id="t70">t70</h2><blockquote><p>设随机变量 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 相互独立, <span class="math inline">\(X\)</span> 服从参数为 1 的指数分布, <span class="math inline">\(Y\)</span> 的概率分布为 <span class="math inline">\(P\{Y=-1\}=p, P\{Y=1\}=1-p\)</span>, 令 <span class="math inline">\(Z=XY\)</span>. （1） 求 <span class="math inline">\(Z\)</span> 的概率密度; （2）求 <span class="math inline">\(p\)</span> 为何值时， <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Z\)</span> 不相关. （3） 问 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Z\)</span> 是否相互独立?</p></blockquote><h3 id="解析">解析</h3><p>（1） <span class="math inline">\(Z\)</span> 的分布函数为 <span class="math display">\[\begin{aligned}F_Z(z) &amp; =P\{Z \leqslant z\} \\&amp; =P\{Y=-1\} \dot{P}\{X Y \leqslant z \mid Y=-1\}+P\{Y=1\} P\{X Y\leqslant z \mid Y=1\} \\&amp; =p P\{-X \leqslant z\}+(1-p) P\{X \leqslant z\} .\end{aligned}\]</span></p><p>当 <span class="math inline">\(z&lt;0\)</span> 时, <span class="math inline">\(F_Z(z)=p P\{X \geqslant-z\}+(1-p) \cdot 0=p\mathrm{e}^z\)</span>; 当 <span class="math inline">\(z \geqslant0\)</span> 时, <span class="math inline">\(F_Z(z)=p \cdot 1+(1-p) P\{X\leqslant z\}=1-(1-p) \mathrm{e}^{-z}\)</span>. 所以 <span class="math inline">\(Z\)</span> 的概率密度为 <span class="math display">\[\begin{aligned}f_Z(z)=F_Z^{\prime}(z) &amp; = \begin{cases}p \mathrm{e}^z, &amp;z&lt;0, \\(1-p) \mathrm{e}^{-z}, &amp; z \geqslant 0 .\end{cases} \\\end{aligned}\]</span></p><p>（2） <span class="math display">\[\begin{aligned}\operatorname{Cov}(X, Z) &amp; =\operatorname{Cov}(X,XY)\\&amp; =E\left(X^2 Y\right)-E (X) \cdot E(X Y) \\&amp; =E\left(X^2\right) \cdot E(Y)-(E X)^2 \cdot E(Y) \\&amp; =\operatorname{Var}(X) \cdot (Y) \\&amp; =1-2 p,\end{aligned}\]</span> 令 <span class="math inline">\(\operatorname{Cov}(X,Z)=0\)</span>, 解得 <span class="math inline">\(p=\dfrac{1}{2}\)</span>.所以当 <span class="math inline">\(p=\dfrac{1}{2}\)</span> 时, <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Z\)</span> 不相关. (3) 因为 <span class="math display">\[\begin{gathered}P\{X \leqslant 1, Z \leqslant-1\}=P\{X \leqslant 1, X Y \leqslant-1\}=0,\\P\{X \leqslant 1\}&gt;0, P\{Z \leqslant-1\}&gt;0,\end{gathered}\]</span></p><p>所以 <span class="math inline">\(P\{X \leqslant 1, Z \leqslant-1\}\neq P\{X \leqslant 1\} P\{Z \leqslant-1\}\)</span>, 故 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Z\)</span> 不相互独立.</p><hr><h2 id="t71">t71</h2><blockquote><p>设 <span class="math inline">\(X, Y\)</span> 为两个随机变量, 且 <span class="math inline">\(E X=2, E Y=1, \operatorname{Var}(X)=4,\operatorname{Var}(Y)=25, \rho_{XY}=-\dfrac{3}{5}\)</span>, 求 <span class="math inline">\(E[X(X+Y-2)]\)</span>.</p></blockquote><h3 id="解析-1">解析</h3><p><span class="math display">\[\begin{aligned}E[X(X+Y-2)]&amp;=E(X^2+XY-2X)\\&amp;=E(X^2)+E(XY)-2E(X)\\&amp;=\operatorname{Var}(X)+(E(X))^2+E(XY)-2E(X)\\&amp;=4+E(XY)\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}\operatorname{Corr}(X,Y)&amp;=\dfrac{\operatorname{Cov}(X,Y)}{\sigma_X\sigma_Y}=\dfrac{E(XY)-E(X)E(Y)}{10}\\&amp;=\dfrac{E(XY)-2}{10}\\&amp;=-\dfrac{3}{5}\end{aligned}\]</span></p><p>解得 <span class="math inline">\(E(XY)=-4\)</span> 再代入上式，得<span class="math inline">\(E[X(X+Y-2)]=0.\)</span></p><hr><h2 id="t72">t72</h2><blockquote><p>设随机变量 <span class="math inline">\(\mathrm{X}\)</span> 和 <span class="math inline">\(\mathrm{Y}\)</span> 相互独立, 分别服从参数为 <span class="math inline">\(\lambda_1, \lambda_2\)</span> 的指数分布,证明随机变量 <span class="math inline">\(\mathrm{U}\)</span> <span class="math inline">\(=\mathrm{X}-\mathrm{Y}\)</span> 和 <span class="math inline">\(\mathrm{V}=\min \{\mathrm{X},\mathrm{Y}\}\)</span> 相互独立.</p></blockquote><h3 id="解析-2">解析</h3><p><img src="../../../../images/概率论5-2期末考试习题/23.jpg"></p><hr><h2 id="t73">t73</h2><blockquote><p>默写大数定律和中心极限定理</p></blockquote><h3 id="答案">答案</h3><p>见《知识点总结》<span class="math inline">\(\S4.3、\S4.4.\)</span></p><hr><h2 id="t74">t74</h2><blockquote><p>设 <span class="math inline">\(\left\{X_i\right\}\)</span>是独立同分布的随机变量序列, 且 <span class="math inline">\(X_i \simU(0,1)\)</span>, 令 <span class="math inline">\(\displaystyleY_n=\left(\prod_{i=1}^n X_i\right)^{\frac{1}{n}}\)</span> 证明: <span class="math inline">\(\ln Y_n \xrightarrow{P} C\)</span>,并求出该常数.</p></blockquote><h3 id="解析-3">解析</h3><p><span class="math inline">\(\displaystyle \lnY_n=\dfrac{1}{n}\sum_{i=1}^n \ln X_i\)</span></p><p>由于 <span class="math inline">\(\left\{X_i\right\}\)</span>是独立同分布的随机变量序列, 则 <span class="math inline">\(\left\{\lnX_i\right\}\)</span> 也是独立同分布的随机变量序列。</p><p><span class="math inline">\(\displaystyle E\left(\lnX_i\right)=\int_0^1\ln xdx=-1\)</span> 由辛钦大数定律得: <span class="math inline">\(\displaystyle \ln Y_n=\frac{1}{n} \sum_{i=1}^n \lnX_i \xrightarrow{P} \frac{1}{n}\sum_{i=1}^nE\left(\lnX_i\right)=-1\)</span></p><p><span class="math inline">\(C=-1.\)</span></p><hr><h2 id="t75">t75</h2><blockquote><p>设 <span class="math inline">\(\left\{X_n\right\}\)</span>为独立的随机变量序列, 其中 <span class="math inline">\(X_n\)</span>服从参数为 <span class="math inline">\(\sqrt{n}\)</span> 的泊松分布,试问 <span class="math inline">\(\left\{X_n\right\}\)</span>是否服从大数定律?</p></blockquote><h3 id="解析-4">解析</h3><p><span class="math display">\[\frac{1}{n^2} \operatorname{Var}\left(\sum_{i=1}^n X_i\right) \leqslant\frac{n \sqrt{n}}{n^2} \rightarrow 0 \quad(n \rightarrow \infty) .\]</span></p><p>所以由马尔可夫大数定律知 <span class="math inline">\(\left\{X_n\right\}\)</span> 服从大数定律.</p><hr><h2 id="t76">t76</h2><blockquote><p>设 <span class="math inline">\(\left\{X_n\right\}\)</span>为独立同分布的随机变量序列, 其共同分布为 <span class="math display">\[P\left(X_n=\frac{2^k}{k^2}\right)=\frac{1}{2^k}, \quad k=1,2, \cdots .\]</span></p><p>试问 <span class="math inline">\(\left\{X_n\right\}\)</span>是否服从大数定律?</p></blockquote><h3 id="解析-5">解析</h3><p>因为 <span class="math display">\[E\left(X_n\right)=\sum_{k=1}^{\infty} \frac{2^k}{k^2} \cdot\frac{1}{2^k}=\sum_{k=1}^{\infty}\frac{1}{k^2}=\frac{\pi^2}{6}&lt;\infty,\]</span></p><p>即 <span class="math inline">\(E\left(X_n\right)\)</span> 存在,所以由辛钦大数定律知 <span class="math inline">\(\left\{X_n\right\}\)</span> 服从大数定律.</p><hr><h2 id="t77">t77</h2><blockquote><p>在伯努利试验中, 事件 <span class="math inline">\(A\)</span>出现的概率为 <span class="math inline">\(p\)</span>, 令 <span class="math display">\[X_n= \begin{cases}1, &amp; \text { 若在第 } n \text { 次及第 } n+1 \text{ 次试验中 } A \text { 都出现, } \\ 0, &amp; \text { 其他. }\end{cases}\]</span></p><p>证明 <span class="math inline">\(\left\{X_n\right\}\)</span>服从大数定律.</p></blockquote><h3 id="解析-6">解析</h3><p><span class="math inline">\(\left\{X_n\right\}\)</span>为同分布随机变量序列, 其共同分布为 <span class="math display">\[\begin{array}{c|cc}\hline X_n  &amp; 0 &amp; 1 \\\hline P &amp; 1-p^2 &amp; p^2 \\\hline\end{array}\]</span> 且 <span class="math inline">\(E\left(X_n\right)=E\left(X_n^2\right)=p^2\)</span>,从而 <span class="math inline">\(\operatorname{Var}\left(X_n\right)=p^2\left(1-p^2\right)\leqslant 1\)</span>, 又当 <span class="math inline">\(|i-j| \geqslant2\)</span> 时, <span class="math inline">\(X_i\)</span> 与 <span class="math inline">\(X_j\)</span> 独立，所以 <span class="math display">\[\frac{1}{n^2} \operatorname{Var}\left(\sum_{i=1}^nX_i\right)=\frac{1}{n^2}\left[\sum_{i=1}^n\operatorname{Var}\left(X_i\right)+2 \sum_{i=1}^{n-1}\operatorname{Cov}\left(X_i, X_{i+1}\right)\right] .\]</span></p><p>由施瓦茨不等式： <span class="math display">\[\left|\operatorname{Cov}\left(X_i, X_{i+1}\right)\right| \leqslant\sqrt{\operatorname{Var}\left(X_i\right)}\sqrt{\operatorname{Var}\left(X_{i+1}\right)}=p^2\left(1-p^2\right),\]</span></p><p>于是有 <span class="math display">\[\frac{1}{n^2} \operatorname{Var}\left(\sum_{i=1}^n X_i\right) \leqslant\frac{1}{n^2}\left[n p^2\left(1-p^2\right)+2(n-1)p^2\left(1-p^2\right)\right] \rightarrow 0 \quad(n \rightarrow \infty),\]</span></p><p>即马尔可夫条件成立, 故 <span class="math inline">\(\left\{X_n\right\}\)</span> 服从大数定律.</p><hr><h2 id="t78">t78</h2><blockquote><p>某型号螺丝钉的质量是相互独立且同分布的随机变量, 其期望为 <span class="math inline">\(50 \mathrm{~g}\)</span>, 标准差 5 克,则 100个该型号得螺丝钉质量不超过 <span class="math inline">\(5.1\mathrm{~kg}\)</span> 的概率近似为？</p></blockquote><h3 id="解析-7">解析</h3><p>设 <span class="math inline">\(\displaystyle Y=\sum_{i=1}^{100}X_i\)</span>由题意得, 各螺丝质量独立同分布, 由中心极限定理值,其质量近似服从正态分布，即： <span class="math inline">\(Y\simN\left(5,0.05^2\right)\)</span> (单位:千克)</p><p>进而计算有: <span class="math display">\[P\left\{\sum_{i=1}^{100} X_i \leq5.1\right\}=P\left\{\frac{\displaystyle \sum_{i=1}^{100}X_i-5}{\sqrt{0.05^2}} \leq \frac{5.1-5}{\sqrt{0.05^2}}\right\} \approx\Phi(2)\]</span></p><hr><h2 id="t79">t79</h2><blockquote><p>设某生产线上组装每件产品的时间服从指数分布, 平均需要 <span class="math inline">\(10 \mathrm{~min}\)</span>,且各件产品的组装时间是相互独立的. (1) 试求组装 100 件产品需要 <span class="math inline">\(15 \mathrm{~h}\)</span> 至 <span class="math inline">\(20 \mathrm{~h}\)</span> 的概率; (2) 保证有 <span class="math inline">\(95 \%\)</span> 的可能性, 问 <span class="math inline">\(16 \mathrm{~h}\)</span>内最多可以组装多少件产品?</p></blockquote><h3 id="解析-8">解析</h3><p>记 <span class="math inline">\(X_i\)</span> 为组装第 <span class="math inline">\(i\)</span> 件产品的时间 (单位: <span class="math inline">\(\min\)</span> ), 则由 <span class="math inline">\(X_i \sim \operatorname{Exp}(\lambda),E\left(X_i\right)=1 / \lambda=\)</span> 10 , 知 <span class="math inline">\(\operatorname{Var}\left(X_i\right)=1 /\lambda^2=100\)</span>. （1）根据题意所求概率如下,再用林德伯格一莱维中心极限定理可得 <span class="math display">\[\begin{aligned}P\left(15 \times 60 \leqslant \sum_{i=1}^{100} X_i \leqslant 20 \times60\right) &amp; \approx \Phi\left(\frac{1200-100 \times 10}{\sqrt{100\times 100}}\right)-\Phi\left(\frac{900-100 \times 10}{\sqrt{100 \times100}}\right) \\&amp; =\Phi(2)-\Phi(-1)=\Phi(2)+\Phi(1)-1=0.8185\end{aligned}\]</span> （2）设 <span class="math inline">\(16 \mathrm{~h}\)</span>内最多可以组装 <span class="math inline">\(k\)</span> 件产品.则根据题意可列出概率不等式 <span class="math display">\[P\left(\sum_{i=1}^k X_i \leqslant 16 \times 60\right) \geqslant 0.95,\]</span></p><p>​ 再用林德伯格－莱维中心极限定理可得 <span class="math display">\[\Phi\left(\frac{960-10 k}{\sqrt{100 k}}\right) \geqslant 0.95,\]</span></p><p>​ 由此查表得 <span class="math inline">\(\dfrac{960-10 k}{10 \sqrt{k}}\geqslant 1.645\)</span>, 从中解得 <span class="math inline">\(k=81\)</span>.</p><hr><h2 id="t80">t80</h2><blockquote><p>一家有 500 间客房的大旅馆的每间客房装有一台 <span class="math inline">\(2 \mathrm{~kW}\)</span> (千瓦) 的空调机.若开房率为 <span class="math inline">\(80 \%\)</span>,需要多少千瓦的电力才能有 <span class="math inline">\(99 \%\)</span>的可能性保证有足够的电力使用空调机?</p></blockquote><h3 id="解析-9">解析</h3><p>记 <span class="math display">\[X_i= \begin{cases}1, &amp; \text { 第 } i \text { 间客房开房, } \\ 0,&amp; \text { 第 } i \text { 间客房未开房, }\end{cases}\]</span></p><p>则 <span class="math inline">\(X_i \sim b(1,0.8)\)</span>, 由此得<span class="math inline">\(Y=X_1+X_2+\cdots+X_{500} \simb(500,0.8)\)</span>. 设共有 <span class="math inline">\(k\mathrm{~kW}\)</span> 的电力可供使用, 根据题意可列不等式 <span class="math display">\[P(2 Y \leqslant k)=P(Y \leqslant k / 2) \geqslant 0.99,\]</span></p><p>再用棣莫弗一拉普拉斯中心极限定理和修正项可得 <span class="math display">\[\Phi\left(\frac{k / 2+0.5-500 \times 0.8}{\sqrt{500 \times 0.8 \times0.2}}\right) \geqslant 0.99,\]</span></p><p>或 <span class="math display">\[\Phi\left(\frac{k-799}{8 \sqrt{5}}\right) \geqslant 0.99\]</span></p><p>由此查表得 <span class="math inline">\(\dfrac{k-799}{8 \sqrt{5}}\geqslant 2.33\)</span>, 从中解得 <span class="math inline">\(k\geqslant 840.68\)</span>, 取 <span class="math inline">\(k=841\mathrm{~kW}\)</span> 即可.这表明: 该旅馆每天需要 <span class="math inline">\(841 \mathrm{~kW}\)</span> 电力, 才能以 <span class="math inline">\(99 \%\)</span> 的把握保证空调机用电.</p><hr><h2 id="t81">t81</h2><blockquote><p>某保险公司多年的统计资料表明, 在索赔户中被盗索赔户占 <span class="math inline">\(20 \%\)</span>, 以 <span class="math inline">\(X\)</span> 表示在随意抽查的 100个索赔户中因被盗向保险公司索赔的户数. (1) 写出 <span class="math inline">\(X\)</span> 的分布列; (2) 求被盗索赔户不少于 14户且不多于 30 户的概率的近似值.</p></blockquote><h3 id="解析-10">解析</h3><ol type="1"><li><span class="math inline">\(X\)</span> 服从 <span class="math inline">\(n=100, p=0.2\)</span> 的二项分布 <span class="math inline">\(b(100,0.2)\)</span>, 即 <span class="math display">\[P(X=k)=\binom{100}{k} 0.2^k 0.8^{100-k}, \quad k=0,1,2, \cdots, 100 .\]</span></li><li>利用棣莫弗一拉普拉斯中心极限定理并修正项，有 <span class="math display">\[\begin{aligned}P(14 \leqslant X \leqslant 30) &amp; =P(13.5&lt;X&lt;30.5) \\&amp; \approx \Phi\left(\frac{30.5-100 \times 0.2}{\sqrt{100 \times 0.2\times 0.8}}\right)-\Phi\left(\frac{13.5-100 \times 0.2}{\sqrt{100\times 0.2 \times 0.8}}\right) \\&amp; =\Phi(2.625)-\Phi(-1.625) \\&amp; =\Phi(2.625)-1+\Phi(1.625) \\&amp; =0.99565-1+0.948=0.9437 .\end{aligned}\]</span></li></ol><p>这表明: 被盗索赔户在 14 与 30 户之间的概率近似为 0.9437 .</p><hr><h2 id="t82">t82</h2><blockquote><p>某产品的合格品率为 <span class="math inline">\(99\%\)</span>,问包装箱中应该装多少个此种产品, 才能有 <span class="math inline">\(95\%\)</span> 的可能性使每箱中的合格品多于 <span class="math inline">\(100\)</span> 个。</p></blockquote><h3 id="解析-11">解析</h3><p>设包装中有几个产品. X为合格品数 <span class="math inline">\(\quad X\sim B(n, 0.99)\)</span> 则 <span class="math inline">\(E(x)=0.99 \pi\quad \operatorname{Var}(x)=0.99 \times 0.01 \times n\)</span>由中心极限定理: <span class="math inline">\(X\)</span> 近似服从 <span class="math inline">\(N(0.99 n, 0.99 \times 0.01 \times n)\)</span><span class="math display">\[\begin{aligned}&amp; \text { 目标: } P\{X&gt;100\} \geqslant 0.95 \quadP\{X&gt;100\}=1-P\{X \leqslant 100\}=1-P\left(\frac{X-0.99 n}{\sqrt{0.99\times 0.01 \times n}} \leqslant \frac{100-0.99 n}{\sqrt{0.99 \times0.01 \times n}}\right) \\&amp; \Rightarrow \Phi\left(\frac{100-0.99 n}{\sqrt{0.99 \times 0.01\times n}}\right) \leqslant 0.05 \quad \text { 而 } \Phi(1.645)=0.95 \\&amp; \Rightarrow \frac{100-0.99 n}{\sqrt{0.99 \times 0.01 \times n}}\leq 1.655 \quad n \geqslant 103.19 \quad \text { 所以104个产品. }\end{aligned}\]</span></p><hr><h2 id="t83">t83</h2><blockquote><p>有一批建筑房屋用的木柱, 其中 <span class="math inline">\(80\%\)</span> 的长度不小于 <span class="math inline">\(3\mathrm{~m}\)</span>, 现从这批木柱中随机地取出 100 根，问其中至少有 30根短于 <span class="math inline">\(3 \mathrm{~m}\)</span>的概率是多少?</p></blockquote><h3 id="解析-12">解析</h3><p>设 <span class="math inline">\(X\)</span> 为 100 根木柱中长度不小于<span class="math inline">\(3 \mathrm{~m}\)</span> 的根数, 则 <span class="math inline">\(X \sim b(100,0.8)\)</span>.利用棣莫弗一拉普拉斯中心极限定理, 所求概率为 <span class="math display">\[\begin{aligned}P(X \leqslant 70) &amp; =P(X&lt;70.5) \approx \Phi\left(\frac{70.5-100\times 0.8}{\sqrt{100 \times 0.8 \times 0.2}}\right) \\&amp; =1-\Phi(2.375)=0.0088 .\end{aligned}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第五章 复习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>概率论习题(2)</title>
      <link href="/2024/05/06/gai-lu-lun-5-2-gai-lu-lun-qi-mo-fu-xi-xi-ti-2/"/>
      <url>/2024/05/06/gai-lu-lun-5-2-gai-lu-lun-qi-mo-fu-xi-xi-ti-2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/igWDk1yeq05g">下载完整PDF点这里</a></p><h2 id="t15">t15</h2><blockquote><p>设随机变量 X 的分布函数为 <span class="math display">\[F(x)=\left\{\begin{array}{c}0, &amp; x&lt;0, \\\frac{1}{2}, &amp; 0 \leq x&lt;1, \\1-e^{-x}, &amp; x \geq 1,\end{array}\right.\]</span></p><p>求 <span class="math inline">\(P\{X=1\}\)</span></p></blockquote><h3 id="解析">解析</h3><p>根据事件概率与分布函数极限的关系有 <span class="math display">\[P\{X=1\}=\lim _{x \rightarrow 1^{+}} F(x)-\lim _{x \rightarrow 1^{-}}F(x)=1-e^{-1}-\frac{1}{2}=\frac{1}{2}-e^{-1}\]</span></p><p>随机变量的分布，《知识点总结》的 <span class="math inline">\(\S2.1\)</span></p><hr><h2 id="t16">t16</h2><blockquote><p>设随机变量 <span class="math inline">\(X\)</span> 的分布函数为 <span class="math display">\[F(x)=\left\{\begin{array}{ll}0, &amp; x&lt;0, \\1 / 4, &amp; 0 \leqslant x&lt;1 \\1 / 3, &amp; 1 \leqslant x&lt;3 \\1 / 2, &amp; 3 \leqslant x&lt;6, \\1, &amp; x \geqslant 6 .\end{array}\right. \text {, }\]</span></p><p>试求 <span class="math inline">\(X\)</span> 的概率分布列及 <span class="math inline">\(P(X&lt;3), P(X \leqslant 3), P(X&gt;1), P(X\geqslant 1)\)</span>.</p></blockquote><h3 id="解析-1">解析</h3><p>大致想象一下 <span class="math inline">\(F(x)\)</span>的图像为阶梯状，这对应离散随机变量的分布函数形状，所以可以写出 <span class="math inline">\(X\)</span> 的分布列：</p><p><span class="math inline">\(X\)</span> 的概率分布列为 <span class="math display">\[\begin{array}{c|cccc}\hline X &amp; 0 &amp; 1 &amp; 3 &amp; 6 \\\hline P &amp; \dfrac{1}{4} &amp; \dfrac{1}{12} &amp; \dfrac{1}{6} &amp;\dfrac{1}{2} \\\hline\end{array}\]</span> 可以看到在 <span class="math inline">\(F(x)\)</span>中分段点的值为 <span class="math inline">\(X\)</span> 的取值。 <span class="math display">\[\begin{array}{ll}P(X&lt;3)=P(X=0)+P(X=1)=\dfrac{1}{3}, &amp; P(X \leqslant3)=1-P(X=6)=\dfrac{1}{2}, \\P(X&gt;1)=P(X=3)+P(X=6)=\dfrac{2}{3}, &amp; P(X \geqslant1)=1-P(X=0)=\dfrac{3}{4} .\end{array}\]</span></p><p>随机变量的分布，《知识点总结》的 <span class="math inline">\(\S2.1\)</span></p><hr><h2 id="t17">t17</h2><blockquote><p>设随机变量 <span class="math inline">\(X\)</span> 的概率密度为 <span class="math inline">\(f(x)=\left\{\begin{array}{c}1-C|x|,-1&lt;x&lt;1 \\0, \text { 其他 }\end{array}\right.\)</span></p><p>（1）求 <span class="math inline">\(C\)</span> 的值；</p><p>（2）求 <span class="math inline">\(Y=X^2+1\)</span> 的概率密度。</p></blockquote><h3 id="解析-2">解析</h3><p>（1）利用密度函数的正则性： <span class="math display">\[1=\int_{-\infty}^{\infty}f(x)dx=\int_{-1}^{1}\left[1-C|x|\right]dx=2\int_{0}^{1}\left(1-Cx\right)dx=2-C\]</span></p><p><span class="math display">\[\Rightarrow C=1\]</span></p><p>（2）由于 <span class="math display">\[\begin{aligned}&amp; F_Y(y)=P_Y\{Y \leqslant y\}=P_X\left\{X^2+1 \leqslanty\right\}=P_X\left\{X^2 \leqslant y-1\right\} \\&amp; =\left\{\begin{array}{cc}0, &amp; y&lt;1 \\P\{-\sqrt{y-1} \leqslant X \leqslant \sqrt{y-1}\}, &amp; 1 \leqslanty&lt;2 \\1, &amp; y \geqslant 2\end{array}\right. \\&amp;\end{aligned}\]</span></p><p>故当 <span class="math inline">\(1 \leqslant y&lt;2\)</span> 时, 有<span class="math display">\[F_Y(y)=\int_{-\sqrt{y-1}}^{\sqrt{y-1}}(1-|x|) \mathrm{d} x=2\int_0^{\sqrt{y-1}}(1-x) \mathrm{d} x=1-(1-\sqrt{y-1})^2\]</span> <span class="math inline">\(Y\)</span> 的分布函数为 <span class="math display">\[F_y(y)=\left\{\begin{array}{cc}0, &amp; y&lt;1 \\1-(1-\sqrt{y-1})^2, &amp; 1 \leqslant y&lt;2 \\1, &amp; y \geqslant 2\end{array}\right.\]</span> <span class="math inline">\(Y\)</span> 的密度函数为 <span class="math display">\[f_Y(y)=\left\{\begin{array}{cc}\frac{1}{\sqrt{y-1}}-1, &amp; 1&lt;y&lt;2 \\0, &amp; \text { 其他 }\end{array}\right.\]</span> <span class="math inline">\(ps:\)</span> 一个检查 <span class="math inline">\(Y\)</span> 密度函数正确性的技巧，<span class="math inline">\(Y\)</span> 的密度函数不为 <span class="math inline">\(0\)</span> 的区间，一定是 <span class="math inline">\(X\)</span> 不为 <span class="math inline">\(0\)</span> 的区间通过变换得到的。比如 <span class="math inline">\(t17\)</span> ，<span class="math inline">\(X\)</span> 的密度函数不为 <span class="math inline">\(0\)</span> 的区间为 <span class="math inline">\((-1,1)\)</span> ，则 <span class="math inline">\(X^2+1\)</span> 后变为 <span class="math inline">\((1,2)\)</span> ，即 <span class="math inline">\(Y\)</span> 密度函数不为 <span class="math inline">\(0\)</span> 的区间。</p><p>随机变量的分布，分布函数与概率密度函数，随机变量函数的分布《知识点总结》的<span class="math inline">\(\S 2.1 、2.6\)</span></p><hr><p>## t18</p><blockquote><p>设随机变量 <span class="math inline">\(X\)</span>的期望存在，概率密度 <span class="math inline">\(p(x)\)</span> 关于<span class="math inline">\(x=\mu\)</span> 对称： <span class="math inline">\(p(\mu+x)=p(\mu-x)\)</span> ，证明： <span class="math inline">\(E(x)=\mu\)</span>.</p></blockquote><h3 id="解析-3">解析</h3><p><span class="math display">\[\begin{array}{ll}E(X)&amp;=\displaystyle\int_{-\infty}^{\infty} x p(x) dx=\int_{-\infty}^{\infty} \mu p(x) d x+\int_{-\infty}^{\infty}(x-\mu)p(x) d x \quad(第一项积值为 \mu ，是对照结果凑出来的\mu) \\&amp;=\displaystyle\mu \int_{-\infty}^{\infty} p(x) dx+\int_{-\infty}^{\infty}(x-\mu) p(x) dx=\mu+\int_{-\infty}^{\infty}(x-\mu) p(x) d x \quad\text {(第二项考虑对称消去) }\\&amp;= \mu+\displaystyle\int_{-\infty}^{+\infty} t p(t+\mu) dt \quad\text{(令$t=x-\mu$)}\\&amp;= \mu \\\end{array}\]</span></p><p><span class="math inline">\(\quad \text { 记 } f(t) =t p(t+\mu) \quadf(-t)=-t p(\mu-t)=-t p(t+\mu) \Rightarrow f(t)+f(-t)=0 \quad f(t) \text{ 为奇函数，所以后一项积分值为0}\)</span></p><hr><h2 id="t19">t19</h2><blockquote><p>国际市场上对我国某种出口商品的每年需求量是个随机变量 <span class="math inline">\(X\)</span> (吨). <span class="math inline">\(X\)</span> 服从区间 <span class="math inline">\([300,500]\)</span> 上的均匀分布.每销售出一吨商品,可为国家赚取外汇1.5千元; 若销售不出, 则每吨商品需贮存费 0.5 千元. 求:应组织多少货源,才能使平均收益最大?</p></blockquote><h3 id="解析-4">解析</h3><p>设组织该货源 <span class="math inline">\(a\)</span> 吨. 则显然应该有<span class="math inline">\(300 \leqslant a \leqslant 500\)</span>. 又记<span class="math inline">\(Y\)</span> 为在 <span class="math inline">\(a\)</span> 吨货源的条件下的收益额 (单位:千元),则收益额 <span class="math inline">\(Y\)</span> 为需求量 <span class="math inline">\(X\)</span> 的函数, 即 <span class="math inline">\(Y=g(X)\)</span>. 由题设条件知: 当 <span class="math inline">\(X \geqslant a\)</span> 时, 则此 <span class="math inline">\(a\)</span> 吨货源全部售出, 共获利 <span class="math inline">\(1.5 a\)</span>. 当 <span class="math inline">\(X&lt;a\)</span> 时, 则售出 <span class="math inline">\(X\)</span> 吨 (获利 <span class="math inline">\(1.5 X\)</span> ), 且还有 <span class="math inline">\(a-X\)</span> 吨积压 (获利 <span class="math inline">\(-0.5(a-X)\)</span> ), 所以共获利 <span class="math inline">\(1.5 X-0.5(a-X)\)</span>,由此知 <span class="math display">\[g(X)=\left\{\begin{array}{ll}1.5 a, &amp; \text { 若 } X \geqslant a, \\1.5 X-0.5(a-X), &amp; \text { 若 } X&lt;a\end{array}= \begin{cases}1.5 a, &amp; \text { 若 } X \geqslant a, \\2 X-0.5 a, &amp; \text { 若 } X&lt;a .\end{cases}\right.\]</span></p><p><span class="math display">\[\begin{aligned}E(Y)&amp;=\int_{-\infty}^{\infty} g(x) p_X(x) \mathrm{d}x=\int_{300}^{500} g(x) \frac{1}{200} \mathrm{~d} x\\&amp; =\frac{1}{200}\left(\int_a^{500} 1.5 a \mathrm{~d}x+\int_{300}^a(2 x-0.5 a) \mathrm{d} x\right) \\&amp; =\frac{1}{200}\left(-a^2+900 a-300^2\right) .\end{aligned}\]</span></p><p>所以当 <span class="math inline">\(a=450\)</span>时可以获利最大。</p><p>随机变量函数的数学期望，随机变量函数的分布《知识点总结》的 <span class="math inline">\(\S 2.2\)</span></p><hr><h2 id="t20">t20</h2><blockquote><p>试证: 对任意的常数 <span class="math inline">\(c \neq E(X)\)</span>,有 <span class="math display">\[\operatorname{Var}(X)=E(X-E(X))^2&lt;E(X-c)^2 .\]</span></p></blockquote><h3 id="解析-5">解析</h3><p>常用的技巧：加一项减一项 <span class="math display">\[E(X-E(X))^2=E[(X-c)-(E(X)-c)]^2=E(X-c)^2-(E(X)-c)^2,\]</span></p><p>由于 <span class="math inline">\(c \neq E(X)\)</span>, 所以 <span class="math inline">\((E(X)-c)^2&gt;0\)</span>, 由此得 <span class="math display">\[\operatorname{Var}(X)=E(X-E(X))^2&lt;E(X-c)^2 .\]</span></p><hr><h2 id="t21">t21</h2><blockquote><p>已知某商场一天来的顾客数 <span class="math inline">\(X\)</span>服从参数为 <span class="math inline">\(\lambda\)</span> 的泊松分布,而每个来到商场的顾客购物的概率为 <span class="math inline">\(p\)</span>，每个顾客是否购买商品间相互独立。证明:此商场一天内购物的顾客数服从参数为 <span class="math inline">\(\lambdap\)</span> 的泊松分布.</p></blockquote><h3 id="解析-6">解析</h3><p>用 <span class="math inline">\(Y\)</span> 表示商场一天内购物的顾客数,则由全概率公式知, 对任意正整数 <span class="math inline">\(k\)</span> 有<span class="math display">\[\begin{aligned}P(Y=k) &amp; =\sum_{i=k}^{\infty} P(X=i) P(Y=k \midX=i)=\sum_{i=k}^{\infty} \frac{\lambda^i\mathrm{e}^{-\lambda}}{i!}\binom{i}{k} p^k(1-p)^{i-k} \\&amp; =\frac{(\lambda p)^k}{k!} \mathrm{e}^{-\lambda}\sum_{i=k}^{\infty} \frac{[\lambda(1-p)]^{i-k}}{(i-k)!}\\&amp;=\frac{(\lambda p)^k}{k!} \mathrm{e}^{-\lambda}\mathrm{e}^{\lambda(1-p)}\\&amp;=\frac{(\lambda p)^k}{k!} \mathrm{e}^{-\lambda p} .\end{aligned}\]</span> <span class="math inline">\(ps:\)</span>第一行到第二行的处理过程是因为要证明服从参数为 <span class="math inline">\(\lambda p\)</span>的泊松分布，所以凑出来和这个分布对应的系数。</p><p>全概率公式、随机变量的独立性、常用离散分布 《知识点总结》的 <span class="math inline">\(\S 1.4、1.5、2.4\)</span></p><hr><h2 id="t22">t22</h2><blockquote><p>设一个人一年内患感冒的次数服从参数 <span class="math inline">\(\lambda=5\)</span> 的泊松分布.现有某种预防感冒的药物对 <span class="math inline">\(75 \%\)</span>的人有效 (能将泊松分布的参数减少为 <span class="math inline">\(\lambda=3\)</span> ), 对另外的 <span class="math inline">\(25 \%\)</span> 的人不起作用.如果某人服用了此药,一年内患了两次感冒, 那么该药对他 (她)有效的可能性是多少?</p></blockquote><h3 id="解析-7">解析</h3><p>根据题干信息肯定需要通过条件概率来修正概率，关键是找到 <span class="math inline">\(P(A \mid B)\)</span> 中的事件 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span></p><p>根据题干所求信息，容易得到 <span class="math inline">\(A\)</span>的含义为该药有效；而这个 <span class="math inline">\(B\)</span>即修正条件是“服药后一年感冒了两次”，所以：</p><p>记事件 <span class="math inline">\(B\)</span>为“服用此药后,一年感冒两次”, 事件 <span class="math inline">\(A\)</span>为“服用此药后有效”. <span class="math display">\[P(A \mid B)=\dfrac{P(B)P(A\mid B)}{P(A)P(B\mid A)+P(\bar{A})P(B\mid\bar{A})}=\frac{0.75 \times \frac{3^2}{2!} \mathrm{e}^{-3}}{0.75 \times\frac{3^2}{2!} \mathrm{e}^{-3}+0.25 \times \frac{5^2}{2!}\mathrm{e}^{-5}}=0.889 .\]</span></p><p>贝叶斯公式、常用离散分布 《知识点总结》的 <span class="math inline">\(\S 1.5、2.4\)</span></p><hr><h2 id="t23">t23</h2><blockquote><p>设随机变量 <span class="math inline">\(X \simN\left(108,3^2\right)\)</span> ，求： (1) <span class="math inline">\(P(102 \leq X \leq 117)\)</span> (2) 求 <span class="math inline">\(a\)</span> ，使 <span class="math inline">\(P(X&lt;a)\geqslant0.95\)</span>.</p></blockquote><h3 id="解析-8">解析</h3><p>（1）： <span class="math display">\[\begin{aligned}P(102 \leqslant X \leqslant 117) &amp; =P\left(\frac{102-108}{3}\leqslant \frac{X-108}{3} \leqslant \frac{117-108}{3}\right)=P\left(-2\leqslant \frac{X-108}{3} \leqslant 3\right) \\&amp; =\Phi(3)-\Phi(-2)\\ &amp;=\Phi(3)-[1-\Phi(2)]=0.9987-[1-0.9772]\\&amp;=0.9795 . \\\end{aligned}\]</span> （2）： <span class="math display">\[\begin{aligned}P(X&lt;a) &amp;=P\left(\frac{X-108}{3}&lt;\frac{a-108}{3}\right)=\Phi\left(\frac{a-108}{3}\right)\geqslant0.95\\\Phi(1.645) &amp; \approx 0.95 \\\Rightarrow a &amp;\geqslant 112.935\end{aligned}\]</span> 正态分布的概率计算 《知识点总结》的 <span class="math inline">\(\S 2.5\)</span></p><hr><h2 id="t24">t24</h2><blockquote><p>某种圆盘的直径在区间 <span class="math inline">\((a, b)\)</span>上服从均匀分布, 试求此种圆盘的平均面积.</p></blockquote><h3 id="解析-9">解析</h3><p>记 <span class="math inline">\(X\)</span> 为圆盘的直径,则圆盘的面积为 <span class="math inline">\(Y=\pi X^2 / 4\)</span>,所以平均面积为 <span class="math display">\[E(Y)=\frac{\pi}{4}E\left(X^2\right)=\frac{\pi}{4}\left[\frac{(b-a)^2}{12}+\frac{(a+b)^2}{4}\right]=\frac{\pi}{12}\left(a^2+b^2+ab\right) .\]</span></p><p>利用方差和期望的关系，通过背诵均匀分布的期望和方差快速得到答案。《知识点总结》的 <span class="math inline">\(\S一定要背诵的常用概率分布数学期\)</span> <span class="math inline">\(望和方差\)</span></p><hr><h2 id="t25">t25</h2><blockquote><p>设某种商品每周的需求量 <span class="math inline">\(X\)</span>服从区间 <span class="math inline">\((10,30)\)</span> 上均匀分布,而商店进货数为区间 <span class="math inline">\((10,30)\)</span>中的某一整数, 商店每销售 1 单位商品可获利 <span class="math inline">\(500\)</span> 元; 若供大于求则降价处理, 每处理 1单位商品亏损 <span class="math inline">\(100\)</span> 元; 若供不应求,则可从外部调剂供应, 此时每 1 单位商品仅获利 <span class="math inline">\(300\)</span> 元. 为使商店所获利润期望值不少于<span class="math inline">\(9280\)</span> 元, 试确定最少进货量.</p></blockquote><h3 id="解析-10">解析</h3><p>设进货量为 <span class="math inline">\(a\)</span>, 则利润为 <span class="math display">\[\begin{aligned}g(X) &amp; =\left\{\begin{array}{l}500 X-100(a-X), \quad 10 \leqslant X \leqslant a, \\500 a+300(X-a), \quad a&lt;X \leqslant 30\end{array}\right. \\&amp; = \begin{cases}600 X-100 a, &amp; 10 \leqslant X \leqslant a, \\300 X+200 a, &amp; a&lt;X \leqslant 30 .\end{cases}\end{aligned}\]</span></p><p>所以平均利润为 <span class="math display">\[\begin{aligned}E(g(X)) &amp; =\int_{10}^{30} g(x) \frac{1}{20} \mathrm{~d}x=\frac{1}{20} \int_{10}^a(600 x-100 a) \mathrm{d} x+\frac{1}{20}\int_a^{30}(300 x+200 a) \mathrm{d} x \\&amp; =-7.5 a^2+350 a+5250 .\end{aligned}\]</span></p><p>按照题意要求有 <span class="math display">\[-7.5 a^2+350 a+5250 \geqslant 9280 \text { 即 }-7.5 a^2+350 a-4030\geqslant 0,\]</span></p><p>解得 <span class="math display">\[20 \frac{2}{3} \leqslant a \leqslant 26,\]</span></p><p>因此最少进货为 21 单位.</p><p>是 <span class="math inline">\(t19\)</span> 的类似题。</p><hr><h2 id="t26">t26</h2><blockquote><p>某种设备的使用寿命 <span class="math inline">\(X\)</span> (以年计)服从指数分布, 其平均寿命为 <span class="math inline">\(4\)</span>年.制造此种设备的厂家规定, 若设备在使用一年之内损坏, 则可以予以调换.如果设备制造厂每售出一台设备可赢利 <span class="math inline">\(100\)</span> 元，而调换一台设备制造厂需花费 <span class="math inline">\(300\)</span> 元. 试求每台设备的平均利润.</p></blockquote><h3 id="解析-11">解析</h3><p>根据设备寿命 <span class="math inline">\(X\)</span>服从指数分布，其平均寿命为 <span class="math inline">\(4\)</span>年，这说的就是寿命期望 <span class="math inline">\(E(X)=4\)</span>，根据指数分布 <span class="math inline">\(Exp(\lambda)\)</span>数学期望为 <span class="math inline">\(\dfrac{1}{\lambda}\)</span>得到使用寿命服从参数为 <span class="math inline">\(\dfrac{1}{4}\)</span>的指数分布。 <span class="math display">\[p(x)=\left\{\begin{array}{r}\dfrac{1}{4}e^{-\frac{1}{4}x},x\geqslant0 \\0,x&lt;0\end{array}\right.\]</span> 所以一年内损坏的概率为 <span class="math display">\[P(X\leqslant1)=\int_0^1\dfrac{1}{4}e^{-\frac{1}{4}x}dx=1-e^{-\frac{1}{4}}=0.2212\]</span> 所以一台机器平均利润 <span class="math inline">\(Y\)</span>为： <span class="math display">\[E(Y)=100+P(X\leqslant1)(-300)=33.64\]</span></p><hr><h2 id="t27">t27</h2><blockquote><p>已知随机变量 <span class="math inline">\(X\)</span> 的密度函数为<span class="math display">\[p(x)=\frac{2}{\pi} \cdot \frac{1}{\mathrm{e}^x+\mathrm{e}^{-x}},\quad-\infty&lt;x&lt;\infty .\]</span></p><p>试求随机变量 <span class="math inline">\(Y=g(X)\)</span> 的概率分布,其中 <span class="math display">\[g(x)=\left\{\begin{aligned}-1, &amp; \text { 当 } x&lt;0, \\1, &amp; \text { 当 } x \geqslant 0 .\end{aligned}\right.\]</span></p></blockquote><h3 id="解析-12">解析</h3><p>因为 <span class="math inline">\(p(x)\)</span> 为偶函数, 所以可得<span class="math inline">\(P(X&lt;0)=P(X \geqslant 0)=0.5\)</span>.由此得 <span class="math display">\[P(Y=-1)=P(X&lt;0)=P(X \geqslant 0)=P(Y=1)=0.5 .\]</span></p><p>所以 <span class="math inline">\(Y\)</span> 的分布列为 <span class="math display">\[\begin{array}{c|cc}\hline Y &amp; -1 &amp; 1 \\\hline P &amp; 0.5 &amp; 0.5 \\\hline\end{array}\]</span></p><hr><h2 id="t28">t28</h2><blockquote><p>设随机变量 <span class="math inline">\(X \sim U(0,1)\)</span>, 试求<span class="math inline">\(1-X\)</span> 的分布.</p></blockquote><h3 id="解析-13">解析</h3><p><span class="math inline">\(X\)</span> 的密度函数为 <span class="math display">\[p_X(x)= \begin{cases}1, &amp; 0&lt;x&lt;1, \\ 0, &amp; \text { 其他.}\end{cases}\]</span></p><p>因为 <span class="math inline">\(y=g(x)=1-x\)</span> 在 <span class="math inline">\((0,1)\)</span> 上为严格单调减函数, 其反函数为<span class="math inline">\(x=h(y)=1-y\)</span>,且有 <span class="math inline">\(h^{\prime}(y)=-1\)</span>, 所以 <span class="math inline">\(Y=1-X\)</span> 的密度函数为 <span class="math display">\[p_Y(y)=\left\{\begin{array}{cl}p_X(1-y)|-1|, &amp; 0&lt;y&lt;1, \\0, &amp; \text { 其他 }\end{array}= \begin{cases}1, &amp; 0&lt;y&lt;1, \\0, &amp; \text { 其他. }\end{cases}\right.\]</span></p><p>这表明: 当 <span class="math inline">\(X \sim U(0,1)\)</span> 时,<span class="math inline">\(1-X\)</span> 与 <span class="math inline">\(X\)</span> 同分布.</p><p>采用公式法求解连续随机变量密度函数，《知识点总结》的 <span class="math inline">\(\S2.6\)</span></p><hr><h2 id="t29">t29</h2><blockquote><p>设随机变量 <span class="math inline">\(\mathrm{X}\)</span>服从指数分布, 其概率为 <span class="math inline">\(f(x)=\left\{\begin{array}{cl}2 e^{-2 x}, &amp;x&gt;0, \\ 0, &amp; \text { 其他, }\end{array}\right.\)</span></p><p>证明:<span class="math inline">\(Y=1-e^{-2 X}\)</span> 在区间 <span class="math inline">\((0,1)\)</span> 上服从均匀分布.</p></blockquote><h3 id="解析-14">解析</h3><p>方法一：</p><p>由随机变量 <span class="math inline">\(X\)</span>的概率密度函数可推之 <span class="math display">\[F_X(x)=\left\{\begin{array}{cc}1-e^{-2 x}, &amp; x \geq 0, \\0, &amp; x&lt;0,\end{array}\right.\]</span> 当 <span class="math inline">\(x&gt;0\)</span> 时, <span class="math inline">\(0&lt;1-e^{-2 x}&lt;1\)</span> 综上 <span class="math inline">\(y \leq 0, F_Y(y)=0 ; y \geq 1, F_Y(y)=1\)</span>当 <span class="math inline">\(0&lt;y&lt;1\)</span> 时, <span class="math inline">\(F_Y(y)=P\{Y \leq y\}=P\left\{1-e^{-2 X} \leqy\right\}\)</span> <span class="math display">\[=P\left\{X \leq-\frac{1}{2} \ln (1-y)\right\}=F_X\left(-\frac{1}{2} \ln(1-y)\right)=y\]</span></p><p>综上: <span class="math display">\[F_Y(y)=\left\{\begin{array}{lc}0, &amp; x&lt;0, \\y, &amp; 0 \leq x&lt;1, \\1, &amp; x \geq 1,\end{array}\right.\]</span></p><p>求导得: <span class="math display">\[f_Y(y)=\frac{\mathrm{d}}{\mathrm{d} y} F_Y(y)=\left\{\begin{array}{cc}1, &amp; 0&lt;x&lt;1, \\0, &amp; \text { 其他. }\end{array}\right.\]</span> 方法二：</p><p>由于 <span class="math inline">\(X\)</span> 在 <span class="math inline">\(X\geqslant0\)</span> 取值，所以 <span class="math inline">\(Y=1-e^{-2X}\)</span> 的取值范围是 <span class="math inline">\((0,1]\)</span></p><p><span class="math inline">\(Y=1-e^{-2 X}\)</span>是严格单调递增的函数，其反函数为 <span class="math inline">\(h(y)=-\dfrac{1}{2}\ln(1-y)\)</span>，对反函数求导：<span class="math inline">\(h^{\prime}(y)=\dfrac{1}{2(1-y)}\)</span></p><p>直接带公式有 <span class="math display">\[f_Y(y)=\left\{\begin{array}{cc}f_X(-\dfrac{1}{2}\ln(1-y))|h^\prime(y)|, &amp; 0&lt;y&lt;1 ， \\0, &amp; \text { 其他. }\end{array}\right.=\left\{\begin{array}{cc}1, &amp; 0&lt;y&lt;1 ， \\0, &amp; \text { 其他. }\end{array}\right.\]</span></p><hr><h2 id="t30">t30</h2><blockquote><p>设 <span class="math inline">\(X \sim N\left(\mu,\sigma^2\right)\)</span>, 求 <span class="math inline">\(Y=\mathrm{e}^X\)</span> 的概率密度函数 <span class="math inline">\(p_Y(y)\)</span>.</p></blockquote><h3 id="解析-15">解析</h3><p>因为 <span class="math inline">\(Y=\mathrm{e}^X\)</span>的可能取值范围为 <span class="math inline">\((0, \infty)\)</span>, 且<span class="math inline">\(y=g(x)=\mathrm{e}^x\)</span>为严格单调增函数, 其反函数为 <span class="math inline">\(x=h(y)=\lny\)</span>, 及 <span class="math inline">\(h^{\prime}(y)=1 / y\)</span>,所以 <span class="math inline">\(Y\)</span> 的密度函数为 <span class="math display">\[p_Y(y)=\left\{\begin{array}{cc}p_X(\ln y)\left|\dfrac{1}{y}\right|, &amp; y&gt;0, \\0, &amp; \text { 其他 }\end{array}= \begin{cases}\dfrac{1}{\sqrt{2 \pi} y \sigma} \exp\left\{-\dfrac{(\ln y-\mu)^2}{2 \sigma^2}\right\}, &amp; y&gt;0, \\0, &amp; \text { 其他. }\end{cases}\right.\]</span></p><hr><h2 id="t31">t31</h2><blockquote><ol type="1"><li>设随机变量 <span class="math inline">\(X \simN\left(10,2^2\right)\)</span> ，求 <span class="math inline">\(Y=3X+5\)</span> 的分布<ol start="2" type="1"><li>设随机变量 <span class="math inline">\(X \simN\left(0,2^2\right)\)</span> ，求 <span class="math inline">\(Y=-X\)</span> 的分布</li></ol></li></ol></blockquote><h3 id="解析-16">解析</h3><p>（1）：<span class="math inline">\(Y\sim N(35,6^2)\)</span></p><p>（2）：<span class="math inline">\(Y\sim N(0,2^2)\)</span></p><p><span class="math inline">\(ps:\)</span> 设随机变量 <span class="math inline">\(X\)</span> 服从正态分布 <span class="math inline">\(N\left(\mu, \sigma^2\right)\)</span>, 则当 <span class="math inline">\(a \neq 0\)</span> 时, 有 <span class="math inline">\(Y=a X+b \sim\)</span> <span class="math inline">\(N\left(a \mu+b, a^2 \sigma^2\right)\)</span></p><hr><h2 id="t32">t32</h2><blockquote><p>设 <span class="math inline">\(X \sim N\left(0,\sigma^2\right)\)</span>, 求 <span class="math inline">\(Y=X^2\)</span>的分布.</p></blockquote><h3 id="解析-17">解析</h3><p>因为 <span class="math inline">\(Y=X^2\)</span> 的可能取值区间为<span class="math inline">\((0, \infty)\)</span>, 所以当 <span class="math inline">\(y \leqslant 0\)</span> 时, <span class="math inline">\(Y\)</span> 的密度函数为 <span class="math inline">\(p_Y(y)=0\)</span>.</p><p>而当 <span class="math inline">\(y&gt;0\)</span> 时, <span class="math inline">\(Y\)</span> 的分布函数为 <span class="math display">\[\begin{aligned}F_Y(y)&amp;=P_Y(Y \leqslant y)=P_X\left(X^2 \leq y\right)=P_X(-\sqrt{y}\leq X \leq \sqrt{y}) \\&amp; =2 \int_0^{\sqrt{y}} \frac{1}{\sqrt{2 \pi} \sigma}e^{-\frac{x^2}{2 \sigma^2}} d x \\&amp; =\frac{2}{\sqrt{2 \pi} \sigma} \int_0^{\sqrt{y}} e^{-\frac{x^2}{2\sigma^2}} d x \\p_Y(y)&amp;=\frac{d}{d y} F_Y(y)=\frac{2}{\sqrt{2 \pi} \sigma} \cdot\frac{1}{2 \sqrt{y}} \cdot e^{-\frac{y}{2 \sigma^2}} \\&amp; =\frac{1}{\sqrt{2 \pi y} \sigma} \exp \left\{-\frac{y}{2\sigma^2}\right\} \\&amp;\end{aligned}\]</span> 综上， <span class="math display">\[p_Y(y)= \begin{cases}\dfrac{1}{\sqrt{2 \pi y} \sigma} \exp\left\{-\dfrac{y}{2 \sigma^2}\right\}, &amp; y&gt;0, \\ 0, &amp; \text {其他. }\end{cases}\]</span></p><hr><h2 id="t33">t33</h2><blockquote><p>设随机变量 <span class="math inline">\(X\)</span> 的密度函数为 <span class="math display">\[p_X(x)= \begin{cases}\dfrac{2 x}{\pi^2}, &amp; 0&lt;x&lt;\pi, \\ 0,&amp; \text { 其他. }\end{cases}\]</span></p><p>求 <span class="math inline">\(Y=\sin X\)</span> 的密度函数 <span class="math inline">\(p_Y(y)\)</span>.</p></blockquote><h3 id="解析-18">解析</h3><p>由于 <span class="math inline">\(X\)</span> 在 <span class="math inline">\((0,\pi)\)</span> 取值，所以 <span class="math inline">\(Y=\sin X\)</span> 的取值范围是 <span class="math inline">\((0,1)\)</span></p><p>当 <span class="math inline">\(0&lt;Y&lt;1\)</span> 时：<span class="math inline">\(F_Y(y)=P_Y(Y \leq y)=P_X(\sin X \leq y)\)</span><span class="math inline">\(X\)</span> 的积分区间如下：</p><p><img src="../../../../images/概率论5-2期末考试习题/4.jpg"> <span class="math display">\[\begin{aligned}F_Y(y) &amp; =P(Y \leqslant y)=P(\sin X \leqslant y) \\&amp; =P(0 \leqslant X \leqslant \arcsin y)+P(\pi-\arcsin y \leqslant X\leqslant \pi) \\&amp; =\int_0^{\arcsin y} \frac{2 x}{\pi^2} d x+\int_{\pi-\arcsin y}\frac{2 x}{\pi^2} d x \\P_Y(y) &amp; =\frac{2 \arcsin y}{\pi^2} \cdot\frac{1}{\sqrt{1-y^2}}+\frac{2(\pi-\arcsin y)}{\pi^2\sqrt{1-y^2}}=\frac{2}{\pi \sqrt{1-y^2}} \\P_Y(y) &amp; =\left\{\begin{array}{cl}\dfrac{2}{\pi \sqrt{1-y^2}}, &amp; 0&lt;y \leqslant 1 \\0, &amp; \left.{(其他}\right)\end{array}\right.\end{aligned}\]</span></p><p><span class="math inline">\(ps:\)</span> 如果函数 <span class="math inline">\(f(x)\)</span> 连续， <span class="math inline">\(\phi(x)\)</span> 和 <span class="math inline">\(\varphi(x)\)</span>可导，那么变限积分函数的求导公式可表示为 <span class="math display">\[\Phi^{\prime}(x)=\frac{d}{d x} \int_{\phi(x)}^{\varphi(x)} f(t) dt=f[\varphi(x)] \varphi^{\prime}(x)-f[\phi(x)] \phi^{\prime}(x)\]</span> 当然，如果忘记这个公式，可以硬算出 <span class="math inline">\(F_Y(y)\)</span> 后再求导。</p><hr><h2 id="t34">t34</h2><blockquote><p>设随机变量 <span class="math inline">\(X\)</span> 的密度函数为 <span class="math display">\[P_X(x)= \begin{cases}\dfrac{1}{2}, &amp; -1&lt;x&lt;0 \\ \dfrac{1}{4},&amp; 0 \leqslant x&lt;2 \\ 0, &amp; \text { 其他. }\end{cases}\]</span></p><p>求 <span class="math inline">\(Y=X^2\)</span> 的密度函数 <span class="math inline">\(P_Y(y)\)</span> .</p></blockquote><h3 id="解析-19">解析</h3><p>从别处看到一个写的很清楚的解析，直接放在下面：</p><figure><img src="../../../../images/概率论5-2期末考试习题/5.jpg" alt="下面解析中的图片,更清楚些"><figcaption aria-hidden="true">下面解析中的图片,更清楚些</figcaption></figure><p><img src="../../../../images/概率论5-2期末考试习题/6.jpg"></p><hr><h2 id="t35">t35</h2><blockquote><p>设随机变量 <span class="math inline">\(X \sim U(0,4)\)</span> ，求<span class="math inline">\(Y=X^2-2 X-3\)</span> 的密度函数 <span class="math inline">\(P_Y(y)\)</span>.</p></blockquote><h3 id="解析-20">解析</h3><p><span class="math inline">\(X\)</span> 的在 <span class="math inline">\((0,4)\)</span> 取值，则 <span class="math inline">\(Y=X^2-2X-3=(X-1)^2-4\)</span> 的取值范围是 <span class="math inline">\([-4,5)\)</span></p><p>所以当 <span class="math inline">\(-4\leq Y &lt;5\)</span> 时：<span class="math inline">\(F_Y(y)=P_Y(Y\leq y)=P_X((X-1)^2\leqy+4)=P_X(1-\sqrt{y+4}\leq X\leq 1+\sqrt{y+4})\)</span></p><p>此时要注意：<span class="math inline">\(1-\sqrt{y+4}\)</span>的取值范围是 <span class="math inline">\((-2,1)\)</span> 所以要继续将<span class="math inline">\(Y\)</span> 的取值分成 <span class="math inline">\((-4,-3)\)</span> 和 <span class="math inline">\((-3,5)\)</span> 分成两段考虑：</p><p>当 <span class="math inline">\(-4&lt;Y&lt;-3\)</span> 时： <span class="math display">\[\begin{aligned}&amp;  0&lt;-\sqrt{y+4}+1&lt;1, \quad 1&lt;\sqrt{y+4}+1&lt;2 \\&amp; F_Y(y)=\int_{-\sqrt{y+4}+1}^{\sqrt{y+4}+1} \frac{1}{4} d x\Rightarrow p_Y(y)=\frac{1}{4} (y+4)^{-\frac{1}{2}}\end{aligned}\]</span> 当 <span class="math inline">\(-3&lt;Y&lt;5\)</span> 时：<span class="math display">\[\begin{aligned}&amp;-\sqrt{y+4}+1 \leqslant 0,2 \leqslant \sqrt{y+4}+1&lt;4 \\&amp; F_Y(y)=\int_0^{\sqrt{y+4}+1} \frac{1}{4} d x \Rightarrowp_Y(y)=\frac{1}{8} (y+4)^{-\frac{1}{2}}\end{aligned}\]</span> 综上： <span class="math display">\[p_Y(y)=\left\{\begin{array}{cc}\dfrac{1}{4}(y+4)^{-\frac{1}{2}}, &amp; -4\leqslant y&lt;-3 \\\dfrac{1}{8}(y+4)^{-\frac{1}{2}}, &amp; -3 \leqslant y&lt;5 \\0, &amp; \text { 其他 }\end{array}\right.\]</span></p><p><span class="math inline">\(t17、t27-t35\)</span>都是随机变量函数的分布问题，需要熟练掌握公式法和分布函数法，对应知识在《知识点总结》的<span class="math inline">\(\S 2.6\)</span></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第五章 复习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>概率论习题(3)</title>
      <link href="/2024/05/06/gai-lu-lun-5-2-gai-lu-lun-qi-mo-fu-xi-xi-ti-3/"/>
      <url>/2024/05/06/gai-lu-lun-5-2-gai-lu-lun-qi-mo-fu-xi-xi-ti-3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/igWDk1yeq05g">下载完整PDF点这里</a></p><h2 id="t36">t36</h2><blockquote><p>设随机变量 <span class="math inline">\(X_i, i=1,2\)</span>的分布列如下, 且满足 <span class="math inline">\(P\left(X_1X_2=0\right)=1\)</span>, 试求 <span class="math inline">\(P\left(X_1=X_2\right)\)</span>. <span class="math display">\[\begin{array}{c|ccc}\hline X_i &amp; -1 &amp; 0 &amp; 1 \\\hline P &amp; 0.25 &amp; 0.5 &amp; 0.25 \\\hline\end{array}\]</span></p></blockquote><h3 id="解析">解析</h3><p>先列出 <span class="math inline">\((X_1,X_2)\)</span>的联合分布列：</p><p><img src="../../../../images/概率论5-2期末考试习题/7.jpg"></p><p>首先根据 <span class="math inline">\(P(X_1X_2=0)=1\)</span> 可以得到<span class="math inline">\(p_{12}+p_{21}+p_{22}+p_{23}+p_{32}=1\)</span>根据联合分布概率的正则性，可以得到 <span class="math display">\[p_{11}=p_{13}=p_{31}=p_{33}=0\]</span> 即：</p><p><img src="../../../../images/概率论5-2期末考试习题/8.jpg"></p><p>根据 <span class="math inline">\(p_{1\cdot}\)</span>的边际分布，有：<span class="math inline">\(p_{11}+p_{12}+p_{13}=P(X_1=-1)=\dfrac{1}{4}\Rightarrowp_{12}=\dfrac{1}{4}\)</span></p><p>同理可以得到 <span class="math inline">\(p_{32}=p_{21}=p_{23}=\dfrac{1}{4}\)</span></p><p>再根据 <span class="math inline">\(p_{\cdot2}\)</span>的边际分布，有：$p_{12}+p_{22}+p_{32}=P(X_2=0)=p_{22}=0 $</p><p>所以：<span class="math inline">\(P(X_1=X_2)=p_{11}+p_{22}+p_{33}=0\)</span></p><hr><h2 id="t37">t37</h2><blockquote><p>设二维随机变量 <span class="math inline">\((X, Y)\)</span>的联合密度函数为 <span class="math display">\[p\left(x,y\right)=\left\{\begin{array}{cl}4 x y, &amp; 0&lt;x&lt;1,0&lt;y&lt;1, \\0, &amp; \text { 其他. }\end{array}\right.\]</span> 求： (1) <span class="math inline">\(P(X=Y)\)</span>;</p><ol start="2" type="1"><li><p><span class="math inline">\(P(X&lt;Y)\)</span>;</p></li><li><p><span class="math inline">\((X, Y)\)</span>的联合分布函数</p></li><li><p><span class="math inline">\(P(0&lt;X&lt;0.5,0.25&lt;Y&lt;1)\)</span>;</p></li></ol></blockquote><h3 id="解析-1">解析</h3><p>（1）<span class="math inline">\(P(X=Y)\)</span>的积分区域为一条直线，所以积分出来的体积为 <span class="math inline">\(0\)</span> 即 <span class="math inline">\(P(X=Y)=0\)</span></p><p>（2）<span class="math inline">\(\displaystyle P(X&lt;Y)=4 \int_0^1\int_0^y x y \mathrm{~d} x \mathrm{~d} y=4 \int_0^1 \frac{1}{2} y^3\mathrm{~d} y=4 \times \frac{1}{8}=0.5\)</span>.</p><p>（3）<span class="math inline">\((X, Y)\)</span> 的联合分布函数 <span class="math inline">\(F(x, y)\)</span> 要分如下 5 个区域表示:</p><p><img src="../../../../images/概率论5-2期末考试习题/9.jpg"> <span class="math display">\[F(x, y)=\left\{\begin{array}{l}\displaystyle \int_{-\infty}^x \int_{-\infty}^y 0 \mathrm{~d} t_2\mathrm{~d} t_1 \\\displaystyle 4 \int_0^x \int_0^y t_1 t_2 \mathrm{~d} t_2 \mathrm{~d}t_1 \\\displaystyle 4 \int_0^x \int_0^1 t_1 t_2 \mathrm{~d} t_2 \mathrm{~d}t_1 \\\displaystyle 4 \int_0^1 \int_0^y t_1 t_2 \mathrm{~d} t_2 \mathrm{~d}t_1 \\\displaystyle 4 \int_0^1 \int_0^1 t_1 t_2 \mathrm{~d} t_2 \mathrm{~d}t_1\end{array}=\left\{\begin{array}{cc}\displaystyle 0, &amp; x&lt;0, \text { 或 } y&lt;0 ， \\\displaystyle x^2 y^2, &amp; 0 \leqslant x&lt;1,0 \leqslant y&lt;1, \\\displaystyle x^2, &amp; 0 \leqslant x&lt;1,1 \leqslant y, \\\displaystyle y^2, &amp; 1 \leqslant x, 0 \leqslant y&lt;1 ， \\\displaystyle 1, &amp; x \geqslant 1, y \geqslant 1 .\end{array}\right.\right.\]</span> （4）</p><p>方法一：直接算积分</p><p><span class="math inline">\(P(0&lt;X&lt;0.5,0.25&lt;Y&lt;1)=\displaystyle 4\int_0^{0.5} x \mathrm{~d} x \int_{0.25}^1 y \mathrm{~d} y=4 \times\frac{1}{8} \times \frac{15}{32}=\frac{15}{64} \text {. }\)</span></p><p>方法二：利用分布函数</p><p><span class="math inline">\(P(0&lt;X&lt;0.5,0.25&lt;Y&lt;1)=F(0.5,1)-F(0,1)-F(0.5,0.25)+F(0,0.25)=\dfrac{1}{4}-0-\dfrac{1}{64}+0=\dfrac{15}{64}.\)</span></p><p><span class="math inline">\(ps:\)</span> 第（3）问中计算分布函数<span class="math inline">\(F(x,y)=P(X\leqslant x,Y\leqslant y)\)</span>，所以可以在坐标上完备地点坐标点，以这些点分别向 <span class="math inline">\(x\)</span> 轴和 <span class="math inline">\(y\)</span> 轴负方向画出积分区间，看这些区间和<span class="math inline">\(p(x,y)\)</span>取值区间的相交情况，以此来分段完整地算出分布函数。</p><p>第（4）问给出了计算某一积分区域上联合分布概率的两种方法。</p><hr><h2 id="t38">t38</h2><blockquote><p>设随机变量 <span class="math inline">\(Y\)</span> 服从参数为 <span class="math inline">\(\lambda=1\)</span> 的指数分布, 定义随机变量 <span class="math inline">\(X_k\)</span> 如下: <span class="math display">\[X_k=\left\{\begin{array}{ll}0, &amp; Y \leqslant k, \\1, &amp; Y&gt;k,\end{array} \quad k=1,2 .\right.\]</span></p><p>求 <span class="math inline">\(X_1\)</span> 和 <span class="math inline">\(X_2\)</span> 的联合分布列.</p></blockquote><h3 id="解析-2">解析</h3><p>随机变量 <span class="math inline">\(Y\sim Exp(1)\)</span> 所以 <span class="math display">\[p_Y(y)=\left\{\begin{array}{}\mathrm{e}^{-y},y\geqslant 0 \\0,其他\end{array}\right.\]</span> <span class="math inline">\(Y\)</span> 的分布函数为 <span class="math inline">\(F_Y(y)=1-\mathrm{e}^{-y}\)</span></p><p><span class="math inline">\(\left(X_1, X_2\right)\)</span>的联合分布列共有如下 4 种情况: <span class="math display">\[\begin{aligned}P\left(X_1=0, X_2=0\right) &amp; =P(Y \leqslant 1, Y \leqslant 2)=P(Y\leqslant 1) \\&amp; =1-\mathrm{e}^{-1}=0.63212 \\P\left(X_1=0, X_2=1\right) &amp; =P(Y \leqslant 1, Y&gt;2)=0 \\P\left(X_1=1, X_2=0\right) &amp; =P(Y&gt;1, Y \leqslant 2)=P(1 \leqslantY \leqslant 2) \\&amp; =\mathrm{e}^{-1}-\mathrm{e}^{-2}=0.23254, \\P\left(X_1=1, X_2=1\right) &amp; =P(Y&gt;1, Y&gt;2)\\&amp;=P(Y&gt;2)=1-P(Y\leqslant2)\\&amp; =\mathrm{e}^{-2}=0.135354\end{aligned}\]</span> <span class="math inline">\((X,Y)\)</span> 的分布列如下：</p><p><img src="../../../../images/概率论5-2期末考试习题/10.jpg"></p><hr><h2 id="t39">t39</h2><blockquote><p>设二维随机变量 <span class="math inline">\((X, Y)\)</span>的联合密度函数为 <span class="math display">\[p(x, y)=\left\{\begin{array}{cl}1 / 2, &amp; 0&lt;x&lt;1,0&lt;y&lt;2, \\0, &amp; \text { 其他. }\end{array}\right.\]</span></p><p>求 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 中至少有一个小于 0.5 的概率.</p></blockquote><h3 id="解析-3">解析</h3><p>两事件 <span class="math inline">\(\{X&lt;0.5\}\)</span> 与 <span class="math inline">\(\{Y&lt;0.5\}\)</span> 中至少有一个发生的概率为<span class="math display">\[\begin{aligned}P(\{X&lt;0.5\} \cup\{Y&lt;0.5\}) &amp; =1-P(X \geqslant 0.5, Y \geqslant0.5) \\&amp; =1-\int_{0.5}^1 \int_{0.5}^2 \frac{1}{2} \mathrm{~d} y \mathrm{~d}x=\frac{5}{8} .\end{aligned}\]</span></p><hr><h2 id="t40">t40</h2><blockquote><p>二维随机变量 <span class="math inline">\((X,Y)\)</span>的联合密度函数为 <span class="math display">\[f(x, y)=\left\{\begin{array}{cc}x^2+\dfrac{1}{3} x y, &amp; 0 \leq x \leq 1,0 \leq y \leq 2 ， \\0, &amp; \text { 其他. }\end{array}\right.\]</span></p><p>求 <span class="math inline">\((X, Y)\)</span> 的边缘密度函数</p></blockquote><h3 id="解析-4">解析</h3><p><span class="math display">\[\begin{aligned}&amp; f_X(x)=\int_{-\infty}^{\infty} f(x, y) \mathrm{d} y=\int_0^2x^2+\frac{1}{3} x y \mathrm{~d} y=2 x^2+\frac{2}{3} x \\&amp; f_Y(y)=\int_{-\infty}^{\infty} f(x, y) \mathrm{d} x=\int_0^1x^2+\frac{1}{3} x y \mathrm{~d} x=\frac{1}{6} y+\frac{1}{3} \\&amp; f_X(x)=\left\{\begin{array}{cc}2 x^2+\dfrac{2}{3} x, &amp; 0 \leq x \leq 1, \\0, &amp; \text { 其他. }\end{array} f_Y(y)=\left\{\begin{array}{cc}\dfrac{1}{6} y+\dfrac{1}{3}, &amp; 0 \leq y \leq 2, \\0, &amp; \text { 其他. }\end{array}\right.\right.\end{aligned}\]</span></p><p><span class="math inline">\(ps:\)</span>注意边缘密度函数的区间范围。</p><hr><h2 id="t41">t41</h2><blockquote><p>设随机变量 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 独立同分布, 且 <span class="math display">\[P(X=-1)=P(Y=-1)=P(X=1)=P(Y=1)=\frac{1}{2} .\]</span></p><p>试求 <span class="math inline">\(P(X=Y)\)</span>.</p></blockquote><h3 id="解析-5">解析</h3><p>由于 <span class="math inline">\(X\)</span> 在某个点处的概率不为<span class="math inline">\(0\)</span> 所以 <span class="math inline">\(X\)</span> 一定是离散随机变量，又 <span class="math inline">\(P(X=-1)+P(X=1)=1\)</span> 所以可以很清楚的知道<span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 的分布。</p><p>利用独立性可得 <span class="math display">\[\begin{aligned}P(X=Y) &amp; =P(X=-1, Y=-1)+P(X=1, Y=1) \\&amp; =P(X=-1) P(Y=-1)+P(X=1) P(Y=1) \\&amp; =\frac{1}{4}+\frac{1}{4}=0.5 .\end{aligned}\]</span></p><hr><h2 id="t42">t42</h2><blockquote><p>若两随机变量边际的分布列分别为: <span class="math display">\[\begin{array}{c|ccc}X &amp; -1 &amp; 0 &amp; 1 \\\hline P &amp; \dfrac{1}{4} &amp; \dfrac{1}{2} &amp; \dfrac{1}{4}\end{array} \quad\begin{array}{c|cc}Y &amp; 0 &amp; 1 \\\hline P &amp; \dfrac{1}{2} &amp; \dfrac{1}{2}\end{array}\]</span> 若 <span class="math inline">\(P(X Y=0)=1\)</span> ，求:</p><p><span class="math inline">\((1)(X, Y)\)</span> 的联合分布列；</p><ol start="2" type="1"><li><span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 是否独立?</li></ol></blockquote><h3 id="解析-6">解析</h3><p>（1）<img src="../../../../images/概率论5-2期末考试习题/11.jpg"></p><p>（2）<span class="math inline">\(P(X=0,Y=0)=0\neqP_X(X=0)P_Y(Y=0)\Rightarrow X和Y不独立\)</span></p><p><span class="math inline">\(ps:\)</span> <span class="math inline">\(t42\)</span> 和 <span class="math inline">\(t36\)</span>是一个类型，都要先列出联合分布列再通过题干条件、边际分布、正则性来计算出联合分布的概率，注意不能在独立性上出错。再结合 <span class="math inline">\(t43\)</span>来巩固一下离散变量的联合分布列。</p><hr><h2 id="t43">t43</h2><blockquote><p><img src="../../../../images/概率论5-2期末考试习题/12.jpg"></p></blockquote><h3 id="解析-7">解析</h3><p>先根据正则性有： <span class="math inline">\(a+1/9+c+1/9+b+1/3=1\)</span> 得：<span class="math inline">\(a+b+c=4/9\)</span></p><p>再利用 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 相互独立的信息计算，即：利用 <span class="math inline">\(P(X=x,Y=y)=P(X=x)P(Y=y)\)</span> 计算：</p><p>先发现第二行和第二列上只有一个未知量，所以： <span class="math display">\[P(X=x_2,Y=y_2)=P(X=x_2)P(Y=y_2)\Rightarrow b=(1/9+b)(4/9+b)\]</span> 解得 <span class="math inline">\(b=\dfrac{2}{9}\)</span></p><p>再发现第二行和第一列上只有一个未知量，所以： <span class="math display">\[P(X=x_2,Y=y_1)=P(X=x_2)P(Y=y_1)\Rightarrow 1/9=(1/9+a)(1/9+2/9+1/3)\]</span> 解得 <span class="math inline">\(a=\dfrac{1}{18}\)</span></p><p>最后得 <span class="math inline">\(c=\dfrac{1}{6}\)</span></p><hr><h2 id="t44">t44</h2><blockquote><p>设随机变量 <span class="math inline">\((X, Y)\)</span>的联合密度函数为 <span class="math display">\[p(x, y)= \begin{cases}1, &amp; |x|&lt;y, \quad 0&lt;y&lt;1, \\ 0, &amp;\text { 其他. }\end{cases}\]</span></p><p>试求: (1) 边际密度函数 <span class="math inline">\(p_x(x)\)</span> 和<span class="math inline">\(p_Y(y)\)</span>; (2) <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 是否独立?</p></blockquote><h3 id="解析-8">解析</h3><p>（1）因为 <span class="math inline">\(p(x, y)\)</span>的非零区域如下：</p><p><img src="../../../../images/概率论5-2期末考试习题/13.jpg"></p><p>所以, 当 <span class="math inline">\(-1&lt;x&lt;0\)</span> 时, 有<span class="math display">\[p_X(x)=\int_{-x}^1 \mathrm{~d} y=1+x,\]</span></p><p>当 <span class="math inline">\(0&lt;x&lt;1\)</span> 时,有 <span class="math display">\[p_X(x)=\int_x^1 \mathrm{~d} y=1-x,\]</span></p><p>因此 <span class="math inline">\(X\)</span> 的边际密度函数为 <span class="math display">\[p_X(x)= \begin{cases}1+x, &amp; -1&lt;x&lt;0, \\ 1-x, &amp; 0&lt;x&lt;1,\\ 0, &amp; \text { 其他. }\end{cases}\]</span></p><p>又当 <span class="math inline">\(0&lt;y&lt;1\)</span> 时, 有 <span class="math display">\[p_Y(y)=\int_{-y}^y \mathrm{~d} x=2 y,\]</span></p><p>因此 <span class="math inline">\(Y\)</span> 的边际密度函数为 <span class="math display">\[p_Y(y)= \begin{cases}2 y, &amp; 0&lt;y&lt;1, \\ 0, &amp; \text { 其他.}\end{cases}\]</span> （2）因为 <span class="math inline">\(p(x, y) \neq p_X(x)p_Y(y)\)</span>, 所以 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 不独立.</p><hr><h2 id="t45">t45</h2><blockquote><p>设随机变量 <span class="math inline">\(X, Y\)</span> 独立同分布,在以下情况下求随机变量 <span class="math inline">\(Z=\max \{X,Y\}\)</span> 的分布列: (1) <span class="math inline">\(X\)</span> 服从<span class="math inline">\(p=0.5\)</span> 的 <span class="math inline">\(0-1\)</span> 分布; (2) <span class="math inline">\(X\)</span> 服从几何分布, 即 <span class="math inline">\(P(X=k)=(1-p)^{k-1} p, k=1,2, \cdots\)</span>.</p></blockquote><h3 id="解析-9">解析</h3><p>（1）因为 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 的可能取值均为 0 或 1 , 所以 <span class="math inline">\(Z=\max \{X, Y\}\)</span> 的可能取值也为 0 或 1 ,因此 <span class="math display">\[\begin{aligned}&amp; P(Z=0)=P(X=0, Y=0)=P(X=0) P(Y=0)=0.5 \times 0.5=0.25, \\&amp; P(Z=1)=1-P(Z=0)=0.75 .\end{aligned}\]</span> （2）因为 <span class="math inline">\(X\)</span> 服从几何分布,所以 <span class="math display">\[P(X \leqslant i)=\sum_{j=1}^i(1-p)^{j-1} p=p\frac{1-(1-p)^i}{1-(1-p)}=1-(1-p)^i, \quad i=1,2, \cdots .\]</span></p><p>​ 由此得 <span class="math display">\[\begin{aligned}P(Z=i) &amp; =P(Z \leqslant i)-P(Z \leqslant i-1) \\&amp; =P(X \leqslant i) P(Y \leqslant i)-P(X \leqslant i-1) P(Y\leqslant i-1) \\&amp; =\left[1-(1-p)^i\right]^2-\left[1-(1-p)^{i-1}\right]^2 \\&amp; =-2(1-p)^i+(1-p)^{2 i}+2(1-p)^{i-1}-(1-p)^{2 i-2} \\&amp; =(1-p)^{i-1} p\left[2-(1-p)^{i-1}-(1-p)^i\right], \quad i=1,2,\cdots .\end{aligned}\]</span></p><p><span class="math inline">\(ps:\)</span>注意通过区间相减计算离散随机变量等于某个数值的概率。相似的想法在 <span class="math inline">\(t3\)</span> 中也有体现。</p><hr><h2 id="t46">t46</h2><blockquote><p>设 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 为两个随机变量, 且 <span class="math display">\[P(X \geqslant 0, Y \geqslant 0)=\frac{3}{7}, \quad P(X \geqslant 0)=P(Y\geqslant 0)=\frac{4}{7} .\]</span></p><p>试求 <span class="math inline">\(P(\max \{X, Y\} \geqslant0)\)</span>.</p></blockquote><h3 id="解析-10">解析</h3><p>因为 <span class="math display">\[\begin{aligned}4 / 7 &amp; =P(X \geqslant 0)=P(X \geqslant 0, Y \geqslant 0)+P(X\geqslant 0, Y&lt;0) \\&amp; =3 / 7+P(X \geqslant 0, Y&lt;0),\end{aligned}\]</span></p><p>由此得 <span class="math inline">\(P(X \geqslant 0, Y&lt;0)=1 /7\)</span>, 同理由 <span class="math inline">\(P(Y \geqslant 0)=4 /7\)</span>, 可得 <span class="math inline">\(P(X&lt;0, Y \geqslant0)=\)</span> <span class="math inline">\(1 / 7\)</span>, 再由 <span class="math display">\[\begin{aligned}&amp; P(X \geqslant 0, Y \geqslant 0)+P(X \geqslant 0, Y&lt;0)+P(X&lt;0,Y \geqslant 0)+P(X&lt;0, Y&lt;0)=1, \\&amp; \text { 得 } P(X&lt;0, Y&lt;0)=2 / 7 \text {, 所以 } \\&amp; P(\max \{X, Y\} \geqslant 0)=1-P(\max \{X, Y\}&lt;0)=1-P(X&lt;0,Y&lt;0)=1-2 / 7=5 / 7 .\end{aligned}\]</span></p><hr><h2 id="t47">t47</h2><blockquote><p>设二维随机变量 <span class="math inline">\((X,Y)\)</span>是连续随机变量，联合密度函数为 <span class="math inline">\(p(x,y)\)</span> ，写出下列连续随机变量 <span class="math inline">\(Z\)</span> 的密度函数：</p><p>（1）<span class="math inline">\(Z=X+Y\)</span></p><p>（2）<span class="math inline">\(Z=XY\)</span></p><p>（3）<span class="math inline">\(Z=X/Y\)</span></p></blockquote><h3 id="答案">答案</h3><p>（1） <span class="math display">\[\begin{aligned}p_Z(z) &amp; =\int_{-\infty}^{\infty} p_{X, Y}(x, z-x) \mathrm{d} x \\\text { 或 } &amp; =\int_{-\infty}^{\infty} p_{X, Y}(z-y, y) \mathrm{d}y .\end{aligned}\]</span> （2） <span class="math display">\[\begin{aligned}p_Z(z) &amp; =\int_{-\infty}^{\infty} p_{X, Y}(x, \dfrac{z}{x}) \left|\dfrac{1}{x}\right|\mathrm{d} x \\\text { 或 } &amp; =\int_{-\infty}^{\infty} p_{X, Y}(\dfrac{z}{y}, y)\left |\dfrac{1}{y}\right| \mathrm{d} y .\end{aligned}\]</span> （3） <span class="math display">\[\begin{aligned}p_Z(z) &amp; =\int_{-\infty}^{\infty} p_{X, Y}(zy, y) \left|y\right|\mathrm{d} x \\\text { 或 } &amp; =\int_{-\infty}^{\infty} p_{X, Y}(x,\dfrac{x}{z})\dfrac{|x|}{z^2} \mathrm{d} y .\end{aligned}\]</span> <span class="math inline">\(ps:\)</span> 记忆的方法是把 <span class="math inline">\(p(x,y)\)</span> 替换成对应于随机变量变换过程的<span class="math inline">\(x,z\)</span> 或 <span class="math inline">\(y,z\)</span> 的式子，比如 <span class="math inline">\(Z=X/Y\)</span> 就换成 <span class="math inline">\((zy,y)\)</span> 或 <span class="math inline">\((x,x/z)\)</span> 然后再在后面乘上一个对 <span class="math inline">\((\quad)\)</span> 内含 <span class="math inline">\(z\)</span> 的那一项对 <span class="math inline">\(z\)</span> 求导的绝对值，比如 <span class="math inline">\(Z=X/Y\)</span> ，<span class="math inline">\(p(zy,y)\)</span> 后面乘 <span class="math inline">\(|y|\)</span> 、<span class="math inline">\(p(x,x/z)\)</span> 后面乘 <span class="math inline">\(\dfrac{|x|}{z^2}.\)</span></p><hr><h2 id="t48">t48</h2><blockquote><p>设 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 的联合密度函数为 <span class="math display">\[p(x, y)= \begin{cases}\mathrm{e}^{-(x+y)}, &amp; x&gt;0, y&gt;0, \\ 0,&amp; \text { 其他. }\end{cases}\]</span></p><p>试求以下随机变量的密度函数: (1) <span class="math inline">\(Z=(X+Y) /2\)</span>; (2) <span class="math inline">\(Z=Y-X\)</span>.</p></blockquote><h3 id="解析-11">解析</h3><p>方法一（分布函数法）：</p><p>（1）因为 <span class="math inline">\(p(x, y)\)</span> 的非零区域为<span class="math inline">\(x&gt;0, y&gt;0\)</span>, 所以当 <span class="math inline">\(z \leqslant 0\)</span> 时, <span class="math inline">\(F_z(z)=0\)</span>, 而当 <span class="math inline">\(z&gt;0\)</span> 时, <span class="math display">\[\begin{aligned}F_Z(z) &amp; =P(Z \leqslant z)=P(X+Y \leqslant 2 z)=\int_0^{2 z}\int_0^{2 z-x} \mathrm{e}^{-(x+y)} \mathrm{d} y \mathrm{~d} x \\&amp; =\int_0^{2 z} \mathrm{e}^{-x}\left(1-\mathrm{e}^{-(2 z-x)}\right)\mathrm{d} x=1-\mathrm{e}^{-2 z}-2 z \mathrm{e}^{-2 z},\end{aligned}\]</span></p><p>​ 所以, 当 <span class="math inline">\(z \leqslant 0\)</span> 时, 有<span class="math inline">\(p_Z(z)=0\)</span>; 而当 <span class="math inline">\(z&gt;0\)</span> 时, 有 <span class="math inline">\(p_{Z}(z)=4 z \mathrm{e}^{-2 z}.\)</span></p><p>（2）当 <span class="math inline">\(z \leqslant 0\)</span> 时, <span class="math inline">\(p(x, y)\)</span> 的非零区域与 <span class="math inline">\(\{y-x \leqslant z\}\)</span> 的交集如下图：</p><p><img src="../../../../images/概率论5-2期末考试习题/14.jpg"> <span class="math display">\[\begin{aligned}F_Z(z) &amp; =P(Z \leqslant z)=P(Y-X \leqslant z)=\int_0^{\infty}\int_{y-z}^{\infty} \mathrm{e}^{-(x+y)} \mathrm{d} x \mathrm{~d} y \\&amp; =\int_0^{\infty} \mathrm{e}^{-y} \mathrm{e}^{-(y-z)} \mathrm{d}y=\mathrm{e}^z / 2, \\p_Z(z) &amp; =F_Z^{\prime}(z)=\mathrm{e}^z / 2 .\end{aligned}\]</span></p><p>又因为当 <span class="math inline">\(z&gt;0\)</span> 时, <span class="math inline">\(p(x, y)\)</span> 的非零区域与 <span class="math inline">\(\{y-x \leqslant z\}\)</span>的交集如下图所示：</p><p><img src="../../../../images/概率论5-2期末考试习题/15.jpg"> <span class="math display">\[\begin{aligned}F_Z(z) &amp; =P(Z \leqslant z)=P(Y-X \leqslant z)=\int_0^{\infty}\int_0^{x+z} \mathrm{e}^{-(x+y)} \mathrm{d} y \mathrm{~d} x \\&amp; =\int_0^{\infty} \mathrm{e}^{-x}\left(1-\mathrm{e}^{-(x+z)}\right)\mathrm{d} x=1-\mathrm{e}^{-z} / 2, \\p_Z(z) &amp; =F_Z^{\prime}(z)=\mathrm{e}^{-z} / 2 .\end{aligned}\]</span> 所以，得： <span class="math display">\[p_Z(z)=\dfrac{\mathrm{e}^{|z|}}{2}, \quad-\infty&lt;z&lt;\infty \text {.}\]</span> 方法二（变换变量法）：</p><p><img src="../../../../images/概率论5-2期末考试习题/16.jpg"></p><hr><h2 id="t49">t49</h2><blockquote><p>设随机变量 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 相互独立, 试在以下情况下求 <span class="math inline">\(Z=X+Y\)</span> 的密度函数: (1) <span class="math inline">\(X \sim U(0,1), Y \sim U(0,1)\)</span>; (2) <span class="math inline">\(X \sim U(0,1), Y \sim\operatorname{Exp}(1)\)</span>.</p></blockquote><h3 id="解析-12">解析</h3><p><span class="math inline">\(Z=X+Y\)</span> 的密度函数可由卷积公式求得<span class="math display">\[p_Z(z)=\int_{-\infty}^{\infty} p_X(x) p_Y(z-x) \mathrm{d} x .\]</span> （1）因为 <span class="math inline">\(X \sim U(0,1), Y \simU(0,1)\)</span>, 所以 <span class="math inline">\(Z=X+Y\)</span>可在区间 <span class="math inline">\((0,2)\)</span> 上取值,且使卷积公式中的被积函数大于 0 的区域必须是 <span class="math inline">\(\{0 \leqslant x \leqslant 1\}\)</span> 与 <span class="math inline">\(\{0 \leqslant z-x \leqslant 1\}\)</span> 的交集,即下图的阴影部分：</p><p><img src="../../../../images/概率论5-2期末考试习题/17.jpg"></p><p>从图中可以看出: <span class="math display">\[\begin{aligned}&amp; \text { 当 } 0 \leqslant z \leqslant 1 \text { 时, 有 }p_Z(z)=\int_0^z \mathrm{~d} x=z, \\&amp; \text { 当 } 1 \leqslant z \leqslant 2 \text { 时, 有 }p_Z(z)=\int_{z-1}^1 \mathrm{~d} x=2-z .\end{aligned}\]</span></p><p>所以得 <span class="math inline">\(Z\)</span> 的密度函数如下: <span class="math display">\[p_z(z)= \begin{cases}z, &amp; 0 \leqslant z&lt;1, \\ 2-z, &amp; 1\leqslant z&lt;2, \\ 0, &amp; \text { 其他. }\end{cases}\]</span> （2）(2) 因为 <span class="math inline">\(X \sim U(0,1), Y\sim \operatorname{Exp}(1)\)</span>, 所以 <span class="math inline">\(Z=X+Y\)</span>可在 <span class="math inline">\((0,\infty)\)</span> 上取值,且要使卷积公式中的被积函数大于 0 的区域必须是<span class="math inline">\(\{0 \leqslant x \leqslant 1\}\)</span> 与<span class="math inline">\(\{z-x \geqslant 0\}\)</span> 的交集,即下图的阴影部分：</p><p><img src="../../../../images/概率论5-2期末考试习题/18.jpg"></p><p>从图中可以看出: <span class="math display">\[\begin{aligned}&amp;当 0 \leqslant z \leqslant 1 时, 有 p_Z(z)=\int_0^z\mathrm{e}^{-(z-x)} \mathrm{d} x=1-\mathrm{e}^{-z},\\&amp;当 1 \leqslant z 时, 有 p_Z(z)=\int_0^1 \mathrm{e}^{-(z-x)}\mathrm{d} x=\mathrm{e}^{-z}(\mathrm{e}-1).\end{aligned}\]</span> 所以得 <span class="math inline">\(Z\)</span> 的密度函数如下:<span class="math display">\[p_Z(z)=\left\{\begin{array}{cl}1-\mathrm{e}^{-z}, &amp; 0&lt;z \leqslant 1, \\\mathrm{e}^{-z}(\mathrm{e}-1), &amp; z&gt;1, \\0, &amp; \text { 其他. }\end{array}\right.\]</span></p><hr><h2 id="t50">t50</h2><blockquote><p>设二维随机变量 <span class="math inline">\((X, Y)\)</span> 在矩形<span class="math display">\[G=\{(x, y): 0 \leqslant x \leqslant 2,0 \leqslant y \leqslant 1\}\]</span></p><p>上服从均匀分布, 试求边长分别为 <span class="math inline">\(X\)</span>和 <span class="math inline">\(Y\)</span> 的矩形面积 <span class="math inline">\(Z\)</span> 的密度函数.</p></blockquote><h3 id="解析-13">解析</h3><p>因为 <span class="math inline">\((X, Y)\)</span> 服从矩形 <span class="math inline">\(G\)</span> 上的均匀分布, 所以 <span class="math inline">\((X, Y)\)</span> 的联合密度函数为 <span class="math display">\[p_{X, Y}(x, y)= \begin{cases}\dfrac{1}{2}, &amp; 0 \leqslant x \leqslant2,0 \leqslant y \leqslant 1, \\ 0, &amp; \text { 其他. }\end{cases}\]</span></p><p>又因为面积 <span class="math inline">\(Z=X Y\)</span>, 所以 <span class="math inline">\(Z\)</span> 可在区间 <span class="math inline">\((0,2)\)</span> 上取值, 且 <span class="math inline">\(Z\)</span> 的密度函数可用积的公式求得 <span class="math display">\[p_Z(z)=\int_{-\infty}^{\infty} p_{X, Y}(z / v, v) \frac{1}{|v|}\mathrm{d} v .\]</span></p><p>要使以上被积函数大于 <span class="math inline">\(0\)</span>的区域必须是 <span class="math inline">\(\{0&lt;z / v&lt;2\}\)</span> 与<span class="math inline">\(\{0&lt;v&lt;1\}\)</span> 的交集, 此交集为<span class="math inline">\(\{z / 2&lt;v&lt;1\}\)</span>, 所以当 <span class="math inline">\(0&lt;z&lt;2\)</span> 时, 有 <span class="math display">\[p_Z(z)=\int_{z / 2}^1 \frac{1}{2 v} \mathrm{~d} v=\left(\frac{1}{2} \lnv\right)_{z / 2}^1=\frac{\ln 2-\ln z}{2} .\]</span></p><hr><h2 id="t51">t51</h2><blockquote><p>设随机变量 <span class="math inline">\((X, Y)\)</span> 相互独立,其概率密度为 <span class="math display">\[f_X(x)=\left\{\begin{array}{cc}1, &amp; 0&lt;x&lt;1, \\0, &amp; \text { 其他. }\end{array} f_Y(y)=\left\{\begin{array}{cc}e^{-y}, &amp; y&gt;0, \\0, &amp; \text { 其他. }\end{array}\right.\right.\]</span></p><p>求 <span class="math inline">\(Z=2 X+Y\)</span> 的概率密度函数</p></blockquote><h3 id="解析-14">解析</h3><p>方法一：</p><p><img src="../../../../images/概率论5-2期末考试习题/19.jpg"></p><p>方法二：</p><p><img src="../../../../images/概率论5-2期末考试习题/20.jpg"></p><p><span class="math inline">\(ps:\)</span> <span class="math inline">\(t47-t51\)</span>都是多为随机变量函数的题目，是考试的重点，要注意练习。</p><hr><h2 id="t52">t52</h2><blockquote><p>设在区间 <span class="math inline">\((0,1)\)</span> 上随机地取 <span class="math inline">\(n\)</span>个点,求相距最远的两点间的距离的数学期望.</p></blockquote><h3 id="解析-15">解析</h3><p>方法一</p><p>分别记此 <span class="math inline">\(n\)</span> 个点为 <span class="math inline">\(X_1, X_2, \cdots, X_n\)</span>, 则 <span class="math inline">\(X_1, X_2, \cdots, X_n\)</span> 相互独立,且都服从区间 <span class="math inline">\((0,1)\)</span> 上的均匀分布<span class="math inline">\(U(0,1)\)</span>. 我们的目的是求 <span class="math display">\[E\left(\max \left\{X_1, X_2, \cdots, X_n\right\}-\min \left\{X_1, X_2,\cdots, X_n\right\}\right) .\]</span></p><p>而 <span class="math inline">\(Z=\max \left\{X_1, X_2, \cdots,X_n\right\}\)</span> 和 <span class="math inline">\(T=\min \left\{X_1,X_2, \cdots, X_n\right\}\)</span> 的密度函数分别为 <span class="math display">\[p_Z(z)=\left\{\begin{array}{ll}n z^{n-1}, &amp; 0&lt;z&lt;1, \\0, &amp; \text { 其他. }\end{array} \quad p_T(t)= \begin{cases}n(1-t)^{n-1}, &amp; 0&lt;t&lt;1,\\0, &amp; \text { 其他. }\end{cases}\right.\]</span></p><p>又因为 <span class="math display">\[E(Z)=\int_0^1 z n z^{n-1} \mathrm{~d} z=\frac{n}{n+1} ; \quadE(T)=\int_0^1 t n(1-t)^{n-1} \mathrm{~d} t=\frac{1}{n+1},\]</span></p><p>所以 <span class="math display">\[E\left(\max \left\{X_1, X_2, \cdots, X_n\right\}-\min \left\{X_1, X_2,\cdots, X_n\right\}\right)=\frac{n}{n+1}-\frac{1}{n+1}=\frac{n-1}{n+1} .\]</span> 方法二</p><p><span class="math inline">\(n\)</span> 个点把区间 <span class="math inline">\((0,1)\)</span> 分成 <span class="math inline">\(n+1\)</span> 段, 它们的长度依次记为 <span class="math inline">\(Y_1, Y_2, \cdots, Y_{n+1}\)</span>.因为此 <span class="math inline">\(n\)</span> 个点是随机取的, 所以 <span class="math inline">\(Y_1, Y_2, \cdots, Y_{n+1}\)</span> 具有相同的分布,从而有相同的数学期望. 而 <span class="math inline">\(Y_1+Y_2+\cdots+Y_{n+1}=1\)</span>, 因此 <span class="math display">\[E\left(Y_1\right)=E\left(Y_2\right)=\cdots=E\left(Y_{n+1}\right)=\frac{1}{n+1}.\]</span></p><p>而相距最远的两点间的距离为 <span class="math inline">\(Y_2+Y_3+\cdots+Y_n\)</span>, 因此所求期望为 <span class="math display">\[E\left(Y_2+Y_3+\cdots+Y_n\right)=\frac{n-1}{n+1} .\]</span></p><p><span class="math inline">\(ps:\)</span>方法一利用了最大值最小值分布，《知识点总结》的 <span class="math inline">\(\S 3.3\)</span></p><hr><h2 id="t53">t53</h2><blockquote><p>已知连续型随机变量 <span class="math inline">\(\mathrm{X}\)</span>的密度函数为 <span class="math display">\[f(x)=\frac{1}{2} e^{-|x|},-\infty&lt;x&lt;\infty\]</span> （1）求 <span class="math inline">\(X\)</span>的数学期望与方差 （2）求 <span class="math inline">\(X,|X|\)</span>的协方差, 并判断是否不相关, （3）求 <span class="math inline">\(X,|X|\)</span> 是否相互独立</p></blockquote><h3 id="解析-16">解析</h3><p>（1） <span class="math inline">\(E(X)=\displaystyle\int_{-\infty}^{\infty} x f(x) d x=0 . Var(X)=\int_{-\infty}^{+\infty}x^2 f(x) d x=\int_0^{+\infty} x^2 e^{-x} d x=2\)</span>.</p><p>​ 计算方差时使用两次分部积分。</p><p>（2） <span class="math inline">\(\displaystyle\operatorname{Cov}(X,|X|)=E(X|X|)-E X \cdotE(|X|)=E(X|X|)=\int_{-\infty}^{+\infty} x|x| f(x) d x=0\)</span>.所以<span class="math inline">\(X\)</span> 与 <span class="math inline">\(|X|\)</span> 不相关. （3）对于任意给定的 <span class="math inline">\(0&lt;x_0&lt;+\infty\)</span>, 事件 <span class="math inline">\(\left\{|X|&lt;x_0\right\}\)</span> 包含在事件<span class="math inline">\(\left\{X&lt;x_0\right\}\)</span> 内, 故有<span class="math inline">\(0&lt;P\left\{|X|&lt;x_0\right\} \leqP\left\{X&lt;x_0\right\}&lt;1\)</span>,</p><p>从而 <span class="math inline">\(P\left\{X&lt;x_0,|X|&lt;x_0\right\}=P\left\{|X|&lt;x_0\right\}&gt;P\left\{|X|&lt;x_0\right\}\cdot P\left\{X&lt;x_0\right\}\)</span>,因此, <span class="math inline">\(X\)</span> 与 <span class="math inline">\(|X|\)</span> 不互相独立.</p><hr><h2 id="t54">t54</h2><blockquote><p>随机变量 <span class="math inline">\((X, Y)\)</span> 服从以点 <span class="math inline">\((0,1),(1,0),(1,1)\)</span>为顶点的三角形区域上的均匀分布, 试求 <span class="math inline">\(E(X+Y)\)</span> 和 <span class="math inline">\(\operatorname{Var}(X+Y)\)</span>.</p></blockquote><h3 id="解析-17">解析</h3><p>记此三角形区域为 <span class="math inline">\(D\)</span> ，因为 <span class="math inline">\(D\)</span> 的面积为 <span class="math inline">\(1/ 2\)</span>, 所以 <span class="math inline">\((X, Y)\)</span>的联合密度函数为 <span class="math display">\[p_{X, Y}(x, y)= \begin{cases}2, &amp; (x, y) \in D, \\ 0, &amp; (x, y)\notin D .\end{cases}\]</span></p><p>下求 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 各自的边际密度函数. 当 <span class="math inline">\(0&lt;x&lt;1\)</span> 时, 有 <span class="math inline">\(\displaystyle p_X(x)=\int_{1-x}^1 2 \mathrm{~d}y=2 x\)</span>.</p><p>当 <span class="math inline">\(0&lt;y&lt;1\)</span> 时, 有 <span class="math inline">\(\displaystyle p_Y(y)=\int_{1-y}^1 2 \mathrm{~d}x=2 y\)</span>.</p><p>计算出期望和方差： <span class="math display">\[E(X)=E(Y)=\frac{2}{3} ; \quad\operatorname{Var}(X)=\operatorname{Var}(Y)=\frac{1}{18} .\]</span></p><p>由于 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 不独立, 所以先计算 <span class="math display">\[E(X Y)=\int_0^1 \int_{1-x}^1 2 x y \mathrm{~d} y \mathrm{~d}x=\frac{5}{12} \cdot\]</span></p><p>由此得 <span class="math display">\[\operatorname{Cov}(X, Y)=E(X Y)-E(X)E(Y)=\frac{5}{12}-\frac{4}{9}=-\frac{1}{36} \text {. (负相关) }\]</span></p><p>最后得 <span class="math display">\[\begin{aligned}&amp; E(X+Y)=\frac{2}{3}+\frac{2}{3}=\frac{4}{3} \\&amp;\operatorname{Var}(X+Y)=\operatorname{Var}(X)+\operatorname{Var}(Y)+2\operatorname{Cov}(X,Y)=\frac{1}{18}+\frac{1}{18}-\frac{2}{36}=\frac{1}{18}\end{aligned}\]</span></p><hr><h2 id="t55">t55</h2><blockquote><p>若随机变量 <span class="math inline">\(X \sim N(0,1), Y \simN(1,4)\)</span> 且相关系数 <span class="math inline">\(\rho_{XY}=1\)</span>. 设 <span class="math inline">\(Y=aX+b\)</span></p><p>求：<span class="math inline">\(a、b.\)</span></p></blockquote><h3 id="解析-18">解析</h3><p>设 <span class="math inline">\(Y=a X+b . \quad \rho_{X Y}=1&gt;0\Rightarrow a&gt;0.\)</span></p><p>求 <span class="math inline">\(b:\)</span></p><p><span class="math inline">\(X \sim N(0,1) \Rightarrow E(X)=0 \quad Y\sim N(1,2) \Rightarrow E(Y)=1\)</span></p><p>则 <span class="math inline">\(E(Y)=E(a X+b)=a E(X)+b=b \quad\Rightarrow b=1\)</span></p><p>求 <span class="math inline">\(a:\)</span> <span class="math inline">\(\quad X \sim N(0,1) \Rightarrow \sigma_X=1 ，\quad Y \sim N(1,4) \Rightarrow \sigma_Y=2\)</span></p><p><span class="math inline">\(\rho_{X Y}=\frac{\operatorname{Cov}(X,Y)}{\sigma_X \sigma_Y}=\frac{\operatorname{Cov}(X, Y)}{1 \cdot 2}=1\Rightarrow \operatorname{Cov}(X, Y)=2 \\\)</span></p><p><span class="math inline">\(\operatorname{Cov}(X,Y)=E(XY)-E(X)E(Y)=E(X Y)=E(X(a X+1))=E\left(a X^2+X)=aE\left(X^2\right)\right.+ E(X)=aE(X^2)\)</span></p><p>$ (X)=1=E(X<sup>2)-(E(X))</sup>2=E(X^2) E(X^2)=1$</p><p><span class="math inline">\(\operatorname{Cov}(X, Y)=a \Rightarrowa=2\)</span></p><hr><h2 id="t56">t56</h2><blockquote><p>一商店经销某种商品, 每周进货量 <span class="math inline">\(X\)</span>与顾客对该种商品的需求量 <span class="math inline">\(Y\)</span>是相互独立的随机变量,且都服从区间 <span class="math inline">\((10,20)\)</span> 上的均匀分布.商店每售出一单位商品可得利润 1000 元; 若需求量超过了进货量,则可从其他商店调剂供应, 这时每单位商品获利润为 500元.试求此商店经销该种商品每周的平均利润.</p></blockquote><h3 id="解析-19">解析</h3><p>记 <span class="math inline">\(Z\)</span>为此商店经销该种商品每周所得的利润, 由题设知 <span class="math inline">\(Z=g(X, Y)\)</span>, 其中 <span class="math display">\[g(x, y)=\left\{\begin{array}{ll}1000 y, \\1000 x+500(y-x)\end{array}= \begin{cases}1000 y, &amp; y \leqslant x, \\500(x+y), &amp; y&gt;x .\end{cases}\right.\]</span></p><p>由题设条件知 <span class="math inline">\((X, Y)\)</span>的联合概率密度为 <span class="math display">\[p_{X, Y}(x, y)= \begin{cases}1 / 100, &amp; 10 \leqslant x \leqslant20,10 \leqslant y \leqslant 20, \\ 0, &amp; \text { 其他 },\end{cases}\]</span></p><p>于是 <span class="math display">\[\begin{aligned}E(Z) &amp; =E(g(X, Y))=\int_{-\infty}^{\infty} \int_{-\infty}^{\infty}g(x, y) p_{X, Y}(x, y) \mathrm{d} x \mathrm{~d} y \\&amp; =\iint_{y \leqslant x} 1000 y p_{X, Y}(x, y) \mathrm{d} x\mathrm{~d} y+\iint_{y&gt;x} 500(x+y) p_{X, Y}(x, y) \mathrm{d} x\mathrm{~d} y \\&amp; =10 \int_{10}^{20} \mathrm{~d} y \int_y^{20} y \mathrm{~d} x+5\int_{10}^{20} \mathrm{~d} y \int_{10}^y(x+y) \mathrm{d} x \\&amp; =20000 / 3+5 \times 1500 \approx 14166.67 .\end{aligned}\]</span></p><hr><h2 id="t57">t57</h2><blockquote><p>设随机变量 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 独立同服从参数为 <span class="math inline">\(\lambda\)</span> 的泊松分布, 令 <span class="math display">\[U=2 X+Y, \quad V=2 X-Y .\]</span></p><p>求 <span class="math inline">\(U\)</span> 和 <span class="math inline">\(V\)</span> 的相关系数 <span class="math inline">\(\operatorname{Corr}(U, V)\)</span>.</p></blockquote><h3 id="解析-20">解析</h3><p>因为 <span class="math display">\[\begin{aligned}&amp; \operatorname{Var}(U)=\operatorname{Var}(2 X+Y)=4\operatorname{Var}(X)+\operatorname{Var}(Y)=5 \lambda, \\&amp; \operatorname{Var}(V)=\operatorname{Var}(2 X-Y)=4\operatorname{Var}(X)+\operatorname{Var}(Y)=5 \lambda .\end{aligned}\]</span></p><p>所以 <span class="math display">\[\begin{aligned}\operatorname{Cov}(U, V) &amp; =\operatorname{Cov}(2 X+Y, 2 X-Y) \\&amp; =\operatorname{Cov}(2 X, 2 X)+\operatorname{Cov}(Y, 2X)-\operatorname{Cov}(2 X, Y)-\operatorname{Cov}(Y, Y) \\&amp; =4 \operatorname{Var}(X)-\operatorname{Var}(Y)=3 \lambda,\end{aligned}\]</span></p><p>由此得 <span class="math display">\[\operatorname{Corr}(U, V)=\frac{\operatorname{Cov}(U,V)}{\sqrt{\operatorname{Var}(U)} \sqrt{\operatorname{Var}(V)}}=\frac{3\lambda}{5 \lambda}=\frac{3}{5} .\]</span></p><hr><h2 id="t58">t58</h2><blockquote><p>设二维随机变量 <span class="math inline">\((X, Y)\)</span>的联合密度函数为 <span class="math display">\[p(x, y)= \begin{cases}3 x, &amp; 0&lt;y&lt;x&lt;1, \\ 0, &amp; \text {其他. }\end{cases}\]</span></p><p>求 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 的相关系数.</p></blockquote><h3 id="解析-21">解析</h3><p><span class="math inline">\(0&lt;x&lt;1\)</span> 时 <span class="math inline">\(x\)</span> 的密度函数为 <span class="math inline">\(\displaystylep_X(x)=\int_0^x3x\mathrm{~d}y\)</span></p><p><span class="math inline">\(0&lt;y&lt;1\)</span> 时 <span class="math inline">\(y\)</span> 的密度函数为 <span class="math inline">\(\displaystylep_Y(y)=\int_y^13x\mathrm{~d}x\)</span></p><p>先计算 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 的期望、方差与协方差. <span class="math display">\[\begin{aligned}&amp; E(X)=\int_0^1 \int_0^x 3 x^2 \mathrm{~d} y \mathrm{~d} x=\int_0^13 x^3 \mathrm{~d} x=\frac{3}{4}, \\&amp; E\left(X^2\right)=\int_0^1 \int_0^x 3 x^3 \mathrm{~d} y\mathrm{~d} x=\int_0^1 3 x^4 \mathrm{~d} x=\frac{3}{5}, \\&amp; E(Y)=\int_0^1 \int_0^x 3 x y \mathrm{~d} y \mathrm{~d} x=\int_0^1\frac{3}{2} x^3 \mathrm{~d} x=\frac{3}{8}, \\&amp; E\left(Y^2\right)=\int_0^1 \int_0^x 3 x y^2 \mathrm{~d} y\mathrm{~d} x=\int_0^1 x^4 \mathrm{~d} x=\frac{1}{5}, \\&amp;\operatorname{Var}(X)=E\left(X^2\right)-[E(X)]^2=\frac{3}{5}-\frac{9}{16}=\frac{3}{80},\\&amp;\operatorname{Var}(Y)=E\left(Y^2\right)-[E(Y)]^2=\frac{1}{5}-\frac{9}{64}=\frac{19}{320},\\&amp; E(X Y)=\int_0^1 \int_0^x 3 x^2 y \mathrm{~d} y \mathrm{~d}x=\int_0^1 \frac{3}{2} x^4 \mathrm{~d} x=\frac{3}{10}, \\&amp; \operatorname{Cov}(X, Y)=E(X Y)-E(X) E(Y)=\frac{3}{10}-\frac{3}{4}\times \frac{3}{8}=\frac{3}{160},\end{aligned}\]</span> 最后可得 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 的相关系数 <span class="math display">\[\operatorname{Corr}(X, Y)=\frac{\operatorname{Cov}(X,Y)}{\sqrt{\operatorname{Var}(X)} \sqrt{\operatorname{Var}(Y)}}=\frac{3 /160}{\sqrt{3 / 80} \sqrt{19 /320}}=\frac{3}{\sqrt{57}}=\frac{\sqrt{57}}{19}\]</span></p><hr><h2 id="t59">t59</h2><blockquote><p>在一个有 <span class="math inline">\(n\)</span> 个人参加的晚会上,每个人带了一件礼物, 且假定各人带的礼物都不相同. 晚会期间各人从放在一起的<span class="math inline">\(n\)</span>件礼物中随机抽取一件,试求抽中自己礼物的人数 <span class="math inline">\(X\)</span> 的均值和方差.</p></blockquote><h3 id="解析-22">解析</h3><p>记 <span class="math display">\[X_i=\left\{\begin{array}{ll}1, &amp; \text { 第 } i \text { 个人恰好取出自己的礼物 }, \\0, &amp; \text { 第 } i \text { 个人取出别人的礼物 },\end{array} \quad i=1,2, \cdots, n .\right.\]</span></p><p>则 <span class="math inline">\(X_1, X_2, \cdots, X_n\)</span>是同分布的, 但不独立. 其共同分布为 <span class="math display">\[P\left(X_i=1\right)=\frac{1}{n}, \quadP\left(X_i=0\right)=1-\frac{1}{n}, \quad i=1,2, \cdots, n .\]</span></p><p>由此得（由两点分布的期望和方差）： <span class="math display">\[E\left(X_i\right)=\frac{1}{n}, \quad\operatorname{Var}\left(X_i\right)=\frac{1}{n}\left(1-\frac{1}{n}\right),\quad i=1,2, \cdots, n .\]</span></p><p>又因为 <span class="math inline">\(X=X_1+X_2+\cdots+X_n\)</span>,所以 <span class="math display">\[E(X)=E\left(X_1\right)+E\left(X_2\right)+\cdots+E\left(X_n\right)=n\cdot \frac{1}{n}=1\]</span></p><p>但因为 <span class="math inline">\(X_i\)</span> 间不独立, 所以 <span class="math display">\[\operatorname{Var}(X)=\sum_{i=1}^n \operatorname{Var}\left(X_i\right)+2\sum_{i=1}^n \sum_{j=i+1}^n \operatorname{Cov}\left(X_i, X_j\right)\text {. }\]</span></p><p>为计算 <span class="math inline">\(\operatorname{Cov}\left(X_i,X_j\right)\)</span>, 先给出 <span class="math inline">\(X_i X_j\)</span>的分布列, 注意到 <span class="math inline">\(X_i X_j\)</span>的可能取值为 0,1 . 且 <span class="math display">\[P\left(X_i X_j=1\right)=P\left(X_i=1, X_j=1\right)=\frac{1}{n} \cdot\frac{1}{n-1},\]</span></p><p>所以 <span class="math display">\[E\left(X_i X_j\right)=0 \times P\left(X_i X_j=0\right)+1 \timesP\left(X_i X_j=1\right)=\frac{1}{n(n-1)} .\]</span></p><p>因此 <span class="math display">\[\operatorname{Cov}\left(X_i, X_j\right)=E\left(X_iX_j\right)-E\left(X_i\right)E\left(X_j\right)=\frac{1}{n(n-1)}-\left(\frac{1}{n}\right)^2=\frac{1}{n^2(n-1)},\]</span></p><p>由此得 <span class="math display">\[\displaystyle \operatorname{Var}(X)=\frac{n-1}{n}+2\binom{n}{2}\frac{1}{n^2(n-1)}=1 .\]</span></p><hr><h2 id="t60">t60</h2><blockquote><p>将一枚硬币重复掷 <span class="math inline">\(n\)</span> 次,以 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 分别表示正面向上和反面向上的次数, 试求<span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 的协方差及相关系数.</p></blockquote><h3 id="解析-23">解析</h3><p>因为 <span class="math inline">\(X+Y=n\)</span>, 且 <span class="math inline">\(X \sim b(n, 1 / 2), Y \sim b(n, 1 / 2)\)</span>,所以（注意 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 不独立） <span class="math display">\[\begin{aligned}&amp; \operatorname{Var}(X)=\operatorname{Var}(Y)=\frac{n}{4}, \\&amp; \operatorname{Cov}(X, Y)=\operatorname{Cov}(X,n-X)=\operatorname{Cov}(X,n)-\operatorname{Cov}(X,X)=-\operatorname{Var}(X)=-\frac{n}{4}, \\&amp; \operatorname{Corr}(X, Y)=\frac{\operatorname{Cov}(X,Y)}{\sqrt{\operatorname{Var}(X)} \sqrt{\operatorname{Var}(Y)}}=\frac{-n/ 4}{n / 4}=-1 .\end{aligned}\]</span> 关键在计算协方差时通过 <span class="math inline">\(X+Y=n\)</span> 将 <span class="math inline">\(Y\)</span> 替换成 <span class="math inline">\(n-X.\)</span></p><hr><h2 id="t61">t61</h2><blockquote><p>设二维随机变量 <span class="math inline">\((X, Y)\)</span> 服从区域<span class="math inline">\(D=\{(x, y):0&lt;x&lt;1,0&lt;x&lt;y&lt;1\}\)</span> 上的均匀分布, 求 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 的协方差及相关系数.</p></blockquote><h3 id="解析-24">解析</h3><p>因为区域 <span class="math inline">\(D\)</span> 的面积为 <span class="math inline">\(1 / 2\)</span>, 所以 <span class="math inline">\((X, Y)\)</span> 的联合密度函数为 <span class="math display">\[p_{X, Y}(x, y)= \begin{cases}2, &amp; (x, y) \in D, \\ 0, &amp; (x, y)\notin D .\end{cases}\]</span></p><p>由此得 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 各自的边际密度函数为 <span class="math display">\[\begin{aligned}&amp; \text { 当 } 0&lt;x&lt;1 \text { 时, } p_X(x)=\int_x^1 2\mathrm{~d} y=2(1-x) . \\&amp; \text { 当 } 0&lt;y&lt;1 \text { 时, } p_Y(y)=\int_0^y 2\mathrm{~d} x=2 y .\end{aligned}\]</span> 这表明 <span class="math inline">\(X \sim B e(1,2), Y \sim Be(2,1)\)</span>. 由此可算得 <span class="math inline">\(X\)</span> 与<span class="math inline">\(Y\)</span> 的期望与方差：</p><p>（如果不知道分布的话根据定义求 <span class="math inline">\(X\)</span>和 <span class="math inline">\(Y\)</span> 的积分也可以） <span class="math display">\[\begin{aligned}&amp; E(X)=\frac{1}{3}, \quad E(Y)=\frac{2}{3} . \\&amp; E\left(X^2\right)=\frac{1}{6}, \quad E\left(Y^2\right)=\frac{1}{2}. \\&amp; \operatorname{Var}(X)=\frac{1}{18}, \quad\operatorname{Var}(Y)=\frac{1}{18} .\end{aligned}\]</span></p><p>另外还需计算 <span class="math inline">\(X Y\)</span> 的期望 <span class="math display">\[E(X Y)=\int_0^1 \int_x^1 2 x y \mathrm{~d} y \mathrm{~d} x=\frac{1}{4},\]</span></p><p>由此得 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 的协方差及相关系数为 <span class="math display">\[\begin{gathered}\operatorname{Cov}(X, Y)=E(X Y)-E(X) E(Y)=\frac{1}{4}-\frac{1}{3} \times\frac{2}{3}=\frac{1}{36}, \\\operatorname{Corr}(X, Y)=\frac{\operatorname{Cov}(X,Y)}{\sqrt{\operatorname{Var}(X)} \sqrt{\operatorname{Var}(Y)}}=\frac{1 /36}{1 / 18}=\frac{1}{2} .\end{gathered}\]</span></p><hr><h2 id="t62">t62</h2><blockquote><p>设二维随机变量 <span class="math inline">\((X, Y)\)</span> 在矩形<span class="math display">\[G=\{(x, y): 0 \leqslant x \leqslant 2,0 \leqslant y \leqslant 1\}\]</span></p><p>上服从均匀分布, 记 <span class="math display">\[U=\left\{\begin{array}{ll}1, &amp; X&gt;Y, \\0, &amp; X \leqslant Y,\end{array} \quad V= \begin{cases}1, &amp; X&gt;2 Y, \\0, &amp; X \leqslant 2 Y .\end{cases}\right.\]</span></p><p>求 <span class="math inline">\(U\)</span> 和 <span class="math inline">\(V\)</span> 的相关系数.</p></blockquote><h3 id="解析-25">解析</h3><p>因为区域 <span class="math inline">\(G\)</span> 的面积为 2 , 所以<span class="math inline">\((X, Y)\)</span> 的联合密度函数为 <span class="math display">\[p_{X, Y}(x, y)=\left\{\begin{array}{cc}1 / 2, &amp; (x, y) \notin G, \\0, &amp; (x, y) \notin G .\end{array}\right.\]</span> 区域如下图：</p><p><img src="../../../../images/概率论5-2期末考试习题/21.jpg"> <span class="math display">\[\begin{array}{ll}\displaystyle P(U=0)=\int_0^1 \mathrm{~d} y \int_0^y \frac{1}{2}\mathrm{~d} x=\frac{1}{4}, &amp; P(U=1)=1-P(U=0)=\frac{3}{4} . \\\displaystyle P(V=1)=\int_0^2 \mathrm{~d} x \int_0^{x / 2} \frac{1}{2}\mathrm{~d} y=\frac{1}{2}, &amp; P(V=0)=1-P(V=1)=\frac{1}{2} .\end{array}\]</span></p><p>这说明: <span class="math inline">\(U \sim b(1,3 / 4), V \sim b(1,1 /2)\)</span>, 所以 <span class="math display">\[\operatorname{Var}(U)=\frac{3}{4}\left(1-\frac{3}{4}\right)=\frac{3}{16},\quad\operatorname{Var}(V)=\frac{1}{2}\left(1-\frac{1}{2}\right)=\frac{1}{4}\text {. }\]</span></p><p>又因为 <span class="math display">\[\begin{gathered}E(U V)=P(U V=1)=P(U=1, V=1)=P(X&gt;Y, X&gt;2 Y) \\=P(X&gt;2 Y)=P(V=1)=\frac{1}{2}, \\\operatorname{Cov}(U, V)=\frac{1}{2}-\frac{3}{4} \times\frac{1}{2}=\frac{1}{8} .\end{gathered}\]</span></p><p>所以 <span class="math inline">\(U\)</span> 和 <span class="math inline">\(V\)</span> 的相关系数为 <span class="math display">\[\operatorname{Corr}(U, V)=\frac{\operatorname{Cov}(U,V)}{\sqrt{\operatorname{Var}(U)} \sqrt{\operatorname{Var}(V)}}=\frac{1 /8}{\sqrt{3 / 16} \sqrt{1 / 4}}=\frac{1}{\sqrt{3}}=0.5774 .\]</span></p><hr><h2 id="t63">t63</h2><blockquote><p>设二维连续随机变量 <span class="math inline">\((X, Y)\)</span>的联合密度函数为 <span class="math display">\[p(x, y)=\left\{\begin{array}{cl}3 x, &amp; 0&lt;x&lt;1,0&lt;y&lt;x, \\0, &amp; \text { 其他. }\end{array}\right.\]</span></p><p>试求条件密度函数 <span class="math inline">\(p(y \midx)\)</span>.</p></blockquote><h3 id="解析-26">解析</h3><p>因为当 <span class="math inline">\(0&lt;x&lt;1\)</span> 时, <span class="math inline">\(p_x(x)=\displaystyle \int_0^x 3 x \mathrm{~d} y=3x^2\)</span>, 所以： <span class="math display">\[p(y \mid x)=\frac{p(x, y)}{p_X(x)}=\left\{\begin{array}{cl}1 / x, &amp;0&lt;y&lt;x&lt;1, \\ 0, &amp; \text { 其他. }\end{array}\right.\]</span></p><hr><h2 id="t64">t64</h2><blockquote><p>设二维连续随机变量 <span class="math inline">\((X, Y)\)</span>的联合密度函数为 <span class="math display">\[p(x, y)= \begin{cases}\frac{21}{4} x^2 y, &amp; x^2 \leqslant y\leqslant 1, \\ 0, &amp; \text { 其他. }\end{cases}\]</span></p><p>求条件概率 <span class="math inline">\(P(Y \geqslant 0.75 \midX=0.5)\)</span>.</p></blockquote><h3 id="解析-27">解析</h3><p>因为 <span class="math inline">\(P(Y \geqslant 0.75 \midX=0.5)=\int_{0.75}^1 p(y \mid x=0.5) \mathrm{d} y\)</span>, 故先求 <span class="math inline">\(p(y \mid x)\)</span>.</p><p><span class="math inline">\(p(x, y)\)</span> 的非零区域如下图：</p><p><img src="../../../../images/概率论5-2期末考试习题/22.jpg"></p><p>所以当 <span class="math inline">\(-1&lt;x&lt;1\)</span> 时， <span class="math display">\[p_X(x)=\int_{x^2}^1 \frac{21}{4} x^2 y \mathrm{~d} y=\frac{21}{8}x^2\left(1-x^4\right) .\]</span></p><p>因而当 <span class="math inline">\(-1&lt;x&lt;1\)</span> 时， <span class="math display">\[p(y \mid x)=\frac{p(x, y)}{p_X(x)}= \begin{cases}\dfrac{2 y}{1-x^4},&amp; 0&lt;y&lt;1, \\ 0, &amp; \text { 其他. }\end{cases}\]</span></p><p>所以当 <span class="math inline">\(0&lt;y&lt;1\)</span> 时, <span class="math display">\[p(y \mid x=0.5)=\frac{32 y}{15}\]</span></p><p>由此得 <span class="math display">\[P(Y \geqslant 0.75 \mid X=0.5)=\int_{0.75}^1 \frac{32 y}{15} \mathrm{~d}y=\frac{7}{15} .\]</span></p><hr><h2 id="t65">t65</h2><blockquote><p>设随机变量 <span class="math inline">\(X\)</span> 服从 <span class="math inline">\((1,2)\)</span> 上的均匀分布, 在 <span class="math inline">\(X=x\)</span> 的条件下, 随机变量 <span class="math inline">\(Y\)</span> 的条件分布是参数为 <span class="math inline">\(x\)</span> 的指数分布, 证明: <span class="math inline">\(X Y\)</span> 服从参数为 <span class="math inline">\(1\)</span> 的指数分布.</p></blockquote><h3 id="解析-28">解析</h3><p>因为 <span class="math inline">\(X \sim U(1,2), Y \mid X=x \sim\operatorname{Exp}(x)\)</span>, 所以 <span class="math display">\[p(x, y)=p_X(x) p(y \mid x)=x \mathrm{e}^{-x y}, \quad 1&lt;x&lt;2,y&gt;0 .\]</span></p><p>令 <span class="math inline">\(\left\{\begin{array}{l}U=X Y, \\V=X,\end{array}\right.\)</span> 则 <span class="math inline">\(\left\{\begin{array}{l}u=x y, \\v=x\end{array}\right.\)</span> 的逆变换为 <span class="math inline">\(\left\{\begin{array}{l}x=v, \\y=\dfrac{u}{v},\end{array}\right.\)</span> 此变换的雅可比行列式为 <span class="math display">\[J=\left|\begin{array}{ll}\dfrac{\partial x}{\partial u} &amp; \dfrac{\partial x}{\partial v} \\\dfrac{\partial y}{\partial u} &amp; \dfrac{\partial y}{\partial v}\end{array}\right|=\left|\begin{array}{cc}0 &amp; 1 \\\dfrac{1}{v} &amp; -\dfrac{u}{v^2}\end{array}\right|=-\dfrac{1}{v} .\]</span> 所以 <span class="math inline">\((U, V)\)</span>的联合密度函数为 <span class="math display">\[p_{u, v}(u, v)=p_{X, Y}\left(v,\frac{u}{v}\right)\left|-\frac{1}{v}\right|=v \mathrm{e}^{-v u / v}\frac{1}{v}=\mathrm{e}^{-u}, \quad 1&lt;v&lt;2, u&gt;0 .\]</span></p><p>由此得 <span class="math inline">\(U=X Y\)</span> 的边际密度函数为<span class="math display">\[p_U(u)=\int_1^2 \mathrm{e}^{-u} \mathrm{~d} v=\mathrm{e}^{-u}, \quadu&gt;0 .\]</span></p><p>这表明: <span class="math inline">\(U=X Y\)</span> 服从参数为 1的指数分布.</p><p><span class="math inline">\(ps:\)</span> 如果令 <span class="math inline">\(\left\{\begin{array}{l}U=X Y, \\V=Y,\end{array}\right.\)</span> 则 <span class="math inline">\(\left\{\begin{array}{l}u=x y, \\v=y\end{array}\right.\)</span> 的逆变换为 <span class="math inline">\(\left\{\begin{array}{l}  x=\dfrac{u}{v},\\y=v,\end{array}\right.\)</span> 则最后在对 <span class="math inline">\(v\)</span> 积分时需要注意 <span class="math inline">\(1&lt;\dfrac{u}{v}&lt;2\)</span> 解得的 <span class="math inline">\(v\)</span> 积分范围是 <span class="math inline">\(\dfrac{u}{2}&lt;v&lt;u.\)</span></p><hr><h2 id="t66">t66</h2><blockquote><p>设在一段时间内进人某一商店的顾客人数 <span class="math inline">\(X\)</span> 服从泊松分布 <span class="math inline">\(P(\lambda)\)</span>, 每个顾客购买某种物品的概率为<span class="math inline">\(p\)</span>,并且各个顾客是否购买该种物品相互独立, 求进人商店的顾客购买这种物品的人数<span class="math inline">\(Y\)</span> 的分布列.</p></blockquote><h3 id="解析-29">解析</h3><p>和 <span class="math inline">\(t21\)</span> 相同。</p><hr><h2 id="t67">t67</h2><blockquote><p>一矿工被困在有三个门的矿井里.第一个门通一坑道, 沿此坑道走 3小时可到达安全区; 第二个门通一坑道, 沿此坑道走 5 小时又回到原处;第三个门通一坑道, 沿此坑道走 7小时也回到原处.假定此矿工总是等可能地在三个门中选择一个,试求他平均要用多少时间才能到达安全区.</p></blockquote><h3 id="解析-30">解析</h3><p>设该矿工需要 <span class="math inline">\(X\)</span> 小时到达安全区,则 <span class="math inline">\(X\)</span> 的可能取值为 <span class="math display">\[3,5+3,7+3,5+5+3,5+7+3,7+7+3, \cdots,\]</span></p><p>要写出 <span class="math inline">\(X\)</span> 的分布列是困难的,所以无法直接求 <span class="math inline">\(E(X)\)</span>. 为此记 <span class="math inline">\(Y\)</span> 表示第一次所选的门, <span class="math inline">\(\{Y=i\}\)</span> 就是选择第 <span class="math inline">\(i\)</span> 个门. 由题设知 <span class="math display">\[P(Y=1)=P(Y=2)=P(Y=3)=\frac{1}{3} .\]</span></p><p>因为选第一个门后 3 小时可到达安全区, 所以 <span class="math inline">\(E(X \mid Y=1)=3\)</span>. 又因为选第二个门后 5小时回到原处, 所以 <span class="math inline">\(E(X \midY=2)=5+E(X)\)</span>.</p><p>又因为选第三个门后 7 小时也回到原处, 所以 <span class="math inline">\(E(X \mid Y=3)=7+E(X)\)</span>.</p><p>这三个事件发生的概率等可能，都是 <span class="math inline">\(1/3\)</span></p><p>由重期望公式： <span class="math display">\[E(X)=\frac{1}{3}[3+5+E(X)+7+E(X)]=5+\frac{2}{3} E(X),\]</span></p><p>解得 <span class="math inline">\(E(X)=15\)</span>, 即该矿工平均要 15小时才能到达安全区.</p><hr><h2 id="t68">t68</h2><blockquote><p>口袋中有编号为 <span class="math inline">\(1,2, \cdots, n\)</span> 的<span class="math inline">\(n\)</span> 个球, 从中任取 1 球. 若取到 1号球, 则得 1 分, 且停止摸球; 若取到 <span class="math inline">\(i\)</span> 号球 <span class="math inline">\((i\geqslant 2)\)</span>, 则得 <span class="math inline">\(i\)</span> 分,且将此球放回, 重新摸球. 如此下去, 试求得到的平均总分数.</p></blockquote><h3 id="解析-31">解析</h3><p>记 <span class="math inline">\(X\)</span> 为最后的总得分数，<span class="math inline">\(Y\)</span> 为第一次取到球的号码，则 <span class="math display">\[P(Y=1)=P(Y=2)=\cdots=P(Y=n)=\frac{1}{n} .\]</span></p><p>又因为 <span class="math inline">\(E(X \mid Y=1)=1\)</span>, 而当<span class="math inline">\(i \geqslant 2\)</span> 时, <span class="math inline">\(E(X \mid Y=i)=i+E(X)\)</span>. 所以 <span class="math display">\[E(X)=\sum_{i=1}^n E(X \mid Y=i) P(Y=i)=\frac{1}{n}[1+2+\cdots+n+(n-1)E(X)] .\]</span></p><p>由此解得 <span class="math display">\[E(X)=\frac{n(n+1)}{2}\]</span></p><hr><h2 id="t69">t69</h2><blockquote><p>设随机变量 <span class="math inline">\(X \sim N(\mu, 1), Y \simN(0,1)\)</span>, 且 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 相互独立, 令 <span class="math display">\[I= \begin{cases}1, &amp; Y&lt;X, \\ 0, &amp; X \leqslant Y .\end{cases}\]</span></p><p>试证明: (1) <span class="math inline">\(E(I \midX=x)=\Phi(x)\)</span>; (2) <span class="math inline">\(E[\Phi(X)]=P(Y&lt;X)\)</span>; (3) <span class="math inline">\(E[\Phi(X)]=\Phi(\mu / \sqrt{2})\)</span>. (提示:<span class="math inline">\(X-Y\)</span> 的分布是什么?)</p></blockquote><h3 id="解析-32">解析</h3><ol type="1"><li><span class="math inline">\(E(I \mid X=x)=P(I=1 \mid X=x)=P(Y&lt;X\mid X=x)=P(Y&lt;x)=\Phi(x)\)</span>.<ol start="2" type="1"><li>由 (1) 知, <span class="math inline">\(\Phi(X)=E(I \mid X)\)</span>,所以 <span class="math display">\[E[\Phi(X)]=E[E(I \mid X)]=E(I)=P(I=1)=P(Y&lt;X) .\]</span></li></ol></li><li>由 (2) 知 <span class="math inline">\(E[\Phi(X)]=P(Y&lt;X)=P(X-Y&gt;0)\)</span>. 因为<span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 相互独立, 所以 <span class="math inline">\(X-Y \sim N(\mu, 2)\)</span>, 由 此得 <span class="math display">\[P(X-Y&gt;0)=1-\Phi(-\mu / \sqrt{2})=\Phi(\mu / \sqrt{2}) .\]</span> <span class="math inline">\(ps:\)</span>每一问都是利用前一问的结果。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第五章 复习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>概率论习题(1)</title>
      <link href="/2024/05/06/gai-lu-lun-5-2-gai-lu-lun-qi-mo-fu-xi-xi-ti-1/"/>
      <url>/2024/05/06/gai-lu-lun-5-2-gai-lu-lun-qi-mo-fu-xi-xi-ti-1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/igWDk1yeq05g">下载完整PDF点这里</a></p><h2 id="t1">t1</h2><blockquote><p><img src="../../../../images/概率论5-2期末考试习题/1.jpg"></p></blockquote><h3 id="解析">解析</h3><p>A：<span class="math inline">\(P(A \cup B)=P(A)+P(B)-P(A B)\)</span>由此推出 <span class="math inline">\(P(AB)=0\)</span>无法推出目标条件，错误；</p><p>B：这是事件独立的充分必要条件，无法推出目标条件，错误；</p><p>C：事件有运算关系：<span class="math inline">\(A-B=A-A B=A\bar{B}\)</span> ，所以有：</p><p><span class="math inline">\(P(A\bar{B})=P(A-B)=P(A)-P(AB)\)</span> ，<span class="math inline">\(P(\bar{A}B)=P(B-A)=P(B)-P(AB)\)</span> 又<span class="math inline">\(P(A\bar{B})=P(\bar{A}B)\)</span></p><p>由此推出 <span class="math inline">\(P(A)=P(B)\)</span> ，正确；</p><p>D：<span class="math inline">\(P(\bar{A} \bar{B})=P(\overline{A \cupB})=1-P(A \cup B)=1-P(A)-P(B)+P(A B)\)</span></p><p>由此推出 <span class="math inline">\(P(A)+P(B)=1\)</span>，无法推出目标条件，错误。</p><p>《知识点总结》的 <span class="math inline">\(\S1.1、1.3\)</span></p><h3 id="答案">答案</h3><p><span class="math inline">\(C\)</span></p><hr><h2 id="t2">t2</h2><blockquote><p><img src="../../../../images/概率论5-2期末考试习题/2.jpg"></p></blockquote><h3 id="解析-1">解析</h3><p>（1）：<span class="math inline">\(A B C \cup \bar{A} \bar{B}\bar{C}\)</span></p><p>（2）：<span class="math inline">\(\bar{A} \bar{B} \bar{C} \cupA\bar{B}\bar{C} \cup \bar{A} B \bar{C} \cup \bar{A} \bar{B}C\)</span></p><p>（3）：唯一不符合的情况是 <span class="math inline">\(ABC\)</span>同时发生，所以可以写为 <span class="math inline">\(\Omega-ABC=\overline{ABC}=\bar{A} \cup \bar{B}\cup \bar{C}\)</span></p><p>（4）：<span class="math inline">\(AB\cup AC \cup BC\)</span></p><p>有运用德摩根律，《知识点总结》的 <span class="math inline">\(\S1.1\)</span></p><hr><h2 id="t3">t3</h2><blockquote><p>投掷3颗骰子，求以下事件的概率</p><p>（1）所得的最大点数小于等于5；</p><p>（2）所得的最大点数等于5。</p></blockquote><h3 id="解析-2">解析</h3><p>记 <span class="math inline">\(Y\)</span> 为所得的最大点数，则</p><p>（1）<span class="math inline">\(P\{Y\leqslant5\}=\dfrac{5^3}{6^3}=\dfrac{125}{126}\)</span></p><p>（2）<span class="math inline">\(P(Y=5)=P\{Y\leqslant5\}-P\{Y\leqslant4\}=\dfrac{5^3-4^3}{6^3}=\dfrac{61}{216}\)</span></p><hr><h2 id="t4">t4</h2><blockquote><p>把 <span class="math inline">\(n\)</span> 个 “ 0 ” 与 <span class="math inline">\(n\)</span> 个 “ 1 ” 随机地排列, 求没有两个 “ 1 ”连在一起的概率.</p></blockquote><h3 id="解析-3">解析</h3><p><span class="math inline">\(n\)</span> 个 “ <span class="math inline">\(1\)</span> ” 的放法: <span class="math inline">\(2n\)</span> 个位置上 “ <span class="math inline">\(1\)</span> ” 占有<span class="math inline">\(n\)</span> 个位置, 所以共有 <span class="math inline">\(\displaystyle \binom{2 n}{n}\)</span>种放法，这是总的放法，即分母。</p><p>“没有两个 1 连在一起”, 相当于在 <span class="math inline">\(n\)</span> 个 “ <span class="math inline">\(0\)</span> ” 之间及两头 （共 <span class="math inline">\(n+1\)</span> 个位置）去放 <span class="math inline">\(1\)</span> ，所以有 <span class="math inline">\(\displaystyle \binom{n+1}{n}\)</span> 种放法。</p><p>综上，答案为：<span class="math inline">\(p_n=\dfrac{\displaystyle\binom{n+1}{n}}{\displaystyle\binom{2n}{n}}=\dfrac{n+1}{\displaystyle\binom{2 n}{n}}\)</span>.</p><h3 id="拓展">拓展</h3><p>问：把 <span class="math inline">\(n\)</span>个完全相同的球随机地放到 <span class="math inline">\(N\)</span>个盒子中，有多少种情况？</p><p>答：用 <span class="math inline">\(N+1\)</span> 根火柴棒来表示 <span class="math inline">\(N\)</span>个盒子，因为球要放到盒子中间，所以最旁边的两根火柴棒的外面不可以放球，所以自由移动的球和火柴棒的位置为<span class="math inline">\(n+N+1-2=N+n-1\)</span> 个，挑出 <span class="math inline">\(n\)</span> 个位置放球，最终答案为：<span class="math inline">\(\displaystyle \binom{N+n-1}{n}\)</span></p><p>这个也称为排列组合里的重复组合。</p><hr><h2 id="t5">t5</h2><blockquote><p>抽样模型：设 <span class="math inline">\(N\)</span> 件产品中有 <span class="math inline">\(M\)</span> 件是次品, <span class="math inline">\(N-M\)</span> 件是正品。现从 <span class="math inline">\(N\)</span> 件中随机地不放回地抽取 <span class="math inline">\(n\)</span> 件产品。求:</p><p>事件 <span class="math inline">\(A_m=\{\)</span> 所取的 <span class="math inline">\(n\)</span> 件产品中恰有 <span class="math inline">\(m\)</span> 件次品 <span class="math inline">\(\}\)</span> 的概率. <span class="math inline">\(m=0,1,2,\cdots,n\)</span></p></blockquote><h3 id="解析-4">解析</h3><p><span class="math display">\[P\left(A_m\right)=\dfrac{\displaystyle \binom{N-M}{n-m} \displaystyle\binom{M}{m}}{\displaystyle \binom{N}{n}}\]</span></p><h3 id="拓展-1">拓展</h3><p>现在为有放回地抽取，则新的概率为 <span class="math display">\[P\left(A_m\right)=\displaystyle\binom{n}{m}\left(\dfrac{M}{N}\right)^m\left(1-\dfrac{M}{N}\right)^{n-m}\]</span></p><hr><h2 id="t6">t6</h2><blockquote><p>盒子模型：设有 <span class="math inline">\(n\)</span> 个(不同)球,每个球等可能地落入 <span class="math inline">\(N\)</span> 个不同的盒子中<span class="math inline">\((n \leq N)\)</span>，设每个盒子容球数不限,求下列事件的概率：</p><ol type="1"><li><p><span class="math inline">\(A=\)</span> “指定的 <span class="math inline">\(n\)</span> 个盒子中各有一球”;</p></li><li><p><span class="math inline">\(B=\)</span> “恰有 <span class="math inline">\(n\)</span> 个盒子中各有一球”.</p></li></ol></blockquote><h3 id="解析-5">解析</h3><p>（1）<span class="math inline">\(P(A)=\dfrac{n!}{N^n}\)</span></p><p>（2）<span class="math inline">\(P(B)=\dfrac{C_N^nn!}{N^n}=\dfrac{N!n!}{(N-n)!n!N^n}=\dfrac{N!}{(N-n)!N^n}\)</span></p><hr><h2 id="t7">t7</h2><blockquote><p>抽签模型：袋中有 <span class="math inline">\(a\)</span> 只白球, <span class="math inline">\(b\)</span> 只红球,它们除颜色不同外，其他方面没有差别，现在把球随机地一只只摸出来, 作</p><p>（1）放回取样；</p><p>（2）不放回取样；</p><p>求第 <span class="math inline">\(k\)</span> 次摸出的球是白球的概率<span class="math inline">\((k \leq a+b)\)</span></p></blockquote><h3 id="解析-6">解析</h3><p>（1）<span class="math inline">\(p_k=\dfrac{a}{a+b}\)</span></p><p>（2）样本空间包含样本点的总数为： <span class="math inline">\(P_{a+b}^k\)</span> （排列）</p><p>​ 第 <span class="math inline">\(k\)</span>个球为白球事件的总数为：<span class="math inline">\(C_a^1P_{a+b-1}^{k-1}\)</span> <span class="math display">\[\Rightarrow P_k=\frac{a \times P_{a+b-1}^{k-1}}{P_{a+b}^k}=\frac{a\times(a+b-1) \cdots(a+b-k+1)}{(a+b) \cdots(a+b-k+1)}=\frac{a}{a+b}\]</span></p><p><span class="math inline">\(t5-t7\)</span>均为古典概型，《知识点总结》的 <span class="math inline">\(\S1.2\)</span></p><hr><h2 id="t8">t8</h2><blockquote><p>甲乙两艘轮船驶向一个不能同时停泊两艘轮船的码头,它们在一昼夜内到达的时间是等可能的. 如果甲船的停泊时间是 1 小时,乙船的停泊时间是 2 小时,求它们中任何一艘都不需要等候码头空出的概率是多少?</p></blockquote><h3 id="解析-7">解析</h3><p><img src="../../../../images/概率论5-2期末考试习题/3.jpg"></p><p>如上图所示，记 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 分别为甲乙两艘轮船到达码头的时间。</p><p>则 <span class="math inline">\(p=\dfrac{S_A}{S_\Omega}=\dfrac{\frac{1}{2}(23^2+22^2)}{24^2}=0.879\)</span></p><p><span class="math inline">\(t8\)</span>均为几何概型，《知识点总结》的 <span class="math inline">\(\S1.2\)</span></p><hr><h2 id="t9">t9</h2><blockquote><p>设随机事件 <span class="math inline">\(A, B\)</span> 相互独立, <span class="math inline">\(A, C\)</span> 相互独立, <span class="math inline">\(B C=\varnothing\)</span> 若<span class="math inline">\(P(A)=P(B)=\frac{1}{2}, P(A C \mid A B \cupC)=\frac{1}{4}\)</span></p><p>求 <span class="math inline">\(P(C)\)</span></p></blockquote><h3 id="解析-8">解析</h3><p><span class="math display">\[\begin{aligned}P(A C \mid A B \cup C) &amp; =\frac{P[A C \cap(A B \cup C)]}{P(A B \cupC)}=\frac{P(A B C \cup A C)}{P(A B)+P(C)-P(A B C)} \\&amp; =\frac{P(A C)}{P(A B)+P(C)-P(A B C)}\\&amp; =\frac{P(A)P(C)}{P(A)P(B)+P(C)-0}\\&amp; =\dfrac{\frac{1}{2}P(C)}{\frac{1}{2}\frac{1}{2}+P(C)}\\&amp; =\frac{1}{4}\end{aligned}\]</span></p><p>解得：<span class="math inline">\(P(C)=\dfrac{1}{4}\)</span></p><p>条件概率与事件独立性、还有事件之间的运算，《知识点总结》的 <span class="math inline">\(\S1.1、1.3、1.4、1.5\)</span></p><hr><h2 id="t10">t10</h2><blockquote><p>匹配问题：某人写好 <span class="math inline">\(n\)</span>封信，又写好 <span class="math inline">\(n\)</span>只信，然后在黑暗中把每封信放入一只信封中,试求至少有一封信放对的概率。</p></blockquote><h3 id="解析-9">解析</h3><p>记 <span class="math inline">\(A_k\)</span> 表示第 <span class="math inline">\(k\)</span> 封信放对了。 <span class="math display">\[\begin{aligned}P&amp;=P\left(A_1 \cup A_2 \cup \cdots \cup A_n\right)=\sumP\left(A_i\right)-\sum P\left(A_i A_j\right)+\sum\left(A_i A_jA_k\right)+\cdots+(-1)^{n-1} \sum\left(A_1 A_2 \cdots A_n\right) \\&amp;其中:\\&amp; P\left(A_i\right)=\frac{(n-1)!}{n!}=\frac{1}{n} \\&amp; P\left(A_i A_j\right)=\frac{(n-2)!}{n!}=\frac{1}{n(n-1)} \\&amp; \cdots \\P&amp;=\binom{n}{1} \frac{1}{n}-\binom{n}{2}\frac{1}{n(n-1)}+\binom{n}{3} \frac{1}{n(n-1)(n-2)}+\cdots+(-1)^{n-1}\frac{1}{n!} \\&amp; =1-\frac{1}{2!}+\frac{1}{3!}-\cdots+(-1)^{n-1} \frac{1}{n!}\end{aligned}\]</span></p><hr><h2 id="t11">t11</h2><blockquote><p>已知 <span class="math inline">\(P(\bar{A})=0.3, P(B)=0.4, P(A\bar{B})=0.5\)</span>, 求 <span class="math inline">\(P(B \mid A \cup\bar{B})\)</span>.</p></blockquote><h3 id="解析-10">解析</h3><p><span class="math display">\[\begin{aligned}&amp;P(B \mid A \cup \bar{B})=\frac{P(A B)}{P(A \cup \bar{B})}, \\&amp;P(A \cup \bar{B})=P(A)+P(\bar{B})-P(A \bar{B})=0.7+0.6-0.5=0.8 . \\&amp;P(A\bar{B})=P(A)-P(A B) \text {, 可得 } P(A B)=P(A)-P(A\bar{B})=0.7-0.5=0.2\\&amp;P(B \mid A \cup \bar{B})=\frac{P(A B)}{P(A \cup\bar{B})}=\frac{0.2}{0.8}=0.25 .\end{aligned}\]</span></p><p>条件概率与事件之间的运算，《知识点总结》的 <span class="math inline">\(\S1.1、1.3、1.4\)</span></p><hr><h2 id="t12">t12</h2><blockquote><p><span class="math inline">\(m\)</span> 个人相互传球, 球从甲手中传出,每次传球时, 传球者等可能地把球传给其余 <span class="math inline">\(m-1\)</span> 个人中的任何一个, 求第 <span class="math inline">\(n\)</span> 次传球时仍由甲传出的概率。</p></blockquote><h3 id="解析-11">解析</h3><p><span class="math display">\[\begin{aligned}&amp;\text {设} A_i \text {为第i以次甲传出} \RightarrowP\left(A_n\right)=P\left(A_{n-1}\right) P\left(A_n \midA_{n-1}\right)+P\left(\bar{A}_{n-1}\right) P\left(A_n \mid\bar{A}_{n-1}\right)\\&amp;\Rightarrow P\left(A_n\right)=\frac{1}{m-1}P\left(\bar{A}_{n-1}\right) \\&amp;\RightarrowP\left(A_n\right)=\frac{1}{m-1}\left(1-P\left(A_{n-1}\right)\right)\quad\text {一阶线性递推数列} \\&amp;\text{上述等式一定可以化成这样的形式：}P\left(A_n\right)-M=N\left[P\left(A_{n-1}\right)-M\right] \\&amp;\text {对比系数：} N=-\frac{1}{m-1}, M=\frac{1}{m} \\&amp;P\left(A_n\right)-\frac{1}{m}=\frac{1}{1-m}\left(P\left(A_{n-1}\right)-\frac{1}{m}\right)\quad P\left(A_1\right)=1 \\&amp;\text {令} P\left(A_n\right)-\frac{1}{m}=b_n \\&amp;\quad b_n=\frac{1}{1-m} \cdot b_{n-1}=\left(\frac{1}{1-m}\right)^2\cdot b_{n-2}=\cdots=\left(\frac{1}{1-m}\right)^{n-1} \cdot b_1 \\&amp;\quad=\left(\frac{1}{1-m}\right)^{n-1}\cdot\left(1-\frac{1}{m}\right)=\left(\frac{-1}{m-1}\right)^{n-2} \times\frac{-1}{m} \\&amp;\RightarrowP\left(A_n\right)=b_n+\frac{1}{m}=\frac{1}{m}\left[1-\left(\frac{-1}{m-1}\right)^{n-2}\right],n=2,3,4, \cdots\end{aligned}\]</span></p><p>关键在于利用全概率公式划分事件。</p><p>线性递推数列求解通项公式可以参考 <a href="https://studyincau.github.io/2024/03/17/shu-lie-di-tui/">第零篇数列递推 | StudyinCAU</a></p><hr><h2 id="t13">t13</h2><blockquote><p>盒中装有8个乒乓球，其中有6个新的。第一次练习时，从中任取2个来用，用完后放回盒中。第二次练习时，再从盒中任取2个。求：</p><p>(1)第二次取出的球都是新球的概率；</p><p>(2)在第二次取出的球都是新球的条件下，第一次取到的球都是新球的概率。</p></blockquote><h3 id="解析-12">解析</h3><p>（1）记 <span class="math inline">\(B\)</span>为第二次取出的球是2个新球。 <span class="math display">\[P(B)=\frac{C_6^2 C_4^2}{C_8^2 C_8^2}+\frac{C_6^1 C_2^1 C_5^2}{C_8^2C_8^2}+\frac{C_2^2 C_6^2}{C_8^2 C_8^2}=\frac{225}{784}\]</span> （2）记 <span class="math inline">\(A\)</span>为第一次取出的球是2个新球。 <span class="math display">\[P(A \mid B)=\frac{P(A B)}{P(B)}=\frac{C_6^2 C_4^2}{C_8^2 C_8^2} \times\frac{784}{225}=\frac{2}{5} .\]</span></p><p>古典概型、条件概率，《知识点总结》的 <span class="math inline">\(\S1.2、1.4\)</span></p><hr><h2 id="t14">t14</h2><blockquote><p>某人从外地赶来参加会议, 他乘火车、轮船、汽车或飞机来的概率分别为<span class="math inline">\(\dfrac{3}{10}, \dfrac{1}{5}, \dfrac{1}{10},\dfrac{2}{5}\)</span> 如果他乘飞机来, 则不会迟到,乘火车、轮船或汽车迟到的概率分别为 <span class="math inline">\(\dfrac{1}{4}, \dfrac{1}{3},\dfrac{1}{12}\)</span>, 试问:</p><p>(1)他迟到的概率;</p><p>(2)此人迟到, 试推断他乘火车来的概率有多大。</p></blockquote><h3 id="解析-13">解析</h3><p>（1）记 <span class="math inline">\(A\)</span> 为迟到；记 <span class="math inline">\(B_1\)</span> 为乘火车，<span class="math inline">\(B_2\)</span> 为乘轮船，<span class="math inline">\(B_3\)</span> 为乘汽车，<span class="math inline">\(B_4\)</span> 为乘飞机。 <span class="math display">\[P(A)=\sum_{i=1}^4 P\left(B_i\right) P\left(A \midB_i\right)=\frac{3}{20}\]</span> （2）<span class="math inline">\(P\left(B_1 \midA\right)=\dfrac{P\left(A \mid B_1\right)P\left(B_1\right)}{P(A)}=\dfrac{1}{2}\)</span></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第五章 复习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第三节 统计量及其分布</title>
      <link href="/2024/05/06/shu-li-tong-ji-5-3-tong-ji-liang-ji-qi-fen-bu/"/>
      <url>/2024/05/06/shu-li-tong-ji-5-3-tong-ji-liang-ji-qi-fen-bu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/itNX31xuzrqd">下载PDF点这里</a></p><p><img src="../../../../images/数理统计5-3统计量及其分布/数理统计5.3-7.jpg"></p><p><img src="../../../../images/数理统计5-3统计量及其分布/数理统计5.3-8.jpg"></p><p><img src="../../../../images/数理统计5-3统计量及其分布/数理统计5.3-9.jpg"></p><p><img src="../../../../images/数理统计5-3统计量及其分布/数理统计5.3-10.jpg"></p><p><img src="../../../../images/数理统计5-3统计量及其分布/数理统计5.3-11.jpg"></p><p><img src="../../../../images/数理统计5-3统计量及其分布/数理统计5.3-12.jpg"></p><p><img src="../../../../images/数理统计5-3统计量及其分布/数理统计5.3-13.jpg"></p><p><img src="../../../../images/数理统计5-3统计量及其分布/数理统计5.3-14.jpg"></p><p><img src="../../../../images/数理统计5-3统计量及其分布/数理统计5.3-15.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数理统计 </category>
          
          <category> 第一章 统计量及其分布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计量 </tag>
            
            <tag> 抽样分布 </tag>
            
            <tag> 样本均值 </tag>
            
            <tag> 样本方差 </tag>
            
            <tag> 样本矩 </tag>
            
            <tag> 次序统计量 </tag>
            
            <tag> 样本分位数 </tag>
            
            <tag> 箱线图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论知识点</title>
      <link href="/2024/05/04/gai-lu-lun-5-1-gai-lu-lun-qi-mo-fu-xi-zhi-shi-dian/"/>
      <url>/2024/05/04/gai-lu-lun-5-1-gai-lu-lun-qi-mo-fu-xi-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<p>大致梳理重要的，需要掌握背诵的知识。</p><p><a href="https://wwb.lanzouj.com/i8QUz1xn4yfg">下载PDF点这里</a></p><p><span class="math inline">\(ps\)</span>：根据《概率论与数理统计教程（第三版）》汇总的知识总结，根据教材的不同可以自行删减复习知识内容。每一部分的知识点虽然较为完整，但不敢肯定包含所有知识点，详细可参照之前文章进行对比复习。</p><p>如果文章内容有错误的地方，欢迎留言或发送信息至<a href="mailto:3187248635@qq.com">邮箱</a></p><h2 id="第一章-随机事件与概率">第一章 随机事件与概率</h2><h3 id="随机事件及其运算">1.1 随机事件及其运算</h3><p>1.事件间关系及运算：</p><p>1）包含：∅ ⊂ <span class="math inline">\(A\)</span> ⊂ Ω <span class="math inline">\(\quad A=B \Leftrightarrow A \subset B\)</span> 且<span class="math inline">\(B \subset A\)</span></p><p>2）差: <span class="math inline">\(A-B=A-A B\)</span></p><p>​ <span class="math inline">\(A-B=A \cap \bar{B}\)</span> <span class="math inline">\(A\)</span> 发生并且 <span class="math inline">\(B\)</span> 不发生</p><p>​ <span class="math inline">\(A B=A-A \bar{B}\)</span> <span class="math inline">\(AB\)</span> 都发生 = <span class="math inline">\(A\)</span> 发生减去 <span class="math inline">\(A\)</span> 发生 <span class="math inline">\(B\)</span> 不发生</p><p>3）对立: <span class="math inline">\(\bar{A}=\Omega-A \quad\bar{\bar{A}}=A\)</span></p><p>​ 特别地：<span class="math inline">\(\bar{\Omega}=\varnothing \quad\bar{\varnothing}=\Omega\)</span></p><p>4）互斥：<span class="math inline">\(A \capB=\varnothing\)</span></p><p>​ 对立事件 <span class="math inline">\(\rightarrow\)</span>互不相容事件（反之不成立）</p><p>5）对偶律（德摩根公式）</p><p>​ <span class="math inline">\(\overline{A \cup B}=\bar{A} \bar{B},\overline{A B}=\bar{A} \cup \bar{B}\)</span></p><p>​ <span class="math inline">\(A\)</span> 或 <span class="math inline">\(B\)</span> 发生的对立 = <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 都不发生，<span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 都发生的对立 = <span class="math inline">\(A\)</span> 不发生或 <span class="math inline">\(B\)</span> 不发生（“都”变“或”，“发生”变“不发生”）</p><p>​ 推广： <span class="math display">\[\overline{\bigcup_{i=1}^n A_i}=\bigcap_{i=1}^n \bar{A}_i, \quad\overline{\bigcup_{i=1}^{\infty} A_i}=\bigcap_{i=1}^{\infty} \bar{A}_i,\]</span></p><p><span class="math display">\[\overline{\bigcap_{i=1}^n A_i}=\bigcup_{i=1}^n \overline{A_i}, \quad\overline{\bigcap_{i=1}^{\infty} A_i}=\bigcup_{i=1}^{\infty} \bar{A}_i .\]</span></p><p>​ 也可以记忆成 <span class="math inline">\(\cup\)</span> 和 <span class="math inline">\(\cap\)</span> 互相转换，而对立从所有变成个体。</p><h3 id="概率的定义及其确定方法">1.2 概率的定义及其确定方法</h3><p>1.概率的公理化定义：</p><p>​ 1）非负性公理 若 <span class="math inline">\(A \in\mathscr{F}\)</span>, 则 <span class="math inline">\(P(A) \geqslant0\)</span>;</p><p>​ 2）正则性公理 <span class="math inline">\(P(\Omega)=1\)</span>;</p><p>​ 3）可列可加性公理 若 <span class="math inline">\(A_1, A_2, \cdots,A_n, \cdots\)</span> 互不相容, 则： <span class="math display">\[P\left(\bigcup_{i=1}^{\infty} A_i\right)=\sum_{i=1}^{\infty}P\left(A_i\right),\]</span> ​ 则称 <span class="math inline">\(P(A)\)</span> 为事件 <span class="math inline">\(A\)</span> 的概率,称三元素 <span class="math inline">\((\Omega, \mathscr{F}, P)\)</span>​ 为概率空间。</p><hr><p>2.排列与组合公式：</p><p>​ 1）排列： <span class="math display">\[P_n^r=\underbrace{n \times(n-1) \times \cdots\times(n-r+1)}_{r个}=\frac{n!}{(n-r)!} \quad r \leqslant n\]</span> ​ 若 <span class="math inline">\(r=n\)</span>, 则称为全排列,记为 <span class="math inline">\(\mathrm{P}_n\)</span> 。 显然, 全排列<span class="math inline">\(\mathrm{P}_n=n!\)</span> 。</p><p>​ 2）组合： <span class="math display">\[C_n^r=\binom{n}{r}=\frac{p_n^r}{r!}=\frac{n(n-1)\cdots(n-r+1)}{r!}=\frac{n!}{r!(n-r)!} \quad r \leqslant n\]</span></p><p><span class="math display">\[\binom{n}{r}=\binom{n}{n-r} \quad P_n^r=r!C_n^r\]</span></p><hr><p>3.古典概型：参考复习习题中的抽样模型。</p><hr><p>4.几何概率：<span class="math inline">\(P(G)=\dfrac{G \text { 的测度}}{\Omega \text { 的测度 }} = \dfrac{S_G}{S_{\Omega}} \text {.}\)</span></p><h3 id="概率的性质">1.3 概率的性质</h3><p>1.<span class="math inline">\(P(\varnothing)=0\quadP(\Omega)=1\)</span></p><p>2.有限可加性：若有限个事件 <span class="math inline">\(A_1, A_2,\cdots, A_n\)</span> 互不相容, 则有 <span class="math display">\[P\left(\bigcup_{i=1}^n A_i\right)=\sum_{i=1}^n P\left(A_i\right) .\]</span> 3.对任一事件 <span class="math inline">\(A\)</span>, 有：<span class="math inline">\(P(\bar{A})=1-P(A)\)</span></p><p>4.可减性：对任意两个事件 <span class="math inline">\(A, B\)</span>,有 <span class="math display">\[P(A-B)=P(A)-P(A B) .\]</span> 5.加法公式：对任意两个事件 <span class="math inline">\(A,B\)</span>, 有 <span class="math display">\[P(A \cup B)=P(A)+P(B)-P(A B)\]</span> ​ 对任意 <span class="math inline">\(n\)</span> 个事件 <span class="math inline">\(A_1, A_2, \cdots, A_n\)</span>, 有 <span class="math display">\[\begin{aligned}P\left(\bigcup_{i=1}^n A_i\right)=  \sum_{i=1}^nP\left(A_i\right)-\sum_{1 \leqslant i&lt;j \leqslant n} P\left(A_iA_j\right)+ \sum_{1 \leqslant i&lt;j&lt;k \leqslant n} P\left(A_i A_jA_k\right)+\cdots+(-1)^{n-1} P\left(A_1 A_2 \cdots A_n\right) .\end{aligned}\]</span></p><h3 id="条件概率">1.4 条件概率</h3><p>1.条件概率： <span class="math display">\[P(A \mid B)=\frac{P(A B)}{P(B)}=\frac{P(B \mid A) P(A)}{P(B)} \quadP(B)&gt;0\]</span> ​ 性质：<span class="math inline">\(P(\bar{A} \mid B)=1-P(A\mid B)\)</span></p><p>​ <span class="math inline">\(P\left(\left(A_1 \cup A_2) \midB\right)=P\left(A_1 \mid B\right)+P\left(A_2 \mid B\right)-P\left(A_1A_2 \mid B\right)\right.\)</span></p><p>​ 注意：<span class="math inline">\(P(A \mid B)+P(A \mid \bar{B}) \neq1\)</span></p><hr><p>2.乘法公式（<span class="math inline">\(n\)</span>个事件发生有明显的先后顺序） <span class="math display">\[\left\{\begin{array}{l}\text { 若 } P(B)&gt;0, \text { 则: } P(A B)=P(B) P(A \mid B) \\ \text {若 } P(A)&gt;0, \text { 则: } P(A B)=P(A) P(A \mid B)\end{array}\right.\]</span></p><p><span class="math inline">\(\text { 若 } P\left(A_1 A_2 \cdotsA_{n-1}\right)&gt;0 \text {, }{则: }\)</span> <span class="math display">\[P\left(A_1 A_2 \cdots A_n\right)=P\left(A_1\right) P\left(A_2 \midA_1\right) P\left(A_3 \mid A_1 A_2\right) \cdots P\left(A_n \mid A_1 A_2\cdots A_{n-1}\right)\]</span></p><hr><p>3.全概率公式：</p><p>​ 设 <span class="math inline">\(B_1, B_2, \cdots, B_n\)</span>为样本空间 <span class="math inline">\(\Omega\)</span> 的一个分割，即<span class="math inline">\(B_1, B_2, \cdots, B_n\)</span> 互不相容, 且<span class="math inline">\(\bigcup\limits_{i=1}^n B_i =\Omega\)</span>, 如果<span class="math inline">\(P\left(B_i\right)&gt;0,i=1,2, \cdots, n\)</span>, 则对任一事件 <span class="math inline">\(A\)</span> 有 <span class="math display">\[P(A)=\sum_{i=1}^n P\left(B_i\right) P\left(A \mid B_i\right) .\]</span> ​ 全概率公式的最简形式: 若 <span class="math inline">\(0&lt;P(B)&lt;1\)</span> ，则 <span class="math inline">\(P(A)=P(B) P(A \mid B)+P(\bar{B}) P(A \mid\bar{B})\)</span>.</p><hr><p>4.贝叶斯公式：</p><p>​ 设 <span class="math inline">\(B_1, B_2, \cdots, B_n\)</span>是样本空间 <span class="math inline">\(\Omega\)</span> 的一个分割, 即<span class="math inline">\(B_1\)</span>, <span class="math inline">\(B_2, \cdots, B_n\)</span> 互不相容, 且 <span class="math inline">\(\bigcup\limits_{i=1}^n B_i = \Omega\)</span>, 如果<span class="math inline">\(P(A)&gt;0, P\left(B_i\right)&gt;0,\)</span><span class="math inline">\(i=1,2, \cdots, n\)</span>, 则 <span class="math display">\[P\left(B_i \mid A\right)=\frac{P\left(B_i\right) P\left(A \midB_i\right)}{\sum\limits_{j=1}^n P\left(B_j\right) P\left(A \midB_j\right)}, \quad i=1,2, \cdots, n\]</span> ​ 特别地 <span class="math display">\[P(B \mid A)=\frac{P(A B)}{P(A)}=\frac{P(B) P(A \mid B)}{P(B) P(A \midB)+P(\bar{B}) P(A \mid \bar{B})}\]</span> ​ 顺便提一下： <span class="math display">\[P\left(A_i \mid B\right)=\frac{P\left(A_i\right) P\left(B \midA_i\right)}{P(B)} \stackrel{\text { converting }}{\Rightarrow} \quad\text { 后验概率 }=\frac{\text { 先验概率 } \times \text { 似然 }}{\text{ 证据因子 }}\]</span></p><h3 id="独立性">1.5 独立性</h3><p>1.定义: 设 <span class="math inline">\(A, B\)</span>为任意两个随机事件, 如果满足 <span class="math inline">\(P(A B)=P(A)P(B)\)</span> 则称事件 <span class="math inline">\(A, B\)</span>相互独立。</p><p>​ 推论1：若 <span class="math inline">\(P(A)&gt;0, A, B\)</span> 独立<span class="math inline">\(\Longleftrightarrow P(B)=P(B \midA)\)</span></p><p>​ 推论2：若事件 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(B\)</span> 独立，则 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(\bar{B}\)</span> 独立， <span class="math inline">\(\bar{A}\)</span> 与 <span class="math inline">\(B\)</span> 独立， <span class="math inline">\(\bar{A}\)</span> 与 <span class="math inline">\(\bar{B}\)</span> 独立。</p><p>​ 注意：事件 <span class="math inline">\(A\)</span> 与事件 <span class="math inline">\(B\)</span> 独立不能用韦恩图表示；互斥 <span class="math inline">\(\Rightarrow\)</span>不独立（反之不一定成立）。</p><hr><p>2.多个事件的相互独立性：</p><p>​ 1）定义：设有 <span class="math inline">\(n\)</span> 个事件 <span class="math inline">\(A_1, A_2, \cdots, A_n\)</span>, 对任意的 <span class="math inline">\(1 \leqslant i&lt;j&lt;k&lt;\cdots \leqslantn\)</span>, 如果以下等式均成立 <span class="math display">\[\left\{\begin{array}{l}P\left(A_i A_j\right)=P\left(A_i\right) P\left(A_j\right), \\ P\left(A_iA_j A_k\right)=P\left(A_i\right) P\left(A_j\right) P\left(A_k\right), \\\quad \cdots \cdots \cdots \cdots \\ P\left(A_1 A_2 \cdotsA_n\right)=P\left(A_1\right) P\left(A_2\right) \cdots P\left(A_n\right),\end{array}\right.\]</span> ​ 则称此 <span class="math inline">\(n\)</span> 个事件 <span class="math inline">\(A_1, A_2, \cdots, A_n\)</span> 相互独立。</p><p>​ 相互独立 <span class="math inline">\(\Rightarrow\)</span>两两独立（反之不一定成立）</p><p>​ 2）几个结论：</p><ul><li><p><span class="math inline">\(n\)</span>个事件独立的充要条件是任意取出其中的 <span class="math inline">\(k\)</span> 个事件都是相互独立的;</p></li><li><p>若 <span class="math inline">\(A_1 A_2 \cdots A_n\)</span>独立，则将他们任意分成 <span class="math inline">\(l\)</span>组，每一组中的事件经过任何运算产生一个新的事件，这样的 <span class="math inline">\(l\)</span> 个新的事件依然相互独立；</p></li><li><p>小概率原理：</p><p>若 <span class="math inline">\(n\)</span> 个事件 <span class="math inline">\(A_1, A_2, \ldots, A_n\)</span>相互独立，其发生的概率分别为 <span class="math inline">\(p_1, p_2,\ldots, p_n\)</span> ，则</p></li></ul><p>​ ①事件 <span class="math inline">\(A_1, A_2, \ldots, A_n\)</span>中至少有一个事件发生的概率为 <span class="math display">\[P\left(\bigcup_{i=1}^n A_i\right)=1-P\left(\bigcap_{i=1}^n\bar{A}_i\right)=1-\prod_{i=1}^n\left(1-p_i\right)\]</span> ​ ②事件 <span class="math inline">\(A_1, A_2, \ldots,A_n\)</span> 中至少有一个事件不发生的概率为 <span class="math display">\[P\left(\bigcup_{i=1}^n \bar{A}_i\right)=1-P\left(\bigcap_{i=1}^nA_i\right)=1-\prod_{i=1}^n p_i\]</span></p><hr><p>3.试验的独立性</p><p>​ 设有两个试验 <span class="math inline">\(E_1\)</span> 和 <span class="math inline">\(E_2\)</span>, 假如试验 <span class="math inline">\(E_1\)</span> 的任一结果 (事件) 与试验 <span class="math inline">\(E_2\)</span> 的任一结果 (事件) 都是相互独立的事件,则称这两个试验相互独立。</p><p>​ 类似地可以定义 <span class="math inline">\(n\)</span> 个试验 <span class="math inline">\(E_1, E_2, \cdots, E_n\)</span> 的相互独立性: 如果<span class="math inline">\(E_1\)</span> 的任一结果、 <span class="math inline">\(E_2\)</span> 的任一结果、 <span class="math inline">\(\cdots \cdots 、 E_n\)</span>的任一结果都是相互独立的事件, 则称试验 <span class="math inline">\(E_1\)</span>, <span class="math inline">\(E_2,\cdots, E_n\)</span> 相互独立. 如果这 <span class="math inline">\(n\)</span> 个独立试验还是相同的, 则称其为 <span class="math inline">\(n\)</span> 重独立重夏试验.</p><p>​ 如果在 <span class="math inline">\(n\)</span> 重独立重复试验中,每次试验的可能结果为两个: <span class="math inline">\(A\)</span> 或<span class="math inline">\(\bar{A}\)</span>, 则称这种试验为 <span class="math inline">\(n\)</span> 重伯努利 (Bernoulli) 试验.</p><h2 id="第二章-随机变量及其分布">第二章 随机变量及其分布</h2><h3 id="随机变量及其分布">2.1 随机变量及其分布</h3><p>1.随机变量</p><p>​ 定义在样本空间 <span class="math inline">\(\Omega\)</span>上的实值函数 <span class="math inline">\(X=X(\omega)\)</span>称为随机变量, 常用大写字母 <span class="math inline">\(X, Y, Z\)</span>等表示随机变量, 其取值用小写字母 <span class="math inline">\(x, y,z\)</span> 等表示。</p><p>​ 这个定义表明: 随机变量 <span class="math inline">\(X\)</span>是样本点 <span class="math inline">\(\omega\)</span> 的一个函数,这个函数可以是不同样本点对应不同的实数, 也允许多个样本点对应同一个实数.这个函数的自变量 (样本点) 可以是数,也可以不是数,但因变量一定是实数。</p><p>​ 随机变量分为离散型随机变量和连续型随机变量。</p><hr><p>2.随机变量的分布函数</p><p>1）定义：设 <span class="math inline">\(X\)</span> 是一个随机变量,对任意实数 <span class="math inline">\(x\)</span>, 称<span class="math inline">\(F(x)=P(X \leqslant x)\)</span>为随机变量 <span class="math inline">\(X\)</span> 的分布函数. 且称 <span class="math inline">\(X\)</span> 服从 <span class="math inline">\(F(x)\)</span>, 记为 <span class="math inline">\(X\sim F(x)\)</span>。</p><p>2）性质：单调性（单调非减）、有界性、右连续性。</p><hr><p>3.离散随机变量的概率分布列</p><p>1）定义：设 <span class="math inline">\(X\)</span>是一个离散随机变量, 如果 <span class="math inline">\(X\)</span>的所有可能取值是 <span class="math inline">\(x_1, x_2, \cdots, x_n,\cdots\)</span>, 则称 <span class="math inline">\(X\)</span> 取 <span class="math inline">\(x_i\)</span> 的概率 <span class="math display">\[p_i=p\left(x_i\right)=P\left(X=x_i\right), i=1,2, \cdots, n, \cdots\]</span> ​ 为 <span class="math inline">\(X\)</span>的概率分布列或简称为分布列，记为 <span class="math inline">\(X \sim\{p_i\}\)</span> 。</p><p>2）性质：非负性、正则性。</p><p>3）离散随机变量 <span class="math inline">\(X\)</span> 的分布函数<span class="math inline">\(F(x)=\sum_\limits{x_i \leqslant x}p\left(x_i\right)\)</span> ，<span class="math inline">\(F(x)\)</span>是分段阶梯函数。</p><hr><p>4.连续随机变量的概率密度函数</p><p>1）定义：设随机变量 <span class="math inline">\(X\)</span>的分布函数为 <span class="math inline">\(F(x)\)</span>,如果存在实数轴上的一个非负可积函数 <span class="math inline">\(p(x)\)</span>,使得对任意实数 <span class="math inline">\(x\)</span> 有 <span class="math display">\[F(x)=\int_{-\infty}^x p(t) \mathrm{d} t,\]</span> ​ 则称 <span class="math inline">\(p(x)\)</span> 为 <span class="math inline">\(X\)</span>的概率密度函数，简称为密度函数或密度。同时称 <span class="math inline">\(X\)</span> 为连续随机变量，称 <span class="math inline">\(F(x)\)</span> 为连续分布函数。</p><p>2）性质：非负性、正则性。</p><p>3）对于连续随机变量 <span class="math inline">\(X\)</span> 有 <span class="math display">\[P(a \leqslant X \leqslant b)=P(a&lt;X \leqslant b)=P(a \leqslantX&lt;b)=P(a&lt;X&lt;b) .\]</span>4）一个连续分布的密度函数并不唯一，因为只在若干点上改变密度函数 <span class="math inline">\(p(x)\)</span> 的值并不影响其积分值。</p><h3 id="随机变量的数学期望">2.2 随机变量的数学期望</h3><p>1.数学期望的定义</p><p>1）设离散随机变量 <span class="math inline">\(X\)</span> 的分布列为<span class="math display">\[p\left(x_i\right)=P\left(X=x_i\right), i=1,2, \cdots, n, \cdots .\]</span> ​ 如果 <span class="math display">\[\sum_{i=1}^{\infty}\left|x_i\right| p\left(x_i\right)&lt;\infty,\]</span> ​ 则称 <span class="math display">\[E(X)=\sum_{i=1}^{\infty} x_i p\left(x_i\right)\]</span> ​ 为随机变量 <span class="math inline">\(X\)</span>的数学期望，简称期望或均值。</p><p>​ 值得注意的是级数绝对收敛的条件。</p><p>2）设连续随机变量 <span class="math inline">\(X\)</span> 的密度函数为<span class="math inline">\(p(x)\)</span> ，如果 <span class="math display">\[\int_{-\infty}^{\infty}|x| p(x) \mathrm{d} x&lt;\infty,\]</span> ​ 则称 <span class="math display">\[E(X)=\int_{-\infty}^{\infty} x p(x) \mathrm{d} x\]</span> ​ 为随机变量 <span class="math inline">\(X\)</span>的数学期望，简称期望或均值。</p><p>​ 同样要注意收敛的条件。</p><hr><p>2.数学期望的性质</p><p>1）若 <span class="math inline">\(c\)</span> 是常数，则 <span class="math inline">\(E(c)=c\)</span>.</p><p>2）对任意常数 <span class="math inline">\(a\)</span> 有 <span class="math inline">\(E(aX)=aE(X)\)</span>.</p><p>3）线性性质：对任意的两个函数 <span class="math inline">\(g_1(x)\)</span> 和 <span class="math inline">\(g_2(x)\)</span> 有 <span class="math inline">\(E\left[g_1(X) \pmg_2(X)\right]=E\left[g_1(X)\right] \pmE\left[g_2(X)\right]\)</span>.</p><p>​ 特别地，<span class="math inline">\(E(aX+b)=aE(X)+b\)</span>.</p><p>4）若 <span class="math inline">\(a\leq X \leq b\)</span>，则 <span class="math inline">\(a\leq E(x) \leq b\)</span>.</p><hr><p>3.随机变量函数的数学期望</p><p>若随机变量 <span class="math inline">\(X\)</span> 的分布用分布列<span class="math inline">\(p(x_i)\)</span> 或用密度函数 <span class="math inline">\(p(x)\)</span> 表示，则 <span class="math inline">\(X\)</span> 的某一函数 <span class="math inline">\(g(X)\)</span> 的数学期望为 <span class="math display">\[E[g(X)] = \begin{cases} \displaystyle \sum\limits_{i} g(x_i) p(x_i),&amp; \text{在离散场合}, \\ \displaystyle\int_{-\infty}^{\infty} g(x)p(x) \, dx, &amp; \text{在连续场合}.\end{cases}\]</span> 这里涉及的数学期望都假定存在。</p><h3 id="随机变量的方差与标准差">2.3 随机变量的方差与标准差</h3><p>1.方差与标准差的定义</p><p>1）方差：若随机变量 <span class="math inline">\(X^2\)</span>的数学期望 <span class="math inline">\(E(X^2)\)</span>存在，则称偏差平方 <span class="math inline">\((X-E(X))^2\)</span>的数学期望 <span class="math inline">\(E(X-E(X))^2\)</span> 为随机变量<span class="math inline">\(X\)</span> 的方差，记为<br><span class="math display">\[Var(X)=E(X-E(X))^2 = \begin{cases}\displaystyle \sum_\limitsi\left(x_i-E(X)\right)^2 p\left(x_i\right),  \text { 在离散场合, } \\\displaystyle\int_{-\infty}^{\infty}(x-E(X))^2 p(x) \mathrm{d} x, \text{ 在连续场合. }\end{cases}\]</span> 2）标准差：称方差的正平方根 <span class="math inline">\(\sqrt{Var(X)}\)</span> 为随机变量 <span class="math inline">\(X\)</span> 的标准差，记为 <span class="math inline">\(\sigma(X)\)</span> 或 <span class="math inline">\(\sigma_X\)</span>.</p><p>3）随机变量 <span class="math inline">\(X\)</span>的方差存在则期望一定存在，而期望存在方差不一定存在。</p><hr><p>2.方差的性质</p><p>​ 假设随机变量的方差存在：</p><p>1）方差的计算公式： <span class="math inline">\(Var(X)=E(X^2)-[E(X)]^2\)</span>.</p><p>2）常数的方差为 <span class="math inline">\(0\)</span> ，即 <span class="math inline">\(Var(c)=0\)</span> ，其中 <span class="math inline">\(c\)</span> 是常数.</p><p>3）若 <span class="math inline">\(a,b\)</span> 是常数，则 <span class="math inline">\(Var(aX+b) = a^2Var(X)\)</span>.</p><p>注意：方差不具备线性性质，即 <span class="math inline">\(Var(X+Y)\neqVar(X) + Var(Y)\)</span></p><hr><p>3.切比雪夫不等式</p><p>​ 设随机变量 <span class="math inline">\(X\)</span>的数学期望和方差都存在，则对任意常数 <span class="math inline">\(\varepsilon&gt;0\)</span> ，有 <span class="math display">\[P(|X-E(X)| \geqslant \varepsilon) \leqslant\frac{\operatorname{Var}(X)}{\varepsilon^2},\]</span> ​ 或 <span class="math display">\[P(|X-E(X)|&lt;\varepsilon) \geqslant1-\frac{\operatorname{Var}(X)}{\varepsilon^2} \text {. }\]</span> ​ 切比雪夫不等式给出了大偏差发生概率的上界。</p><h3 id="常用离散分布">2.4 常用离散分布</h3><p>1.二项分布</p><p>1）<span class="math inline">\(0-1\)</span> 分布（二点分布）</p><p>​ 随机变量 <span class="math inline">\(X\)</span> 的取值为 <span class="math inline">\(\{0,1\}\)</span> ,其分布列为 <span class="math inline">\(P(X=x)=p^x(1-p)^{1-x},\quad x=0,1\)</span> .</p><p>​ 或记为 <span class="math display">\[\begin{array}{c|cc}X &amp; 0 &amp; 1 \\ \hline P &amp; 1-p &amp; p\end{array}\]</span> ​ 若随机变量 <span class="math inline">\(X\sim b(1,p)\)</span>，则 <span class="math display">\[E(X)=p \quad Var(X)=p(1-p)\]</span> 2）二项分布的定义</p><p>​ 记 <span class="math inline">\(X\)</span> 为 <span class="math inline">\(n\)</span> 重伯努利试验中成功（记为事件 <span class="math inline">\(A\)</span> ）的次数，则 <span class="math inline">\(X\)</span> 的可能取值为 <span class="math inline">\(0,1,\cdots,n\)</span> .记 <span class="math inline">\(p\)</span> 为每次试验中 <span class="math inline">\(A\)</span> 发生的概率，即 <span class="math inline">\(P(A)=p\)</span> ，则 <span class="math inline">\(X\)</span> 的分布列为 <span class="math display">\[P(X=k)=\binom{n}{k} p^k(1-p)^{n-k}, k=0,1, \cdots, n \text {. }\]</span> ​ 记为 $X b(n,p) $ ，二项概率 <span class="math inline">\(P(X=k)=\displaystyle\binom{n}{k}p^k(1-p)^{n-k}\)</span> 恰好是 <span class="math inline">\(n\)</span>次二项式 <span class="math inline">\((p+(1-p))^n\)</span> 的展开式的第<span class="math inline">\(k+1\)</span> 项。</p><p>3）二项分布的数学期望和方差</p><p>​ 设随机变量 <span class="math inline">\(X\sim b(n,p)\)</span> ，则<span class="math display">\[E(X)=np \quad Var(X)=np(1-p)\]</span> 4）二项分布的随机变量可以分解成 <span class="math inline">\(n\)</span>个的独立同分布的二点分布的随机变量之和，所以数学期望和方差系数差了一个<span class="math inline">\(n\)</span>。</p><hr><p>2.泊松分布</p><p>1）泊松分布的定义：泊松分布的概率分布列是 <span class="math display">\[P(X=k)=\frac{\lambda^k}{k!} \mathrm{e}^{-\lambda}, k=0,1,2, \cdots,\]</span> ​ 其中参数 <span class="math inline">\(\lambda&gt;0\)</span>，记为 <span class="math inline">\(X\sim P(\lambda)\)</span>.</p><p>2）泊松分布的数学期望和方差</p><p>​ 设随机变量 <span class="math inline">\(X\sim P(\lambda)\)</span>，则<span class="math display">\[E(X)=Var(X)=\lambda\]</span> 3）泊松定理（二项分布的泊松近似）</p><p>​ 在 <span class="math inline">\(n\)</span> 重伯努利试验中，记事件<span class="math inline">\(A\)</span> 在一次试验中发生的概率为 <span class="math inline">\(p_n\)</span> （与试验次数 <span class="math inline">\(n\)</span> 有关），如果当 <span class="math inline">\(n \rightarrow \infty\)</span> 时, 有 <span class="math inline">\(n p_n \rightarrow \lambda\)</span>, 则 <span class="math display">\[\lim _{n \rightarrow \infty}\binom{n}{k}p_n^k\left(1-p_n\right)^{n-k}=\frac{\lambda^k}{k!} \mathrm{e}^{-\lambda}.\]</span> ​ 在计算二项分布 <span class="math inline">\(b(n,p)\)</span>时，当 <span class="math inline">\(n\)</span> 很大，<span class="math inline">\(p\)</span> 很小，而乘积 <span class="math inline">\(\lambda=np\)</span>大小适中时，就可以用泊松分布作近似分布，即 <span class="math display">\[\binom{n}{k} p^k\left(1-p\right)^{n-k} \approx \frac{(n p)^k}{k!}\mathrm{e}^{-n p}, k=0,1,2, \cdots .\]</span></p><hr><p>3.超几何分布</p><p>1）超几何分布的定义</p><p>​ 设有 <span class="math inline">\(N\)</span> 件产品，其中有 <span class="math inline">\(M\)</span> 件不合格品。若从中不放回地随机抽取<span class="math inline">\(n\)</span> 件，则其中含有地不合格品的件数<span class="math inline">\(X\)</span> 服从超几何分布，记为 <span class="math inline">\(X\sim h(n,N,M)\)</span> 。超几何分布的概率分布列为<span class="math display">\[P(X=k)=\frac{\displaystyle\binom{M}{k}\binom{N-M}{n-k}}{\displaystyle\binom{N}{n}},k=0,1, \cdots, r .\]</span> 其中 <span class="math inline">\(r=\min\{M,n\}\)</span> ，且<span class="math inline">\(M\leq N,n\leq N\)</span> ，<span class="math inline">\(n,N,M\)</span> 均为正整数。</p><p>2）超几何分布的数学期望和方差 (方差不用背)</p><p>设随机变量 <span class="math inline">\(X\sim h(n,N,M)\)</span> ，则<span class="math display">\[E(X)=n\frac{M}{N}\quad Var(X)=\frac{n M(N-M)(N-n)}{N^2(N-1)} .\]</span> 3）超几何分布的二项近似：当 <span class="math inline">\(n \llN\)</span> 时, 即抽取个数 <span class="math inline">\(n\)</span>远小于产品总数 <span class="math inline">\(N\)</span> 时, 每次抽取后,总体中的不合格品率 <span class="math inline">\(p=M / N\)</span>改变甚微, 所以不放回抽样可近似地看成放回抽样,这时超几何分布可用二项分布近似。</p><hr><p>4.几何分布</p><p>1）几何分布的定义</p><p>​ 在伯努利实验中，记每次试验中事件 <span class="math inline">\(A\)</span> 发生的概率为 <span class="math inline">\(p\)</span> ，如果 <span class="math inline">\(X\)</span> 为事件 <span class="math inline">\(A\)</span> 首次出现时试验次数，则 <span class="math inline">\(X\)</span> 的可能取值为 <span class="math inline">\(1,2,\cdots\)</span> ，称 <span class="math inline">\(X\)</span> 服从几何分布，记为 <span class="math inline">\(X \sim Ge(p)\)</span>，其分布列为 <span class="math display">\[P(X=k)=(1-p)^{k-1}p,k=1,2,\cdots.\]</span> 2）几何分布的数学期望和方差：</p><p>​ 设随机变量 <span class="math inline">\(X\)</span> 服从几何分布 <span class="math inline">\(Ge(p)\)</span> ，则 <span class="math display">\[E(X)=\frac{1}{p}\quad Var(X)=\frac{1-p}{p^2}\]</span> 3）几何分布的无记忆性：</p><p>​ 设随机变量 <span class="math inline">\(X \sim Ge(p)\)</span>,对任意正整数 <span class="math inline">\(m, n\)</span> 有 <span class="math display">\[P(X&gt;m+n \mid X&gt;m)=P(X&gt;n)\]</span></p><hr><p>5.负二项分布（几何分布的延伸）</p><p>1）负二项分布的定义</p><p>​ 在伯努利试验序列中，记每次试验中事件 <span class="math inline">\(A\)</span> 发生的概率为 <span class="math inline">\(p\)</span> ，如果 <span class="math inline">\(X\)</span> 为事件 <span class="math inline">\(A\)</span> 第 <span class="math inline">\(r\)</span> 次出现时的试验次数，则 <span class="math inline">\(X\)</span> 的可能取值为 <span class="math inline">\(r, r+1,\cdots,r+m,\cdots\)</span> 。称 <span class="math inline">\(X\)</span> 服从负二项分布或帕斯卡分布，其分布列为<span class="math display">\[P(X=k)=\binom{k-1}{r-1} p^r(1-p)^{k-r}, k=r, r+1, \cdots .\]</span> ​ 记为 <span class="math inline">\(X\sim Nb(r,p)\)</span>. 当<span class="math inline">\(r=1\)</span> 时，即为几何分布。</p><p>​ <span class="math inline">\(ps:\)</span>解释一下前面的系数，最后一次一定是第 <span class="math inline">\(k\)</span> 次试验时事件 <span class="math inline">\(A\)</span> 发生了第 <span class="math inline">\(r\)</span> 次，所以只需要在剩下的 <span class="math inline">\(k-1\)</span> 次试验中选取 <span class="math inline">\(r-1\)</span> 次试验表示事件 <span class="math inline">\(A\)</span> 发生即可。</p><p>2）负二项分布的数学期望和方差：</p><p>​ 设随机变量 <span class="math inline">\(X\)</span> 服从负二项分布<span class="math inline">\(Nb(r,p)\)</span> ，则 <span class="math display">\[E(X)=\frac{r}{p}\quad Var(X)=\frac{r(1-p)}{p^2}\]</span> ​ 和几何分布很像，差一个 <span class="math inline">\(r\)</span>，这是因为负二项分布的随机变量可以分解成 <span class="math inline">\(r\)</span>个独立同分布的几何分布的随机变量之和。</p><p>3）负二项分布也有无记忆性。</p><h3 id="常用连续分布">2.5 常用连续分布</h3><p>1.均匀分布</p><p>1）均匀分布的定义</p><p>​ 若随机变量 <span class="math inline">\(X\)</span> 的密度函数为 <span class="math display">\[p(x)=\left\{\begin{array}{cl}\dfrac{1}{b-a}, &amp; a&lt;x&lt;b \\ 0, &amp; \text { 其他 }\end{array}\right.\]</span> 则称 <span class="math inline">\(X\)</span> 服从区间 <span class="math inline">\((a,b)\)</span> 上的均匀分布，记作 <span class="math inline">\(X \sim U(a,b)\)</span>，其分布函数为 <span class="math display">\[F(x)=\left\{\begin{array}{cc}0, &amp; x&lt;a, \\ \dfrac{x-a}{b-a}, &amp; a \leqslant x&lt;b, \\ 1,&amp; x \geqslant b.\end{array}\right.\]</span> 2）均匀分布的数学期望与方差：</p><p>​ 设随机变量 <span class="math inline">\(X\sim U(a,b)\)</span> ，则<span class="math display">\[E(X)=\frac{a+b}{2}\quad Var(X)=\frac{(b-a)^2}{12}\]</span></p><hr><p>2.指数分布</p><p>1）指数分布的定义</p><p>​ 若随机变量 <span class="math inline">\(X\)</span> 的密度函数为 <span class="math display">\[p(x)= \begin{cases}\lambda \mathrm{e}^{-\lambda x}, &amp; x \geqslant 0,\\ 0, &amp; x&lt;0,\end{cases}\]</span> 则称 <span class="math inline">\(X\)</span> 服从指数分布，记作<span class="math inline">\(X\sim Exp(\lambda)\)</span> ，其中参数 <span class="math inline">\(\lambda&gt;0\)</span> .指数分布的分布函数为 <span class="math display">\[F(x)= \begin{cases}1-\mathrm{e}^{-\lambda x}, &amp; x \geqslant 0, \\ 0,&amp; x&lt;0 .\end{cases}\]</span> 2）指数分布的数学期望与方差：</p><p>​ 设随机变量 <span class="math inline">\(X \sim Exp(\lambda)\)</span>，则 <span class="math display">\[E(X)=\frac{1}{\lambda} \quad Var(X)=\frac{1}{\lambda^2}\]</span> 3）指数分布的无记忆性：如果随机变量 <span class="math inline">\(X\sim Exp(\lambda)\)</span>，则对任意 <span class="math inline">\(s&gt;0,t&gt;0\)</span> 有 <span class="math display">\[P(X&gt;s+t \mid X&gt;s)=P(X&gt;t) .\]</span> ​ <span class="math inline">\(ps:\)</span>指数分布是唯一具有无记忆性的连续型随机变量。</p><hr><p>3.正态分布</p><p>1）正态分布的定义</p><p>​ 若随机变量 <span class="math inline">\(X\)</span> 的密度函数为 <span class="math display">\[p(x)=\frac{1}{\sqrt{2 \pi} \sigma} \mathrm{e}^{-\frac{(x-\mu)^2}{2\sigma^2}}, \quad-\infty&lt;x&lt;\infty,\]</span> 则称 <span class="math inline">\(X\)</span> 服从正态分布，记作<span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span> .其中参数<span class="math inline">\(-\infty&lt;\mu&lt;\infty,\sigma&gt;0\)</span>.正态分布的分布函数为 <span class="math display">\[F(x)=\frac{1}{\sqrt{2 \pi} \sigma} \int_{-\infty}^x\mathrm{e}^{-\frac{(t-\mu)^2}{2 \sigma^2}} \mathrm{~d} t .\]</span> ​ 特别地，若 <span class="math inline">\(\mu=0\)</span> 和<span class="math inline">\(\sigma=1\)</span>, 称 <span class="math inline">\(N(0,1)\)</span> 为标准正态分布。</p>​通常记标准正态变量为 <span class="math inline">\(U\)</span>,记标准正态分布的密度函数为 <span class="math inline">\(\varphi(u)\)</span>, 分布函数为 <span class="math inline">\(\Phi(u)\)</span>, 即 $$<span class="math display">\[\begin{aligned}&amp;\varphi(u) = \frac{1}{\sqrt{2 \pi}} e^{-\frac{u^2}{2}},\quad-\infty&lt;u&lt;\infty,\\&amp;\Phi(u) = \frac{1}{\sqrt{2 \pi}} \int_{-\infty}^u\mathrm{e}^{-\frac{t^2}{2}} \mathrm{~d} t, \quad-\infty&lt;u&lt;\infty .\end{aligned}\]</span><p>$$</p><p>2）正态分布密度函数 <span class="math inline">\(p(x)\)</span>图像的性质：</p><ul><li>关于 <span class="math inline">\(x=\mu\)</span> 对称，即 <span class="math inline">\(p(\mu-x)=p(\mu+x)\)</span> .</li><li><span class="math inline">\(x=\mu\)</span> 时， <span class="math inline">\(p(x)\)</span> 取最大值 <span class="math inline">\(\dfrac{1}{\sqrt{2\pi}\sigma}\)</span> .</li><li><span class="math inline">\(x = \mu \pm \sigma\)</span> 是 <span class="math inline">\(y=p(x)\)</span> 的拐点横坐标.</li></ul><p>3）标准正态分布函数 <span class="math inline">\(\Phi(x)\)</span>的性质：</p><ul><li><span class="math inline">\(\Phi(-u)=1-\Phi(u)\)</span>.</li><li><span class="math inline">\(P(a&lt;U&lt;b)=\Phi(b)-\Phi(a)\)</span>.</li><li><span class="math inline">\(P(|U|&lt;c)=2 \Phi(c)-1 \quad(c\geqslant 0)\)</span>.</li><li><span class="math inline">\(\Phi(0)=\dfrac{1}{2}\)</span> .</li></ul><p>4）正态变量的标准化</p><p>​一般正态变量都可以通过一个线性变换（标准化）化成标准正态变量．因此与正态变量有关的一切事件的概率都可通过查标准正态分布函数表获得。</p><p>​ 定理1：若随机变量 <span class="math inline">\(X\simN(\mu,\sigma^2)\)</span> ，则 <span class="math inline">\(U=\dfrac{X-\mu}{\sigma}\sim N(0,1)\)</span> .</p><p>​ 定理2（正态分布事件概率计算）：若随机变量 <span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span> ，则 <span class="math display">\[P(X \leqslant c)=\Phi\left(\frac{c-\mu}{\sigma}\right) .\]</span></p><p><span class="math display">\[P(a&lt;X \leqslantb)=\Phi\left(\frac{b-\mu}{\sigma}\right)-\Phi\left(\frac{a-\mu}{\sigma}\right).\]</span></p><p><span class="math display">\[P(X&gt;c)=1-\Phi(\frac{c-\mu}{\sigma}).\]</span></p><p>5）正态分布的数学期望与方差：</p><p>​ 设随机变量 <span class="math inline">\(X \sim N\left(\mu,\sigma^2\right)\)</span>，则 <span class="math display">\[E(X)=\mu \quad Var(X)=\sigma^2\]</span> 6）正态分布的 <span class="math inline">\(3\sigma\)</span>原则：</p><p>​ 设随机变量 <span class="math inline">\(X \sim N\left(\mu,\sigma^2\right)\)</span>, 则 <span class="math display">\[P(\mu-k \sigma&lt;X&lt;\mu+k\sigma)=P\left(\left|\frac{X-\mu}{\sigma}\right|&lt;k\right)=\Phi(k)-\Phi(-k)=2\Phi(k)-1\]</span> ​ 当 <span class="math inline">\(k=1,2,3\)</span> 时，有 <span class="math display">\[P(\mu-\sigma&lt;X&lt;\mu+\sigma)=2 \Phi(1)-1=0.6826,\]</span></p><p><span class="math display">\[P(\mu-2 \sigma&lt;X&lt;\mu+2 \sigma)=2 \Phi(2)-1=0.9545,\]</span></p><p><span class="math display">\[P(\mu-3 \sigma&lt;X&lt;\mu+3 \sigma)=2 \Phi(3)-1=0.9973 .\]</span></p><p>​ 随机变量 <span class="math inline">\(X \sim N\left(\mu,\sigma^2\right)\)</span> 的取值落在 <span class="math inline">\([\mu-3\sigma,\mu+3\sigma]\)</span>之外的概率不超过千分之三，即 <span class="math inline">\(X\)</span>的取值几乎都落在<span class="math inline">\([\mu-3\sigma,\mu+3\sigma]\)</span>之内，这就是人们常说的 <span class="math inline">\(3\sigma\)</span>原则。</p><hr><p>4.伽马分布（了解）</p><p>1）伽马分布的定义</p><p>​ 若随机变量 <span class="math inline">\(X\)</span> 的密度函数为 <span class="math display">\[p(x)=\left\{\begin{array}{cc}\dfrac{\lambda^\alpha}{\Gamma(\alpha)} x^{\alpha-1} e^{-\lambda x},&amp; x \geqslant 0 \\0 &amp; , x&lt;0\end{array} \quad \alpha&gt;0, \lambda&gt;0\right.\]</span> 称 <span class="math inline">\(X\)</span> 服从伽马分布，记为<span class="math inline">\(X\sim Ga(\alpha,\lambda)\)</span> .</p><p>2）伽马分布的数学期望与方差</p><p>​ 设随机变量 <span class="math inline">\(X\simGa(\alpha,\lambda)\)</span>，则 <span class="math display">\[E(X)=\frac{\alpha}{\lambda} \quad Var(X)=\frac{\alpha}{\lambda^2}\]</span> 3）两个特例</p><p>​ <span class="math inline">\(\alpha=1\)</span>时的伽马分布就是指数分布, 即 <span class="math display">\[Ga(1, \lambda) = Exp(\lambda) .\]</span> ​ 称 <span class="math inline">\(\alpha=n / 2, \lambda=1 /2\)</span> 时的伽马分布是自由度为 <span class="math inline">\(n\)</span>的 <span class="math inline">\(\chi^2\)</span> (卡方) 分布，即 <span class="math display">\[G a\left(\frac{n}{2}, \frac{1}{2}\right)=\chi^2(n).\]</span> 4）伽马分布与指数分布的关系：若第一参数为 <span class="math inline">\(k\)</span> ，则伽马变量可以表示成 <span class="math inline">\(k\)</span> 个独立同分布的指数变量之和，即</p><p>若 <span class="math inline">\(X \sim Ga(k, \lambda)\)</span>. 则<span class="math inline">\(X=X_1+X_2+\cdots+X_k \quad X_i \simExp(\lambda)\)</span> .</p><hr><p>5.贝塔分布（了解）</p><p>1）贝塔函数</p><p>​ 称以下函数 <span class="math display">\[\mathrm{B}(a, b)=\int_0^1 x^{a-1}(1-x)^{b-1} \mathrm{~d} x\]</span> 为贝塔函数，其中参数 <span class="math inline">\(a&gt;0,b&gt;0\)</span> .</p><p>​ 贝塔函数具有的性质：<span class="math inline">\(B(a,b) =B(b,a)\)</span>.</p><p>2）贝塔分布的定义</p><p>​ 若随机变量 <span class="math inline">\(X\)</span> 的密度函数为 <span class="math display">\[p(x)= \begin{cases}\dfrac{\Gamma(a+b)}{\Gamma(a) \Gamma(b)}x^{a-1}(1-x)^{b-1}, &amp; 0&lt;x&lt;1, \\ 0, &amp; \text { 其他,}\end{cases}\]</span> 则称 <span class="math inline">\(X\)</span> 服从贝塔分布, 记作<span class="math inline">\(X \sim B e(a, b)\)</span>, 其中 <span class="math inline">\(a&gt;0, b&gt;0\)</span> 都是形状参数。</p><p>​ 特别地，<span class="math inline">\(Be(1,1) =U(0,1)\)</span></p><p>3）贝塔分布的数学期望与方差</p><p>​ 设随机变量 <span class="math inline">\(X\sim Be(a,b)\)</span> ，则<span class="math display">\[E(x)=\frac{a}{a+b} \quad Var(X)=\frac{a b}{(a+b)^2(a+b+1)}\]</span></p><h3 id="随机变量函数的分布">2.6 随机变量函数的分布</h3><p>1.离散随机变量的函数分布</p><p>​ 设离散随机变量 <span class="math inline">\(X\)</span> 的分布列为<span class="math inline">\(P\left\{X=x_i\right\}=p_i, i=1,2,\cdots\)</span>, 已知 <span class="math inline">\(y=g(x)\)</span>为连续函数, 则 <span class="math inline">\(Y=g(X)\)</span> 的分布列为 <span class="math inline">\(P\left\{Y=g\left(x_i\right)\right\}=p_i, i=1,2,\cdots\)</span> .然后再合并 <span class="math inline">\(g(x_i)\)</span>值相等的概率即可。</p><hr><p>2.连续随机变量的函数分布</p><p>1）当 <span class="math inline">\(Y=g(X)\)</span>仍然为离散随机变量</p><p>​ 这种情况下只用将 <span class="math inline">\(Y\)</span>的可能取值一一列出，再将 <span class="math inline">\(Y\)</span>取各种可能值的概率求出即可。</p><p>2）当 <span class="math inline">\(Y=g(X)\)</span> 为连续随机变量</p><p>​ 求 <span class="math inline">\(Y\)</span> 的密度函数 <span class="math inline">\(p_Y(y)\)</span> 的两种方法：</p><p>​ ①分布函数法：求 <span class="math inline">\(Y\)</span> 的分布函数<span class="math inline">\(F_Y(y)\)</span> ，<span class="math inline">\(F_Y(y)=P_Y(Y\leqslant y)=P(g(X)\leqslanty)=P_X(X\in A)\)</span> ，对变量 <span class="math inline">\(y\)</span>求导从而得到 <span class="math inline">\(P_Y(y)\)</span> .</p><p>​ ②公式法：设 <span class="math inline">\(X\)</span>是连续随机变量，其密度函数为 <span class="math inline">\(p_X(x)\)</span>. <span class="math inline">\(Y=g(X)\)</span> 是另一个连续随机变量. 若<span class="math inline">\(y=g(x)\)</span> 严格单调，其反函数 <span class="math inline">\(h(y)\)</span> 有连续导函数，则 <span class="math inline">\(Y=g(X)\)</span> 的密度函数为 <span class="math display">\[p_Y(y)= \begin{cases}p_X[h(y)]\left|h^{\prime}(y)\right|, &amp;a&lt;y&lt;b, \\\\ 0, &amp; \text { 其他. }\end{cases}\]</span> 其中 <span class="math inline">\(a=\min \{g(-\infty),g(\infty)\}, b=\max \{g(-\infty), g(\infty)\}\)</span>.</p><p>​ 由公式法得到的一些结论：</p><ul><li>定理1：设随机变量 <span class="math inline">\(X\)</span>服从正态分布 <span class="math inline">\(N\left(\mu,\sigma^2\right)\)</span>, 则当 <span class="math inline">\(a \neq0\)</span> 时, 有 <span class="math inline">\(Y=a X+b \simN(a\mu+b,a^2\sigma^2)\)</span> .即：正态变量经过线性变换后仍为正态变量。</li><li>定理2：若随机变量 <span class="math inline">\(X\)</span> 的分布函数<span class="math inline">\(F_X(x)\)</span> 为严格单调增的连续函数,其反函数<span class="math inline">\(F_X^{-1}(y)\)</span> 存在, 则 <span class="math inline">\(Y=F_X(x)\)</span> 服从 <span class="math inline">\((0,1)\)</span> 上的均匀分布 <span class="math inline">\(U(0,1)\)</span>.</li></ul><h3 id="附一定要背诵的常用概率分布数学期望和方差">附：一定要背诵的常用概率分布数学期望和方差</h3><p><span class="math display">\[\begin{array}{|c|c|c|c|}\hline \text { 分布 } &amp; \text { 分布律或概率密度 } &amp; \text {数学期望 } &amp; \text { 方差 } \\\hline \text { 0-1 分布 } &amp; \begin{array}{l}P\{x=k\}=p^k(1-p)^{1-k} \\(k=0,1)\end{array} &amp; p &amp; p(1-p) \\\hline \text { 二项分布 } B(n,p) &amp; P\{x=k\}=\displaystyle\displaystyle\binom{n}{k} p^k(1-p)^{1-k} &amp; n p &amp; n p(1-p) \\\hline \text { 泊松分布 } P(\lambda) &amp; P\{x=k\}=\dfrac{\lambda^k}{k!}e^{-\lambda} &amp; \lambda &amp; \lambda \\\hline \text { 均匀分布 } U(a, b) &amp; p(x)=\dfrac{1}{b-a}(a&lt;x&lt;b) &amp; \dfrac{a+b}{2} &amp; \dfrac{(b-a)^2}{12} \\\hline \text { 正态分布 } N\left(\mu, \sigma^2\right) &amp;p(x)=\dfrac{1}{\sqrt{2 \pi} \sigma} e^{\frac{(x-\mu)^2}{2 \sigma^2}}&amp; \mu &amp; \sigma^2 \\\hline \text { 指数分布 } Exp(\theta) &amp;p(x)=\left\{\begin{array}{rr}\theta e^{-\theta x}, &amp; x\geqslant0 \\ 0, &amp; \text { 其他 }\end{array}\right. &amp; \dfrac{1}{\theta} &amp; \dfrac{1}{\theta^2} \\\hline\end{array}\]</span></p><h2 id="第三章-多维随机变量及其分布">第三章 多维随机变量及其分布</h2><h3 id="多维随机变量及其联合分布">3.1 多维随机变量及其联合分布</h3><p>1.多维随机变量的定义：如果 <span class="math inline">\(X_1(\omega),X_2(\omega),\cdots,X_n(\omega)\)</span>是定义在同一个样本空间 <span class="math inline">\(\Omega={\omega}\)</span> 上的 <span class="math inline">\(n\)</span> 个随机变量，则称 <span class="math display">\[X(\omega)=(X_1(\omega),X_2(\omega),\cdots,X_n(\omega))\]</span> 为 <span class="math inline">\(n\)</span> 维（或 <span class="math inline">\(n\)</span> 元）随机变量或随机向量。</p><hr><p>2.联合分布函数</p><p>1）定义：对任意 <span class="math inline">\(n\)</span> 个实数 <span class="math inline">\(x_1,x_2,\cdots,x_n\)</span> ，<span class="math inline">\(n\)</span> 个事件 <span class="math inline">\(\{X_1\leqslant x_1\} , \{X_2\leqslant x_2\},\cdots, \{X_n\leqslant x_n\}\)</span> 同时发生的概率 <span class="math display">\[F\left(x_1, x_2, \cdots, x_n\right)=P\left(X_1 \leqslant x_1, X_2\leqslant x_2, \cdots, X_n \leqslant x_n\right)\]</span> 为 <span class="math inline">\(n\)</span> 维随机变量 <span class="math inline">\((X_1,X_2,\cdots,X_n)\)</span> 的联合分布函数。</p><p>2）任一二维联合分布函数 <span class="math inline">\(F(x,y)\)</span>具备的性质：</p><ul><li>单调性</li><li>有界性</li><li>右连续性</li><li>非负性：对任意的 <span class="math inline">\(a&lt;b,c&lt;d\)</span>有 <span class="math inline">\(P(a&lt;X \leqslant b, c&lt;Y \leqslantd)=F(b, d)-F(a, d)-F(b, c)+F(a, c) \geqslant 0 .\)</span></li></ul><hr><p>3.联合分布列（对于离散随机变量）</p><p>1）定义：如果二维随机变量 <span class="math inline">\((X,Y)\)</span>只取有限个或可列个数对 <span class="math inline">\((x_i,y_j)\)</span>，则称 <span class="math inline">\((X,Y)\)</span> 为二维离散随机变量，称<span class="math display">\[p_{i j}=P\left(X=x_i, Y=y_j\right), \quad i, j=1,2, \cdots\]</span> 为 <span class="math inline">\((X,Y)\)</span>的联合分布列。也可以用如下表格的形式记录：</p><table border="1"><tbody><tr><th rowspan="2" bgcolor="#ffffcc" align="middle">X</th><th colspan="5" bgcolor="#ffffcc" align="middle">Y</th></tr><tr><td align="middle">y<sub>1</sub></td><td align="middle">y<sub>2</sub></td><td align="middle">...</td><td align="middle">y<sub>j</sub></td><td align="middle">...</td></tr><tr><td align="middle">x<sub>1</sub></td><td align="middle">p<sub>11</sub></td><td align="middle">p<sub>12</sub></td><td align="middle">...</td><td align="middle">p<sub>1j</sub></td><td align="middle">...</td></tr><tr><td align="middle">x<sub>2</sub></td><td align="middle">p<sub>21</sub></td><td align="middle">p<sub>22</sub></td><td align="middle">...</td><td align="middle">p<sub>2j</sub></td><td align="middle">...</td></tr><tr><td align="middle">...</td><td align="middle">...</td><td align="middle">...</td><td align="middle">...</td><td align="middle">...</td><td align="middle">...</td></tr><tr><td align="middle">x<sub>i</sub></td><td align="middle">p<sub>i1</sub></td><td align="middle">p<sub>i2</sub></td><td align="middle">...</td><td align="middle">p<sub>ij</sub></td><td align="middle">...</td></tr><tr><td align="middle">...</td><td align="middle">...</td><td align="middle">...</td><td align="middle">...</td><td align="middle">...</td><td align="middle">...</td></tr></tbody></table><p><span class="math display">\[p_{i \cdot}=\sum_j p_{i j}\quad p_{\cdot j}=\sum_i p_{i j}\]</span></p><p>2）性质：非负性、正则性。</p><hr><p>4.联合密度函数（对于连续随机变量）</p><p>1）定义：如果存在二元非负函数 <span class="math inline">\(p(x,y)\)</span>, 便得二维随机变量 <span class="math inline">\((X,Y)\)</span> 的分布函数 <span class="math inline">\(F(x,y)\)</span>可以表示为 <span class="math display">\[F(x, y)=\int_{-\infty}^{x} \int_{-\infty}^y p(u, v) \mathrm{d} v\mathrm{~d} u,\]</span> 则称 <span class="math inline">\((X, Y)\)</span>为二维连续随机变量, 称 <span class="math inline">\(p(u, v)\)</span> 为<span class="math inline">\((X, Y)\)</span> 的联合密度函数.</p><p>​ 在 <span class="math inline">\(F(x,y)\)</span> 偏导数存在的点上有<span class="math display">\[p(x, y)=\frac{\partial^2}{\partial x \partial y} F(x, y).\]</span> ​ 若 <span class="math inline">\(G\)</span>为平面上的一个区域，则事件 <span class="math inline">\(\{(X,Y)\inG\}\)</span> 的概率可以表示为在 <span class="math inline">\(G\)</span>上对 <span class="math inline">\(p(x,y)\)</span> 的二重积分 <span class="math display">\[P((X, Y) \in G)=\iint_G p(x, y) \mathrm{d} x \mathrm{d} y .\]</span> 2）性质：非负性、正则性。</p><p>3）在计算积分时要注意点、线的面积为 <span class="math inline">\(0\)</span>.</p><hr><p>5.常见多维分布</p><p>1）多维均匀分布</p><p>​ 设 <span class="math inline">\(D\)</span> 为 <span class="math inline">\(\mathbb{R}^n\)</span> 中一个有界区域，其度量(平面的为面积, 空间的为体积等) 为 <span class="math inline">\(S_D\)</span> ，如果多维随机变量 <span class="math inline">\((X_1,X_2,\cdots,X_n)\)</span> 的联合密度函数为<span class="math display">\[p\left(x_1, x_2, \cdots, x_n\right)= \begin{cases}\dfrac{1}{S_D}, &amp;\left(x_1, x_2, \cdots, x_n\right) \in D, \\\\ 0, &amp; \text { 其他,}\end{cases}\]</span> 则称 <span class="math inline">\(\left(X_1, X_2, \cdots,X_n\right)\)</span> 服从 <span class="math inline">\(D\)</span>上的多维均匀分布, 记为 <span class="math inline">\(\left(X_1, X_2,\cdots, X_n\right) \sim U(D)\)</span>.</p><p>2）二元正态分布</p><p>​ 如果二维随机变量 <span class="math inline">\((X,Y)\)</span>的联合密度函数为 <span class="math display">\[p(x, y)=\frac{1}{2 \pi \sigma_1 \sigma_2 \sqrt{1-\rho^2}} \exp\left\{-\frac{1}{2\left(1-\rho^2\right)}\left[\frac{\left(x-\mu_1\right)^2}{\sigma_1^2}-2\rho \frac{\left(x-\mu_1\right)\left(y-\mu_2\right)}{\sigma_1\sigma_2}+\frac{\left(y-\mu_2\right)^2}{\sigma_2^2}\right]\right\}\]</span> 其中<span class="math inline">\(-\infty&lt;x,y&lt;+\infty\)</span></p><p>则称 <span class="math inline">\((X, Y)\)</span> 服从二元正态分布,记为 <span class="math inline">\((X, Y) \sim N\left(\mu_1, \mu_2,\sigma_1^2, \sigma_2^2,\rho\right)\)</span>.其中五个参数的取值范围分别是 <span class="math display">\[-\infty&lt;\mu_1, \mu_2&lt;\infty, \quad \sigma_1, \sigma_2&gt;0,\quad-1 \leqslant \rho \leqslant 1 .\]</span> <span class="math inline">\(\mu_1, \mu_2\)</span> 分别是 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 的均值, <span class="math inline">\(\sigma_1^2, \sigma_2^2\)</span> 分别是 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 的方差, <span class="math inline">\(\rho\)</span> 是 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 的相关系数。</p><p>3）多项分布</p><p>​ 进行 <span class="math inline">\(n\)</span>次独立重复试验，如果每次试验有 <span class="math inline">\(r\)</span>个互不相容的结果： <span class="math inline">\(A_1,A_2,\cdots,A_r\)</span> 之一发生，且每次试验中<span class="math inline">\(A_i\)</span> 发生的概率为 <span class="math inline">\(p_i = P(A_i),i=1,2,\cdots,r.\)</span> 且 <span class="math inline">\(p_1+p_2+\cdots+p_r=1.\)</span> 记 <span class="math inline">\(X_i\)</span> 为 <span class="math inline">\(n\)</span> 次独立重复试验中 <span class="math inline">\(A_i\)</span> 出现的次数，<span class="math inline">\(i=1,2,\cdots,r\)</span> ，则 <span class="math inline">\((X_1,X_2,\cdots,X_r)\)</span> 取值 <span class="math inline">\((n_1,n_2,\cdots,n_r)\)</span> 的概率，即 <span class="math inline">\(A_1\)</span> 出现 <span class="math inline">\(n_1\)</span> 次，<span class="math inline">\(A_2\)</span> 出现 <span class="math inline">\(n_2\)</span> …… <span class="math inline">\(A_r\)</span> 出现 <span class="math inline">\(n_r\)</span> 次的概率为 <span class="math display">\[P\left(X_1=n_1, X_2=n_2, \cdots,X_r=n_r\right)=\frac{n!}{n_{1}!n_{2}!\cdots n_{r}!} p_1^{n_1} p_2^{n_2}\cdots p_r^{n_r},\]</span> 其中 <span class="math inline">\(n=n_1+n_2+ \cdots+n_r.\)</span></p><p>​ 这个联合分布列称为 <span class="math inline">\(r\)</span> 项分布,又称多项分布, 记为 <span class="math inline">\(M\left(n, p_1, p_2,\cdots, p_r\right)\)</span>. 这个概率是 <span class="math inline">\((p_1+p_2+\cdots +p_r)^n\)</span>展开式的一项。</p><p>4）多维超几何分布</p><p>​ 袋中有 <span class="math inline">\(N\)</span> 个球, 其中有 <span class="math inline">\(N_i\)</span> 个 <span class="math inline">\(i\)</span> 号球, <span class="math inline">\(i=1,2, \cdots,r\)</span> ，且 <span class="math inline">\(N=N_1+N_2+\cdots+N_r\)</span>. 从中任意取出 <span class="math inline">\(n(\leqslant N)\)</span> 个, 若记 <span class="math inline">\(X_i\)</span> 为取出的 <span class="math inline">\(n\)</span> 个球中 <span class="math inline">\(i\)</span> 号球的个数， <span class="math inline">\(i=1,2,\cdots,r\)</span> ,则 <span class="math display">\[P\left(X_1=n_1, X_2=n_2, \cdots,X_r=n_r\right)=\dfrac{\displaystyle\binom{N_1}{n_1}\binom{N_2}{n_2}\cdots\binom{N_r}{n_r}}{\displaystyle\binom{N}{n}},\]</span> 其中 <span class="math inline">\(n_1+n_2+\cdots+n_r=n, n_i\leqslant N_i, i=1,2, \cdots, r\)</span>.</p><h3 id="边际分布与随机变量的独立性">3.2 边际分布与随机变量的独立性</h3><p>1.边际分布函数</p><p>​ 设二维随机变量 <span class="math inline">\((X,Y)\)</span>的联合分布函数为 <span class="math inline">\(F(x,y)\)</span> ，则 <span class="math inline">\(X\)</span> 的边际分布函数为 <span class="math display">\[F_X(x)=F(x,\infty)=P(X\leqslant x,y&lt;\infty)\]</span> ​ 相似地， <span class="math inline">\(Y\)</span>的边际分布函数为 <span class="math display">\[F_Y(y)=F(\infty , y)=P(x&lt;\infty, Y\leqslant y)\]</span> ​ 注意：由分布函数可以唯一确定边际分布函数，反之不成立。</p><hr><p>2.边际分布列（对离散随机变量）</p><p>​ 在二维离散随机变量 <span class="math inline">\((X, Y)\)</span>的联合分布列 <span class="math inline">\(\left\{P\left(X=x_i,Y=y_j\right)\right\}\)</span> 中：</p><p>​ <span class="math inline">\(X\)</span> 的边际分布列：对 <span class="math inline">\(j\)</span> 求和所得的分布列，即 <span class="math display">\[\sum_{j=1}^{\infty} P\left(X=x_i,Y=y_j\right)=P\left(X=x_i\right)=\sum_{j=1}^{\infty}p_{ij}, \quad i=1,2,\cdots\]</span> ​ <span class="math inline">\(Y\)</span> 的边际分布列：对 <span class="math inline">\(i\)</span> 求和所得的分布列，即 <span class="math display">\[\sum_{i=1}^{\infty} P\left(X=x_i,Y=y_j\right)=P\left(Y=y_j\right)=\sum_{i=1}^{\infty}p_{ij}, \quad j=1,2,\cdots\]</span> ​ 常以列表格的形式来描述： <span class="math display">\[\begin{array}{c|cccc|c}\hline X /Y &amp; y_1 &amp; \cdots &amp; y_j &amp; \cdots &amp;P\left(Y=y_j\right) \\\hline x_1 &amp; p_{11} &amp; \cdots &amp; p_{i j} &amp; \cdots &amp;\displaystyle\sum_{j=1}^{\infty} p_{1 j} \\\vdots &amp; \vdots &amp; &amp; \vdots &amp; &amp; \vdots \\x_i &amp; p_{i 1} &amp; \cdots &amp; p_{i j} &amp; \cdots &amp;\displaystyle \sum_{j=1}^{\infty} p_{i j} \\\vdots &amp; \vdots &amp; &amp; \vdots &amp; &amp; \vdots \\\hline P\left(X=x_i\right) &amp; \displaystyle\sum_{i=1}^{\infty} p_{i1} &amp; \cdots &amp; \displaystyle\sum_{i=1}^{\infty} p_{i j} &amp;\cdots &amp; 1\end{array}\]</span></p><hr><p>3.边际密度函数（对连续随机变量）</p><p>​ 如果二维连续随机变量 <span class="math inline">\((X, Y)\)</span>的联合密度函数为 <span class="math inline">\(p(x, y)\)</span> ,则 <span class="math display">\[\left\{\begin{array}{l}p_X(x)=\displaystyle \int_{-\infty}^{\infty} p(x, y) d y \\p_Y(y)=\displaystyle \int_{-\infty}^{\infty} p(x, y) d x\end{array}\right.\]</span> ​ <span class="math inline">\(p_X(x)\)</span> 为 <span class="math inline">\(X\)</span> 的边际密度函数，<span class="math inline">\(p_Y(y)\)</span> 为 <span class="math inline">\(Y\)</span> 的边际密度函数。</p><p>​ 对应的边际分布函数为 <span class="math display">\[\left\{\begin{array}{l}F_X(x)=\displaystyle \int_{-\infty}^x\left(\int_{-\infty}^{\infty} f(t,y) d y\right) d t \\F_Y(y)=\displaystyle \int_{-\infty}^y\left(\int_{-\infty}^{\infty} f(x,s) d x\right) d s\end{array}\right.\]</span> ​注意：由联合密度函数求边际密度函数时，要注意积分区域的确定。</p><hr><p>​ 4.随机变量间的独立性</p><p>1）定义：设 <span class="math inline">\(n\)</span> 维随机变量 <span class="math inline">\(\left(X_1, X_2, \cdots, X_n\right)\)</span>的联合分布函数为 <span class="math inline">\(F\left(x_1, x_2, \cdots,x_n\right)\)</span> ，<span class="math inline">\(F_i\left(x_i\right)\)</span> 为 <span class="math inline">\(X_i\)</span> 的边际分布函数。如果对任意 <span class="math inline">\(n\)</span> 个实数 <span class="math inline">\(x_1,x_2,\cdots,x_n\)</span> ，有 <span class="math display">\[F\left(x_1, x_2, \cdots, x_n\right)=\prod_{i=1}^n F_i\left(x_i\right),\]</span> 则称 <span class="math inline">\(X_1,X_2,\cdots,X_n\)</span>相互独立。</p><p>2）在离散场合</p><p>​ 如果对任意 <span class="math inline">\(n\)</span> 个取值 <span class="math inline">\(x_1,x_2,\cdots,x_n\)</span> 有 <span class="math display">\[P\left(X_1=x_1, X_2=x_2, \cdots, X_n=x_n\right)=\prod_{i=1}^nP\left(X_i=x_i\right),\]</span> 则称 <span class="math inline">\(X_1,X_2,\cdots,X_n\)</span>相互独立。</p><p>3）在连续场合</p><p>​ 如果对任意 <span class="math inline">\(n\)</span> 个实数 <span class="math inline">\(x_1,x_2,\cdots,x_n\)</span> 有 <span class="math display">\[p\left(x_1, x_2, \cdots, x_n\right)=\prod_{i=1}^n p_i\left(x_i\right),\]</span> 则称 <span class="math inline">\(X_1,X_2,\cdots,X_n\)</span>相互独立。</p><p>4）特别地，</p><p>​ 对于二维离散随机变量 <span class="math inline">\((X,Y)\)</span> ，若<span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 相互独立，则 <span class="math inline">\(p_{ij}=p_{i\cdot}p_{\cdotj},i,j=1,2,\cdots\)</span></p><p>​ 对于二维连续随机变量 <span class="math inline">\((X,Y)\)</span> ，若<span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 相互独立，则 <span class="math inline">\(F(X,Y) = F_X(x)F_Y(y)\)</span>.</p><p>注意：若随机变量间相互独立，则由边际密度函数可以推出联合分布函数。</p><h3 id="多维随机变量函数的分布">3.3 多维随机变量函数的分布</h3><p>1.多维离散随机变量函数的分布</p><p>1）设 <span class="math inline">\(\left(X_1, X_2, \cdots,X_n\right)\)</span> 为 <span class="math inline">\(n\)</span>维离散随机变量, 则某一函数 <span class="math inline">\(Y=g\left(X_1,X_2, \cdots, X_n\right)\)</span> 是一维离散随机变量，当 <span class="math inline">\(\left(X_1, X_2, \cdots, X_n\right)\)</span>所有可能取值较少时, 可将 <span class="math inline">\(Y\)</span>的取值一一列出，然后再整理合并。</p><p>2）具有可加性的离散随机变量</p><ul><li>二项分布的可加性：设随机变量 <span class="math inline">\(X \sim b(n,p), Y \sim b(m, p)\)</span>, 且 <span class="math inline">\(X\)</span>与 <span class="math inline">\(Y\)</span> 独立，则 <span class="math inline">\(Z=X+Y \sim b(n+m, p)\)</span>.</li><li>泊松分布的可加性：设随机变量 <span class="math inline">\(X \simP\left(\lambda_1\right), Y \sim P\left(\lambda_2\right)\)</span>, 且<span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 独立，则 <span class="math inline">\(Z=X+Y \simP\left(\lambda_1+\lambda_2\right)\)</span>.</li></ul><hr><p>2.多维连续随机变量函数的分布</p><p>​ 设 <span class="math inline">\((X,Y)\)</span>为二维连续随机变量，联合密度函数为 <span class="math inline">\(p(x,y)\)</span>.</p><p>1）<span class="math inline">\(Z=X+Y\)</span> 的分布（卷积公式）<span class="math display">\[p_Z(z)=\int_{-\infty}^{\infty} p(x, z-x)\mathrm{d}x=\int_{-\infty}^{\infty} p(z-y, y) \mathrm{d} y\]</span> ​ 特别地，如果 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 相互独立，则 <span class="math display">\[P_Z(z)=\int_{-\infty}^{\infty} p_X(x) p_Y(z-x) \mathrm{d} x =\int_{-\infty}^{\infty} p_X(z-y) p_Y(y) \mathrm{d} y\]</span> 2）<span class="math inline">\(Z=XY\)</span> 的分布 <span class="math display">\[p_{X Y}(z)=\int_{-\infty}^{\infty} \frac{1}{|x|} p\left(x,\frac{z}{x}\right) d x=\int_{-\infty}^{\infty} \frac{1}{|y|}p\left(\frac{z}{y},y\right) d y\]</span> ​ 特别地，如果 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 相互独立，则 <span class="math display">\[p_{X Y}(z)=\int_{-\infty}^{\infty} \frac{1}{|x|} p_X(x)p_Y\left(\frac{z}{x}\right) d x=\int_{-\infty}^{\infty} \frac{1}{|y|}p_X\left(\frac{z}{y}\right)p_Y(y) d y\]</span> 3）<span class="math inline">\(Z=\dfrac{Y}{X}\)</span> 的分布<span class="math display">\[p_{Y/X}(z)=\int_{-\infty}^{\infty}|x| p(x, x z) d x\]</span> ​ 若 <span class="math inline">\(Z=\dfrac{X}{Y}\)</span> <span class="math display">\[p_{X/Y}(z)=\int_{-\infty}^{\infty}|y| p(z y, y) d y\]</span> 4）具有可加性的连续随机变量</p><ul><li><p>正态分布的可加性：设随机变量 <span class="math inline">\(X \simN\left(\mu_1, \sigma_1^2\right), Y \sim N\left(\mu_2,\sigma_2^2\right)\)</span>, 且 <span class="math inline">\(X\)</span> 与<span class="math inline">\(Y\)</span> 独立，则 <span class="math display">\[  Z=X+Y \sim N\left(  \mu_1+\mu_2, \sigma_1^2+\sigma_2^2\right)  \]</span></p></li><li><p>伽马分布的可加性：设随机变量 <span class="math inline">\(X \sim Ga\left(\alpha_1, \lambda\right), Y \sim G a\left(\alpha_2,\lambda\right)\)</span>, 且 <span class="math inline">\(X\)</span> 与<span class="math inline">\(Y\)</span> 独立，则 <span class="math display">\[  Z=X+Y \sim G a\left(\alpha_1+\alpha_2, \lambda\right)  \]</span></p></li></ul><p>5）变换变量法求解多维随机变量函数的分布</p><p>​ 设二维随机变量 <span class="math inline">\((X,Y)\)</span>的联合密度函数为 <span class="math inline">\(p(x,y)\)</span> ，如果函数<span class="math display">\[\left\{\begin{array}{l}u=g_1(x, y), \\v=g_2(x, y)\end{array}\right.\]</span> ​ 有连续偏导数，并存在唯一的反函数 <span class="math display">\[\left\{\begin{array}{l}x=x(u, v), \\y=y(u, v),\end{array}\right.\]</span> ​ 其变换的雅可比行列式 <span class="math display">\[J=\frac{\partial(x, y)}{\partial(u, v)}=\left|\begin{array}{ll}\dfrac{\partial x}{\partial u} &amp; \dfrac{\partial x}{\partial v} \\\dfrac{\partial y}{\partial u} &amp; \dfrac{\partial y}{\partial v}\end{array}\right|=\left(\frac{\partial(u, v)}{\partial(x,y)}\right)^{-1}= \left( \left| \begin{array}{ll}\dfrac{\partial u}{\partial x} &amp; \dfrac{\partial u}{\partial y} \\\dfrac{\partial v}{\partial x} &amp; \dfrac{\partial v}{\partial y}\end{array} \right\rvert\,\right)^{-1} \neq0 .\]</span> ​ 若 <span class="math display">\[\left\{\begin{array}{l}U=g_1(X, Y), \\V=g_2(X, Y),\end{array}\right.\]</span> ​ 则 <span class="math inline">\((U,V)\)</span>的联合密度函数为 <span class="math display">\[p(u, v)=p(x(u, v), y(u, v))|J| .\]</span></p><hr><p>3.最大值最小值分布</p><p>​ 设 <span class="math inline">\(X_1, X_2, \cdots, X_n\)</span> 是<span class="math inline">\(n\)</span>个相互独立的随机变量，他们的分布函数分别为 <span class="math inline">\(F_{X_i}(x), i=1,2,\cdots,n.\)</span></p><p>1）最大值分布：<span class="math inline">\(Y_1=\max\{X_1,X_2,\cdots,X_n\}\)</span> 的分布函数为 <span class="math display">\[F_{Y_1}(y)=F_{X_1}(y)  F_{X_2}(y)  \cdots  F_{X_n}(y)=\prod_{i=1}^nF_{X_i}(y)\]</span> ​ 特别地，当 <span class="math inline">\(X_1,X_2,\cdots,X_n\)</span> 的分布函数都为 <span class="math inline">\(F(x)\)</span> 密度函数均为 <span class="math inline">\(p(x)\)</span> 时，有 <span class="math display">\[F_{Y_1}(y)=[F(y)]^n \quad p_{Y_1}(y)=n[F(y)]^{n-1} p(y)\]</span> 2）最小值分布：<span class="math inline">\(Y_2=\min\{X_1,X_2,\cdots,X_n\}\)</span> 的分布函数为 <span class="math display">\[F_{Y_2}(y)=1-\left[1-F_{X_1}(y)\right]\left[1-F_{X_2}(y)\right]\cdots\left[1-F_{X_n}(y)\right]=1-\prod_{i=1}^n\left[1-F_{X_i}\left(y\right)\right]\]</span> ​ 特别地，当 <span class="math inline">\(X_1,X_2,\cdots,X_n\)</span> 的分布函数都为 <span class="math inline">\(F(x)\)</span> 密度函数均为 <span class="math inline">\(p(x)\)</span> 时，有 <span class="math display">\[F_{Y_2}(y)=1-[1-F(y)]^n \quad p_{Y_2}(y)=n[1-F(y)]^{n-1} p(y)\]</span></p><h3 id="多维随机变量的特征数">3.4 多维随机变量的特征数</h3><p>1.多维随机变量函数的数学期望</p><p>1）定义：若二维随机变量 <span class="math inline">\((X, Y)\)</span>的分布用联合分布列 <span class="math inline">\(P\left(X=x_i,Y=y_j\right)\)</span> 或用联合密度 <span class="math inline">\(p(x,y)\)</span> 表示，则</p><ul><li><span class="math inline">\(Z=g(X,Y)\)</span> 的数学期望为</li></ul><p><span class="math display">\[E(Z)= \begin{cases}\displaystyle\sum_i \sum_j g\left(x_i, y_j\right)P\left(X=x_i, Y=y_j\right), &amp; \text { 在离散场合, } \\\displaystyle\int_{-\infty}^{\infty} \int_{-\infty}^{\infty} g(x, y)p(x, y) \mathrm{d}x \mathrm{d}y, &amp; \text { 在连续场合. }\end{cases}\]</span></p><p>​ 假设数学期望都存在。</p><ul><li>当 <span class="math inline">\(g(X,Y) = X\)</span> 时，可以得到<span class="math inline">\(X\)</span> 的数学期望：</li></ul><p><span class="math display">\[E(X)=\int_{-\infty}^{\infty} \int_{-\infty}^{\infty} x p(x, y)\mathrm{d} x \mathrm{d} y=\int_{-\infty}^{\infty} x p_X(x) \mathrm{d} x.\]</span></p><p>​ 同理可得 <span class="math inline">\(Y\)</span> 的期望： <span class="math display">\[E(Y)=\int_{-\infty}^{\infty} \int_{-\infty}^{\infty} y p(x, y)\mathrm{d} x \mathrm{d} y=\int_{-\infty}^{\infty} y p_Y(y) \mathrm{d}y .\]</span></p><ul><li>当 <span class="math inline">\(g(X,Y) = (X-E(X))^2\)</span>时，可以得到 <span class="math inline">\(X\)</span> 的方差： <span class="math display">\[  \begin{aligned}  \operatorname{Var}(X) &amp; =E(X-E(X))^2=\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}(x-E(X))^2 p(x, y) \mathrm{d} x \mathrm{d} y \\  &amp; =\int_{-\infty}^{\infty}(x-E(X))^2 p_X(x) \mathrm{d} x .  \end{aligned}  \]</span></li></ul><p>​ 同理可得 <span class="math inline">\(Y\)</span> 的方差： <span class="math display">\[\begin{aligned}\operatorname{Var}(Y) &amp; =E(Y-E(Y))^2=\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}(Y-E(Y))^2 p(x, y) \mathrm{d} x \mathrm{d} y \\&amp; =\int_{-\infty}^{\infty}(Y-E(Y))^2 p_Y(y) \mathrm{d} y .\end{aligned}\]</span></p><ul><li>随机变量的数学期望 <span class="math display">\[  \begin{array}{|c|c|c|}  \hline &amp; \text { 离散型随机变量 } &amp; \text { 连续型随机变量 }\\  \hline \text { 一维随机变量 } &amp; E(X)=\displaystyle\sum_i x_i p_i&amp; E(X)=\displaystyle \int_{-\infty}^{\infty} x f(x) \mathrm{d} x \\  \hline \text { 二维随机变量 } &amp; E(X)=\displaystyle \sum_i \sum_j xp_{i j} &amp; E(X)=\displaystyle\int_{-\infty}^{\infty}\int_{-\infty}^{\infty} x f(x, y) \mathrm{d} x \mathrm{d} y =\int_{-\infty}^{\infty} x p_X(x) \mathrm{d} x\\  &amp; E(Y)=\displaystyle \sum_i \sum_j y p_{i j} &amp;E(Y)=\displaystyle \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} yf(x, y) \mathrm{d} x \mathrm{d} y =\int_{-\infty}^{\infty} y p_Y(y)\mathrm{d} y\\  \hline  \end{array}  \]</span></li></ul><p>​ 随机变量函数的数学期望 <span class="math display">\[\begin{array}{|c|c|c|}\hline &amp; \text { 离散型随机变量 } &amp; \text { 连续型随机变量 } \\\hline \begin{array}{c}\text { 一维随机 } \\\text { 变量 }\end{array} &amp; E[g(X)]=\displaystyle \sum_i g\left(x_i\right) p_i&amp; E[g(X)]=\displaystyle \int_{-\infty}^{\infty} g(x) p(x) \mathrm{d}x \\\hline \begin{array}{c}\text { 二维随机 } \\\text { 变量 }\end{array} &amp; E[g(X, Y)]=\displaystyle \sum_i \sum_j g\left(x_i,y_j\right) p_{i j} &amp; E[g(x, y)]=\displaystyle\int_{-\infty}^{\infty} \int_{-\infty}^{\infty} g(x, y) p(x, y)\mathrm{d} x \mathrm{d} y \\\hline\end{array}\]</span></p><hr><p>2.数学期望与方差的运算性质</p><ul><li><p>设 <span class="math inline">\((X,Y)\)</span>是二维随机变量，则有 <span class="math inline">\(E(X+Y) =E(X)+E(Y).\)</span></p><p>推广：对于 <span class="math inline">\(n\)</span> 维随机变量 <span class="math inline">\((X_1,X_2,\cdots, X_n)\)</span>，则有 <span class="math inline">\(\displaystyle E\left(\sum_{i=1}^n a_iX_i+b\right)=\sum_{i=1}^n a_i E\left(X_i\right)+b.\)</span></p></li><li><p>若随机变量 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 相互独立（或不相关），则有 <span class="math inline">\(E(XY) =E(X)E(Y).\)</span></p><p>推广：若随机变量 <span class="math inline">\(X_1,X_2,\cdots,X_n\)</span> 相互独立，则 <span class="math inline">\(\displaystyle E\left(\prod_{i=1}^nX_i\right)=\prod_{i=1}^n E\left(X_i\right).\)</span></p></li><li><p>若随机变量 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 相互独立（或不相关），则有 $ (XY)=(X)+(Y)$.</p><p>推广：若随机变量 <span class="math inline">\(X_1,X_2,\cdots,X_n\)</span> 相互独立，则 <span class="math inline">\(\displaystyle \operatorname{Var}\left(\sum_{i=1}^na_i X_i+b\right)=\sum_{i=1}^n a_i^2\operatorname{Var}\left(X_i\right).\)</span></p></li></ul><p>​ 对任意的随机变量 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 是： <span class="math display">\[\begin{align}\operatorname{Var}(X \pm Y) &amp;= \operatorname{Var}(X) +\operatorname{Var}(Y) \pm 2 E\left((X-E(X))(Y-E(Y))\right) \\&amp;= \operatorname{Var}(X) + \operatorname{Var}(Y) \pm 2\operatorname{Cov}(X,Y).\end{align}\]</span> ​ 注意：由 <span class="math inline">\(E(XY)=E(X)E(Y)\)</span>和 $ (X Y)=(X)+(Y)$ 都无法推出 <span class="math inline">\(X\)</span> 和<span class="math inline">\(Y\)</span> 相互独立。</p><hr><p>3.协方差</p><p>1）定义：设 <span class="math inline">\((X, Y)\)</span>是一个二维随机变量, 若 <span class="math inline">\(E[(X-E(X))(Y-E(Y))]\)</span>存在，则称此数学期望为 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 的协方差, 或称为 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 的相关 (中心) 矩, 并记为 <span class="math display">\[\operatorname{Cov}(X, Y)=E[(X-E(X))(Y-E(Y))] .\]</span> 特别有 <span class="math inline">\(\operatorname{Cov}(X,X)=\operatorname{Var}(X)\)</span>.</p><p>2）性质</p><ul><li><p><span class="math inline">\(\operatorname{Cov}(X, Y)=E(X Y)-E(X)E(Y)\)</span>.</p></li><li><p>若随机变量 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 相互独立, 则 <span class="math inline">\(\operatorname{Cov}(X, Y)=0\)</span>,反之不然。</p><p>即：独立 $$ 不相关，反之不成立。</p></li><li><p>对任意 <span class="math inline">\(n\)</span> 个随机变量 <span class="math inline">\(X_1,X_2,\cdots,X_n\)</span> 有：<span class="math inline">\(\displaystyle \operatorname{Var}\left(\sum_{i=1}^nX_i\right)=\sum_{i=1}^n \operatorname{Var}\left(X_i\right)+2\sum_{i=1}^n \sum_{j=1}^{i-1} \operatorname{Cov}\left(X_i,X_j\right)\)</span>.</p></li><li><p>协方差 <span class="math inline">\(\operatorname{Cov}(X,Y)\)</span> 的计算与 <span class="math inline">\(X, Y\)</span>的次序无关，即： <span class="math inline">\(\operatorname{Cov}(X,Y)=\operatorname{Cov}(Y, X).\)</span></p></li><li><p>任意随机变量 <span class="math inline">\(X\)</span> 与常数 <span class="math inline">\(a\)</span> 的协方差为零，即：<span class="math inline">\(\operatorname{Cov}(X, a)=0\)</span>.</p></li><li><p>对任意常数 <span class="math inline">\(a, b\)</span> 有： <span class="math inline">\(\operatorname{Cov}(a X, b Y)=a b\operatorname{Cov}(X, Y).\)</span></p></li><li><p>设 <span class="math inline">\(X, Y, Z\)</span>是任意三个随机变量，则：<span class="math inline">\(\operatorname{Cov}(X+Y, Z)=\operatorname{Cov}(X,Z)+\operatorname{Cov}(Y, Z)\)</span>.</p></li><li><p>对任意常数 <span class="math inline">\(a,b,c,d\)</span> 有：<span class="math display">\[  \operatorname{Cov}\left(a X_1+b Y_1, c X_2+d Y_2\right)=a c\operatorname{Cov}\left(X_1, X_2\right)+a d \operatorname{Cov}\left(X_1,Y_2\right)+b c \operatorname{Cov}\left(Y_1, X_2\right)+b d\operatorname{Cov}\left(Y_1, Y_2\right)  \]</span> <span class="math inline">\(ps:\)</span>后5个性质是协方差的线性性质，<span class="math inline">\(\operatorname{Cov}\)</span>运算法则类似于有理式乘法。</p></li></ul><hr><p>4.相关系数</p><p>1）定义：设 <span class="math inline">\((X, Y)\)</span>是一个二维随机变量, 且 <span class="math inline">\(\operatorname{Var}(X)=\sigma_X^2&gt;0,\operatorname{Var}(Y)=\sigma_Y^2&gt;0\)</span>. 则称 <span class="math display">\[\operatorname{Corr}(X, Y)=\frac{\operatorname{Cov}(X,Y)}{\sqrt{\operatorname{Var}(X)}\sqrt{\operatorname{Var}(Y)}}=\frac{\operatorname{Cov}(X, Y)}{\sigma_X\sigma_Y}\]</span> 为 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 的相关系数，记作 <span class="math inline">\(\rho_{XY}.\)</span></p><p>2）性质</p><ul><li>随机变量 <span class="math inline">\(X\)</span> 的标准化为：<span class="math inline">\(X^*=\dfrac{X-E(X)}{\sqrt{\operatorname{Var}(X)}}\)</span>，则有</li></ul><p><span class="math display">\[\operatorname{Cov}\left(X^*, Y^*\right)=\frac{\operatorname{Cov}(X,Y)}{\sigma_X \sigma_Y}=\operatorname{Corr}(X, Y)\]</span></p><ul><li>二维正态分布 <span class="math inline">\(N\left(\mu_1, \mu_2,\sigma_1^2, \sigma_2^2, \rho\right)\)</span> 的相关系数就是 <span class="math inline">\(\rho\)</span> ；若 <span class="math inline">\((X,Y)\)</span>服从二维正态分布，则相互独立和不相关是等价的。</li><li>施瓦茨不等式：对任意二维随机变量 <span class="math inline">\((X,Y)\)</span>, 若 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 的方差部存在, 且记 <span class="math inline">\(\sigma_X^2=\operatorname{Var}(X),\sigma_Y^2=\operatorname{Var}(Y)\)</span>, 则有</li></ul><p><span class="math display">\[[\operatorname{Cov}(X, Y)]^2 \leqslant \sigma_X^2 \sigma_Y^2 .\]</span></p><ul><li><p><span class="math inline">\(-1 \leqslant \operatorname{Corr}(X,Y) \leqslant 1\)</span>, 或 <span class="math inline">\(|\operatorname{Corr}(X, Y)| \leqslant1\)</span>.</p></li><li><p><span class="math inline">\(\operatorname{Corr}(X, Y)= \pm 1\Leftrightarrow Y\)</span> 和 <span class="math inline">\(X\)</span>几乎处处有线性关系，即存在 <span class="math inline">\(a(a \neq 0),b\)</span> 有： $ P(a X+b=Y)=1.$</p></li><li><p>下面 <span class="math inline">\(5\)</span> 个条件等价： <span class="math display">\[  \begin{aligned}  \operatorname{Corr}(X, Y)=0  &amp;\Leftrightarrow X, Y \text { 不相关} \\  &amp;\Leftrightarrow \operatorname{Cov}(X, Y)=0 \\  &amp;\Leftrightarrow E(X Y)=E(X) E(Y) \\  &amp;\Leftrightarrow \operatorname{Var}(X \pmY)=\operatorname{Var}(X)+\operatorname{Var}(Y)  \end{aligned}  \]</span></p></li></ul><p>​ 注意：<span class="math inline">\(X,Y\)</span> 相互独立 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(X,Y\)</span> 不相关，反之则不成立。</p><hr><p>5.协方差矩阵</p><p>定义：<span class="math inline">\(n\)</span> 维随机变量 <span class="math inline">\(\boldsymbol X =\left(X_1, X_2, \cdots,X_n\right)^{\top}\)</span> 的协方差矩阵： <span class="math display">\[\begin{aligned}&amp; E\left[(\boldsymbol X-E(\boldsymbol X))(\boldsymbolX-E(\boldsymbol X))^{\top}\right] \\\\= &amp; \displaystyle  \left(\begin{array}{cccc}\operatorname{Var}\left(X_1\right) &amp; \operatorname{Cov}\left(X_1,X_2\right) &amp; \cdots &amp; \operatorname{Cov}\left(X_1, X_n\right) \\\operatorname{Cov}\left(X_2, X_1\right) &amp;\operatorname{Var}\left(X_2\right) &amp; \cdots &amp;\operatorname{Cov}\left(X_2, X_n\right) \\\vdots &amp; \vdots &amp; &amp; \vdots \\\operatorname{Cov}\left(X_n, X_1\right) &amp;\operatorname{Cov}\left(X_n, X_2\right) &amp; \cdots &amp;\operatorname{Var}\left(X_n\right)\end{array}\right)\end{aligned}\]</span> 性质： <span class="math inline">\(n\)</span>维随机变量协方差矩阵是对称的非负定矩阵。</p><h3 id="条件分布与条件期望">3.5 条件分布与条件期望</h3><p>1.离散随机变量的条件分布</p><p>1）离散随机变量的条件分布列：</p><p>​ 设 <span class="math inline">\((X,Y)\)</span>是二维离散随机变量，对固定的 <span class="math inline">\(Y=y_j\)</span>，若 <span class="math inline">\(P(Y=y_j)=p_{\cdot j}&gt;0\)</span>，则称 <span class="math display">\[p_{i \mid j}=P\left(X=x_i \mid Y=y_j\right)=\frac{P\left(X=x_i,Y=y_j\right)}{P\left(Y=y_j\right)}=\frac{p_{i j}}{p_{\cdot j}}, \quadi=1,2, \cdots\]</span> 为给定 <span class="math inline">\(Y=y_j\)</span> 条件下 <span class="math inline">\(X\)</span> 的条件分布列。</p><p>​ 同理，对一切使 <span class="math inline">\(P\left(X=x_i\right)=p_{i\cdot}&gt;0\)</span> 的<span class="math inline">\(x_i\)</span> ，称 <span class="math display">\[p_{j\mid i}=P\left(Y=y_j \mid X=x_i\right)=\frac{P\left(X=x_i,Y=y_j\right)}{P\left(X=x_i\right)}=\frac{p_{i j}}{p_{i\cdot}}, \quadj=1,2, \cdots\]</span> 为给定 <span class="math inline">\(X=x_i\)</span> 条件下 <span class="math inline">\(Y\)</span> 的条件分布列。</p><p>2）离散随机变量的条件分布函数：</p><p>​ 给定 <span class="math inline">\(Y=y_j\)</span> 条件下 <span class="math inline">\(X\)</span> 的条件分布函数为 <span class="math display">\[F\left(x \mid y_j\right)=\sum_{x_i \leqslant x} P\left(X=x_i \midY=y_j\right)=\sum_{x_i \leqslant x} p_{i \mid j},\]</span> ​ 给定 <span class="math inline">\(X=x_i\)</span> 条件下 <span class="math inline">\(Y\)</span> 的条件分布函数为 <span class="math display">\[F\left(y \mid x_i\right)=\sum_{y_j \leqslant y} P\left(Y=y_j \midX=x_i\right)=\sum_{y_j \leqslant y} p_{j\mid i} .\]</span></p><hr><p>2.连续随机变量的条件分布</p><p>​ 设 <span class="math inline">\((X,Y)\)</span>是二维连续随机变量，联合密度函数为 <span class="math inline">\(p(x,y)\)</span> ，边际密度函数为 <span class="math inline">\(p_X(x),p_Y(y).\)</span></p><p>​ 对一切使 <span class="math inline">\(p_Y(y)&gt;0\)</span> 的 <span class="math inline">\(y\)</span> ，给定 <span class="math inline">\(Y=y\)</span> 条件下 <span class="math inline">\(X\)</span> 的条件分布函数和条件密度函数分别为<span class="math display">\[\begin{aligned}&amp; F(x \mid y)=\int_{-\infty}^x \frac{p(u, y)}{p_Y(y)} \mathrm{d} u,\\&amp; p(x \mid y)=\frac{p(x, y)}{p_Y(y)} .\end{aligned}\]</span> ​ 同理，对一切使 <span class="math inline">\(p_X(x)&gt;0\)</span> 的 <span class="math inline">\(x\)</span>, 给定 <span class="math inline">\(X=x\)</span> 条件下 <span class="math inline">\(Y\)</span> 的条件分布函数和条件密度函数分别为<span class="math display">\[\begin{aligned}&amp; F(y \mid x)=\int_{-\infty}^y \frac{p(x, v)}{p_X(x)} \mathrm{d} v,\\&amp; p(y \mid x)=\frac{p(x, y)}{p_X(x)} .\end{aligned}\]</span></p><hr><p>3.连续场合的全概率公式和贝叶斯公式</p><p>1）<span class="math inline">\(p(x, y)=p_x(x) p(y \mid x)=p_Y(y) p(x\mid y)\)</span> 由边际分布和条件分布 <span class="math inline">\(\Rightarrow\)</span> 联合分布</p><p>2）全概率公式的密度函数形式 <span class="math display">\[\quad\left\{\begin{array}{l}p_Y(y)=\displaystyle \int_{-\infty}^{\infty} p_X(x) p(y \mid x) d x \\p_X(x)=\displaystyle \int_{-\infty}^{\infty} p_Y(y) p(x \mid y) d y\end{array}\right.\quad\]</span> 3）贝叶斯公式的密度函数形式 <span class="math display">\[\left\{\begin{array}{l}p(x \mid y)=\dfrac{\displaystyle p_X(x) p(y \mid x)}{\displaystyle\int_{-\infty}^{\infty} p_X(x) p (y\mid x) d x} \\p(y \mid x)=\dfrac{\displaystyle p_Y(y) p(x \mid y)}{\displaystyle\int_{-\infty}^{\infty} p_Y(y) p(x \mid y) d y}\end{array}\right.\]</span></p><hr><p>4.条件数学期望</p><p>1）定义：条件分布的数学期望（若期望存在）称为条件期望，定义如下：<span class="math display">\[E(X \mid Y=y)= \begin{cases}\displaystyle \sum_i x_i P\left(X=x_i \midY=y\right), &amp; (X, Y) \text { 为二维离散随机变量, } \\ \displaystyle\int_{-\infty}^{\infty} x p(x \mid y) \mathrm{d} x, &amp; (X, Y) \text {为二维连续随机变量. }\end{cases}\]</span></p><p><span class="math display">\[E(Y \mid X=x)= \begin{cases}\displaystyle \sum_j y_j P\left(Y=y_j \midX=x\right), &amp; (X, Y) \text { 为二维离散随机变量, } \\ \displaystyle\int_{-\infty}^{\infty} y p(y \mid x) \mathrm{d} y, &amp; (X, Y) \text {为二维连续随机变量. }\end{cases}\]</span></p><p>​ 性质：</p><ul><li><span class="math inline">\(E\left(a_1 X_1+a_2 X_2 \midY=y\right)=a_1 E\left(X_1 \mid Y=y\right)+a_2 E\left(X_2 \midY=y\right)\)</span></li><li><span class="math inline">\(E[h(Y) g(X) \mid Y]=h(Y) E[g(X) \midY]\)</span></li><li><span class="math inline">\(X,Y\)</span> 独立时, <span class="math inline">\(E[g(X) \mid Y]=E[g(X)]\)</span></li></ul><p>注意：条件期望 <span class="math inline">\(E(X \mid Y=y)\)</span> 是<span class="math inline">\(y\)</span> 的函数。</p><p>2）重期望公式：设 <span class="math inline">\((X,Y)\)</span>是二维随机变量，且 <span class="math inline">\(E(X)\)</span>存在，则：<span class="math inline">\(E(X)=E(E(X\mid Y)).\)</span></p><p>​ 假如求一个取值范围很大的随机变量 <span class="math inline">\(X\)</span> 的期望 <span class="math inline">\(E(X)\)</span> ，可以先找一个与 <span class="math inline">\(X\)</span> 有关的变量 <span class="math inline">\(Y\)</span>，用 <span class="math inline">\(Y\)</span>的不同取值把大范围划分成小范圈，先在每个小范围上求 <span class="math inline">\(X\)</span>的期望。再对所有小范围的期望求期望，即为大范围上 <span class="math inline">\(X\)</span> 的期望 <span class="math inline">\(E(X).\)</span></p><p>​ 具体使用： <span class="math display">\[\begin{cases}\text { 若Y为离散随机变量， } E(X)=\displaystyle \sum_jE\left(X \mid Y=y_j\right) P\left(Y=y_j\right) \\ \text {若Y为连续随机变量， } E(X)=\displaystyle \int_{-\infty}^{\infty} E(X\mid Y=y) p_Y(y) d y\end{cases}\]</span> 3）随机个随机变量和的数学期望</p><p>​ 设 <span class="math inline">\(X_1, X_2, \cdots\)</span>为一列独立同分布的随机变量,，随机变量 <span class="math inline">\(N\)</span> 只取正整数值， 且 <span class="math inline">\(N\)</span> 与 <span class="math inline">\(\left\{X_n\right\}\)</span> 独立，则 <span class="math display">\[E\left(\sum_{i=1}^N X_i\right)=E\left(X_1\right) E(N) .\]</span></p><h3 id="附具有可加性分布的汇总表">附：具有可加性分布的汇总表</h3><p>假设下表中随机变量 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 相互独立</p><p><span class="math display">\[\begin{array}{|c|c|c|c|}\hline \text { 具有可加性的分布 } &amp; X \text { 服从的分布 } &amp; Y\text { 服从的分布 } &amp; X+Y \text { 服从的分布 } \\\hline \text { 二项分布 } B(n, p) &amp; X \sim B(n, p) &amp; Y \sim B(m,p) &amp; X+Y \sim B(n+m, p) \\\hline \text { 泊松分布 } P(\lambda) &amp; X \simP\left(\lambda_1\right) &amp; Y \sim P\left(\lambda_2\right) &amp; X+Y\sim P\left(\lambda_1+\lambda_2\right) \\\hline \text { 正态分布 } N\left(\mu, \sigma^2\right) &amp; X \simN\left(\mu_1, \sigma_1^2\right) &amp; Y \sim N\left(\mu_2,\sigma_2^2\right) &amp; X+Y \sim N\left(\mu_1+\mu_2,\sigma_1^2+\sigma_2^2\right) \\\hline \text { 伽马分布 } G a(\alpha, \lambda) &amp; X \sim Ga\left(\alpha_1, \lambda\right) &amp; Y \sim G a\left(\alpha_2,\lambda\right) &amp; X+Y \sim G a\left(\alpha_1+\alpha_2, \lambda\right)\\\hline\end{array}\]</span></p><p><span class="math inline">\(ps:\)</span>其他还具有可加性的分布还有：卡方分布、负二项分布、柯西分布等。</p><h2 id="第四章-大数定律与中心极限定理">第四章大数定律与中心极限定理</h2><h3 id="概率母函数">4.0 概率母函数</h3><p>1.母函数的定义：</p><p>​ 若随机变量 <span class="math inline">\(X\)</span>取非负整数值，其分布列为 <span class="math display">\[\begin{array}{c|cccc}X &amp; 0 &amp; 1 &amp; 2 &amp; \cdots \\\hline P &amp; p_0 &amp; p_1 &amp; p_2 &amp; \cdots\end{array}\]</span> ​ 则 <span class="math inline">\(\displaystyleg(s)=E\left(s^X\right)=\sum_{k=0}^{\infty} p_k s^k, s \in[-1,1]\)</span>称为 <span class="math inline">\(X\)</span> 的概率母函数。</p><p>​ 可得：<span class="math inline">\(\displaystyleg(1)=\sum_{k=0}^{\infty} p_k=1.\)</span></p><hr><p>2.母函数的性质</p><ul><li>概率分布与母函数是一一对应的，即</li></ul><p><span class="math display">\[p\{x=k\}=\dfrac{1}{k!} g^{(k)}(0), k=0,1,2, \cdots\]</span></p><ul><li><p><span class="math inline">\(\left\{\begin{array}{l}\text { 当 X期望存在时， } \displaystyle E(X)=\sum_{k=1}^{\infty} kp_k=g^{\prime}(1) \\ \text { 当 X 方差存在时， }\operatorname{Var}(X)=g^{\prime\prime}(1)+g^{\prime}(1)-\left[g^{\prime}(1)\right]^2\end{array}\right.\)</span></p></li><li><p>若随机变量 <span class="math inline">\(X_1,X_2,\cdots,X_n\)</span>相互独立，其母函数分别为 <span class="math inline">\(g_1(s),g_2(s),\cdots ,g_n(s)\)</span> 则 <span class="math inline">\(X_1+X_2+\cdots+X_n\)</span> 的母函数为：</p></li></ul><p><span class="math display">\[g(s)=g_1(s) g_2(s) \cdots g_n(s)\]</span></p><ul><li><p>随机个独立同分布随机变量和的母函数：</p><p>​ 若 <span class="math inline">\(X_1, X_2, \cdots, X_n,\cdots\)</span> 为一列相互独立具有相同概率分布的整值随机变量，<span class="math inline">\(P\left\{X_i=j\right\}=f_j\)</span>, 其母函数为:<span class="math display">\[  \displaystyle F(s)=\sum_{k=0}^{\infty} f_k s^k,  \]</span> ​ 随机变量 <span class="math inline">\(v\)</span>是取正整数值的，且 <span class="math inline">\(P\{v=n\}=g_n\)</span>，其母函数为： <span class="math display">\[  G(s)=\sum_{k=0}^{\infty} g_k s^k .  \]</span></p></li></ul><p>​ ①若 <span class="math inline">\(X_n\)</span> 与 <span class="math inline">\(v\)</span> 独立，则 <span class="math inline">\(\eta=X_1+X_2+\cdots+X_v\)</span> 的母函数为 <span class="math display">\[H(s)=G[F(s)].\]</span> ​ ②若 <span class="math inline">\(E\left(X_n\right)\)</span> 与<span class="math inline">\(E(v)\)</span> 都存在，则 <span class="math display">\[E(\eta)=E\left(X_n\right) E(\nu).\]</span> ​ <span class="math inline">\(ps:\)</span> ② 与 <span class="math inline">\(\S3.5\)</span>中随机个随机变量和的数学期望相对应。</p><h3 id="随机变量序列的两种收敛性">4.1 随机变量序列的两种收敛性</h3><p>1.依概率收敛</p><p>​ 1）定义：设 <span class="math inline">\(\{X_n\}\)</span>为一随机变量序列， <span class="math inline">\(X\)</span>为一随机变量，如果对任意的 <span class="math inline">\(\varepsilon&gt;0\)</span>, 有 <span class="math display">\[P\left(\left|X_n-X\right| \geqslant \varepsilon\right) \rightarrow 0(n\rightarrow \infty),\]</span> 则称序列 <span class="math inline">\(\{X_n\}\)</span>依概率收敛于 <span class="math inline">\(X\)</span> ，记作 <span class="math inline">\(X_n \xrightarrow{P} X\)</span>.</p><p>​ 特别地，当 <span class="math inline">\(X\)</span> 为退化分布时，即<span class="math inline">\(P(X=c)=1\)</span> ，则称序列 <span class="math inline">\(\left\{X_n\right\}\)</span> 依概率收敛于 <span class="math inline">\(c\)</span>, 即 <span class="math inline">\(X_n\xrightarrow{P} c\)</span>.</p><p>​ 2）定义：如果 <span class="math inline">\(P\{\omega:\displaystyle\lim _{n \rightarrow \infty} X_n(\omega)=X(\omega)\}=1\)</span>,则称序列 <span class="math inline">\(\{X_n\}\)</span>以概率1（几乎处处收敛）于 <span class="math inline">\(X\)</span> ，记作<span class="math inline">\(X_n\xrightarrow{a.s.}X.\)</span></p><p>​ 3）设 <span class="math inline">\(\left\{X_n\right\},\left\{Y_n\right\}\)</span>是两个随机变量序列， <span class="math inline">\(a, b\)</span>是两个常数。如果：<span class="math inline">\(X_n \xrightarrow{P} a,\quad Y_n \xrightarrow{P} b\)</span> ，则： <span class="math display">\[\begin{aligned}&amp; X_n \pm Y_n \xrightarrow{P} a \pm b \\&amp; X_n \times Y_n \xrightarrow{P} a \times b  \\&amp; X_n ÷ Y_n \xrightarrow{P} a ÷ b(b \neq 0) .\end{aligned}\]</span></p><hr><p>2.依分布收敛</p><p>1）定义：设随机变量 <span class="math inline">\(X, X_1, X_2,\cdots\)</span> 的分布函数分别为 <span class="math inline">\(F(x),F_1(x), F_2(x), \cdots\)</span>. 若对 <span class="math inline">\(F(x)\)</span> 的任一连续点 <span class="math inline">\(x\)</span>, 都有 <span class="math display">\[\lim _{n \rightarrow \infty} F_n(x)=F(x),\]</span> 则称 <span class="math inline">\(\left\{F_n(x)\}\right.\)</span> 弱收敛于 <span class="math inline">\(F(x)\)</span>，记作 <span class="math inline">\(F_n(x) \xrightarrow{W} F(x)\)</span>.也称相应的随机变量序列 <span class="math inline">\(\left\{X_n\right\}\)</span> 按分布收敛于 <span class="math inline">\(X\)</span>, 记作 <span class="math inline">\(X_n\xrightarrow{L} X\)</span>.</p><p>2）<span class="math inline">\(X_n \xrightarrow{a.s.} X \RightarrowX_n \xrightarrow{P} X \Rightarrow X_n \xrightarrow{L} X\)</span></p><h3 id="特征函数">4.2 特征函数</h3><p>1.特征函数的定义：设 <span class="math inline">\(X\)</span>是一个随机变量，称 <span class="math display">\[\varphi(t)=E\left(\mathrm{e}^{itX}\right)=E(\cos tX)+iE(\sin tX),\quad-\infty&lt;t&lt;\infty,\]</span> ​ 当离散随机变量 <span class="math inline">\(X\)</span>的分布列为 <span class="math inline">\(p_k=P\left(X=x_k\right), k=1,2,\cdots\)</span>, 则 <span class="math inline">\(X\)</span> 的特征函数为<span class="math display">\[\varphi(t)=\sum_{k=1}^{\infty} \mathrm{e}^{i t x_k} p_k,\quad-\infty&lt;t&lt;\infty .\]</span> ​ 当连续随机变量 <span class="math inline">\(X\)</span>的密度函数为 <span class="math inline">\(p(x)\)</span>, 则 <span class="math inline">\(X\)</span> 的特征函数为 <span class="math display">\[\varphi(t)=\int_{-\infty}^{\infty} \mathrm{e}^{itx} p(x) \mathrm{d} x,\quad-\infty&lt;t&lt;\infty .\]</span></p><hr><p>2.特征函数唯一确定分布函数</p><p>1）逆转公式：设 <span class="math inline">\(F(x)\)</span> 和 <span class="math inline">\(\varphi(t)\)</span> 分别为随机变量 <span class="math inline">\(X\)</span> 的分布函数和特征函数，则对 <span class="math inline">\(F(x)\)</span> 的任意两个连续点 <span class="math inline">\(a&lt;b\)</span>, 有 <span class="math display">\[F(b)-F(a)=\lim _{T \rightarrow \infty} \frac{1}{2 \pi} \int_{-T}^T\frac{e^{-i t a}-e^{-i t b}}{i t} \varphi(t) d t\]</span> 2）唯一性定理：随机变量的分布函数由其特征函数唯一确定。</p><p>3）若 <span class="math inline">\(X\)</span>为连续随机变量，其密度函数为 <span class="math inline">\(p(x)\)</span>,特征函数为 <span class="math inline">\(\varphi(t)\)</span>. 如果 <span class="math inline">\(\displaystyle \int_{-\infty}^{\infty}|\varphi(t)|\mathrm{d} t&lt;\infty\)</span>, 则 <span class="math display">\[p(x)=\frac{1}{2 \pi} \int_{-\infty}^{\infty} \mathrm{e}^{-i t x}\varphi(t) \mathrm{d} t .\]</span></p><p><span class="math display">\[\begin{cases}\varphi(t)=\displaystyle\int_{-\infty}^{\infty} e^{i t x}p(x) d x &amp; \text { 特征函数是密度函数的 Fourier 变换 } \\p(x)=\displaystyle \frac{1}{2 \pi} \int_{-\infty}^{\infty} e^{-i t x}\varphi(t) d t &amp; \text { 密度函数是特正函数的 Fourier逆变换}\end{cases}\]</span></p><hr><p>3.特征函数的性质</p><p>1）从函数的角度：</p><ul><li><span class="math inline">\(|\varphi(t)| \leqslant\varphi(0)=1\)</span>.</li><li><span class="math inline">\(\varphi(-t)=\overline{\varphi(t)}\)</span>, 其中<span class="math inline">\(\overline{\varphi(t)}\)</span> 表示 <span class="math inline">\(\varphi(t)\)</span> 的共轭.</li><li>若 <span class="math inline">\(Y=a X+b\)</span>, 其中 <span class="math inline">\(a, b\)</span> 是常数, 则 <span class="math inline">\(\varphi_Y(t)=\mathrm{e}^{\mathrm{i} b t}\varphi_X(a t)\)</span>.</li><li><span class="math inline">\(\varphi\)</span> (t) 在 <span class="math inline">\((-\infty, \infty)\)</span> 上一致连续.</li><li>非负定性：随机变量 <span class="math inline">\(X\)</span> 的特征函数<span class="math inline">\(\varphi(t)\)</span>是非负定的，即对任意正整数 <span class="math inline">\(n\)</span> 及<span class="math inline">\(n\)</span> 个实数 <span class="math inline">\(t_1, t_2, \cdots, t_n\)</span> 和 <span class="math inline">\(n\)</span> 个复数 <span class="math inline">\(z_1,z_2, \cdots, z_n\)</span>, 有 <span class="math inline">\(\displaystyle\sum_{k=1}^n \sum_{j=1}^n \varphi\left(t_k-t_j\right) z_k \overline{z_j}\geqslant 0\)</span>.</li></ul><p>2）利用特征函数求随机变量的矩</p><ul><li>若 <span class="math inline">\(E\left(X^n\right)\)</span> 存在, 则<span class="math inline">\(X\)</span> 的特征函数 <span class="math inline">\(\varphi(t)\)</span> 可 <span class="math inline">\(n\)</span> 次求导, 且对 <span class="math inline">\(1 \leqslant k \leqslant n\)</span>, 有</li></ul><p><span class="math display">\[\varphi^{(k)}(0)=i^k E\left(X^k\right) .\]</span></p><ul><li>若 <span class="math inline">\(E(X^n)\)</span> 存在，则 <span class="math inline">\(X\)</span> 的特征函数可以展开成</li></ul><p><span class="math display">\[\varphi(t)=1+(i t) E(X)+\frac{(i t)^2}{2!}E\left(X^2\right)+\cdots+\frac{(i t)^n}{n!} E\left(X^n\right)+o(t) .\]</span></p><ul><li><span class="math inline">\(E(X)=\dfrac{\varphi^{\prime}(0)}{i}\quad \operatorname{Var}(X)=-\varphi^{\prime\prime}(0)+\left(\varphi^{\prime}(0)\right)^2 .\)</span></li></ul><p>3）<span class="math inline">\(n\)</span>个独立随机变量和的特征函数</p><ul><li>若随机变量 <span class="math inline">\(X_1, X_2, \cdots,X_n\)</span> 相互独立，其特征函数分别为 <span class="math inline">\(\varphi_i(t)\)</span> ，则 <span class="math inline">\(X_1+X_2+\cdots+X_n\)</span> 的特征函数为:</li></ul><p><span class="math display">\[\varphi(t)=\varphi_1(t) \varphi_2(t) \cdots \varphi_n(t)\]</span></p><p>​ <span class="math inline">\(ps:\)</span>可以利用这个性质证明一些分布函数的可加性。</p><hr><p>4.特征函数的连续性定理：分布函数序列 <span class="math inline">\(\left\{F_n(x)\right\}\)</span> 弱收敛于分布函数<span class="math inline">\(F(x)\)</span> 的充要条件是 <span class="math inline">\(\left\{F_n(x)\right\}\)</span> 的特征函数序列<span class="math inline">\(\left\{\varphi_n(t)\right\}\)</span> 收敛于<span class="math inline">\(F(x)\)</span> 的特征函数 <span class="math inline">\(\varphi(t)\)</span>.</p><h3 id="大数定律">4.3 大数定律</h3><ul><li>大数定律的一般形式：设有一随机变量序列 <span class="math inline">\(\{X_n\}\)</span> ，若满足</li></ul><p><span class="math display">\[\frac{1}{n} \sum_{i=1}^n X_i \xrightarrow{P} \frac{1}{n} \sum_{i=1}^nE\left[X_i\right],\]</span></p><p>​ 或者说，对任意 <span class="math inline">\(\varepsilon&gt;0\)</span>有 <span class="math display">\[\lim _{n \rightarrow \infty} P\left(\left|\frac{1}{n} \sum_{i=1}^nX_i-\frac{1}{n} \sum_{i=1}^nE\left(X_i\right)\right|&lt;\varepsilon\right)=1 .\]</span> 则称随机变量序列 <span class="math inline">\(\{X_n\}\)</span>服从大数定律。</p><ul><li>伯努利大数定律：设 <span class="math inline">\(S_n\)</span> 为 <span class="math inline">\(n\)</span> 重伯努利试验中事件 <span class="math inline">\(A\)</span> 发生的次数， <span class="math inline">\(p\)</span> 为每次试验中 <span class="math inline">\(A\)</span> 出现的概率，则对任意的 <span class="math inline">\(\varepsilon&gt;0\)</span>, 有</li></ul><p><span class="math display">\[\lim _{n \rightarrow \infty}P\left(\left|\frac{S_n}{n}-p\right|&lt;\varepsilon\right)=1\]</span></p><p>​ 或者：设随机变量序列 <span class="math inline">\(\{X_n\}\simB(n,p)\)</span> ，则对任意的 <span class="math inline">\(\varepsilon&gt;0\)</span> 有 <span class="math display">\[\lim _{n \rightarrow \infty}P\left(\left|\frac{X_n}{n}-p\right|&lt;\varepsilon\right)=1\]</span> ​ 即：<span class="math inline">\(\dfrac{X_n}{n}\left(\dfrac{S_n}{n}\right)\xrightarrow{P}p.\)</span></p><ul><li>切比雪夫大数定律：设随机变量序列 <span class="math inline">\(\left\{X_n\right\}\)</span> 相互独立， 若每个<span class="math inline">\(X_i\)</span> 的方差存在且有共同的上界，即<span class="math inline">\(\operatorname{Var}\left(X_i\right) \leqslantc, i=1,2, \cdots\)</span>,</li></ul><p>则对任意的 <span class="math inline">\(\varepsilon&gt;0\)</span> 有<span class="math display">\[\lim _{n \rightarrow \infty} P\left(\left|\frac{1}{n} \sum_{i=1}^nX_i-\frac{1}{n} \sum_{i=1}^nE\left(X_i\right)\right|&lt;\varepsilon\right)=1 .\]</span></p><ul><li>马尔可夫大数定律：若随机变量序列 <span class="math inline">\(\{X_n\}\)</span> 满足</li></ul><p><span class="math display">\[\frac{1}{n^2} \operatorname{Var}\left(\sum_{i=1}^n X_i\right)\rightarrow 0, \quad n \rightarrow \infty\]</span></p><p>则称 <span class="math inline">\(\{X_n\}\)</span>服从大数定律，即<span class="math inline">\(\displaystyle \lim _{n\rightarrow \infty} P\left(\left|\frac{1}{n} \sum_{i=1}^nX_i-\frac{1}{n} \sum_{i=1}^nE\left(X_i\right)\right|&lt;\varepsilon\right)=1.\)</span></p><ul><li>辛钦大数定律：设随机变量序列 <span class="math inline">\(\left\{X_n\right\}\)</span>独立同分布，若每个随机变量 <span class="math inline">\(X_i\)</span>的数学期望都存在，则称 <span class="math inline">\(\{X_n\}\)</span>服从大数定律，即</li></ul><p><span class="math inline">\(\displaystyle \lim _{n \rightarrow\infty} P\left(\left|\frac{1}{n} \sum_{i=1}^n X_i-\frac{1}{n}\sum_{i=1}^n E\left(X_i\right)\right|&lt;\varepsilon\right)=1.\)</span>若 <span class="math inline">\(E(X_i)=\mu\)</span>，则 <span class="math inline">\(\overline{X}\xrightarrow{P}\mu\)</span> 其中 <span class="math inline">\(\displaystyle\overline{X}=\frac{1}{n}\sum_{i=1}^nX_i.\)</span></p><h3 id="中心极限定理">4.4 中心极限定理</h3><ul><li>林德伯格-莱维中心极限定理（独立同分布的中心极限定理）</li></ul><p>​ 设 <span class="math inline">\(\left\{X_n\right\}\)</span>是独立同分布的随机变量序列，且 <span class="math inline">\(E\left(X_i\right)=\mu,\operatorname{Var}\left(X_i\right)=\sigma^2&gt;0\)</span> 存在，若记<span class="math display">\[Y_n^{*}=\dfrac{X_1+X_2+\cdots+X_n-n \mu}{\sigma \sqrt{n}}\]</span> ​ 则对任意实数 <span class="math inline">\(y\)</span> 有 <span class="math display">\[\lim _{n \rightarrow \infty} P\left(Y_n^* \leqslanty\right)=\Phi(y)=\frac{1}{\sqrt{2 \pi}} \int_{-\infty}^y\mathrm{e}^{-\frac{t^2}{2}} \mathrm{~d} t .\]</span> ​ 当 <span class="math inline">\(n\)</span> 充分大时，有：<span class="math display">\[\left\{\begin{array}{c}\dfrac{\displaystyle\sum_{i=1}^n X_i-n \mu}{\sigma \sqrt{n}}\stackrel{\text { 近似 }}{\sim} N(0,1) \\\displaystyle\sum_{i=1}^n X_i \stackrel{\text { 近似 }}{\sim} N\left(n\mu, n \sigma^2\right) \\\displaystyle\frac{1}{n} \sum_{i=1}^n X_i \stackrel{\text { 近似}}{\sim} N\left(\mu, \frac{\sigma^2}{n}\right)\end{array}\right.\]</span></p><ul><li>棣莫佛-拉普拉斯中心极限定理（二项分布的正态近似）</li></ul><p>​ 设 <span class="math inline">\(n\)</span> 重伯努利试验中，事件 <span class="math inline">\(A\)</span> 在每次试验中出现的概率为 <span class="math inline">\(p(0&lt;p&lt;1)\)</span>, 记 <span class="math inline">\(S_n\)</span> 为 <span class="math inline">\(n\)</span> 次试验中事件 <span class="math inline">\(A\)</span> 出现的次数，且记 <span class="math display">\[Y_n^*=\dfrac{S_n-n p}{\sqrt{n p (1-p)}} .\]</span> ​ 则对任意实数 <span class="math inline">\(y\)</span> 有 <span class="math display">\[\lim _{n \rightarrow \infty} P\left(Y_n^* \leqslanty\right)=\Phi(y)=\frac{1}{\sqrt{2 \pi}} \int_{-\infty}^y\mathrm{e}^{-\frac{t^2}{2}} \mathrm{~d} t .\]</span></p><ul><li>林德伯格中心极限定理（独立不同分布下的中心极限定理）</li></ul><p>​ 设随机变量序列 <span class="math inline">\(X_1, X_2, \cdotsX_n\)</span> 相互独立，且具有有限的期望和方差: <span class="math inline">\(E\left(X_i\right)=\mu_i ,\operatorname{Var}\left(X_i\right)=\sigma_i^2 ， i=1,2,\cdots\)</span></p><p>​ 记 <span class="math inline">\(\displaystyleB_n^2=\operatorname{Var}\left(X_1+X_2+\cdots+X_n\right)=\sum_{i=1}^n\sigma_i^2, B_n=\sqrt{\sum_{i=1}^n \sigma_i^2},\)</span></p><p>​ 则中心极限定理：对任意的 <span class="math inline">\(x\)</span><span class="math display">\[\lim _{n \rightarrow \infty} P\left(\frac{1}{B_n}\sum_{i=1}^n\left(x_i-\mu_i\right) \leq x\right)=\Phi(x)\]</span> ​ 成立的充分必要条件是林德伯格条件成立，即对任意的 <span class="math inline">\(\tau&gt;0\)</span> 有 <span class="math display">\[\lim _{n \rightarrow \infty} \frac{1}{\tau^2 B_n^2} \sum_{i=1}^n\int_{\left|x-\mu_i\right|&gt;\tau B_n}\left(x-\mu_i\right)^2 p_i(x)\mathrm{d} x=0.\]</span></p><ul><li>李雅普诺夫中心极限定理（林德伯格中心极限定理的推论）</li></ul><p>​ 设随机变量序列 <span class="math inline">\(X_1, X_2, \cdotsX_n\)</span> 相互独立，且具有有限的期望和方差: <span class="math inline">\(E\left(X_i\right)=\mu_i ,\operatorname{Var}\left(X_i\right)=\sigma_i^2 ， i=1,2, \cdots\)</span>，若存在 <span class="math inline">\(\delta&gt;0\)</span> ，满足 <span class="math display">\[\lim _{n \rightarrow \infty} \frac{1}{B_n^{2+\delta}} \sum_{i=1}^nE\left(\left|X_i-\mu_i\right|^{2+\delta}\right)=0 \text {, }\]</span> ​ 则对任意的 <span class="math inline">\(x\)</span> 有 <span class="math display">\[\lim _{n \rightarrow \infty} P\left(\frac{1}{B_n}\sum_{i=1}^n\left(X_i-\mu_i\right) \leqslantx\right)=\Phi(x)=\frac{1}{\sqrt{2 \pi}} \int_{-\infty}^xe^{-\frac{t^2}{2}} d t.\]</span></p><h3 id="附常用分布的概率母函数表">附：常用分布的概率母函数表</h3><p><span class="math display">\[\begin{array}{c|c|c}\hline \text { 分 布 } &amp; \text { 分布列 } p_k  &amp; \text {概率母函数 } g(s) \\\hline \begin{array}{l}\text { 二项分布 } \\b(n, p)\end{array} &amp; p_k=\displaystyle \binom{n}{k} p^k q^{n-k}, \quadk=0,1, \cdots, n &amp; (ps+q)^n\\\hline \begin{array}{c}\text { 泊松分布 } \\P(\lambda)\end{array} &amp; p_k=\dfrac{\lambda^k}{k!} \mathrm{e}^{-\lambda}, \quadk=0,1, \cdots &amp; \mathrm{e}^{\lambda(s-1)}\\\hline \begin{array}{c}\text { 几何分布 } \\Ge(p)\end{array} &amp; p_k=q^{k-1}p, \quad k=0,1, \cdots &amp;\dfrac{ps}{1-qs}\quad (q=1-p) \\\hline\end{array}\]</span></p><h3 id="附常用分布的特征函数表">附：常用分布的特征函数表</h3><p><span class="math display">\[\begin{array}{c|c|c}\hline \text { 分 布 } &amp; \text { 分布列 } p_k \text { 或分布密度 }p(x) &amp; \text { 特征函数 } \varphi(t) \\\hline \begin{array}{l}\text { 二项分布 } \\b(n, p)\end{array} &amp; p_k=\displaystyle \binom{n}{k} p^k q^{n-k}, \quadk=0,1, \cdots, n &amp; \left(p \mathrm{e}^{it}+q\right)^n \quad(q=1-p)\\\hline \begin{array}{c}\text { 泊松分布 } \\P(\lambda)\end{array} &amp; p_k=\dfrac{\lambda^k}{k!} \mathrm{e}^{-\lambda}, \quadk=0,1, \cdots &amp; e^{\lambda\left(e^{i t}-1\right)} \\\hline \begin{array}{l}\text { 正态分布 } \\N\left(\mu, \sigma^2\right)\end{array} &amp; p(x)=\dfrac{1}{\sqrt{2 \pi} \sigma} \exp\left\{-\dfrac{(x-\mu)^2}{2 \sigma^2}\right\} &amp; \exp \left\{i \mut-\dfrac{\sigma^2 t^2}{2}\right\} \\\hline \begin{array}{c}\text { 指数分布 } \\Exp(\lambda)\end{array} &amp; p(x)=\lambda \mathrm{e}^{-\lambda x}, \quad x\geqslant 0 &amp; \left(1-\dfrac{\mathrm{i} t}{\lambda}\right)^{-1} \\\hline \begin{array}{c}\text { 伽马分布 } \\Ga(\alpha,\beta)\end{array} &amp; p(x)=\dfrac{\lambda^\alpha}{\Gamma(\alpha)}x^{\alpha-1} \mathrm{e}^{-\lambda x}, \quad x \geqslant 0 &amp;\left(1-\dfrac{\mathrm{i} t}{\beta}\right)^{-\alpha} \\\hline\end{array}\]</span></p><h3 id="附大数定律和中心极限定理的条件表">附：大数定律和中心极限定理的条件表</h3><p><span class="math display">\[\begin{array}{|c|c|}\hline \text { 定理名称 } &amp; 满足定理随机变量序列需要的条件 \\\hline 伯努利大数定律 &amp; n重伯努利试验 \\\hline 切比雪夫大数定律 &amp; 随机变量序列相互独立且 \displaystyle\operatorname{Var}(X_i)\leqslant c,i=1,2,\cdots \\\hline 马尔可夫大数定律 &amp; 任意随机变量序列,只要:\displaystyle\frac{1}{n^2} \operatorname{Var}\left(\sum_{i=1}^n X_i\right)\rightarrow 0, \quad n \rightarrow \infty \\\hline 辛钦大数定律 &amp; 随机变量序列独立同分布且E(X_i)=\mu(i=1,2,\cdots)存在 \\\hline 林德伯格-莱维中心极限定理 &amp; 随机变量序列独立同分布\\\hline 棣莫佛-拉普拉斯中心极限定理 &amp; n重伯努利试验 \\\hline 林德伯格中心极限定理 &amp; \begin{array}{c}随机变量序列相互独立且具有有限的数学期望和方差,\\E(X_i)=\mu_i,\operatorname{Var}(X_i)=\sigma_i^2,i=1,2,\cdots  \\满足林德伯格条件:对任意的\tau&gt;0\\有\displaystyle\lim _{n \rightarrow\infty} \frac{1}{\tau^2 B_n^2} \sum_{i=1}^n\int_{\left|x-\mu_i\right|&gt;\tau B_n}\left(x-\mu_i\right)^2 p_i(x)\mathrm{d} x=0.\end{array}\\\hline 李雅普诺夫中心极限定理 &amp; \begin{array}{c}随机变量序列相互独立且具有有限的数学期望和方差,\\E(X_i)=\mu_i,\operatorname{Var}(X_i)=\sigma_i^2,i=1,2,\cdots\\存在\delta&gt;0,满足:\displaystyle \lim _{n \rightarrow \infty}\frac{1}{B_n^{2+\delta}} \sum_{i=1}^nE\left(\left|X_i-\mu_i\right|^{2+\delta}\right)=0 \end{array} \\\hline\end{array}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第五章 复习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>人工智能框架思维导图</title>
      <link href="/2024/05/03/ren-gong-zhi-neng-kuang-jia/"/>
      <url>/2024/05/03/ren-gong-zhi-neng-kuang-jia/</url>
      
        <content type="html"><![CDATA[<p>点击查看<a href="../../../../HTML/人工智能.html">人工智能框架</a>（建议使用电脑查看！）</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 人工智能框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4章 朴素贝叶斯</title>
      <link href="/2024/04/29/di-4-zhang-po-su-bei-xie-si/"/>
      <url>/2024/04/29/di-4-zhang-po-su-bei-xie-si/</url>
      
        <content type="html"><![CDATA[<h1 id="第4章-朴素贝叶斯">第4章 朴素贝叶斯</h1><h2 id="引言">引言</h2><p>在众多机器学习分类算法中，本篇我们提到的朴素贝叶斯模型，和其他绝大多数分类算法都不同，也是很重要的模型之一。</p><p>在众多机器学习的分类算法中，朴素贝叶斯模型以其独特的方法和重要性，与其他算法显著不同。相对于KNN、逻辑回归、决策树等判别方法，这些算法直接学习输入特征X与输出Y之间的直接关系（决策函数<span class="math inline">\(Y=f(x)\)</span> 或者条件分布 <span class="math inline">\(P(Y \mid X)\)</span>​），朴素贝叶斯模型则采用了生成方法。它直接找出特征输出Y和特征X的联合分布 <span class="math inline">\(P(X, Y)\)</span> ，进而通过<span class="math display">\[P(Y \mid X)=\frac{P(X, Y)}{P(X)}\]</span></p><p>计算得出结果判定。</p><h2 id="朴素贝叶斯算法原理">朴素贝叶斯算法原理</h2><h3 id="贝叶斯定理">贝叶斯定理</h3><p>贝叶斯理论是以18世纪的一位神学家托马斯.贝叶斯(ThomasBayes)命名。通常，事件A在事件B (发生) 的条件下的概率，与事件B在事件A(发生)的条件下的概率是不一样的。然而，这两者是有确定的关系的，贝叶斯定理就是这种关系的陈述。<span class="math display">\[P(A \mid B)=\frac{P(B \mid A) P(A)}{P(B)}\]</span></p><ul><li>条件概率：就是事件 <span class="math inline">\(A\)</span>在另外一个事件 <span class="math inline">\(B\)</span>已经发生条件下的发生概率。条件概率表示为 <span class="math inline">\(P(A\mid B)\)</span> ，即在 <span class="math inline">\(B\)</span>发生的条件下 <span class="math inline">\(A\)</span> 发生的概率。</li><li>联合概率：表示两个事件共同发生（数学概念上的交集）的概率。 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(B\)</span>的联合概率表示为联合概率。联合概率表示为 <span class="math inline">\(P(AB)\)</span> <span class="math display">\[P(A B)=P(A \mid B) P(B)=P(B \mid A) P(A) \text {, 若 } A B \text {相互独立, 则} P(A B)=P(A) P(B)\]</span></li><li>全概率公式: <span class="math inline">\(\displaystyle P(X)=\sum_kP\left(X \mid Y=Y_k\right) P\left(Y_k\right)\)</span>， 其中 <span class="math inline">\(\displaystyle  \sum_kP\left(Y_k\right)=1\)</span></li></ul><h3 id="朴素贝叶斯">朴素贝叶斯</h3><p>朴素贝叶斯方法是<strong>基于贝叶斯定理</strong>和特征条件独立假设的<strong>分类方法</strong>。</p><p>这是一个较强的假设。由于这一假设，模型包含的条件概率的数量大为减少，朴素贝叶斯法的学习与预测大为简化。因而朴素贝叶斯法高效，且易于实现。其缺点是分类的性能不一定很高。</p><p>对于给定的训练数据集：</p><ol type="1"><li>首先基于特征条件独立假设学习输入 / 输出的联合概率分布</li><li>然后基于此模型，对给定的输入 <span class="math inline">\(x\)</span>，利用贝叶斯定理求出后验概率最大的输出 <span class="math inline">\(y\)</span> :</li></ol><p><span class="math display">\[\begin{aligned}P\left(X=x \mid Y=c_k\right) &amp; =P\left(X^{(1)}=x^{(1)}, \cdots,X^{(n)}=x^{(n)} \mid Y=c_k\right) \\&amp; =\prod_{j=1}^n P\left(X^{(j)}=x^{(j)} \mid Y=c_k\right)\end{aligned}\tag{1}\]</span></p><p><strong>原理</strong></p><p>朴素贝叶斯方法属于生成模型的范畴。在给定输入 <span class="math inline">\(x\)</span>的情况下，这种方法通过已学习的模型计算后验概率分布 <span class="math inline">\(P(Y=c_k \mid X=x)\)</span>。它选择后验概率最高的类别 $c_k $ 作为输入 $x $的预测分类。其中<strong>后验概率的计算</strong>基于贝叶斯定理进行<br><span class="math display">\[\begin{aligned}P\left(Y=c_k \mid X=x\right) &amp;= \frac{P\left(X=x \mid Y=c_k\right)P\left(Y=c_k\right)}{\displaystyle \sum_k P\left(X=x \mid Y=c_k\right)P\left(Y=c_k\right)}\end{aligned}\tag{2}\]</span> 将式<span class="math inline">\((1)\)</span>代入式<span class="math inline">\((2)\)</span>，有 <span class="math display">\[P\left(Y=c_k \mid X=x\right)=\frac{\displaystyle P\left(Y=c_k\right)\prod_j P\left(X^{(j)}=x^{(j)} \mid Y=c_k\right)}{\displaystyle \sum_{k}P\left(Y=c_k\right) \prod_{j} P\left(X^{(j)}=x^{(j)} \midY=c_k\right)},k=1,2, \cdots, K\tag{3}\]</span> 这是朴素贝叶斯法分类的基本公式。于是, 朴素贝叶斯分类器可表示为<span class="math display">\[y=f(x)=\arg \max _{c_k} \frac{\displaystyle P\left(Y=c_k\right) \prod_jP\left(X^{(j)}=x^{(j)} \mid Y=c_k\right)}{\displaystyle \sum_kP\left(Y=c_k\right) \prod_j P\left(X^{(j)}=x^{(j)} \midY=c_k\right)}\tag{4}\]</span> 注意到, 在式 <span class="math inline">\((4)\)</span>中分母对所有 <span class="math inline">\(c_k\)</span> 都是相同的，所以<span class="math display">\[y=\arg \max _{c_k} P\left(Y=c_k\right) \prod_j P\left(X^{(j)}=x^{(j)}\mid Y=c_k\right)\tag{5}\]</span></p><h3 id="后验概率最大化的含义">后验概率最大化的含义</h3><p>朴素贝叶斯法将实例分到后验概率最大的类中,这等价于期望风险最小化。假设选择 0-1 损失函数: <span class="math display">\[L(Y, f(X))=\left\{\begin{array}{rr}1, &amp; Y \neq f(X) \\0, &amp; Y=f(X)\end{array}\right.\tag{6}\]</span></p><p>式中 <span class="math inline">\(f(X)\)</span>是分类决策函数。这时，期望风险函数为 <span class="math display">\[R_{\exp }(f)=E[L(Y, f(X))]\tag{7}\]</span> 期望是对联合分布 <span class="math inline">\(P(X, Y)\)</span>取的。由此取条件期望 <span class="math display">\[R_{\exp }(f)=E_X \sum_{k=1}^K\left[L\left(c_k, f(X)\right)\right]P\left(c_k \mid X\right)\tag{8}\]</span></p><p>为了使期望风险最小化, 只需对 <span class="math inline">\(X=x\)</span>逐个极小化, 由此得到: <span class="math display">\[\begin{aligned}f(x) &amp; =\arg \min _{y \in \mathcal{Y}} \sum_{k=1}^K L\left(c_k,y\right) P\left(c_k \mid X=x\right) \\&amp; =\arg \min _{y \in \mathcal{Y}} \sum_{k=1}^K P\left(y \neq c_k\mid X=x\right) \\\\&amp; =\arg \min _{y \in \mathcal{Y}}\left(1-P\left(y=c_k \midX=x\right)\right) \\\\&amp; =\arg \max _{y \in \mathcal{Y}} P\left(y=c_k \mid X=x\right)\end{aligned}\tag{9}\]</span></p><p>这样一来, 根据期望风险最小化准则就得到了后验概率最大化准则: <span class="math display">\[f(x)=\arg \max _{c_k} P\left(c_k \mid X=x\right)\tag{10}\]</span></p><p>即朴素贝叶斯法所采用的原理。</p><h3 id="极大似然估计">极大似然估计</h3><p>在朴素贝叶斯法中，学习意味着估计 <span class="math inline">\(P\left(Y=c_k\right)\)</span> 和 <span class="math inline">\(P\left(X^{(j)}=x^{(j)} \mid Y=c_k\right)\)</span>。可以应用极大似然估计法估计相应的概率。先验概率 <span class="math inline">\(P\left(Y=c_k\right)\)</span> 的极大似然估计是<span class="math display">\[P\left(Y=c_k\right)=\frac{\displaystyle \sum_{i=1}^NI\left(y_i=c_k\right)}{N}, \quad k=1,2, \cdots, K\tag{11}\]</span></p><p>设第 <span class="math inline">\(j\)</span> 个特征 <span class="math inline">\(x^{(j)}\)</span> 可能取值的集合为 <span class="math inline">\(\left\{a_{j 1}, a_{j 2}, \cdots, a_{jS_j}\right\}\)</span>，条件概率 <span class="math inline">\(P\left(X^{(j)}=a_{j l} \midY=c_k\right)\)</span>的极大似然估计是 <span class="math display">\[\begin{aligned}&amp; P\left(X^{(j)}=a_{j l} \mid Y=c_k\right)=\frac{\displaystyle\sum_{i=1}^N I\left(x_i^{(j)}=a_{j l}, y_i=c_k\right)}{\displaystyle\sum_{i=1}^N I\left(y_i=c_k\right)}, \\&amp; j=1,2, \cdots, n, \quad l=1,2, \cdots, S_j, \quad k=1,2, \cdots, K\end{aligned}\tag{12}\]</span></p><p>式中， <span class="math inline">\(x_i^{(j)}\)</span> 是第 <span class="math inline">\(i\)</span> 个样本的第 <span class="math inline">\(j\)</span> 个特征； <span class="math inline">\(a_{j l}\)</span> 是第 <span class="math inline">\(j\)</span> 个特征可能取的第 <span class="math inline">\(l\)</span> 个值； <span class="math inline">\(I\)</span> 为指示函数。</p><p><strong>创建训练集和测试集</strong></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> math</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_data</span>():</span><br><span class="line">    iris = load_iris()</span><br><span class="line">    df = pd.DataFrame(iris.data, columns=iris.feature_names)</span><br><span class="line">    df[<span class="string">'label'</span>] = iris.target</span><br><span class="line">    df.columns = [</span><br><span class="line">        <span class="string">'sepal length'</span>, <span class="string">'sepal width'</span>, <span class="string">'petal length'</span>, <span class="string">'petal width'</span>, <span class="string">'label'</span></span><br><span class="line">    ]</span><br><span class="line">    data = np.array(df.iloc[:<span class="number">100</span>, :])</span><br><span class="line">    <span class="comment"># print(data)</span></span><br><span class="line">    <span class="keyword">return</span> data[:, :-<span class="number">1</span>], data[:, -<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">X, y = create_data()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.3</span>)</span><br><span class="line">X_test[<span class="number">0</span>], y_test[<span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">(array([6.6, 2.9, 4.6, 1.3]), 1.0)</span><br></pre></td></tr></tbody></table></figure><ul><li><h3 id="高斯模型">高斯模型</h3><p><strong>GaussianNB 高斯朴素贝叶斯</strong>特征的可能性被假设为高斯概率密度函数: <span class="math display">\[P\left(x_i \mid y_k\right)=\frac{1}{\sqrt{2 \pi \sigma_{y k}^2}} \exp\left(-\frac{\left(x_i-\mu_{y k}\right)^2}{2 \sigma_{yk}^2}\right)\tag{13}\]</span></p><p>数学期望： <span class="math inline">\(\mu\)</span> 方差: <span class="math inline">\(\sigma^2=\frac{\sum(X-\mu)^2}{N}\)</span></p></li></ul><h4 id="实现一个朴素贝叶斯分类器"><strong>实现一个朴素贝叶斯分类器</strong></h4><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NaiveBayes</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.model = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数学期望</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mean</span>(<span class="params">X</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(X) / <span class="built_in">float</span>(<span class="built_in">len</span>(X))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 标准差（方差）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stdev</span>(<span class="params">self, X</span>):</span><br><span class="line">        avg = self.mean(X)</span><br><span class="line">        <span class="keyword">return</span> math.sqrt(<span class="built_in">sum</span>([<span class="built_in">pow</span>(x - avg, <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> X]) / <span class="built_in">float</span>(<span class="built_in">len</span>(X)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 概率密度函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gaussian_probability</span>(<span class="params">self, x, mean, stdev</span>):</span><br><span class="line">        exponent = math.exp(-(math.<span class="built_in">pow</span>(x - mean, <span class="number">2</span>) /</span><br><span class="line">                              (<span class="number">2</span> * math.<span class="built_in">pow</span>(stdev, <span class="number">2</span>))))</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> / (math.sqrt(<span class="number">2</span> * math.pi) * stdev)) * exponent</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理X_train</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">summarize</span>(<span class="params">self, train_data</span>):</span><br><span class="line">        summaries = [(self.mean(i), self.stdev(i)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(*train_data)]</span><br><span class="line">        <span class="keyword">return</span> summaries</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 分类别求出数学期望和标准差</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, X, y</span>):</span><br><span class="line">        labels = <span class="built_in">list</span>(<span class="built_in">set</span>(y))</span><br><span class="line">        data = {label: [] <span class="keyword">for</span> label <span class="keyword">in</span> labels}</span><br><span class="line">        <span class="keyword">for</span> f, label <span class="keyword">in</span> <span class="built_in">zip</span>(X, y):</span><br><span class="line">            data[label].append(f)</span><br><span class="line">        self.model = {</span><br><span class="line">            label: self.summarize(value)</span><br><span class="line">            <span class="keyword">for</span> label, value <span class="keyword">in</span> data.items()</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'gaussianNB train done!'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算概率</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate_probabilities</span>(<span class="params">self, input_data</span>):</span><br><span class="line">        <span class="comment"># summaries:{0.0: [(5.0, 0.37),(3.42, 0.40)], 1.0: [(5.8, 0.449),(2.7, 0.27)]}</span></span><br><span class="line">        <span class="comment"># input_data:[1.1, 2.2]</span></span><br><span class="line">        probabilities = {}</span><br><span class="line">        <span class="keyword">for</span> label, value <span class="keyword">in</span> self.model.items():</span><br><span class="line">            probabilities[label] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(value)):</span><br><span class="line">                mean, stdev = value[i]</span><br><span class="line">                probabilities[label] *= self.gaussian_probability(</span><br><span class="line">                    input_data[i], mean, stdev)</span><br><span class="line">        <span class="keyword">return</span> probabilities</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类别</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X_test</span>):</span><br><span class="line">        <span class="comment"># {0.0: 2.9680340789325763e-27, 1.0: 3.5749783019849535e-26}</span></span><br><span class="line">        label = <span class="built_in">sorted</span>(</span><br><span class="line">            self.calculate_probabilities(X_test).items(),</span><br><span class="line">            key=<span class="keyword">lambda</span> x: x[-<span class="number">1</span>])[-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self, X_test, y_test</span>):</span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> <span class="built_in">zip</span>(X_test, y_test):</span><br><span class="line">            label = self.predict(X)</span><br><span class="line">            <span class="keyword">if</span> label == y:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right / <span class="built_in">float</span>(<span class="built_in">len</span>(X_test))</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">model = NaiveBayes()</span><br><span class="line">model.fit(X_train, y_train)</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">'gaussianNB train done!'</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(model.predict([<span class="number">4.4</span>,  <span class="number">3.2</span>,  <span class="number">1.3</span>,  <span class="number">0.2</span>]))</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">0.0</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">model.score(X_test, y_test)</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1.0</span><br></pre></td></tr></tbody></table></figure><h4 id="scikit-learn实例"><strong>scikit-learn实例</strong></h4><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line">clf = GaussianNB()</span><br><span class="line">clf.fit(X_train, y_train)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">clf.score(X_test, y_test)</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1.0</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">clf.predict([[<span class="number">4.4</span>,  <span class="number">3.2</span>,  <span class="number">1.3</span>,  <span class="number">0.2</span>]])</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">array([0.])</span><br></pre></td></tr></tbody></table></figure><p><strong>而scikit-learn中的伯努利模型和多项式模型</strong></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> BernoulliNB, MultinomialNB <span class="comment"># 伯努利模型和多项式模型</span></span><br></pre></td></tr></tbody></table></figure><hr><h2 id="第4章朴素贝叶斯法-习题">第4章朴素贝叶斯法-习题</h2><h3 id="用极大似然估计法推出朴素贝叶斯法中的概率估计公式11及公式-12">1.用极大似然估计法推出朴素贝叶斯法中的概率估计公式<span class="math inline">\((11)\)</span>及公式 <span class="math inline">\((12)\)</span>。</h3><p><strong>解答：</strong><br><strong>第1步：</strong>证明公式<span class="math inline">\((11)\)</span>：<span class="math inline">\(\displaystyle P(Y=c_k) = \frac{\displaystyle\sum_{i=1}^N I(y_i=c_k)}{N}\)</span></p><p>由于朴素贝叶斯法假设<span class="math inline">\(Y\)</span>是定义在输出空间<span class="math inline">\(\mathcal{Y}\)</span>上的随机变量，因此可以定义<span class="math inline">\(P(Y=c_k)\)</span>概率为<span class="math inline">\(p\)</span>。</p><p>令<span class="math inline">\(\displaystylem=\sum_{i=1}^NI(y_i=c_k)\)</span>，得出似然函数： <span class="math display">\[L(p)=f_D(y_1,y_2,\cdots,y_n|\theta)=\binom{N}{m}p^m(1-p)^{(N-m)}\]</span> 使用微分求极值，两边同时对<span class="math inline">\(p\)</span>求微分： <span class="math display">\[\begin{aligned}0 &amp;=\binom{N}{m}\left[mp^{(m-1)}(1-p)^{(N-m)}-(N-m)p^m(1-p)^{(N-m-1)}\right]\\&amp; = \binom{N}{m}\left[p^{(m-1)}(1-p)^{(N-m-1)}(m-Np)\right]\end{aligned}\]</span> 可求解得到： <span class="math display">\[\displaystyle p=0,p=1,p=\frac{m}{N}\]</span> 显然 <span class="math display">\[\begin{aligned}\displaystyle P(Y=c_k)&amp;=p=\frac{m}{N}=\frac{\displaystyle \sum_{i=1}^N I(y_i=c_k)}{N}\end{aligned}\]</span> 公式<span class="math inline">\((11)\)</span>得证。</p><hr><p><strong>第2步：</strong>证明公式<span class="math inline">\((11)\)</span>： <span class="math display">\[\displaystyle P(X^{(j)}=a_{jl}|Y=c_k) = \frac{\displaystyle \sum_{i=1}^NI(x_i^{(j)}=a_{jl},y_i=c_k)}{\displaystyle \sum_{i=1}^N I(y_i=c_k)}\]</span> 令 <span class="math display">\[P(X^{(j)}=a_{jl}|Y=c_k)=p\]</span></p><p><span class="math display">\[\displaystyle m=\sum_{i=1}^N I(y_i=c_k), q=\sum_{i=1}^NI(x_i^{(j)}=a_{jl},y_i=c_k)\]</span></p><p>得出似然函数： <span class="math display">\[L(p)=\binom{m}{q}p^q(i-p)^{m-q}\]</span> 使用微分求极值，两边同时对<span class="math inline">\(p\)</span>求微分： <span class="math display">\[\begin{aligned}0 &amp;=\binom{m}{q}\left[qp^{(q-1)}(1-p)^{(m-q)}-(m-q)p^q(1-p)^{(m-q-1)}\right]\\&amp; = \binom{m}{q}\left[p^{(q-1)}(1-p)^{(m-q-1)}(q-mp)\right]\end{aligned}\]</span> 可求解得到 <span class="math display">\[\displaystyle p=0,p=1,p=\frac{q}{m}\]</span></p><p>显然 <span class="math display">\[\displaystyle P(X^{(j)}=a_{jl}|Y=c_k)=p=\frac{q}{m}=\frac{\displaystyle\sum_{i=1}^N I(x_i^{(j)}=a_{jl},y_i=c_k)}{\displaystyle \sum_{i=1}^NI(y_i=c_k)}\]</span> 公式<span class="math inline">\((12)\)</span>得证。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
          <category> 机器学习方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3章 k近邻法</title>
      <link href="/2024/04/29/di-03-zhang-k-jin-lin-fa/"/>
      <url>/2024/04/29/di-03-zhang-k-jin-lin-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="第3章-k近邻法">第3章 k近邻法</h1><ol type="1"><li><p><span class="math inline">\(k\)</span>近邻法是基本且简单的分类与回归方法。<span class="math inline">\(k\)</span>近邻法的基本做法是：对给定的训练实例点和输入实例点，首先确定输入实例点的<span class="math inline">\(k\)</span>个最近邻训练实例点，然后利用这<span class="math inline">\(k\)</span>个训练实例点的类的多数来预测输入实例点的类。</p></li><li><p><span class="math inline">\(k\)</span>近邻模型对应于基于训练数据集对特征空间的一个划分。<span class="math inline">\(k\)</span>近邻法中，当训练集、距离度量、<span class="math inline">\(k\)</span>值及分类决策规则确定后，其结果唯一确定。</p></li><li><p><span class="math inline">\(k\)</span>近邻法三要素：距离度量、<span class="math inline">\(k\)</span>值的选择和分类决策规则。常用的距离度量是欧氏距离及更一般的<strong>pL</strong>距离。<span class="math inline">\(k\)</span>值小时，<span class="math inline">\(k\)</span>近邻模型更复杂；<span class="math inline">\(k\)</span>值大时，<span class="math inline">\(k\)</span>近邻模型更简单。<span class="math inline">\(k\)</span>值的选择反映了对近似误差与估计误差之间的权衡，通常由交叉验证选择最优的<span class="math inline">\(k\)</span>。</p></li><li><p>常用的分类决策规则是多数表决，对应于经验风险最小化。</p></li><li><p><span class="math inline">\(k\)</span>近邻法的实现需要考虑如何快速搜索k个最近邻点。<code>kd</code>树是一种便于对k维空间中的数据进行快速检索的数据结构。<code>kd</code>树是二叉树，表示对<span class="math inline">\(k\)</span>维空间的一个划分，其每个结点对应于<span class="math inline">\(k\)</span>维空间划分中的一个超矩形区域。利用<code>kd</code>树可以省去对大部分数据点的搜索，从而减少搜索的计算量。</p><p><img src="../../../../images/第03章k近邻法/fig1.png"></p><center style="color:#C0C0C0;text-decoration:underline"><p>图1：k近邻法的模型对应特征空间的一个划分</p></center></li></ol><h2 id="距离度量">距离度量</h2><p>设特征空间<span class="math inline">\(x\)</span>是<span class="math inline">\(n\)</span>维实数向量空间 ，<span class="math inline">\(x_{i}, x_{j} \in \mathcal{X}\)</span>, <span class="math display">\[x_{i}=\left(x_{i}^{(1)}, x_{i}^{(2)}, \cdots,x_{i}^{(n)}\right)^{\mathrm{T}}\]</span></p><p><span class="math display">\[x_{j}=\left(x_{j}^{(1)}, x_{j}^{(2)}, \cdots,x_{j}^{(n)}\right)^{\mathrm{T}}\]</span></p><p>则：<span class="math inline">\(x_i\)</span>,<span class="math inline">\(x_j\)</span>的<span class="math inline">\(L_p\)</span>距离定义为: <span class="math display">\[L_{p}\left(x_{i},x_{j}\right)=\left(\sum_{i=1}^{n}\left|x_{i}^{(i)}-x_{j}^{(l)}\right|^{p}\right)^{\frac{1}{p}}\]</span></p><ul><li><span class="math inline">\(p= 1\)</span> 曼哈顿距离</li></ul><p><span class="math display">\[L_1\left(x_i, x_j\right)=\sum_{l=1}^n\left|x_i^{(l)}-x_j^{(l)}\right|\]</span></p><ul><li><span class="math inline">\(p= 2\)</span> 欧氏距离</li></ul><p><span class="math display">\[L_2\left(x_i,x_j\right)=\left(\sum_{l=1}^n\left|x_i^{(l)}-x_j^{(l)}\right|^2\right)^{\frac{1}{2}}\]</span></p><ul><li><span class="math inline">\(p= \infty\)</span> 切比雪夫距离</li></ul><p><span class="math display">\[L_{\infty}\left(x_i, x_j\right)=\max _l\left|x_i^{(l)}-x_j^{(l)}\right|\]</span></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">L</span>(<span class="params">x, y, p=<span class="number">2</span></span>):</span><br><span class="line">    <span class="comment"># x1 = [1, 1], x2 = [5,1]</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(x) == <span class="built_in">len</span>(y) <span class="keyword">and</span> <span class="built_in">len</span>(x) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">            <span class="built_in">sum</span> += math.<span class="built_in">pow</span>(<span class="built_in">abs</span>(x[i] - y[i]), p)</span><br><span class="line">        <span class="keyword">return</span> math.<span class="built_in">pow</span>(<span class="built_in">sum</span>, <span class="number">1</span> / p)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><h3 id="例">例：</h3><p>已知二维空间的 3 个点 <span class="math inline">\(x_1=(1,1)^{\mathrm{T}}, x_2=(5,1)^{\mathrm{T}},x_3=(4,4)^{\mathrm{T}}\)</span>, 试求在 <span class="math inline">\(p\)</span> 取不同值时, <span class="math inline">\(L_p\)</span> 距离下 <span class="math inline">\(x_1\)</span> 的最近邻点。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">x1 = [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">x2 = [<span class="number">5</span>, <span class="number">1</span>]</span><br><span class="line">x3 = [<span class="number">4</span>, <span class="number">4</span>]</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># x1, x2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">    r = {<span class="string">'1-{}'</span>.<span class="built_in">format</span>(c): L(x1, c, p=i) <span class="keyword">for</span> c <span class="keyword">in</span> [x2, x3]}</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">min</span>(<span class="built_in">zip</span>(r.values(), r.keys())))</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>(4.0, '1-[5, 1]')(4.0, '1-[5, 1]')(3.7797631496846193, '1-[4, 4]')(3.5676213450081633, '1-[4, 4]')</code></pre><p>python实现，遍历所有数据点，找出<span class="math inline">\(n\)</span>个距离最近的点的分类情况，少数服从多数</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># data</span></span><br><span class="line">iris = load_iris()</span><br><span class="line">df = pd.DataFrame(iris.data, columns=iris.feature_names)</span><br><span class="line">df[<span class="string">'label'</span>] = iris.target</span><br><span class="line">df.columns = [<span class="string">'sepal length'</span>, <span class="string">'sepal width'</span>, <span class="string">'petal length'</span>, <span class="string">'petal width'</span>, <span class="string">'label'</span>]</span><br><span class="line"><span class="comment"># data = np.array(df.iloc[:100, [0, 1, -1]])</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">df</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code> <span class="math display">\[\begin{aligned}&amp;\begin{array}{|l|l|l|l|l|l|}\hline &amp; \text { sepal length } &amp; \text { sepal width } &amp;\text { petal length } &amp; \text { petal width } &amp; \text { label }\\\hline \mathbf{0} &amp; 5.1 &amp; 3.5 &amp; 1.4 &amp; 0.2 &amp; 0 \\\hline \mathbf{1} &amp; 4.9 &amp; 3.0 &amp; 1.4 &amp; 0.2 &amp; 0 \\\hline \mathbf{2} &amp; 4.7 &amp; 3.2 &amp; 1.3 &amp; 0.2 &amp; 0 \\\hline \mathbf{3} &amp; 4.6 &amp; 3.1 &amp; 1.5 &amp; 0.2 &amp; 0 \\\hline \mathbf{4} &amp; 5.0 &amp; 3.6 &amp; 1.4 &amp; 0.2 &amp; 0 \\\hline \ldots &amp; \ldots &amp; \ldots &amp; \ldots &amp; \ldots &amp;\ldots \\\hline \mathbf{1 4 5} &amp; 6.7 &amp; 3.0 &amp; 5.2 &amp; 2.3 &amp; 2 \\\hline \mathbf{1 4 6} &amp; 6.3 &amp; 2.5 &amp; 5.0 &amp; 1.9 &amp; 2 \\\hline \mathbf{1 4 7} &amp; 6.5 &amp; 3.0 &amp; 5.2 &amp; 2.0 &amp; 2 \\\hline \mathbf{1 4 8} &amp; 6.2 &amp; 3.4 &amp; 5.4 &amp; 2.3 &amp; 2 \\\hline \mathbf{1 4 9} &amp; 5.9 &amp; 3.0 &amp; 5.1 &amp; 1.8 &amp; 2 \\\hline\end{array}\\&amp;150 \text { rows } \times 5 \text { columns }\end{aligned}\]</span></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">plt.scatter(df[:<span class="number">50</span>][<span class="string">'sepal length'</span>], df[:<span class="number">50</span>][<span class="string">'sepal width'</span>], label=<span class="string">'0'</span>)</span><br><span class="line">plt.scatter(df[<span class="number">50</span>:<span class="number">100</span>][<span class="string">'sepal length'</span>], df[<span class="number">50</span>:<span class="number">100</span>][<span class="string">'sepal width'</span>], label=<span class="string">'1'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'sepal length'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'sepal width'</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>&lt;matplotlib.legend.Legend at 0x223cea49490&gt;</code></pre><p><img src="../../../../images/第03章k近邻法/output_13_1.png"></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">data = np.array(df.iloc[:<span class="number">100</span>, [<span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>]])</span><br><span class="line">X, y = data[:,:-<span class="number">1</span>], data[:,-<span class="number">1</span>]</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KNN</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, X_train, y_train, n_neighbors=<span class="number">3</span>, p=<span class="number">2</span></span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        parameter: n_neighbors 临近点个数</span></span><br><span class="line"><span class="string">        parameter: p 距离度量</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.n = n_neighbors</span><br><span class="line">        self.p = p</span><br><span class="line">        self.X_train = X_train</span><br><span class="line">        self.y_train = y_train</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="comment"># 取出n个点</span></span><br><span class="line">        knn_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n):</span><br><span class="line">            dist = np.linalg.norm(X - self.X_train[i], <span class="built_in">ord</span>=self.p)</span><br><span class="line">            knn_list.append((dist, self.y_train[i]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n, <span class="built_in">len</span>(self.X_train)):</span><br><span class="line">            max_index = knn_list.index(<span class="built_in">max</span>(knn_list, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]))</span><br><span class="line">            dist = np.linalg.norm(X - self.X_train[i], <span class="built_in">ord</span>=self.p)</span><br><span class="line">            <span class="keyword">if</span> knn_list[max_index][<span class="number">0</span>] &gt; dist:</span><br><span class="line">                knn_list[max_index] = (dist, self.y_train[i])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 统计</span></span><br><span class="line">        knn = [k[-<span class="number">1</span>] <span class="keyword">for</span> k <span class="keyword">in</span> knn_list]</span><br><span class="line">        count_pairs = Counter(knn)</span><br><span class="line"><span class="comment">#         max_count = sorted(count_pairs, key=lambda x: x)[-1]</span></span><br><span class="line">        max_count = <span class="built_in">sorted</span>(count_pairs.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])[-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> max_count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self, X_test, y_test</span>):</span><br><span class="line">        right_count = <span class="number">0</span></span><br><span class="line">        n = <span class="number">10</span></span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> <span class="built_in">zip</span>(X_test, y_test):</span><br><span class="line">            label = self.predict(X)</span><br><span class="line">            <span class="keyword">if</span> label == y:</span><br><span class="line">                right_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right_count / <span class="built_in">len</span>(X_test)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">clf = KNN(X_train, y_train)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">clf.score(X_test, y_test)</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>1.0</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">test_point = [<span class="number">6.0</span>, <span class="number">3.0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Test Point: {}'</span>.<span class="built_in">format</span>(clf.predict(test_point)))</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>Test Point: 1.0</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">plt.scatter(df[:<span class="number">50</span>][<span class="string">'sepal length'</span>], df[:<span class="number">50</span>][<span class="string">'sepal width'</span>], label=<span class="string">'0'</span>)</span><br><span class="line">plt.scatter(df[<span class="number">50</span>:<span class="number">100</span>][<span class="string">'sepal length'</span>], df[<span class="number">50</span>:<span class="number">100</span>][<span class="string">'sepal width'</span>], label=<span class="string">'1'</span>)</span><br><span class="line">plt.plot(test_point[<span class="number">0</span>], test_point[<span class="number">1</span>], <span class="string">'bo'</span>, label=<span class="string">'test_point'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'sepal length'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'sepal width'</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>&lt;matplotlib.legend.Legend at 0x223d67b9490&gt;</code></pre><p><img src="../../../../images/第03章k近邻法/output_19_1.png"></p><h3 id="scikit-learn实例">scikit-learn实例</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line">clf_sk = KNeighborsClassifier()</span><br><span class="line">clf_sk.fit(X_train, y_train)</span><br><span class="line">clf_sk.score(X_test, y_test)</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>1.0</code></pre><h3 id="sklearn.neighbors.kneighborsclassifier">sklearn.neighbors.KNeighborsClassifier</h3><ul><li><code>n_neighbors</code>: 临近点个数</li><li><code>p</code>: 距离度量</li><li><code>algorithm</code>:近邻算法，可选<code>{'auto', 'ball_tree', 'kd_tree', 'brute'}</code></li><li><code>weights</code>: 确定近邻的权重</li></ul><h3 id="kd树">kd树</h3><p><strong>kd</strong>树是一种对k维空间中的实例点进行存储以便对其进行快速检索的树形数据结构。</p><p><strong>kd</strong>树是二叉树，表示对<span class="math inline">\(k\)</span>维空间的一个划分（partition）。构造<strong>kd</strong>树相当于不断地用垂直于坐标轴的超平面将<span class="math inline">\(k\)</span>维空间切分，构成一系列的k维超矩形区域。kd树的每个结点对应于一个<span class="math inline">\(k\)</span>维超矩形区域。</p><p>构造<strong>kd</strong>树的方法如下：</p><p>构造根结点，使根结点对应于<span class="math inline">\(k\)</span>维空间中包含所有实例点的超矩形区域；通过下面的递归方法，不断地对<span class="math inline">\(k\)</span>维空间进行切分，生成子结点。在超矩形区域（结点）上选择一个坐标轴和在此坐标轴上的一个切分点，确定一个超平面，这个超平面通过选定的切分点并垂直于选定的坐标轴，将当前超矩形区域切分为左右两个子区域（子结点）；这时，实例被分到两个子区域。这个过程直到子区域内没有实例时终止（终止时的结点为叶结点）。在此过程中，将实例保存在相应的结点上。</p><p>通常，依次选择坐标轴对空间切分，选择训练实例点在选定坐标轴上的中位数（median）为切分点，这样得到的<strong>kd</strong>树是平衡的。注意，平衡的<strong>kd</strong>树搜索时的效率未必是最优的。</p><h3 id="构造平衡kd树算法">构造平衡kd树算法</h3><p>输入：<span class="math inline">\(k\)</span>维空间数据集<span class="math inline">\(T＝\{x_1，x_2,…,x_N\}\)</span>，</p><p>其中：<span class="math inline">\(x_{i}=\left(x_{i}^{(1)},x_{i}^{(2)}, \cdots, x_{i}^{(k)}\right)^{\mathrm{T}}\)</span> ，<span class="math inline">\(i＝1,2,…,N\)</span>；</p><p>输出：<strong>kd</strong>树。</p><p>（1）开始：构造根结点，根结点对应于包含<span class="math inline">\(T\)</span>的<span class="math inline">\(k\)</span>维空间的超矩形区域。</p><p>选择<span class="math inline">\(x^{(1)}\)</span>为坐标轴，以T中所有实例的<span class="math inline">\(x^{(1)}\)</span>坐标的中位数为切分点，将根结点对应的超矩形区域切分为两个子区域。切分由通过切分点并与坐标轴<span class="math inline">\(x^{(1)}\)</span>垂直的超平面实现。</p><p>由根结点生成深度为1的左、右子结点：左子结点对应坐标<span class="math inline">\(x^{(1)}\)</span>小于切分点的子区域，右子结点对应于坐标<span class="math inline">\(x^{(1)}\)</span>大于切分点的子区域。</p><p>将落在切分超平面上的实例点保存在根结点。</p><p>（2）重复：对深度为<span class="math inline">\(j\)</span>的结点，选择<span class="math inline">\(x^{(1)}\)</span>为切分的坐标轴，<span class="math inline">\(l＝j(modk)+1\)</span>，以该结点的区域中所有实例的<span class="math inline">\(x^{(1)}\)</span>坐标的中位数为切分点，将该结点对应的超矩形区域切分为两个子区域。切分由通过切分点并与坐标轴<span class="math inline">\(x^{(1)}\)</span>垂直的超平面实现。</p><p>由该结点生成深度为<span class="math inline">\(j+1\)</span>的左、右子结点：左子结点对应坐标<span class="math inline">\(x^{(1)}\)</span>小于切分点的子区域，右子结点对应坐标<span class="math inline">\(x^{(1)}\)</span>大于切分点的子区域。</p><p>将落在切分超平面上的实例点保存在该结点。</p><p>（3）直到两个子区域没有实例存在时停止。从而形成<strong>kd</strong>树的区域划分。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># kd-tree每个结点中主要包含的数据结构如下</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KdNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, dom_elt, split, left, right</span>):</span><br><span class="line">        self.dom_elt = dom_elt  <span class="comment"># k维向量节点(k维空间中的一个样本点)</span></span><br><span class="line">        self.split = split  <span class="comment"># 整数（进行分割维度的序号）</span></span><br><span class="line">        self.left = left  <span class="comment"># 该结点分割超平面左子空间构成的kd-tree</span></span><br><span class="line">        self.right = right  <span class="comment"># 该结点分割超平面右子空间构成的kd-tree</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KdTree</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        k = <span class="built_in">len</span>(data[<span class="number">0</span>])  <span class="comment"># 数据维度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">CreateNode</span>(<span class="params">split, data_set</span>):  <span class="comment"># 按第split维划分数据集exset创建KdNode</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data_set:  <span class="comment"># 数据集为空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="comment"># key参数的值为一个函数，此函数只有一个参数且返回一个值用来进行比较</span></span><br><span class="line">            <span class="comment"># operator模块提供的itemgetter函数用于获取对象的哪些维的数据，参数为需要获取的数据在对象中的序号</span></span><br><span class="line">            <span class="comment">#data_set.sort(key=itemgetter(split)) # 按要进行分割的那一维数据排序</span></span><br><span class="line">            data_set.sort(key=<span class="keyword">lambda</span> x: x[split])</span><br><span class="line">            split_pos = <span class="built_in">len</span>(data_set) // <span class="number">2</span>  <span class="comment"># //为Python中的整数除法</span></span><br><span class="line">            median = data_set[split_pos]  <span class="comment"># 中位数分割点</span></span><br><span class="line">            split_next = (split + <span class="number">1</span>) % k  <span class="comment"># cycle coordinates</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 递归的创建kd树</span></span><br><span class="line">            <span class="keyword">return</span> KdNode(</span><br><span class="line">                median,</span><br><span class="line">                split,</span><br><span class="line">                CreateNode(split_next, data_set[:split_pos]),  <span class="comment"># 创建左子树</span></span><br><span class="line">                CreateNode(split_next, data_set[split_pos + <span class="number">1</span>:]))  <span class="comment"># 创建右子树</span></span><br><span class="line"></span><br><span class="line">        self.root = CreateNode(<span class="number">0</span>, data)  <span class="comment"># 从第0维分量开始构建kd树,返回根节点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># KDTree的前序遍历</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="built_in">print</span>(root.dom_elt)</span><br><span class="line">    <span class="keyword">if</span> root.left:  <span class="comment"># 节点不为空</span></span><br><span class="line">        preorder(root.left)</span><br><span class="line">    <span class="keyword">if</span> root.right:</span><br><span class="line">        preorder(root.right)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 对构建好的kd树进行搜索，寻找与目标点最近的样本点：</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个namedtuple,分别存放最近坐标点、最近距离和访问过的节点数</span></span><br><span class="line">result = namedtuple(<span class="string">"Result_tuple"</span>,</span><br><span class="line">                    <span class="string">"nearest_point  nearest_dist  nodes_visited"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_nearest</span>(<span class="params">tree, point</span>):</span><br><span class="line">    k = <span class="built_in">len</span>(point)  <span class="comment"># 数据维度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">kd_node, target, max_dist</span>):</span><br><span class="line">        <span class="keyword">if</span> kd_node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> result([<span class="number">0</span>] * k, <span class="built_in">float</span>(<span class="string">"inf"</span>),</span><br><span class="line">                          <span class="number">0</span>)  <span class="comment"># python中用float("inf")和float("-inf")表示正负无穷</span></span><br><span class="line"></span><br><span class="line">        nodes_visited = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        s = kd_node.split  <span class="comment"># 进行分割的维度</span></span><br><span class="line">        pivot = kd_node.dom_elt  <span class="comment"># 进行分割的“轴”</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> target[s] &lt;= pivot[s]:  <span class="comment"># 如果目标点第s维小于分割轴的对应值(目标离左子树更近)</span></span><br><span class="line">            nearer_node = kd_node.left  <span class="comment"># 下一个访问节点为左子树根节点</span></span><br><span class="line">            further_node = kd_node.right  <span class="comment"># 同时记录下右子树</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 目标离右子树更近</span></span><br><span class="line">            nearer_node = kd_node.right  <span class="comment"># 下一个访问节点为右子树根节点</span></span><br><span class="line">            further_node = kd_node.left</span><br><span class="line"></span><br><span class="line">        temp1 = travel(nearer_node, target, max_dist)  <span class="comment"># 进行遍历找到包含目标点的区域</span></span><br><span class="line"></span><br><span class="line">        nearest = temp1.nearest_point  <span class="comment"># 以此叶结点作为“当前最近点”</span></span><br><span class="line">        dist = temp1.nearest_dist  <span class="comment"># 更新最近距离</span></span><br><span class="line"></span><br><span class="line">        nodes_visited += temp1.nodes_visited</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> dist &lt; max_dist:</span><br><span class="line">            max_dist = dist  <span class="comment"># 最近点将在以目标点为球心，max_dist为半径的超球体内</span></span><br><span class="line"></span><br><span class="line">        temp_dist = <span class="built_in">abs</span>(pivot[s] - target[s])  <span class="comment"># 第s维上目标点与分割超平面的距离</span></span><br><span class="line">        <span class="keyword">if</span> max_dist &lt; temp_dist:  <span class="comment"># 判断超球体是否与超平面相交</span></span><br><span class="line">            <span class="keyword">return</span> result(nearest, dist, nodes_visited)  <span class="comment"># 不相交则可以直接返回，不用继续判断</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line">        <span class="comment"># 计算目标点与分割点的欧氏距离</span></span><br><span class="line">        temp_dist = sqrt(<span class="built_in">sum</span>((p1 - p2)**<span class="number">2</span> <span class="keyword">for</span> p1, p2 <span class="keyword">in</span> <span class="built_in">zip</span>(pivot, target)))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> temp_dist &lt; dist:  <span class="comment"># 如果“更近”</span></span><br><span class="line">            nearest = pivot  <span class="comment"># 更新最近点</span></span><br><span class="line">            dist = temp_dist  <span class="comment"># 更新最近距离</span></span><br><span class="line">            max_dist = dist  <span class="comment"># 更新超球体半径</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查另一个子结点对应的区域是否有更近的点</span></span><br><span class="line">        temp2 = travel(further_node, target, max_dist)</span><br><span class="line"></span><br><span class="line">        nodes_visited += temp2.nodes_visited</span><br><span class="line">        <span class="keyword">if</span> temp2.nearest_dist &lt; dist:  <span class="comment"># 如果另一个子结点内存在更近距离</span></span><br><span class="line">            nearest = temp2.nearest_point  <span class="comment"># 更新最近点</span></span><br><span class="line">            dist = temp2.nearest_dist  <span class="comment"># 更新最近距离</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result(nearest, dist, nodes_visited)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> travel(tree.root, point, <span class="built_in">float</span>(<span class="string">"inf"</span>))  <span class="comment"># 从根节点开始递归</span></span><br></pre></td></tr></tbody></table></figure><h3 id="例-1">例：</h3><p>给定一个二维空间的数据集 <span class="math display">\[T=\left\{(2,3)^{\mathrm{T}},(5,4)^{\mathrm{T}},(9,6)^{\mathrm{T}},(4,7)^{\mathrm{T}},(8,1)^{\mathrm{T}},(7,2)^{\mathrm{T}}\right\}\]</span></p><p>构造一个平衡 <span class="math inline">\(k d\)</span> 树。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">data = [[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">4</span>],[<span class="number">9</span>,<span class="number">6</span>],[<span class="number">4</span>,<span class="number">7</span>],[<span class="number">8</span>,<span class="number">1</span>],[<span class="number">7</span>,<span class="number">2</span>]]</span><br><span class="line">kd = KdTree(data)</span><br><span class="line">preorder(kd.root)</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>[7, 2][5, 4][2, 3][4, 7][9, 6][8, 1]</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> perf_counter</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 产生一个k维随机向量，每维分量值在0~1之间</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">random_point</span>(<span class="params">k</span>):</span><br><span class="line">    <span class="keyword">return</span> [random() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 产生n个k维随机向量 </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">random_points</span>(<span class="params">k, n</span>):</span><br><span class="line">    <span class="keyword">return</span> [random_point(k) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]   </span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">ret = find_nearest(kd, [<span class="number">3</span>,<span class="number">4.5</span>])</span><br><span class="line"><span class="built_in">print</span> (ret)</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>Result_tuple(nearest_point=[2, 3], nearest_dist=1.8027756377319946, nodes_visited=4)</code></pre><p><img src="../../../../images/第03章k近邻法/fig2.png"></p><center style="color:#C0C0C0;text-decoration:underline">特征空间划分</center><p><img src="../../../../images/第03章k近邻法/fig3.png"></p><center style="color:#C0C0C0;text-decoration:underline">例：kd树</center><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">N = <span class="number">400000</span></span><br><span class="line">t0 = perf_counter()</span><br><span class="line">kd2 = KdTree(random_points(<span class="number">3</span>, N))            <span class="comment"># 构建包含四十万个3维空间样本点的kd树</span></span><br><span class="line">ret2 = find_nearest(kd2, [<span class="number">0.1</span>,<span class="number">0.5</span>,<span class="number">0.8</span>])      <span class="comment"># 四十万个样本点中寻找离目标最近的点</span></span><br><span class="line">t1 = perf_counter()</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"time: "</span>,t1-t0, <span class="string">"s"</span>)</span><br><span class="line"><span class="built_in">print</span> (ret2)</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>time:  4.075719999964349 sResult_tuple(nearest_point=[0.09993972407411433, 0.4996761242830129, 0.8017383410409034], nearest_dist=0.0017692818435128142, nodes_visited=25)</code></pre><h2 id="第3章-k近邻法-练习">第3章 k近邻法-练习</h2><h3 id="section">1</h3><p>  参照下图，在二维空间中给出实例点，画出<span class="math inline">\(k\)</span>为1和2时的<span class="math inline">\(k\)</span>近邻法构成的空间划分，并对其进行比较，体会<span class="math inline">\(k\)</span>值选择与模型复杂度及预测准确率的关系。</p><p><img src="../../../../images/第03章k近邻法/fig1.png"></p><p><strong>解答：</strong></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"></span><br><span class="line">data = np.array([[<span class="number">5</span>, <span class="number">12</span>, <span class="number">1</span>], [<span class="number">6</span>, <span class="number">21</span>, <span class="number">0</span>], [<span class="number">14</span>, <span class="number">5</span>, <span class="number">0</span>], [<span class="number">16</span>, <span class="number">10</span>, <span class="number">0</span>], [<span class="number">13</span>, <span class="number">19</span>, <span class="number">0</span>],</span><br><span class="line">                 [<span class="number">13</span>, <span class="number">32</span>, <span class="number">1</span>], [<span class="number">17</span>, <span class="number">27</span>, <span class="number">1</span>], [<span class="number">18</span>, <span class="number">24</span>, <span class="number">1</span>], [<span class="number">20</span>, <span class="number">20</span>,</span><br><span class="line">                                                         <span class="number">0</span>], [<span class="number">23</span>, <span class="number">14</span>, <span class="number">1</span>],</span><br><span class="line">                 [<span class="number">23</span>, <span class="number">25</span>, <span class="number">1</span>], [<span class="number">23</span>, <span class="number">31</span>, <span class="number">1</span>], [<span class="number">26</span>, <span class="number">8</span>, <span class="number">0</span>], [<span class="number">30</span>, <span class="number">17</span>, <span class="number">1</span>],</span><br><span class="line">                 [<span class="number">30</span>, <span class="number">26</span>, <span class="number">1</span>], [<span class="number">34</span>, <span class="number">8</span>, <span class="number">0</span>], [<span class="number">34</span>, <span class="number">19</span>, <span class="number">1</span>], [<span class="number">37</span>, <span class="number">28</span>, <span class="number">1</span>]])</span><br><span class="line">X_train = data[:, <span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">y_train = data[:, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">models = (KNeighborsClassifier(n_neighbors=<span class="number">1</span>, n_jobs=-<span class="number">1</span>),</span><br><span class="line">          KNeighborsClassifier(n_neighbors=<span class="number">2</span>, n_jobs=-<span class="number">1</span>))</span><br><span class="line">models = (clf.fit(X_train, y_train) <span class="keyword">for</span> clf <span class="keyword">in</span> models)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">titles = (<span class="string">'K Neighbors with k=1'</span>, <span class="string">'K Neighbors with k=2'</span>)</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">15</span>, <span class="number">5</span>))</span><br><span class="line">plt.subplots_adjust(wspace=<span class="number">0.4</span>, hspace=<span class="number">0.4</span>)</span><br><span class="line"></span><br><span class="line">X0, X1 = X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">x_min, x_max = X0.<span class="built_in">min</span>() - <span class="number">1</span>, X0.<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">y_min, y_max = X1.<span class="built_in">min</span>() - <span class="number">1</span>, X1.<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class="number">0.2</span>),</span><br><span class="line">                     np.arange(y_min, y_max, <span class="number">0.2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> clf, title, ax <span class="keyword">in</span> <span class="built_in">zip</span>(models, titles, fig.subplots(<span class="number">1</span>, <span class="number">2</span>).flatten()):</span><br><span class="line">    Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])</span><br><span class="line">    Z = Z.reshape(xx.shape)</span><br><span class="line">    colors = (<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'lightgreen'</span>, <span class="string">'gray'</span>, <span class="string">'cyan'</span>)</span><br><span class="line">    cmap = ListedColormap(colors[:<span class="built_in">len</span>(np.unique(Z))])</span><br><span class="line">    ax.contourf(xx, yy, Z, cmap=cmap, alpha=<span class="number">0.5</span>)</span><br><span class="line">    ax.scatter(X0, X1, c=y_train, s=<span class="number">50</span>, edgecolors=<span class="string">'k'</span>, cmap=cmap, alpha=<span class="number">0.5</span>)</span><br><span class="line">    ax.set_title(title)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><p><img src="../../../../images/第03章k近邻法/output_37_0.png"></p><h3 id="section-1">2</h3><p>  利用<span class="math inline">\(T=\left\{(2,3)^{\mathrm{T}},(5,4)^{\mathrm{T}},(9,6)^{\mathrm{T}},(4,7)^{\mathrm{T}},(8,1)^{\mathrm{T}},(7,2)^{\mathrm{T}}\right\}\)</span>构造的<span class="math inline">\(kd\)</span>树求点<span class="math inline">\(x=(3,4.5)^T\)</span>的最近邻点。</p><p><strong>解答：</strong></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KDTree</span><br><span class="line"></span><br><span class="line">train_data = np.array([(<span class="number">2</span>, <span class="number">3</span>), (<span class="number">5</span>, <span class="number">4</span>), (<span class="number">9</span>, <span class="number">6</span>), (<span class="number">4</span>, <span class="number">7</span>), (<span class="number">8</span>, <span class="number">1</span>), (<span class="number">7</span>, <span class="number">2</span>)])</span><br><span class="line">tree = KDTree(train_data, leaf_size=<span class="number">2</span>)</span><br><span class="line">dist, ind = tree.query(np.array([(<span class="number">3</span>, <span class="number">4.5</span>)]), k=<span class="number">1</span>)</span><br><span class="line">x1 = train_data[ind[<span class="number">0</span>]][<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">x2 = train_data[ind[<span class="number">0</span>]][<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"x点的最近邻点是({0}, {1})"</span>.<span class="built_in">format</span>(x1, x2))</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>x点的最近邻点是(2, 3)</code></pre><h3 id="section-2">3</h3><p>  参照如下算法，写出输出为<span class="math inline">\(x\)</span>的<span class="math inline">\(k\)</span>近邻的算法。</p><p><strong>解答：</strong><br><strong>算法：用kd树的<span class="math inline">\(k\)</span>近邻搜索</strong><br>输入：已构造的kd树；目标点<span class="math inline">\(x\)</span>；<br>输出：<span class="math inline">\(x\)</span>的最近邻</p><ol type="1"><li>在<span class="math inline">\(kd\)</span>树中找出包含目标点<span class="math inline">\(x\)</span>的叶结点：从根结点出发，递归地向下访问树。若目标点<span class="math inline">\(x\)</span>当前维的坐标小于切分点的坐标，则移动到左子结点，否则移动到右子结点，直到子结点为叶结点为止；<br></li><li>如果“当前<span class="math inline">\(k\)</span>近邻点集”元素数量小于<span class="math inline">\(k\)</span>或者叶节点距离小于“当前<span class="math inline">\(k\)</span>近邻点集”中最远点距离，那么将叶节点插入“当前k近邻点集”；<br></li><li>递归地向上回退，在每个结点进行以下操作：<br>(a)如果“当前<span class="math inline">\(k\)</span>近邻点集”元素数量小于<span class="math inline">\(k\)</span>或者当前节点距离小于“当前<span class="math inline">\(k\)</span>近邻点集”中最远点距离，那么将该节点插入“当前<span class="math inline">\(k\)</span>近邻点集”。<br>(b)检查另一子结点对应的区域是否与以目标点为球心、以目标点与于“当前<span class="math inline">\(k\)</span>近邻点集”中最远点间的距离为半径的超球体相交。如果相交，可能在另一个子结点对应的区域内存在距目标点更近的点，移动到另一个子结点，接着，递归地进行最近邻搜索；如果不相交，向上回退；</li><li>当回退到根结点时，搜索结束，最后的“当前<span class="math inline">\(k\)</span>近邻点集”即为<span class="math inline">\(x\)</span>的最近邻点。</li></ol><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 构建kd树，搜索待预测点所属区域</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(namedtuple(<span class="string">"Node"</span>, <span class="string">"location left_child right_child"</span>)):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">tuple</span>(self))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># kd tree类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KdTree</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, k=<span class="number">1</span></span>):</span><br><span class="line">        self.k = k</span><br><span class="line">        self.kdtree = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建kd tree</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_fit</span>(<span class="params">self, X, depth=<span class="number">0</span></span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            k = self.k</span><br><span class="line">        <span class="keyword">except</span> IndexError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 这里可以展开，通过方差选择axis</span></span><br><span class="line">        axis = depth % k</span><br><span class="line">        X = X[X[:, axis].argsort()]</span><br><span class="line">        median = X.shape[<span class="number">0</span>] // <span class="number">2</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            X[median]</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> Node(location=X[median],</span><br><span class="line">                    left_child=self._fit(X[:median], depth + <span class="number">1</span>),</span><br><span class="line">                    right_child=self._fit(X[median + <span class="number">1</span>:], depth + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_search</span>(<span class="params">self, point, tree=<span class="literal">None</span>, depth=<span class="number">0</span>, best=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> tree <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> best</span><br><span class="line">        k = self.k</span><br><span class="line">        <span class="comment"># 更新 branch</span></span><br><span class="line">        <span class="keyword">if</span> point[<span class="number">0</span>][depth % k] &lt; tree.location[depth % k]:</span><br><span class="line">            next_branch = tree.left_child</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            next_branch = tree.right_child</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> next_branch <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            best = next_branch.location</span><br><span class="line">        <span class="keyword">return</span> self._search(point,</span><br><span class="line">                            tree=next_branch,</span><br><span class="line">                            depth=depth + <span class="number">1</span>,</span><br><span class="line">                            best=best)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, X</span>):</span><br><span class="line">        self.kdtree = self._fit(X)</span><br><span class="line">        <span class="keyword">return</span> self.kdtree</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X</span>):</span><br><span class="line">        res = self._search(X, self.kdtree)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">KNN = KdTree()</span><br><span class="line">X_train = np.array([[<span class="number">2</span>, <span class="number">3</span>], [<span class="number">5</span>, <span class="number">4</span>], [<span class="number">9</span>, <span class="number">6</span>], [<span class="number">4</span>, <span class="number">7</span>], [<span class="number">8</span>, <span class="number">1</span>], [<span class="number">7</span>, <span class="number">2</span>]])</span><br><span class="line">KNN.fit(X_train)</span><br><span class="line">X_new = np.array([[<span class="number">3</span>, <span class="number">4.5</span>]])</span><br><span class="line">res = KNN.predict(X_new)</span><br><span class="line"></span><br><span class="line">x1 = res[<span class="number">0</span>]</span><br><span class="line">x2 = res[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"x点的最近邻点是({0}, {1})"</span>.<span class="built_in">format</span>(x1, x2))</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>x点的最近邻点是(2, 3)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
          <category> 机器学习方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二节 样本数据的整理与显示</title>
      <link href="/2024/04/29/shu-li-tong-ji-5-2-yang-ben-shu-ju-de-zheng-li-yu-xian-shi/"/>
      <url>/2024/04/29/shu-li-tong-ji-5-2-yang-ben-shu-ju-de-zheng-li-yu-xian-shi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iJJrt1wwwhsd">下载PDF点这里</a></p><p><img src="../../../../images/数理统计5-2样本数据的整理与显示/5.jpg"></p><p><img src="../../../../images/数理统计5-2样本数据的整理与显示/6.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数理统计 </category>
          
          <category> 第一章 统计量及其分布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验分布函数 </tag>
            
            <tag> 有序样本 </tag>
            
            <tag> 格利文科定理 </tag>
            
            <tag> 频数频率表 </tag>
            
            <tag> 直方图 </tag>
            
            <tag> 茎叶图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2章 感知机</title>
      <link href="/2024/04/28/di-02-zhang-gan-zhi-ji/"/>
      <url>/2024/04/28/di-02-zhang-gan-zhi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="第2章-感知机">第2章 感知机</h1><p>1．感知机是根据输入实例的特征向量<span class="math inline">\(x\)</span>对其进行二类分类的线性分类模型： <span class="math display">\[f(x)=\operatorname{sign}(w \cdot x+b)\]</span></p><p>感知机模型对应于输入空间（特征空间）中的分离超平面<span class="math inline">\(w \cdot x+b=0\)</span>。</p><p>2．感知机学习的策略是极小化损失函数： <span class="math display">\[\min _{w, b} L(w, b)=-\sum_{x_{i} \in M} y_{i}\left(w \cdotx_{i}+b\right)\]</span></p><p>损失函数对应于误分类点到分离超平面的总距离。</p><p>3．感知机学习算法是基于随机梯度下降法的对损失函数的最优化算法，有原始形式和对偶形式。算法简单且易于实现。原始形式中，首先任意选取一个超平面，然后用梯度下降法不断极小化目标函数。在这个过程中一次随机选取一个误分类点使其梯度下降。</p><p>4．当训练数据集线性可分时，感知机学习算法是收敛的。感知机算法在训练数据集上的误分类次数<span class="math inline">\(k\)</span>满足不等式：</p><p><span class="math display">\[k \leqslant\left(\frac{R}{\gamma}\right)^{2}\]</span></p><p>当训练数据集线性可分时，感知机学习算法存在无穷多个解，其解由于不同的初值或不同的迭代顺序而可能有所不同。</p><h2 id="二分类模型">二分类模型</h2><p><span class="math display">\[f(x) = sign(w\cdot x + b)\]</span></p><p><span class="math display">\[\operatorname{sign}(x)=\left\{\begin{array}{ll}{+1,} &amp; {x \geqslant0} \\ {-1,} &amp; {x&lt;0}\end{array}\right.\]</span></p><p>给定训练集：</p><p><span class="math display">\[T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right),\cdots,\left(x_{N}, y_{N}\right)\right\}\]</span> 定义感知机的损失函数</p><p><span class="math display">\[L(w, b)=-\sum_{x_{i} \in M} y_{i}\left(w \cdot x_{i}+b\right)\]</span></p><h2 id="算法">算法</h2><p>随即梯度下降法 <code>Stochastic Gradient Descent</code></p><p>随机抽取一个误分类点使其梯度下降。</p><p><span class="math display">\[\begin{aligned}w&amp;=w+\eta y_i x_i \\b&amp;=b+\eta y_i\end{aligned}\]</span> 当实例点被误分类，即位于分离超平面的错误侧，则调整<span class="math inline">\(w\)</span>, <span class="math inline">\(b\)</span>的值，使分离超平面向该无分类点的一侧移动，直至误分类点被正确分类</p><p>拿出<code>iris</code>数据集中两个分类的数据和<code>[sepal length，sepal width]</code>作为特征</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># load data</span></span><br><span class="line">iris = load_iris()</span><br><span class="line">df = pd.DataFrame(iris.data, columns=iris.feature_names)</span><br><span class="line">df[<span class="string">'label'</span>] = iris.target</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">df.columns = [</span><br><span class="line">    <span class="string">'sepal length'</span>, <span class="string">'sepal width'</span>, <span class="string">'petal length'</span>, <span class="string">'petal width'</span>, <span class="string">'label'</span></span><br><span class="line">]</span><br><span class="line">df.label.value_counts()</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>2    501    500    50Name: label, dtype: int64</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">plt.scatter(df[:<span class="number">50</span>][<span class="string">'sepal length'</span>], df[:<span class="number">50</span>][<span class="string">'sepal width'</span>], label=<span class="string">'0'</span>)</span><br><span class="line">plt.scatter(df[<span class="number">50</span>:<span class="number">100</span>][<span class="string">'sepal length'</span>], df[<span class="number">50</span>:<span class="number">100</span>][<span class="string">'sepal width'</span>], label=<span class="string">'1'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'sepal length'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'sepal width'</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>&lt;matplotlib.legend.Legend at 0x1781578e588&gt;</code></pre><p><img src="../../../../images/第02章感知机/output_7_1.png"></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">data = np.array(df.iloc[:<span class="number">100</span>, [<span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>]])</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">X, y = data[:,:-<span class="number">1</span>], data[:,-<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">y = np.array([<span class="number">1</span> <span class="keyword">if</span> i == <span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> y])</span><br></pre></td></tr></tbody></table></figure><h2 id="perceptron">Perceptron</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 数据线性可分，二分类数据</span></span><br><span class="line"><span class="comment"># 此处为一元一次线性方程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.w = np.ones(<span class="built_in">len</span>(data[<span class="number">0</span>]) - <span class="number">1</span>, dtype=np.float32)</span><br><span class="line">        self.b = <span class="number">0</span></span><br><span class="line">        self.l_rate = <span class="number">0.1</span></span><br><span class="line">        <span class="comment"># self.data = data</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">self, x, w, b</span>):</span><br><span class="line">        y = np.dot(x, w) + b</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 随机梯度下降法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, X_train, y_train</span>):</span><br><span class="line">        is_wrong = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> is_wrong:</span><br><span class="line">            wrong_count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(X_train)):</span><br><span class="line">                X = X_train[d]</span><br><span class="line">                y = y_train[d]</span><br><span class="line">                <span class="keyword">if</span> y * self.sign(X, self.w, self.b) &lt;= <span class="number">0</span>:</span><br><span class="line">                    self.w = self.w + self.l_rate * np.dot(y, X)</span><br><span class="line">                    self.b = self.b + self.l_rate * y</span><br><span class="line">                    wrong_count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> wrong_count == <span class="number">0</span>:</span><br><span class="line">                is_wrong = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Perceptron Model!'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">perceptron = Model()</span><br><span class="line">perceptron.fit(X, y)</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>'Perceptron Model!'</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">x_points = np.linspace(<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>)</span><br><span class="line">y_ = -(perceptron.w[<span class="number">0</span>] * x_points + perceptron.b) / perceptron.w[<span class="number">1</span>]</span><br><span class="line">plt.plot(x_points, y_)</span><br><span class="line"></span><br><span class="line">plt.plot(data[:<span class="number">50</span>, <span class="number">0</span>], data[:<span class="number">50</span>, <span class="number">1</span>], <span class="string">'bo'</span>, color=<span class="string">'blue'</span>, label=<span class="string">'0'</span>)</span><br><span class="line">plt.plot(data[<span class="number">50</span>:<span class="number">100</span>, <span class="number">0</span>], data[<span class="number">50</span>:<span class="number">100</span>, <span class="number">1</span>], <span class="string">'bo'</span>, color=<span class="string">'orange'</span>, label=<span class="string">'1'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'sepal length'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'sepal width'</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>&lt;matplotlib.legend.Legend at 0x178158adfc8&gt;</code></pre><p><img src="../../../../images/第02章感知机/output_14_1.png"></p><h2 id="scikit-learn实例"><code>scikit-learn</code>实例</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sklearn</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Perceptron</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">sklearn.__version__</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>'0.23.1'</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">clf = Perceptron(fit_intercept=<span class="literal">True</span>, </span><br><span class="line">                 max_iter=<span class="number">1000</span>, </span><br><span class="line">                 shuffle=<span class="literal">True</span>)</span><br><span class="line">clf.fit(X, y)</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>Perceptron()</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Weights assigned to the features.</span></span><br><span class="line"><span class="built_in">print</span>(clf.coef_)</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>[[ 23.2 -38.7]]</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 截距 Constants in decision function.</span></span><br><span class="line"><span class="built_in">print</span>(clf.intercept_)</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>[-5.]</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 画布大小</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中文标题</span></span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>]=[<span class="string">'SimHei'</span>]</span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span></span><br><span class="line">plt.title(<span class="string">'鸢尾花线性数据示例'</span>)</span><br><span class="line"></span><br><span class="line">plt.scatter(data[:<span class="number">50</span>, <span class="number">0</span>], data[:<span class="number">50</span>, <span class="number">1</span>], c=<span class="string">'b'</span>, label=<span class="string">'Iris-setosa'</span>,)</span><br><span class="line">plt.scatter(data[<span class="number">50</span>:<span class="number">100</span>, <span class="number">0</span>], data[<span class="number">50</span>:<span class="number">100</span>, <span class="number">1</span>], c=<span class="string">'orange'</span>, label=<span class="string">'Iris-versicolor'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画感知机的线</span></span><br><span class="line">x_ponits = np.arange(<span class="number">4</span>, <span class="number">8</span>)</span><br><span class="line">y_ = -(clf.coef_[<span class="number">0</span>][<span class="number">0</span>]*x_ponits + clf.intercept_)/clf.coef_[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">plt.plot(x_ponits, y_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他部分</span></span><br><span class="line">plt.legend()  <span class="comment"># 显示图例</span></span><br><span class="line">plt.grid(<span class="literal">False</span>)  <span class="comment"># 不显示网格</span></span><br><span class="line">plt.xlabel(<span class="string">'sepal length'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'sepal width'</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>&lt;matplotlib.legend.Legend at 0x17815902248&gt;</code></pre><p><img src="../../../../images/第02章感知机/output_21_1.png"> ​</p><p><strong>注意 !</strong></p><p>在上图中，有一个位于左下角的蓝点没有被正确分类，这是因为<code>SKlearn</code>的<code>Perceptron</code>实例中有一个<code>tol</code>参数。</p><p><code>tol</code>参数规定了如果本次迭代的损失和上次迭代的损失之差小于一个特定值时，停止迭代。所以需要设置<code>tol=None</code> 使之可以继续迭代：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">clf = Perceptron(fit_intercept=<span class="literal">True</span>, </span><br><span class="line">                 max_iter=<span class="number">1000</span>,</span><br><span class="line">                 tol=<span class="literal">None</span>,</span><br><span class="line">                 shuffle=<span class="literal">True</span>)</span><br><span class="line">clf.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画布大小</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中文标题</span></span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>]=[<span class="string">'SimHei'</span>]</span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span></span><br><span class="line">plt.title(<span class="string">'鸢尾花线性数据示例'</span>)</span><br><span class="line"></span><br><span class="line">plt.scatter(data[:<span class="number">50</span>, <span class="number">0</span>], data[:<span class="number">50</span>, <span class="number">1</span>], c=<span class="string">'b'</span>, label=<span class="string">'Iris-setosa'</span>,)</span><br><span class="line">plt.scatter(data[<span class="number">50</span>:<span class="number">100</span>, <span class="number">0</span>], data[<span class="number">50</span>:<span class="number">100</span>, <span class="number">1</span>], c=<span class="string">'orange'</span>, label=<span class="string">'Iris-versicolor'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画感知机的线</span></span><br><span class="line">x_ponits = np.arange(<span class="number">4</span>, <span class="number">8</span>)</span><br><span class="line">y_ = -(clf.coef_[<span class="number">0</span>][<span class="number">0</span>]*x_ponits + clf.intercept_)/clf.coef_[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">plt.plot(x_ponits, y_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他部分</span></span><br><span class="line">plt.legend()  <span class="comment"># 显示图例</span></span><br><span class="line">plt.grid(<span class="literal">False</span>)  <span class="comment"># 不显示网格</span></span><br><span class="line">plt.xlabel(<span class="string">'sepal length'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'sepal width'</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>&lt;matplotlib.legend.Legend at 0x1781588e608&gt;</code></pre><p><img src="../../../../images/第02章感知机/output_23_1.png"></p><p>现在可以看到，所有的两种鸢尾花都被正确分类了。</p><hr><h2 id="第2章感知机-习题">第2章感知机-习题</h2><p>  Minsky 与 Papert指出：感知机因为是线性模型，所以不能表示复杂的函数，如<code>异或 (XOR)</code>。验证感知机为什么不能表示异或。</p><p><strong>解答：</strong></p><p>对于异或函数XOR，全部的输入与对应的输出如下：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(x^{(1)}\)</span></th><th style="text-align: center;"><span class="math inline">\(x^{(2)}\)</span></th><th style="text-align: center;"><span class="math inline">\(y\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">&nbsp;1</td><td style="text-align: center;">&nbsp;1</td><td style="text-align: center;">-1</td></tr><tr class="even"><td style="text-align: center;">&nbsp;1</td><td style="text-align: center;">-1</td><td style="text-align: center;">&nbsp;1</td></tr><tr class="odd"><td style="text-align: center;">-1</td><td style="text-align: center;">&nbsp;1</td><td style="text-align: center;">&nbsp;1</td></tr><tr class="even"><td style="text-align: center;">-1</td><td style="text-align: center;">-1</td><td style="text-align: center;">-1</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
          <category> 机器学习方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1章 统计学习方法概论</title>
      <link href="/2024/04/28/di-01-zhang-tong-ji-xue-xi-fang-fa-gai-lun/"/>
      <url>/2024/04/28/di-01-zhang-tong-ji-xue-xi-fang-fa-gai-lun/</url>
      
        <content type="html"><![CDATA[<h1 id="第1章-统计学习方法概论">第1章 统计学习方法概论</h1><h3 id="使用最小二乘法拟和曲线">使用最小二乘法拟和曲线</h3><p>高斯于1823年在误差<span class="math inline">\(e_1,…,e_n\)</span>独立同分布的假定下,证明了最小二乘方法的一个最优性质:在所有无偏的线性估计类中,最小二乘方法是其中方差最小的。 对于数据<span class="math inline">\((x_i, y_i)   (i=1, 2, 3...,m)\)</span></p><p>拟合出函数<span class="math inline">\(h(x)\)</span></p><p>有误差，即残差：<span class="math inline">\(r_i=h(x_i)-y_i\)</span></p><p>此时<span class="math inline">\(L2\)</span>范数(残差平方和)最小时，<span class="math inline">\(h(x)\)</span> 和 <span class="math inline">\(y\)</span> 相似度最高，更拟合</p><p>一般的<span class="math inline">\(H(x)\)</span>为<span class="math inline">\(n\)</span>次的多项式： <span class="math display">\[H(x)=w_0+w_1x+w_2x^2+...w_nx^n\]</span> <span class="math inline">\(w(w_0,w_1,w_2,...,w_n)\)</span>为参数</p><p>最小二乘法就是要找到一组 <span class="math inline">\(w(w_0,w_1,w_2,...,w_n)\)</span> ，使得<span class="math inline">\(\sum_{i=1}^n(h(x_i)-y_i)^2\)</span> (残差平方和)最小</p><p>即，求 <span class="math display">\[min\sum_{i=1}^n(h(x_i)-y_i)^2\]</span></p><hr><p>举例：用目标函数<span class="math inline">\(y=sin2{\pi}x\)</span>,加上一个正态分布的噪音干扰，用多项式去拟合</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy <span class="keyword">as</span> sp</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> leastsq</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></tbody></table></figure><ul><li>ps: <code>numpy.poly1d([1,2,3])</code> 生成 <span class="math inline">\(1x^2+2x^1+3x^0\)</span>*</li></ul><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 目标函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">real_func</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> np.sin(<span class="number">2</span>*np.pi*x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多项式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fit_func</span>(<span class="params">p, x</span>):</span><br><span class="line">    f = np.poly1d(p)</span><br><span class="line">    <span class="keyword">return</span> f(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 残差</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">residuals_func</span>(<span class="params">p, x, y</span>):</span><br><span class="line">    ret = fit_func(p, x) - y</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 十个点</span></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">x_points = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="comment"># 加上正态分布噪音的目标函数的值</span></span><br><span class="line">y_ = real_func(x)</span><br><span class="line">y = [np.random.normal(<span class="number">0</span>, <span class="number">0.1</span>) + y1 <span class="keyword">for</span> y1 <span class="keyword">in</span> y_]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fitting</span>(<span class="params">M=<span class="number">0</span></span>):</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    M    为 多项式的次数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 随机初始化多项式参数</span></span><br><span class="line">    p_init = np.random.rand(M + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 最小二乘法</span></span><br><span class="line">    p_lsq = leastsq(residuals_func, p_init, args=(x, y))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Fitting Parameters:'</span>, p_lsq[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可视化</span></span><br><span class="line">    plt.plot(x_points, real_func(x_points), label=<span class="string">'real'</span>)</span><br><span class="line">    plt.plot(x_points, fit_func(p_lsq[<span class="number">0</span>], x_points), label=<span class="string">'fitted curve'</span>)</span><br><span class="line">    plt.plot(x, y, <span class="string">'bo'</span>, label=<span class="string">'noise'</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    <span class="keyword">return</span> p_lsq</span><br></pre></td></tr></tbody></table></figure><h3 id="m0">M=0</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># M=0</span></span><br><span class="line">p_lsq_0 = fitting(M=<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>Fitting Parameters: [0.02515259]</code></pre><p><img src="../../../../images/第01章统计学习方法概论/output_10_1.png"></p><h3 id="m1">M=1</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># M=1</span></span><br><span class="line">p_lsq_1 = fitting(M=<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>Fitting Parameters: [-1.50626624  0.77828571]</code></pre><p><img src="../../../../images/第01章统计学习方法概论/output_12_1.png"></p><h3 id="m3">M=3</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># M=3</span></span><br><span class="line">p_lsq_3 = fitting(M=<span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>Fitting Parameters: [ 2.21147559e+01 -3.34560175e+01  1.13639167e+01 -2.82318048e-02]</code></pre><p><img src="../../../../images/第01章统计学习方法概论/output_14_1.png"></p><h3 id="m9">M=9</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># M=9</span></span><br><span class="line">p_lsq_9 = fitting(M=<span class="number">9</span>)</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>Fitting Parameters: [-1.70872086e+04  7.01364939e+04 -1.18382087e+05  1.06032494e+05 -5.43222991e+04  1.60701108e+04 -2.65984526e+03  2.12318870e+02 -7.15931412e-02  3.53804263e-02]</code></pre><p><img src="../../../../images/第01章统计学习方法概论/output_16_1.png"></p><p>当M=9时，多项式曲线通过了每个数据点，但是造成了过拟合</p><h3 id="正则化">正则化</h3><p>结果显示过拟合，引入<code>正则化项(regularizer)</code>，降低过拟合</p><p><span class="math display">\[Q(x)=\sum_{i=1}^n(h(x_i)-y_i)^2+\lambda||w||^2\]</span>回归问题中，损失函数是平方损失，正则化可以是参数向量的<code>L2</code>范数,也可以是<code>L1</code>范数。</p><ul><li><p><span class="math inline">\(L1\)</span>: <span class="math inline">\(\|v\|_1=\sum_{n=1}^N\left|v_n\right|\)</span></p></li><li><p><span class="math inline">\(L2\)</span>: <span class="math inline">\(\|v\|_2=\sqrt{\sum_{n=1}^N v_n^2}=\sqrt{v Tv}\)</span></p></li></ul><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">regularization = <span class="number">0.0001</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">residuals_func_regularization</span>(<span class="params">p, x, y</span>):</span><br><span class="line">    ret = fit_func(p, x) - y</span><br><span class="line">    ret = np.append(ret,</span><br><span class="line">                    np.sqrt(<span class="number">0.5</span> * regularization * np.square(p)))  <span class="comment"># L2范数作为正则化项</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 最小二乘法,加正则化项</span></span><br><span class="line">p_init = np.random.rand(<span class="number">9</span> + <span class="number">1</span>)</span><br><span class="line">p_lsq_regularization = leastsq(</span><br><span class="line">    residuals_func_regularization, p_init, args=(x, y))</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">plt.plot(x_points, real_func(x_points), label=<span class="string">'real'</span>)</span><br><span class="line">plt.plot(x_points, fit_func(p_lsq_9[<span class="number">0</span>], x_points), label=<span class="string">'fitted curve'</span>)</span><br><span class="line">plt.plot(</span><br><span class="line">    x_points,</span><br><span class="line">    fit_func(p_lsq_regularization[<span class="number">0</span>], x_points),</span><br><span class="line">    label=<span class="string">'regularization'</span>)</span><br><span class="line">plt.plot(x, y, <span class="string">'bo'</span>, label=<span class="string">'noise'</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></tbody></table></figure><p><code>Output[ ]</code></p><pre><code>&lt;matplotlib.legend.Legend at 0x295a5c757b8&gt;</code></pre><p><img src="../../../../images/第01章统计学习方法概论/output_22_1.png"></p><h2 id="第1章统计学习方法概论-习题">第1章统计学习方法概论-习题</h2><h3 id="习题1.1">习题1.1</h3><p>  说明伯努利模型的极大似然估计以及贝叶斯估计中的统计学习方法三要素。伯努利模型是定义在取值为0与1的随机变量上的概率分布。假设观测到伯努利模型<span class="math inline">\(n\)</span>次独立的数据生成结果，其中<span class="math inline">\(k\)</span>次的结果为1，这时可以用极大似然估计或贝叶斯估计来估计结果为1的概率。</p><p><strong>解答：</strong></p><p>伯努利模型的极大似然估计以及贝叶斯估计中的<strong>统计学习方法三要素</strong>如下：<br>1. <strong>极大似然估计</strong><br><strong>模型：</strong> <span class="math inline">\(\mathcal{F}=\{f|f_p(x)=p^x(1-p)^{(1-x)}\}\)</span><br><strong>策略：</strong> 最大化似然函数<br><strong>算法：</strong> <span class="math inline">\(\displaystyle\mathop{\arg\min}_{p} L(p)= \mathop{\arg\min}_{p}\binom{n}{k}p^k(1-p)^{(n-k)}\)</span> 2.<strong>贝叶斯估计</strong><br><strong>模型：</strong> <span class="math inline">\(\mathcal{F}=\{f|f_p(x)=p^x(1-p)^{(1-x)}\}\)</span><br><strong>策略：</strong> 求参数期望<br><strong>算法：</strong> <span class="math display">\[  \begin{aligned}  E_\pi\big[p \big| y_1,\cdots,y_n\big]  &amp; = {\int_0^1}p\pi (p|y_1,\cdots,y_n) dp \\  &amp; = {\int_0^1}p\frac{f_D(y_1,\cdots,y_n|p)\pi(p)}{\int_{\Omega}f_D(y_1,\cdots,y_n|p)\pi(p)dp}dp\\  &amp; = {\int_0^1}\frac{p^{k+1}(1-p)^{(n-k)}}{\int_0^1p^k(1-p)^{(n-k)}dp}dp  \end{aligned}\]</span></p><p><strong>伯努利模型的极大似然估计：</strong><br>定义<span class="math inline">\(P(Y=1)\)</span>概率为<span class="math inline">\(p\)</span>，可得似然函数为： <span class="math display">\[L(p)=f_D(y_1,y_2,\cdots,y_n|\theta)=\binom{n}{k}p^k(1-p)^{(n-k)}\]</span> 方程两边同时对<span class="math inline">\(p\)</span>求导，则：<span class="math display">\[\begin{aligned}0 &amp; = \binom{n}{k}[kp^{k-1}(1-p)^{(n-k)}-(n-k)p^k(1-p)^{(n-k-1)}]\\&amp; = \binom{n}{k}[p^{(k-1)}(1-p)^{(n-k-1)}(m-kp)]\end{aligned}\]</span> 可解出<span class="math inline">\(p\)</span>的值为 <span class="math display">\[p=0,p=1,p=k/n\]</span> 显然 <span class="math display">\[\displaystyle P(Y=1)=p=\frac{k}{n}\]</span> <strong>伯努利模型的贝叶斯估计：</strong><br>定义<span class="math inline">\(P(Y=1)\)</span>概率为<span class="math inline">\(p\)</span>，<span class="math inline">\(p\)</span>在<span class="math inline">\([0,1]\)</span>之间的取值是等概率的，因此先验概率密度函数<span class="math inline">\(\pi(p) = 1\)</span>，可得似然函数为： <span class="math display">\[L(p)=f_D(y_1,y_2,\cdots,y_n|\theta)=\binom{n}{k}p^k(1-p)^{(n-k)}\]</span></p><p>根据似然函数和先验概率密度函数，可以求解<span class="math inline">\(p\)</span>的条件概率密度函数： <span class="math display">\[\begin{aligned}\pi(p|y_1,\cdots,y_n)&amp;=\frac{f_D(y_1,\cdots,y_n|p)\pi(p)}{\int_{\Omega}f_D(y_1,\cdots,y_n|p)\pi(p)dp}\\&amp;=\frac{p^k(1-p)^{(n-k)}}{\int_0^1p^k(1-p)^{(n-k)}dp}\\&amp;=\frac{p^k(1-p)^{(n-k)}}{B(k+1,n-k+1)}\end{aligned}\]</span> 所以<span class="math inline">\(p\)</span>的期望为： <span class="math display">\[\begin{aligned}E_\pi[p|y_1,\cdots,y_n]&amp;={\int}p\pi(p|y_1,\cdots,y_n)dp \\&amp; = {\int_0^1}\frac{p^{(k+1)}(1-p)^{(n-k)}}{B(k+1,n-k+1)}dp \\&amp; = \frac{B(k+2,n-k+1)}{B(k+1,n-k+1)}\\&amp; = \frac{k+1}{n+2}\end{aligned}\]</span></p><p><span class="math inline">\(\therefore \displaystyleP(Y=1)=\frac{k+1}{n+2}\)</span></p><h3 id="习题1.2">习题1.2</h3><p>  通过经验风险最小化推导极大似然估计。证明模型是条件概率分布，当损失函数是对数损失函数时，经验风险最小化等价于极大似然估计。</p><p><strong>解答：</strong></p><p>假设模型的条件概率分布是<span class="math inline">\(P_{\theta}(Y|X)\)</span>，现推导当损失函数是对数损失函数时，极大似然估计等价于经验风险最小化。极大似然估计的似然函数为： <span class="math display">\[L(\theta)=\prod_D P_{\theta}(Y|X)\]</span> 两边取对数： <span class="math display">\[\ln L(\theta) = \sum_D \ln P_{\theta}(Y|X) \\\mathop{\arg \max}_{\theta} \sum_D \ln P_{\theta}(Y|X) = \mathop{\arg\min}_{\theta} \sum_D (- \ln P_{\theta}(Y|X))\]</span>反之，经验风险最小化等价于极大似然估计，亦可通过经验风险最小化推导极大似然估计。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
          <category> 机器学习方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四节 多维随机变量的特征数</title>
      <link href="/2024/04/27/gai-lu-lun-3-4-duo-wei-sui-ji-bian-liang-de-te-zheng-shu/"/>
      <url>/2024/04/27/gai-lu-lun-3-4-duo-wei-sui-ji-bian-liang-de-te-zheng-shu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/itaGp1wqr47i">下载PDF点这里</a></p><p><img src="../../../../images/概率论3-4多维随机变量的特征数/73.jpg"></p><p><img src="../../../../images/概率论3-4多维随机变量的特征数/74.jpg"></p><p><img src="../../../../images/概率论3-4多维随机变量的特征数/75.jpg"></p><p><img src="../../../../images/概率论3-4多维随机变量的特征数/76.jpg"></p><p><img src="../../../../images/概率论3-4多维随机变量的特征数/77.jpg"></p><p><img src="../../../../images/概率论3-4多维随机变量的特征数/78.jpg"></p><p><img src="../../../../images/概率论3-4多维随机变量的特征数/79.jpg"></p><p><img src="../../../../images/概率论3-4多维随机变量的特征数/80.jpg"></p><p><img src="../../../../images/概率论3-4多维随机变量的特征数/81.jpg"></p><p><img src="../../../../images/概率论3-4多维随机变量的特征数/82.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第三章 多维随机变量及其分布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多维随机变量 </tag>
            
            <tag> 多为随机变量函数的数学期望 </tag>
            
            <tag> 协方差 </tag>
            
            <tag> 相关系数 </tag>
            
            <tag> 协方差矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五节 条件分布与条件期望</title>
      <link href="/2024/04/27/gai-lu-lun-3-5-tiao-jian-fen-bu-yu-tiao-jian-qi-wang/"/>
      <url>/2024/04/27/gai-lu-lun-3-5-tiao-jian-fen-bu-yu-tiao-jian-qi-wang/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iV0Nd1wmvnni">下载PDF点这里</a></p><p><img src="../../../../images/概率论3-5条件分布与条件期望/82.jpg"></p><p><img src="../../../../images/概率论3-5条件分布与条件期望/83.jpg"></p><p><img src="../../../../images/概率论3-5条件分布与条件期望/84.jpg"></p><p><img src="../../../../images/概率论3-5条件分布与条件期望/85.jpg"></p><p><img src="../../../../images/概率论3-5条件分布与条件期望/86.jpg"></p><p><img src="../../../../images/概率论3-5条件分布与条件期望/87.jpg"></p><p><img src="../../../../images/概率论3-5条件分布与条件期望/88.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第三章 多维随机变量及其分布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多维随机变量 </tag>
            
            <tag> 条件分布 </tag>
            
            <tag> 条件期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三节 多维随机变量函数的分布</title>
      <link href="/2024/04/27/gai-lu-lun-3-3-duo-wei-sui-ji-bian-liang-han-shu-de-fen-bu/"/>
      <url>/2024/04/27/gai-lu-lun-3-3-duo-wei-sui-ji-bian-liang-han-shu-de-fen-bu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iFumU1wqoneb">下载PDF点这里</a></p><p><img src="../../../../images/概率论3-3多维随机变量函数的分布/59.jpg"></p><p><img src="../../../../images/概率论3-3多维随机变量函数的分布/60.jpg"></p><p><img src="../../../../images/概率论3-3多维随机变量函数的分布/61.jpg"></p><p><img src="../../../../images/概率论3-3多维随机变量函数的分布/62.jpg"></p><p><img src="../../../../images/概率论3-3多维随机变量函数的分布/63.jpg"></p><p><img src="../../../../images/概率论3-3多维随机变量函数的分布/64.jpg"></p><p><img src="../../../../images/概率论3-3多维随机变量函数的分布/65.jpg"></p><p><img src="../../../../images/概率论3-3多维随机变量函数的分布/66.jpg"></p><p><img src="../../../../images/概率论3-3多维随机变量函数的分布/67.jpg"></p><p><img src="../../../../images/概率论3-3多维随机变量函数的分布/68.jpg"></p><p><img src="../../../../images/概率论3-3多维随机变量函数的分布/69.jpg"></p><p><img src="../../../../images/概率论3-3多维随机变量函数的分布/70.jpg"></p><p><img src="../../../../images/概率论3-3多维随机变量函数的分布/71.jpg"></p><p><img src="../../../../images/概率论3-3多维随机变量函数的分布/72.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第三章 多维随机变量及其分布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多维随机变量 </tag>
            
            <tag> 最大值与最小值分布 </tag>
            
            <tag> 卷积公式 </tag>
            
            <tag> 变量变换法 </tag>
            
            <tag> 雅可比矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四节 中心极限定理</title>
      <link href="/2024/04/27/gai-lu-lun-4-4-zhong-xin-ji-xian-ding-li/"/>
      <url>/2024/04/27/gai-lu-lun-4-4-zhong-xin-ji-xian-ding-li/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iYRvn1wmhoob">下载PDF点这里</a></p><p><img src="../../../../images/概率论4-4中心极限定理/105.jpg"></p><p><img src="../../../../images/概率论4-4中心极限定理/106.jpg"></p><p><img src="../../../../images/概率论4-4中心极限定理/107.jpg"></p><p><img src="../../../../images/概率论4-4中心极限定理/108.jpg"></p><p><img src="../../../../images/概率论4-4中心极限定理/109.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第四章 大数定律与中心极限定理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 林德伯格-莱维定理 </tag>
            
            <tag> 棣莫佛-拉普拉斯定理 </tag>
            
            <tag> 林德伯格中心极限定理 </tag>
            
            <tag> 李雅普诺夫中心极限定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三节 大数定律</title>
      <link href="/2024/04/27/gai-lu-lun-4-3-da-shu-ding-lu/"/>
      <url>/2024/04/27/gai-lu-lun-4-3-da-shu-ding-lu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iBFmK1wiilsj">下载PDF点这里</a></p><p><img src="../../../../images/概率论4-3大数定律/100.jpg"></p><p><img src="../../../../images/概率论4-3大数定律/101.jpg"></p><p><img src="../../../../images/概率论4-3大数定律/102.jpg"></p><p><img src="../../../../images/概率论4-3大数定律/103.jpg"></p><p><img src="../../../../images/概率论4-3大数定律/104.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第四章 大数定律与中心极限定理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 伯努利大数定律 </tag>
            
            <tag> 切比雪夫大数定律 </tag>
            
            <tag> 马尔可夫大数定律 </tag>
            
            <tag> 辛钦大数定律 </tag>
            
            <tag> 蒙特卡罗方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二节 特征函数</title>
      <link href="/2024/04/27/gai-lu-lun-4-2-te-zheng-han-shu/"/>
      <url>/2024/04/27/gai-lu-lun-4-2-te-zheng-han-shu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/i0C2k1woq1je">下载PDF点这里</a></p><p><img src="../../../../images/概率论4-2特征函数/95.jpg"></p><p><img src="../../../../images/概率论4-2特征函数/96.jpg"></p><p><img src="../../../../images/概率论4-2特征函数/97.jpg"></p><p><img src="../../../../images/概率论4-2特征函数/98.jpg"></p><p><img src="../../../../images/概率论4-2特征函数/99.jpg"></p><p><img src="../../../../images/概率论4-2特征函数/100.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第四章 大数定律与中心极限定理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 特征函数 </tag>
            
            <tag> 逆转公式 </tag>
            
            <tag> 特征函数连续性定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一节 随机变量序列的两种收敛性</title>
      <link href="/2024/04/26/gai-lu-lun-4-1-sui-ji-bian-liang-xu-lie-de-liang-chong-shou-lian-xing/"/>
      <url>/2024/04/26/gai-lu-lun-4-1-sui-ji-bian-liang-xu-lie-de-liang-chong-shou-lian-xing/</url>
      
        <content type="html"><![CDATA[<p><img src="../../../../images/概率论4-1随机变量序列的两种收敛性/94.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第四章 大数定律与中心极限定理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 依概率收敛 </tag>
            
            <tag> 依分布收敛 </tag>
            
            <tag> 弱收敛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目标检测中数据集格式之间的相互转换</title>
      <link href="/2024/04/24/shen-du-xue-xi-mu-biao-jian-ce-zhong-shu-ju-ji-ge-shi-zhi-jian-de-xiang-hu-zhuan-huan/"/>
      <url>/2024/04/24/shen-du-xue-xi-mu-biao-jian-ce-zhong-shu-ju-ji-ge-shi-zhi-jian-de-xiang-hu-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<h1 id="目标检测中数据集格式之间的相互转换">目标检测中数据集格式之间的相互转换</h1><blockquote><p>主要涉及--voc、coco、yolo之间的格式转换</p><p>即.xml、.json、.txt格式之间的转换</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/461488682">看这篇文章</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一节 总体与样本</title>
      <link href="/2024/04/23/shu-li-tong-ji-5-1-zong-ti-yu-yang-ben/"/>
      <url>/2024/04/23/shu-li-tong-ji-5-1-zong-ti-yu-yang-ben/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/ib6cL1w9jali">下载PDF点这里</a></p><p><img src="../../../../images/数理统计5-1总体与样本/2.jpg"></p><p><img src="../../../../images/数理统计5-1总体与样本/3.jpg"></p><p><img src="../../../../images/数理统计5-1总体与样本/4.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 数理统计 </category>
          
          <category> 第一章 统计量及其分布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总体 </tag>
            
            <tag> 个体 </tag>
            
            <tag> 样本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零节 概率母函数</title>
      <link href="/2024/04/23/gai-lu-lun-4-0-gai-lu-mu-han-shu/"/>
      <url>/2024/04/23/gai-lu-lun-4-0-gai-lu-mu-han-shu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iCEiV1w8l80b">下载PDF点这里</a></p><p><img src="../../../../images/概率论4-0概率母函数/89.jpg"></p><p><img src="../../../../images/概率论4-0概率母函数/90.jpg"></p><p><img src="../../../../images/概率论4-0概率母函数/91.jpg"></p><p><img src="../../../../images/概率论4-0概率母函数/92.jpg"></p><p><img src="../../../../images/概率论4-0概率母函数/93.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第四章 大数定律与中心极限定理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率母函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>税法概述及货物和劳务税法律制度(上)</title>
      <link href="/2024/04/22/jing-ji-fa-ji-chu-1-1-chen/"/>
      <url>/2024/04/22/jing-ji-fa-ji-chu-1-1-chen/</url>
      
        <content type="html"><![CDATA[<blockquote><p>投稿自宸溦</p></blockquote><h2 id="税法概述及货物和劳务税法律制度">税法概述及货物和劳务税法律制度</h2><h3 id="税收法律制度概述">税收法律制度概述</h3><h4 id="税收及税法">税收及税法</h4><p>税收的主体是<u>国家</u>，征税的依据是<u>政治权力</u>，税收的目的是<u>实现国家职能、取得财政收入</u>，税收的本质<u>是一种特定的分配形式</u>，税收的特征是<u>强制性、无偿性、固定性。</u></p><ul><li>税法即<u>税收法律制度</u>，是调整税收关系的法律规范的总称。</li></ul><p>在我国税收法律关系中：主体的一方是代表国家行使征税职责的机关，包括国家各级税务机关和海关，另一方是履行纳税义务的人，包括法人、自然人和其他组织；我国税收法律关系确定主体的时候采取属地兼属人的原则。</p><ul><li><p>税收法律关系的内容：主体所享受的权利和所承担的义务（这是税收法律关系中最实质的东西，是税法的灵魂）</p></li><li><p>海关征税：关税，船舶吨税，委托代征的进口环节的增值税、消费税。</p></li><li><p>税务机关征收管理：除海关负责的税种以外的其他所有税种，部分非税收入和社会保险费的征收。</p></li></ul><h4 id="税法要素">税法要素</h4><p>税法要素一般包括纳税人、征税对象、税率、计税依据、纳税环节、纳税期限、纳税地点、税收优惠、法律责任等。</p><ul><li>税法要素解决的是“对谁征”“对什么征”“征多少、怎么算”“什么时间”“什么地点”“有什么优惠”等问题</li></ul><p>纳税人是指依法直接负有纳税义务的法人、自然人和其他组织。（提示：需要注意区分纳税人与扣缴义务人的概念，扣缴义务人是指税法规定的，在其经营活动中负有代扣或代收税款并向国库缴纳义务的单位。）</p><p>征税对象指税收法律关系中权利义务所指的对象，即“对什么征税”。不同的征税对象是区别不同税种的重要标志。例如，企业所得税法律关系的征税对象，就是生产经营所得和其他所得。</p><p>税率是计算税额的尺度，是税收法律制度中的核心要素。我国现行的税率主要有以下三种：比例税率、定额税率、累进税率。</p><ul><li>计税依据：从量计征、从价计征、复合计征</li></ul><p>1.纳税环节纳税环节，主要是指税法规定的征税对象在从生产到消费的流转过程中应当缴纳税款的环节。</p><p>2.纳税期限具体包括：包括纳税义务发生时间、纳税期限和缴库期限。</p><p>3.纳税地点纳税人（包括代征、代扣、代缴义务人）具体申报缴纳税款的地点。</p><p>减税和免税：少征部分税款即为减税，对于应征收的税款予以免除即为免税。</p><p>起征点：起征点，也称“征税起点”，是指对征税对象开始征税的数额界限。征税对象的数额没有达到规定起征点的不征税；达到或超过起征点的，就其全部数额征税。</p><p>免征额：免征额，是指对征税对象中的一部分给予减免，只就减除后的剩余部分征税。</p><h3 id="增值税法律制度">增值税法律制度</h3><p>增值税是对销售货物、劳务或服务等行为中实现的增值额征收的一种税。增值税在每一道流转环节都要征收，征收的范围非常广泛。从2012 年一直到 2016年，我国逐步在全国范围内开展“营业税”改征“增值税”的改革（简称为“营改增”）。分阶段逐步将过去征收营业税的交通运输、邮政、电信、建筑、金融、现代服务业、生活服务业、房地产等行业全面纳入增值税的征税范围。从2016 年5月1日起，我国全面营改增正式完成，全部行业全面征收增值税，营业税正式成为历史。</p><h4 id="增值税征税范围">增值税征税范围</h4><p>增值税的征税范围包括在中华人民共和国境内销售货物或者劳务，销售服务、无形资产、不动产以及进口货物。</p><h5 id="一销售货物">（一）销售货物</h5><p>销售货物是指有偿转让货物的所有权。（1）货物，是指有形动产，包括电力、热力、气体在内。</p><p>（2）有偿，是指从购买方取得货币、货物或者其他经济利益（如抵偿债务）。</p><h5 id="二销售劳务">（二）销售劳务</h5><p>销售劳务是指有偿提供加工、修理修配劳务。提示：单位或者个体工商户聘用的员工为本单位或者雇主提供加工、修理修配劳务不包括在内。</p><h5 id="三销售服务">（三）销售服务</h5><p>销售服务是指提供交通运输服务、邮政服务、电信服务、建筑服务、金融服务、现代服务和生活服务。</p><p>各项服务的具体范围如下：</p><p>1.交通运输服务包括陆路运输服务、水路运输服务、航空运输服务、管道运输服务等。（提示：无运输工具承运业务，按照交通运输服务缴纳增值税。）</p><ul><li>原理：</li></ul><p>（1）水路运输服务的“程租”“期租”和航空运输服务的“湿租”业务的共同特点是配备有操作人员、机组人员，所以从实质上来判断属于交通运输服务；</p><p>（2）而水路运输服务中的“光租”和航空运输服务中的“干租”业务的共同特点是不配有操作人员或机组人员，单纯租赁船只或飞机，故不属于交通运输服务，属于“现代服务——租赁服务”。</p><p>2.邮政服务包括邮票发行、报刊发行等邮政普遍服务，机要通信等邮政特殊服务和邮品销售、邮政代理等其他邮政服务。提示：邮政汇兑属于邮政服务，但邮政储蓄业务按金融服务缴纳增值税。</p><p>3.电信服务包括基础电信服务和增值电信服务。</p><p>（1）基础电信服务：包括语音通话服务业务，以及出租或者出售带宽等业务。</p><p>（2）增值电信服务：提供短信彩信、互联网接入、卫星电视信号落地转接等业务活动。</p><p>4.建筑服务包括工程服务、安装服务、修缮服务、装饰服务和其他建筑服务。</p><p>5.金融服务包括贷款服务、直接收费金融服务、保险服务和金融商品转让。</p><p>（1）贷款服务，是指将资金贷与他人使用而取得利息收入的业务活动。具体包括：金融商品持有期间（含到期）利息（或保本收益、报酬、资金占用费等）收入、信用卡透支利息收入、买入返售金融商品利息收入、融资融券收取的利息收入，以及融资性售后回租、押汇、罚息、票据贴现、转贷等业务取得的利息及利息性质的收入。</p><p>（2）直接收费金融服务，包括：提供货币兑换、账户管理、电子银行、信用卡、信用证、财务担保、资产管理、信托管理、基金管理、金融交易场所（平台）管理、资金结算、资金清算、金融支付等服务。</p><p>（3）保险服务，包括人身保险服务和财产保险服务。</p><p>（4）金融商品转让，指转让外汇、有价证券、非货物期货和其他金融商品（基金、信托、理财产品等各类资产管理产品和各种金融衍生品）的所有权取得的收入。</p><ul><li>注意：区分直接收费金融服务与贷款服务！（直接收费金融服务不是出借资金收取利息，而是提供了服务而收取的服务费，如银行卡收单业务手续费，以及第三章中学到的银行提供支付结算服务收取的资金结算费用等。）</li></ul><p>6.现代服务</p><p>（1）研发和技术服务，包括研发服务、合同能源管理服务、工程勘察勘探服务、专业技术服务。</p><p>（2）信息技术服务，包括软件服务、电路设计及测试服务、信息系统服务、业务流程管理服务和信息系统增值服务。</p><p>（3）文化创意服务，包括设计服务、知识产权服务、广告服务和会议展览服务。</p><p>（4）广播影视服务，包括广播影视节目（作品）的制作服务、发行服务和播映（含放映）服务。</p><p>（5）租赁服务，包括有形动产、不动产的经营租赁和融资租赁。</p><p>（6）物流辅助服务，包括航空服务、港口码头服务、货运客运场站服务、打捞救助服务、装卸搬运服务、仓储服务和收派服务。</p><p>（7）商务辅助服务，包括企业管理服务、经纪代理服务、人力资源服务、安全保护服务。</p><p>（8）鉴证咨询服务，包括认证服务、鉴证服务和咨询服务。翻译服务和市场调查服务按照咨询服务缴纳增值税。</p><p>（9）其他现代服务。除上述服务以外的现代服务。</p><p>7.生活服务</p><p>包括文化体育服务、教育医疗服务、旅游娱乐服务、餐饮住宿服务、居民日常服务和其他生活服务。其中“居民日常服务”包括市容市政管理、家政、婚庆、养老、殡葬、照料和护理、救助救济、美容美发、按摩、桑拿、氧吧、足疗、沐浴、洗染、摄影扩印等服务。</p><h5 id="四销售无形资产">（四）销售无形资产</h5><p>销售无形资产，是指转让无形资产所有权或者使用权的业务活动。其中“无形资产”包括：</p><p>（1）技术（专利技术和非专利技术）；</p><p>（2）商标、著作权；</p><p>（3）商誉；</p><p>（4）自然资源使用权，包括土地使用权、海域使用权、探矿权、采矿权、取水权等；</p><p>（5）其他权益性无形资产。例如：基础设施资产经营权、公共事业特许权、特许经营权、连锁经营权、经销权、分销权、代理权、会员权、席位权、网络游戏虚拟道具、域名、名称权、肖像权、冠名权、转会费等。</p><h5 id="五销售不动产">（五）销售不动产</h5><p>销售不动产是指转让不动产所有权的业务活动。</p><h5 id="六进口货物">（六）进口货物</h5><p>只要是报关进口的应税货物，均属于增值税的征税范围，除免税货物外，在进口环节均应缴纳增值税。</p><p>提示：销售不动产及销售无形资产两税目的区分，又是一个常见“挖坑点”，应注意辨析如下易错易混的项目：</p><p>（1）转让基础设施资产的“经营权”，属于销售无形资产；</p><p>（2）单独转让自然资源的使用权（包括土地使用权），属于销售无形资产；</p><p>（3）转让建筑物的产权、所有权或永久使用权，属于销售不动产；</p><p>（4）“房地一起卖”：在转让建筑物或者构筑物时一并转让其所占土地的使用权，一并按照销售不动产缴纳增值税。</p><h4 id="增值税纳税人和扣缴义务人">增值税纳税人和扣缴义务人</h4><h5 id="一纳税人">（一）纳税人</h5><p>1.概念</p><p>（1）一般规定：在我国境内销售货物或者加工、修理修配劳务，销售服务、无形资产、不动产以及进口货物的单位和个人，为增值税的纳税人。</p><p>（2）单位以承包、承租、挂靠方式经营的，承包人（包括承租人、挂靠人）以发包人（包括出租人、被挂靠人）名义对外经营并由发包人承担相关法律责任的，以该发包人为纳税人。否则，以承包人为纳税人。</p><p>（3）资管产品运营过程中发生的增值税应税行为，以资管产品管理人为增值税纳税人。</p><p>2.纳税人的分类</p><p>根据纳税人的经营规模以及会计核算健全程度的不同，纳税人可分为小规模纳税人和一般纳税人（年应税销售额超过500 万元）。</p><ul><li>提示：纳税人一经登记为一般纳税人后，一般不得转为小规模纳税人。</li></ul><h5 id="二扣缴义务人">（二）扣缴义务人</h5><p>我国境外的单位或者个人在境内销售劳务，在境内未设有经营机构的，以购买方为扣缴义务人。</p><h4 id="视同销售行为混合销售与兼营">视同销售行为、混合销售与兼营</h4><h5 id="一视同销售行为">（一）视同销售行为</h5><p>1.视同销售货物单位或者个体工商户的下列行为，应视同销售货物，征收增值税：（1）代销行为：①将货物交付其他单位或者个人代销；②销售代销货物。</p><p>（2）异地总分机构移送：设有两个以上机构并实行统一核算的纳税人，将货物从一个机构移送至其他机构用于销售，但相关机构设在同一县（市）的除外。</p><p>（3）“非销售行为”：①将自产、委托加工的货物用于集体福利或者个人消费；②将自产、委托加工的货物用于非增值税应税项目；③将自产、委托加工或者购进的货物作为投资，提供给其他单位或者个体工商户；④将自产、委托加工或者购进的货物分配给股东或者投资者；⑤将自产、委托加工或者购进的货物无偿赠送其他单位或者个人。</p><p>2.视同销售服务、无形资产和不动产单位或者个体工商户向其他单位或者个人无偿提供服务、无偿转让无形资产或不动产，应视同销售。但用于公益事业或者以社会公众为对象的除外。</p><h5 id="二混合销售与兼营">（二）混合销售与兼营</h5><p>1.概念</p><p>（1）混合销售：一项销售行为如果既涉及货物又涉及服务，为混合销售。</p><p>（2）兼营：是指纳税人的经营中包括销售货物、劳务以及销售服务、无形资产和不动产的行为。</p><p>2.增值税处理的提示</p><p>混合销售中的特殊除外情形：纳税人销售活动板房、机器设备、钢结构件等自产货物的同时提供建筑、安装服务，不属于混合销售，应分别核算货物和建筑服务的销售额，分别适用不同的税率或者征收率。</p><h4 id="不征收增值税的情形">不征收增值税的情形</h4><h5 id="一非经营活动">（一）非经营活动</h5><p>1.政府性基金或者行政事业性收费需要同时满足以下条件：</p><p>（1）由国务院或者财政部批准设立的政府性基金，由国务院或者省级人民政府及其财政、价格主管部门批准设立的行政事业性收费；</p><p>（2）收取时开具省级以上（含省级）财政部门监（印）制的财政票据；</p><p>（3）所收款项全额上缴财政。</p><p>2.雇主和员工之间互相提供服务单位或者个体工商户聘用的员工为本单位或者雇主提供取得工资的服务，以及单位或者个体工商户为聘用的员工提供服务。</p><h5 id="二不属于在境内提供应税行为的情形">（二）不属于在“境内”提供应税行为的情形</h5><p>（1）境外单位或者个人向境内单位或者个人销售完全在境外发生的服务；</p><p>（2）境外单位或者个人向境内单位或者个人销售完全在境外使用的无形资产；</p><p>（3）境外单位或者个人向境内单位或者个人出租完全在境外使用的有形动产。</p><h5 id="三不征收增值税的特殊项目">（三）不征收增值税的特殊项目</h5><p>（1）资产重组中的“整体资产转让”行为。在资产重组过程中，通过合并、分立、出售、置换等方式，将全部或者部分实物资产以及与其相关联的债权、负债和劳动力一并转让给其他单位和个人，其中涉及的货物转让、不动产和土地使用权转让行为。</p><p>（2）存款利息。</p><p>（3）被保险人获得的保险赔付。</p><p>（4）无偿提供的用于公益事业的铁路、航空运输服务。</p><ul><li>提示：根据国家指令无偿提供的铁路运输服务、航空运输服务，属于之前视同销售规定中的无偿提供“用于公益事业”的服务，所以无须视同销售，不征收增值税。</li></ul><p>（5）房地产主管部门或者其指定机构、公积金管理中心、开发企业以及物业管理单位代收的住宅专项维修资金。</p><p>（6）纳税人取得的财政补贴收入，与其销售货物、劳务、服务、无形资产、不动产的收入或者数量直接挂钩的，应按规定计算缴纳增值税。纳税人取得的其他情形的财政补贴收入，不属于增值税应税收入，不征收增值税。</p><h4 id="增值税税率和征收率">增值税税率和征收率</h4><h5 id="一税率">（一）税率</h5><p>13%：销售货物、劳务、有形动产租赁服务或者进口货物，除适用 9%及零税率的情形以外，税率为 13%</p><p>9%：（1）销售交通运输、邮政、基础电信、建筑、不动产租赁服务。</p><p>（2）销售不动产、转让土地使用权。</p><p>（3）销售或者进口下列货物：①粮食等农产品、食用植物油、食用盐；②自来水、暖气、冷气、热水、煤气、石油液化气、天然气、二甲醚、沼气、居民用煤炭制品；③图书、报纸、杂志、音像制品、电子出版物；④饲料、化肥、农药、农机、农膜</p><p>6%：销售服务、无形资产，除适用 9% 及零税率的情形以外，税率为 6%</p><p>零税率：（1）出口货物（国务院另有规定的除外）。</p><p>（2）境内单位和个人“跨境销售”下列服务、无形资产：①国际运输服务、航天运输服务；②向境外单位提供的完全在境外消费的下列服务：研发服务；合同能源管理服务；设计服务；广播影视节目（作品）的制作和发行服务；软件服务；电路设计及测试服务；信息系统服务；业务流程管理服务；离岸服务外包业务；转让技术</p><h5 id="二征收率征收率仅适用于简易计税方法">（二）征收率征收率仅适用于简易计税方法。</h5><p>具体内容见“简易计税方法”部分内容。</p><h4 id="一般计税方法下销售额和销项税额的计算">一般计税方法下销售额和销项税额的计算</h4><h5 id="一基本计算公式">（一）基本计算公式</h5><p>增值税一般纳税人，通常情况下默认采用“一般计税方法”计算增值税应纳税额。</p><p><u>应纳税额=当期销项税额-当期进项税额</u></p><p>其中：<u>当期销项税额=销售额×适用税率</u></p><h5 id="二销售额的概念">（二）销售额的概念</h5><p>销售额是指纳税人发生应税销售行为向购买方收取的全部价款和价外费用，但不包括收取的销项税额。</p><p>1.包括项目——“价外费用”价外费用包括：手续费、补贴、基金、集资费、返还利润、奖励费、违约金、滞纳金、延期付款利息、赔偿金、代收款项、代垫款项、包装费、包装物租金、储备费、优质费、运输装卸费等。</p><ul><li>提示：价外费用一般情况下均包为含增值税的“含税金额”，必须进行价税分离，换算为不含税金额后再计算增值税。</li></ul><p>2.不包括项目——“代收转付”性质的费用（1）向购买方收取的销项税额；</p><p>（2）受托加工应税消费品所代收代缴的消费税；</p><p>（3）以委托方名义开具发票代委托方收取的款项；</p><p>（4）销售货物的同时代办保险等而向购买方收取的保险费，以及向购买方收取的代购买方缴纳的车辆购置税、车辆牌照费；</p><p>（5）符合条件的代为收取的政府性基金或者行政事业性收费。</p><p>3.包装物租金与包装物押金</p><p>（1）包装物租金：属于价外费用，在收取时随同货物一并计算增值税。</p><p>（2）包装物押金：一般情况下，向购货方收取的独立核算的包装物押金，购货方在规定时间内返还包装物，销货方会将收取的包装物押金返还。</p><h5 id="三含税销售额的换算">（三）含税销售额的换算</h5><p><u>不含税销售额=价税合计金额（或含税收入）÷（1+增值税税率）</u></p><ul><li>提示：</li></ul><p>（1）计算增值税的基数中不包括增值税本身，如果题目给出的金额是含增值税的金额，需要用上述公式进行价税分离换算；</p><p>（2）在解题中第一步应首先判断题目给出的金额是否包含增值税。一般情况下，如果题目中出现“价税合计金额”“含税价格”“零售价格”“价外费用”“包装物租金或押金”，一般均为含税金额，需要进行价税分离；但如果出现的是“不含税收入”“不含税销售额”“增值税专用发票上注明的金额”“增值税专用发票上注明的价款”等字眼，则为不含税的销售额，无需价税分离，直接乘以税率即可。</p><h5 id="四视同销售的销售额的确定">（四）视同销售的销售额的确定</h5><p>1.适用情形</p><p>（1）视同销售；</p><p>（2）其他。例如：销售价格明显偏低或者偏高且不具有正当理由的情形。</p><p>2.确定销售额的方式——“按顺序”确定销售额时，按照下列顺序进行：</p><p>（1）纳税人最近时期同类货物（或服务、无形资产、不动产）的平均销售价格；</p><p>（2）其他纳税人最近时期同类货物（或服务、无形资产、不动产）的平均销售价格；</p><p>（3）组成计税价格。</p><p>非应税消费品：<u>组成计税价格=成本×（1+成本利润率）</u></p><p>应税消费品：<u>组成计税价格=成本×（1+成本利润率）÷（1-消费税税率）</u></p><h5 id="五特殊销售方式下销售额的确定">（五）特殊销售方式下销售额的确定</h5><p>1.折扣销售</p><p>销售额和折扣额在同一张发票（“金额栏”）上分别注明的，按折扣后的销售额（可以扣减折扣额）</p><p>不符合上述情形的，例如：销售额和折扣额在“备注栏”上分别注明的，或折扣额另开发票的按折扣前的销售额（不得扣减折扣额）</p><p>2.退货或折让如果发生开票有误或者销售折让、中止、退回等情形的，应当按照规定开具红字增值税专用发票；未按照规定开具红字增值税专用发票的，不得扣减销项税额或者销售额。</p><p>3.以旧换新</p><p>（1）金银首饰以旧换新业务，可以按销售方实际收取的不含增值税的全部价款征收增值税。</p><ul><li>提示：按实际收取的“差额”计算增值税。</li></ul><p>（2）其他货物，按新货物的同期销售价格作为销售额，不得扣减旧货物的收购价格。</p><p>4.还本销售还本销售应当以货物的正常销售价格作为销售额，不得扣减还本支出。</p><p>5.以物易物双方都应作购销处理：以各自发出的货物核算销售额并计算销项税额，以各自收到的货物按规定核算购货额并计算进项税额。</p>]]></content>
      
      
      <categories>
          
          <category> 经济法基础 </category>
          
          <category> 第一章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 税法 </tag>
            
            <tag> 增值税 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学生成绩管理系统</title>
      <link href="/2024/04/22/xue-sheng-cheng-ji-guan-li-xi-tong/"/>
      <url>/2024/04/22/xue-sheng-cheng-ji-guan-li-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="学生成绩管理系统">学生成绩管理系统</h1><p><strong>系统功能：</strong></p><ol type="1"><li>成绩录入</li><li>成绩输出</li><li>成绩查询</li><li>成绩排序</li><li>身份验证</li></ol><h2 id="原来c语言代码为">原来c语言代码为：</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*******************************************************************</span></span><br><span class="line"><span class="comment">*名    称：学生成绩管理系统1.0                         *</span></span><br><span class="line"><span class="comment">*创建日期：2023-4-3                                 *</span></span><br><span class="line"><span class="comment">*最后修改：2023-4-3                                *</span></span><br><span class="line"><span class="comment">*版    权：中国农业大学信息与电气工程学院           *</span></span><br><span class="line"><span class="comment">*版 本 号：1.0                                      *</span></span><br><span class="line"><span class="comment">*******************************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 20   <span class="comment">//数组的长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">功能:显示菜单</span></span><br><span class="line"><span class="comment">参数：无</span></span><br><span class="line"><span class="comment">返回值：无</span></span><br><span class="line"><span class="comment">*******************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">displayMenu</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"++++++++++++++++++++++++++++++++++++++++++++++++++++\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"+                 学生成绩管理系统                 +\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"+                                                  +\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"+                    1. 录入                       +\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"+                    2. 输出                       +\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"+                    3. 查询                       +\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"+                    4. 排序                       +\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"+                    5. 结束                       +\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"+                                                  +\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"++++++++++++++++++++++++++++++++++++++++++++++++++++\n"</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">功能:登陆函数，验证口令</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">类型：char []</span></span><br><span class="line"><span class="comment">说明：用户输入口令</span></span><br><span class="line"><span class="comment">返回值：1或0</span></span><br><span class="line"><span class="comment">类型：int</span></span><br><span class="line"><span class="comment">说明：1表示通过验证；0表示没有通过</span></span><br><span class="line"><span class="comment">*******************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">login</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> password[<span class="number">8</span>];<span class="comment">/*用户输入的口令*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> key[<span class="number">8</span>] = <span class="string">"1234"</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*====验证用户的口令，如果三次输入均错误，则不允许进入系统====*/</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line">count++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入口令："</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;password;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(password, key) == <span class="number">0</span>)</span><br><span class="line">s = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">s = <span class="number">0</span>;</span><br><span class="line">} <span class="keyword">while</span> (s == <span class="number">0</span> &amp;&amp; count &lt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">功能:输入学生成绩到数组中</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">参数1：score[]</span></span><br><span class="line"><span class="comment">类型：int []</span></span><br><span class="line"><span class="comment">说明：学生成绩数组</span></span><br><span class="line"><span class="comment">参数2：length</span></span><br><span class="line"><span class="comment">类型：int</span></span><br><span class="line"><span class="comment">说明：要输入的学生成绩数组的长度</span></span><br><span class="line"><span class="comment">返回值：i</span></span><br><span class="line"><span class="comment">类型：int</span></span><br><span class="line"><span class="comment">说明：实际成绩数组的有效值个数</span></span><br><span class="line"><span class="comment">*******************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inputScore</span><span class="params">(<span class="type">int</span> score[], <span class="type">int</span> length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> tmp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入学生的成绩（以-1结束输入):\n"</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">"个学生："</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line"><span class="keyword">if</span> (tmp &gt;= <span class="number">0</span> &amp;&amp; tmp &lt;= <span class="number">100</span>)</span><br><span class="line">{</span><br><span class="line">score[i] = tmp;</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line">} <span class="keyword">while</span> (tmp != <span class="number">-1</span> &amp;&amp; i &lt; length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">功能:输出数组中的学生成绩</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">参数1：score[]</span></span><br><span class="line"><span class="comment">类型：int []</span></span><br><span class="line"><span class="comment">说明：学生成绩数组</span></span><br><span class="line"><span class="comment">参数2：length</span></span><br><span class="line"><span class="comment">类型：int</span></span><br><span class="line"><span class="comment">说明：要输出的成绩数组的长度</span></span><br><span class="line"><span class="comment">返回值：无</span></span><br><span class="line"><span class="comment">类型：void</span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">*******************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">outputScore</span><span class="params">(<span class="type">int</span> score[], <span class="type">int</span> length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"学生成绩如下：\n"</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; score[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">功能:查找某个学生成绩是否在数组中，如果找到，则输出下标，</span></span><br><span class="line"><span class="comment">否则，显示没有找到。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">参数1：score[]</span></span><br><span class="line"><span class="comment">类型：int []</span></span><br><span class="line"><span class="comment">说明：学生成绩数组</span></span><br><span class="line"><span class="comment">参数2：length</span></span><br><span class="line"><span class="comment">类型：int</span></span><br><span class="line"><span class="comment">说明：要输入的学生成绩数组的长度</span></span><br><span class="line"><span class="comment">参数2：xScore</span></span><br><span class="line"><span class="comment">类型：int</span></span><br><span class="line"><span class="comment">说明：要查找的学生成绩</span></span><br><span class="line"><span class="comment">返回值：k</span></span><br><span class="line"><span class="comment">类型：int</span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">*******************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">queryScore</span><span class="params">(<span class="type">int</span> score[], <span class="type">int</span> length, <span class="type">int</span> xScore)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (xScore == score[i])</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">功能:排序学生的成绩，按照从小到大顺序排序。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">参数1：score[]</span></span><br><span class="line"><span class="comment">类型：int []</span></span><br><span class="line"><span class="comment">说明：学生成绩数组</span></span><br><span class="line"><span class="comment">参数2：length</span></span><br><span class="line"><span class="comment">类型：int</span></span><br><span class="line"><span class="comment">说明：要输入的学生成绩数组的长度</span></span><br><span class="line"><span class="comment">返回值：无</span></span><br><span class="line"><span class="comment">类型：void</span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">*******************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sortScore</span><span class="params">(<span class="type">int</span> score[], <span class="type">int</span> length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i, j, t;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"成绩排序如下：\n"</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; length - i - <span class="number">1</span>; j++)</span><br><span class="line"><span class="keyword">if</span> (score[j] &gt; score[j + <span class="number">1</span>])</span><br><span class="line">{</span><br><span class="line">t = score[j];</span><br><span class="line">score[j] = score[j + <span class="number">1</span>];</span><br><span class="line">score[j + <span class="number">1</span>] = t;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">功能:主函数</span></span><br><span class="line"><span class="comment">参数：无</span></span><br><span class="line"><span class="comment">返回值：无</span></span><br><span class="line"><span class="comment">*******************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> choice = <span class="number">0</span>; <span class="comment">/*代表用户选择的操作数字 */</span></span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>, datalen = <span class="number">0</span>, x, find;</span><br><span class="line"><span class="type">int</span> score[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*====验证用户的口令====*/</span></span><br><span class="line"><span class="keyword">if</span> (login() == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"口令错误，不允许进入本系统!\n"</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*====根据用户的选择，执行相应的操作.====*/</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">displayMenu();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n 请选择您的操作(1,2,3,4,5)：\n"</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (choice)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">datalen = inputScore(score, N);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">outputScore(score, datalen);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n 请输入要查找的成绩："</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">find = queryScore(score, datalen, x);</span><br><span class="line"><span class="keyword">if</span> (find &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"要查成绩在数组中的下表为:"</span> &lt;&lt; find &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"没有要查找的成绩:\n"</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">sortScore(score, datalen); outputScore(score, datalen);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p><strong>代码解释：</strong></p></li><li><p><code>void welcome();</code></p><p>​ 欢迎界面</p></li><li><p><code>int login();</code></p><ul><li>验证身份，成功返回<code>1</code>，否则返回<code>0</code></li><li>支持由数字和字符混合组成的口令</li><li>最长为8位</li><li>用户有三次录入机会，如果第三次失败，则不允许登录系统</li></ul></li><li><p><code>void displayMenu();</code></p><p>​ 功能显示提示菜单</p></li><li><p><code>int inputScore(int s[],int len);</code>或<code>int inputScore(int *s,int len);</code></p><p>​输入学生成绩数组中，如果学生的成绩输入<code>-1</code>，就表示输入结束，<code>s</code>为成绩数组，<code>len</code>为数组的最大列数；返回实际输入学生成绩的个数</p></li><li><p><code>void outputsScore(int s[],int len);</code>或<code>void outputsScore(int *s,int len);</code></p><p>​ 输出学生成绩，<code>s</code>为成绩数组，<code>len</code>为实际存储的成绩个数</p></li><li><p><code>int queryScore(int s[],int len,int xScore);</code>或<code>int queryScore(int *s,int len,int xScore);</code></p><p>​查询成绩。<code>s</code>为成绩数组，<code>len</code>为实际存储成绩个数；<code>xScore</code>为要查找的成绩，若找到该成绩，则返回该成绩的下标，否则返回<code>-1</code></p></li><li><p><code>void count(int a[],int n,int b[]);</code>或<code>void count(int *a,int n,int *b);</code></p><ul><li><p>统计成绩各个挡次中的人数<code>90 ~ 100</code>,<code>80 ~ 89</code>,<code>70 ~ 79</code>,<code>60 ~ 69</code>,<code>0 ~ 59</code></p></li><li><p><code>a</code>为学生成绩数组；<code>n</code>为数组实际长度；<code>b</code>为各挡人数数组</p></li></ul></li><li><p><code>void sortScore(int ps[],int len);</code>或<code>void sortScore(int *ps,int len);</code></p><ul><li>成绩升序排序</li><li><code>ps</code>为成绩数组</li><li><code>len</code>数组实际长度</li></ul></li></ul><h2 id="将c语言代码改写为c的类">将c语言代码改写为c++的类：</h2><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*******************************************************************</span></span><br><span class="line"><span class="comment">*名    称：学生成绩管理系统1.1                         *</span></span><br><span class="line"><span class="comment">*创建日期：2024-4-16                                 *</span></span><br><span class="line"><span class="comment">*最后修改：2024-4-16                                *</span></span><br><span class="line"><span class="comment">*版    权：中国农业大学信息与电气工程学院           *</span></span><br><span class="line"><span class="comment">*版 本 号：2.0                                      *</span></span><br><span class="line"><span class="comment">*******************************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 20   <span class="comment">//数组的长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">功能:显示菜单</span></span><br><span class="line"><span class="comment">参数：无</span></span><br><span class="line"><span class="comment">返回值：无</span></span><br><span class="line"><span class="comment">*******************************************************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"++++++++++++++++++++++++++++++++++++++++++++++++++++\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+                 学生成绩管理系统                 +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+                                                  +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+                    1. 录入                       +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+                    2. 输出                       +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+                    3. 查询                       +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+                    4. 排序                       +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+                    5. 结束                       +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+                                                  +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"++++++++++++++++++++++++++++++++++++++++++++++++++++\n"</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">功能:登陆函数，验证口令</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">类型：char []</span></span><br><span class="line"><span class="comment">说明：用户输入口令</span></span><br><span class="line"><span class="comment">返回值：1或0</span></span><br><span class="line"><span class="comment">类型：int</span></span><br><span class="line"><span class="comment">说明：1表示通过验证；0表示没有通过</span></span><br><span class="line"><span class="comment">*******************************************************/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">login</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">char</span> password[<span class="number">8</span>];<span class="comment">/*用户输入的口令*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> key[<span class="number">8</span>] = <span class="string">"1234"</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*====验证用户的口令，如果三次输入均错误，则不允许进入系统====*/</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line">count++;</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入口令："</span>;</span><br><span class="line">cin &gt;&gt; password;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(password, key) == <span class="number">0</span>)</span><br><span class="line">s = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">s = <span class="number">0</span>;</span><br><span class="line">} <span class="keyword">while</span> (s == <span class="number">0</span> &amp;&amp; count &lt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span>* score;</span><br><span class="line"><span class="type">int</span> Mlen;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Score</span>(<span class="type">int</span>* s, <span class="type">int</span> n)</span><br><span class="line">{</span><br><span class="line">Mlen = n;</span><br><span class="line">score = s;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inputScore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入学生的成绩（以-1结束输入):\n"</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> tmp;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; <span class="string">"第"</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">"个学生："</span>;</span><br><span class="line">cin &gt;&gt; tmp;</span><br><span class="line"><span class="keyword">if</span> (tmp &gt;= <span class="number">0</span> &amp;&amp; tmp &lt;= <span class="number">100</span>)</span><br><span class="line">{</span><br><span class="line">score[i] = tmp;</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line">} <span class="keyword">while</span> (tmp != <span class="number">-1</span> &amp;&amp; i &lt; Mlen);</span><br><span class="line"></span><br><span class="line">length = i;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outputScore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"学生成绩如下：\n"</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; score[i] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">queryScore</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line"><span class="keyword">if</span> (score[i] == x)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortScore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> i, j, t;</span><br><span class="line">cout &lt;&lt; <span class="string">"成绩排序如下：\n"</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; length - i - <span class="number">1</span>; j++)</span><br><span class="line"><span class="keyword">if</span> (score[j] &gt; score[j + <span class="number">1</span>])</span><br><span class="line">{</span><br><span class="line">t = score[j];</span><br><span class="line">score[j] = score[j + <span class="number">1</span>];</span><br><span class="line">score[j + <span class="number">1</span>] = t;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">功能:主函数</span></span><br><span class="line"><span class="comment">参数：无</span></span><br><span class="line"><span class="comment">返回值：无</span></span><br><span class="line"><span class="comment">*******************************************************/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> choice = <span class="number">0</span>; <span class="comment">/*代表用户选择的操作数字 */</span></span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>, datalen = <span class="number">0</span>, x, find;</span><br><span class="line"><span class="type">int</span> as[N];</span><br><span class="line"><span class="function">Score <span class="title">testS</span><span class="params">(as, N)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*====验证用户的口令====*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">login</span>() == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; <span class="string">"口令错误，不允许进入本系统!\n"</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*====根据用户的选择，执行相应的操作.====*/</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="built_in">displayMenu</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"\n 请选择您的操作(1,2,3,4,5)：\n"</span>;</span><br><span class="line">cin &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (choice)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">testS.<span class="built_in">inputScore</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">testS.<span class="built_in">outputScore</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">"\n 请输入要查找的成绩："</span>;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">find = testS.<span class="built_in">queryScore</span>(x);</span><br><span class="line"><span class="keyword">if</span> (find &gt;= <span class="number">0</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">"要查成绩在数组中的下表为:"</span> &lt;&lt; find &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">"没有要查找的成绩:\n"</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">testS.<span class="built_in">sortScore</span>();</span><br><span class="line">testS.<span class="built_in">outputScore</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="缺点及可补充功能">缺点及可补充功能：</h3><ol type="1"><li><p><strong>数据持久化：</strong>成绩数据只在程序运行期间存储在内存中，没有实现数据持久化。可以选择将数据保存在文件中</p></li><li><p><strong>错误处理和用户输入验证：</strong></p><ul><li><p>增加对用户输入的验证，确保输入的数据有效，检查成绩是否在合法范围<code>（0-100分）</code>之内。</p></li><li><p>在用户输入非法时，给出明确的错误信息，并允许重新输入而不是立即退出。</p></li></ul></li><li><p><strong>增加更多成绩管理功能：</strong></p><ul><li><p><strong>统计功能：</strong>计算全班的平均成绩、最高分、最低分等。</p></li><li><p><strong>成绩修改和删除：</strong>允许用户修改或删除已录入的成绩。</p></li><li><p><strong>分组排序显示：</strong>统计成绩各个挡次中的人数<code>90 ~ 100</code>,<code>80 ~ 89</code>,<code>70 ~ 79</code>,<code>60 ~ 69</code>,<code>0 ~ 59</code></p></li><li><p><strong>实现多科目动态输入：</strong>可输入多个学科的名称，实现对多个学科的成绩录入</p></li></ul></li></ol><h2 id="优化修改后的代码-1.0">优化修改后的代码 1.0 ：</h2><p><strong>使用c++14实现（auto关键字）</strong></p><h3 id="可以实现">可以实现：</h3><ol type="1"><li><strong>读入数据（选项0）</strong>：<ul><li>从一个指定的文本文件（<code>scores.txt</code>）中加载学生数据，包括学号、姓名和多个学科的成绩。</li><li>每个学生的信息由学号、姓名、科目成绩构成，信息间通过换行分隔，不同学生之间通过空行分隔。</li></ul></li><li><strong>设置学科（选项1）</strong>：<ul><li>允许用户输入一系列学科名称，通过空格分隔，输入<code>-1</code>结束输入。</li><li>用户可以选择添加新的学科或重新设置所有学科。</li></ul></li><li><strong>录入成绩（选项2）</strong>：<ul><li>允许用户为每个学科手动录入学生的成绩。</li><li>用户需输入学号、姓名，然后为每个已设定的学科输入成绩。</li></ul></li><li><strong>显示成绩（选项3）</strong>：<ul><li>显示当前系统中所有学生的学号、姓名和每个学科的成绩。</li><li>如果某个学科的成绩不存在，则显示<code>N/A</code>。</li></ul></li><li><strong>查询成绩（选项4）</strong>：<ul><li>允许用户通过学号查询单个学生的所有科目成绩。</li></ul></li><li><strong>排序显示（选项5）</strong>：<ul><li>按总成绩降序排序所有学生，若总成绩相同则按学号升序排序。</li><li>显示排序后的学生列表，包括学号、姓名、各科成绩及总成绩。</li></ul></li><li><strong>统计成绩（选项6）</strong>：<ul><li>对每个科目进行统计，包括最高分、最低分和平均分。</li></ul></li><li><strong>修改/删除成绩（选项7）</strong>：<ul><li>允许用户修改指定学生的某科目成绩或删除整个科目的成绩。</li><li>用户可以选择删除整个学生记录。</li></ul></li><li><strong>清除所有数据（选项8）</strong>：<ul><li>清空系统中的所有学生记录。</li></ul></li><li><strong>保存并退出（选项9）</strong>：<ul><li>将所有学生的数据保存到文本文件（<code>scores.txt</code>）中，并退出程序。</li></ul></li><li><strong>用户登录功能</strong>：<ul><li>系统启动时要求用户输入密码，密码验证成功后才能访问以上功能。</li></ul></li></ol><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*******************************************************************</span></span><br><span class="line"><span class="comment">*名    称：学生成绩管理系统1.1                         *</span></span><br><span class="line"><span class="comment">*创建日期：2024-4-16                                 *</span></span><br><span class="line"><span class="comment">*最后修改：2024-4-18                                *</span></span><br><span class="line"><span class="comment">*版    权：中国农业大学信息与电气工程学院           *</span></span><br><span class="line"><span class="comment">*版 本 号：3.0                                      *</span></span><br><span class="line"><span class="comment">*******************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> string dataFile = <span class="string">"scores.txt"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">login</span><span class="params">()</span> </span>{</span><br><span class="line">    string password;</span><br><span class="line">    string correctPassword = <span class="string">"1234"</span>;</span><br><span class="line">    <span class="type">int</span> attempts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (attempts &lt; <span class="number">3</span>) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"请输入密码："</span>;</span><br><span class="line">        cin &gt;&gt; password;</span><br><span class="line">        <span class="keyword">if</span> (password == correctPassword) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            cout &lt;&lt; <span class="string">"密码错误！还有 "</span> &lt;&lt; <span class="number">2</span> - attempts &lt;&lt; <span class="string">" 次机会。\n"</span>;</span><br><span class="line">        }</span><br><span class="line">        attempts++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> {</span><br><span class="line">    string id;</span><br><span class="line">    string name;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; scores;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScoreManager</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;string, Student&gt; students;</span><br><span class="line">    vector&lt;string&gt; subjects;  <span class="comment">// 存储学科名称列表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayMenu</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"++++++++++++++++++++++++++++++++++++++++++++++++++++\n"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"+                  学生成绩管理系统                +\n"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"+                    0. 读入数据                   +\n"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"+                    1. 设置学科                   +\n"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"+                    2. 录入成绩                   +\n"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"+                    3. 显示成绩                   +\n"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"+                    4. 查询成绩                   +\n"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"+                    5. 排序显示                   +\n"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"+                    6. 统计成绩                   +\n"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"+                    7. 修改/删除成绩              +\n"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"+                    8. 清除所有数据               +\n"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"+                    9. 保存并退出                 +\n"</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"++++++++++++++++++++++++++++++++++++++++++++++++++++\n"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSubjects</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"请选择您的操作(1或2)：\n"</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">"1.添加学科\n"</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">"2.重新设置学科\n"</span>;</span><br><span class="line">        <span class="type">char</span> choicee;</span><br><span class="line">        cin &gt;&gt; choicee;</span><br><span class="line">        <span class="keyword">switch</span> (choicee) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"请输入学科名称，以空格分隔，输入-1结束："</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'1'</span>: <span class="built_in">setSubjects1</span>(); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'2'</span>: <span class="built_in">setSubjects1</span>(); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: cout &lt;&lt; <span class="string">"无效的输入。\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">"已设置的学科有："</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; sub : subjects) {</span><br><span class="line">            cout &lt;&lt; sub &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSubjects1</span><span class="params">()</span> </span>{</span><br><span class="line">string subject;</span><br><span class="line">        <span class="keyword">while</span> (cin &gt;&gt; subject &amp;&amp; subject != <span class="string">"-1"</span>) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(subjects.<span class="built_in">begin</span>(), subjects.<span class="built_in">end</span>(), subject) == subjects.<span class="built_in">end</span>()) {</span><br><span class="line">                subjects.<span class="built_in">push_back</span>(subject);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                cout &lt;&lt; <span class="string">"科目 '"</span> &lt;&lt; subject &lt;&lt; <span class="string">"' 已存在，跳过添加。\n"</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSubjects2</span><span class="params">()</span> </span>{</span><br><span class="line">        subjects.<span class="built_in">clear</span>();</span><br><span class="line">        string subject;</span><br><span class="line">        <span class="keyword">while</span> (cin &gt;&gt; subject &amp;&amp; subject != <span class="string">"-1"</span>) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(subjects.<span class="built_in">begin</span>(), subjects.<span class="built_in">end</span>(), subject) == subjects.<span class="built_in">end</span>()) {</span><br><span class="line">                subjects.<span class="built_in">push_back</span>(subject);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                cout &lt;&lt; <span class="string">"科目 '"</span> &lt;&lt; subject &lt;&lt; <span class="string">"' 已存在，跳过添加。\n"</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadScores</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="function">ifstream <span class="title">file</span><span class="params">(dataFile)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) {</span><br><span class="line">            cerr &lt;&lt; <span class="string">"无法打开文件 "</span> &lt;&lt; dataFile &lt;&lt; <span class="string">" 进行读取。\n"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        string line, id, name, ssubject;</span><br><span class="line">        <span class="type">int</span> score;</span><br><span class="line">        Student student;</span><br><span class="line">        <span class="type">bool</span> isNewStudent = <span class="literal">true</span>; <span class="comment">// 标志是否读取新学生的学号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">getline</span>(file, line)) {</span><br><span class="line">            <span class="keyword">if</span> (line.<span class="built_in">empty</span>()) {</span><br><span class="line">                <span class="comment">// 当遇到空行时，假设完成了一个学生的所有输入</span></span><br><span class="line">                <span class="keyword">if</span> (!student.id.<span class="built_in">empty</span>()) {</span><br><span class="line">                    students[student.id] = student;  <span class="comment">// 保存当前学生的数据</span></span><br><span class="line">                    student = <span class="built_in">Student</span>(); <span class="comment">// 重置学生对象</span></span><br><span class="line">                    isNewStudent = <span class="literal">true</span>; <span class="comment">// 准备读取下一个学生的数据</span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isNewStudent) {</span><br><span class="line">                <span class="comment">// 读取学号</span></span><br><span class="line">                student.id = line;</span><br><span class="line">                isNewStudent = <span class="literal">false</span>;  <span class="comment">// 标记已经读取了学号</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (student.name.<span class="built_in">empty</span>()) {</span><br><span class="line">                <span class="comment">// 读取姓名</span></span><br><span class="line">                student.name = line;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取科目和成绩</span></span><br><span class="line">            <span class="function">istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">            iss &gt;&gt; ssubject &gt;&gt; score;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(subjects.<span class="built_in">begin</span>(), subjects.<span class="built_in">end</span>(), ssubject) == subjects.<span class="built_in">end</span>()) {</span><br><span class="line">                subjects.<span class="built_in">push_back</span>(ssubject);</span><br><span class="line">            }</span><br><span class="line">            student.scores[ssubject] = score;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保文件结束时最后一个学生也被添加</span></span><br><span class="line">        <span class="keyword">if</span> (!student.id.<span class="built_in">empty</span>() &amp;&amp; !student.name.<span class="built_in">empty</span>()) {</span><br><span class="line">            students[student.id] = student;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">"数据已读取。读取数据如下：\n"</span>;</span><br><span class="line">        <span class="built_in">outputScores</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inputScores</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"开始输入成绩。请输入学号和姓名，对于每个学科输入成绩：\n"</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            Student student;</span><br><span class="line">            cout &lt;&lt; <span class="string">"请输入学号（输入-1结束输入）："</span>;</span><br><span class="line">            cin &gt;&gt; student.id;</span><br><span class="line">            <span class="keyword">if</span> (student.id == <span class="string">"-1"</span>) <span class="keyword">break</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">"请输入姓名："</span>;</span><br><span class="line">            cin &gt;&gt; student.name;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; subject : subjects) {</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                    <span class="type">int</span> score;</span><br><span class="line">                    cout &lt;&lt; <span class="string">"请输入 "</span> &lt;&lt; subject &lt;&lt; <span class="string">" 的成绩："</span>;</span><br><span class="line">                    cin &gt;&gt; score;</span><br><span class="line">                    <span class="keyword">if</span> (score &gt;= <span class="number">0</span> &amp;&amp; score &lt;= <span class="number">100</span>) {</span><br><span class="line">                        student.scores[subject] = score;</span><br><span class="line">                        <span class="keyword">break</span>;  <span class="comment">// 成绩有效，跳出内部循环</span></span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span> {</span><br><span class="line">                        cout &lt;&lt; <span class="string">"无效成绩，请输入0-100之间的数值。\n"</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            students[student.id] = student;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">outputScores</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (students.<span class="built_in">empty</span>()) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"没有数据显示。\n"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; left &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"学号"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">15</span>) &lt;&lt; <span class="string">"姓名"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; subject : subjects) {</span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; subject;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : students) {</span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; pair.second.id &lt;&lt; <span class="built_in">setw</span>(<span class="number">15</span>) &lt;&lt; pair.second.name;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; subject : subjects) {</span><br><span class="line">                <span class="keyword">auto</span> it = pair.second.scores.<span class="built_in">find</span>(subject);</span><br><span class="line">                <span class="keyword">if</span> (it != pair.second.scores.<span class="built_in">end</span>()) {</span><br><span class="line">                    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; it-&gt;second;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"N/A"</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">queryScore</span><span class="params">()</span> </span>{</span><br><span class="line">        string id;</span><br><span class="line">        cout &lt;&lt; <span class="string">"请输入学号："</span>;</span><br><span class="line">        cin &gt;&gt; id;</span><br><span class="line">        <span class="keyword">if</span> (students.<span class="built_in">find</span>(id) == students.<span class="built_in">end</span>()) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"学号不存在！\n"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        Student&amp; student = students[id];</span><br><span class="line">        cout &lt;&lt; <span class="string">"学号 "</span> &lt;&lt; student.id &lt;&lt; <span class="string">" 的成绩如下：\n"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; score : student.scores) {</span><br><span class="line">            cout &lt;&lt; score.first &lt;&lt; <span class="string">": "</span> &lt;&lt; score.second &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortScores</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 将学生数据从map转移到vector，并计算每个学生的总分</span></span><br><span class="line">        vector&lt;pair&lt;Student, <span class="type">int</span>&gt;&gt; sortedStudents;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : students) {</span><br><span class="line">            <span class="type">int</span> totalScore = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; score : pair.second.scores) {</span><br><span class="line">                totalScore += score.second;</span><br><span class="line">            }</span><br><span class="line">            sortedStudents.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(pair.second, totalScore));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对学生进行排序，首先按总分降序，若总分相同，则按学号升序</span></span><br><span class="line">        <span class="built_in">sort</span>(sortedStudents.<span class="built_in">begin</span>(), sortedStudents.<span class="built_in">end</span>(),</span><br><span class="line">            [](<span class="type">const</span> pair&lt;Student, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> pair&lt;Student, <span class="type">int</span>&gt;&amp; b) {</span><br><span class="line">                <span class="keyword">if</span> (a.second != b.second) {</span><br><span class="line">                    <span class="keyword">return</span> a.second &gt; b.second; <span class="comment">// 总分高的在前</span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> a.first.id &lt; b.first.id; <span class="comment">// 学号小的在前</span></span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出排序后的学生信息</span></span><br><span class="line">        cout &lt;&lt; left &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"学号"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">15</span>) &lt;&lt; <span class="string">"姓名"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; subject : subjects) {</span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">15</span>) &lt;&lt; subject;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"总成绩"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : sortedStudents) {</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span>&amp; student = item.first;</span><br><span class="line">            <span class="type">int</span> totalScore = item.second;</span><br><span class="line"></span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; student.id &lt;&lt; <span class="built_in">setw</span>(<span class="number">15</span>) &lt;&lt; student.name;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; subject : subjects) {</span><br><span class="line">                cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">15</span>) &lt;&lt; student.scores.<span class="built_in">at</span>(subject); <span class="comment">// 显示每门科目的成绩</span></span><br><span class="line">            }</span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; totalScore; <span class="comment">// 显示总成绩</span></span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">statsScores</span><span class="params">()</span> </span>{</span><br><span class="line">        map&lt;string, <span class="type">int</span>&gt; maxScores, minScores;</span><br><span class="line">        map&lt;string, <span class="type">double</span>&gt; averageScores;</span><br><span class="line">        map&lt;string, <span class="type">int</span>&gt; countScores;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化最大和最小分数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; sub : subjects) {</span><br><span class="line">            maxScores[sub] = numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();  <span class="comment">// 设置最大分数为最小可能值</span></span><br><span class="line">            minScores[sub] = numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();  <span class="comment">// 设置最小分数为最大可能值</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有学生的成绩</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : students) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; score : pair.second.scores) {</span><br><span class="line">                <span class="type">const</span> string&amp; subject = score.first;</span><br><span class="line">                <span class="type">int</span> value = score.second;</span><br><span class="line">                <span class="keyword">if</span> (maxScores.<span class="built_in">find</span>(subject) != maxScores.<span class="built_in">end</span>()) {</span><br><span class="line">                    maxScores[subject] = <span class="built_in">max</span>(maxScores[subject], value);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (minScores.<span class="built_in">find</span>(subject) != minScores.<span class="built_in">end</span>()) {</span><br><span class="line">                    minScores[subject] = <span class="built_in">min</span>(minScores[subject], value);</span><br><span class="line">                }</span><br><span class="line">                averageScores[subject] += value;</span><br><span class="line">                countScores[subject]++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出统计结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; subject : subjects) {</span><br><span class="line">            cout &lt;&lt; subject &lt;&lt; <span class="string">" - 最高分: "</span> &lt;&lt; maxScores[subject];</span><br><span class="line">            cout &lt;&lt; <span class="string">", 最低分: "</span> &lt;&lt; minScores[subject];</span><br><span class="line">            <span class="keyword">if</span> (countScores[subject] &gt; <span class="number">0</span>) {  <span class="comment">// 确保有成绩被录入</span></span><br><span class="line">                cout &lt;&lt; <span class="string">", 平均分: "</span> &lt;&lt; (averageScores[subject] / countScores[subject]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                cout &lt;&lt; <span class="string">", 平均分: 无数据"</span>;  <span class="comment">// 如果没有成绩数据，输出无数据</span></span><br><span class="line">            }</span><br><span class="line">            cout &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modifyOrDeleteScores</span><span class="params">()</span> </span>{</span><br><span class="line">        string id;</span><br><span class="line">        cout &lt;&lt; <span class="string">"请输入学号："</span>;</span><br><span class="line">        cin &gt;&gt; id;</span><br><span class="line">        <span class="keyword">if</span> (students.<span class="built_in">find</span>(id) == students.<span class="built_in">end</span>()) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"学号不存在！\n"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">"当前成绩："</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; score : students[id].scores) {</span><br><span class="line">            cout &lt;&lt; score.first &lt;&lt; <span class="string">": "</span> &lt;&lt; score.second &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; <span class="string">"\n请输入要修改的科目名称（输入\"delete\"删除学生记录）："</span>;</span><br><span class="line">        string subject;</span><br><span class="line">        cin &gt;&gt; subject;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (subject == <span class="string">"delete"</span>) {</span><br><span class="line">            students.<span class="built_in">erase</span>(id);</span><br><span class="line">            cout &lt;&lt; <span class="string">"学生记录已删除。\n"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (students[id].scores.<span class="built_in">find</span>(subject) == students[id].scores.<span class="built_in">end</span>()) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"科目不存在！\n"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> newScore;</span><br><span class="line">        cout &lt;&lt; <span class="string">"输入新成绩（输入-1删除该科目成绩）："</span>;</span><br><span class="line">        cin &gt;&gt; newScore;</span><br><span class="line">        <span class="keyword">if</span> (newScore == <span class="number">-1</span>) {</span><br><span class="line">            students[id].scores.<span class="built_in">erase</span>(subject);</span><br><span class="line">            cout &lt;&lt; <span class="string">"该科目成绩已删除。\n"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            students[id].scores[subject] = newScore;</span><br><span class="line">            cout &lt;&lt; <span class="string">"成绩已更新。\n"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">saveScores</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="function">ofstream <span class="title">file</span><span class="params">(dataFile)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) {</span><br><span class="line">            cerr &lt;&lt; <span class="string">"无法打开文件 '"</span> &lt;&lt; dataFile &lt;&lt; <span class="string">"' 进行写入。\n"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : students) {</span><br><span class="line">            file &lt;&lt; pair.second.id &lt;&lt; <span class="string">"\n"</span> &lt;&lt; pair.second.name &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; score : pair.second.scores) {</span><br><span class="line">                file &lt;&lt; score.first &lt;&lt; <span class="string">" "</span> &lt;&lt; score.second &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">            }</span><br><span class="line">            file &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearAllData</span><span class="params">()</span> </span>{</span><br><span class="line">        students.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="function">ofstream <span class="title">file</span><span class="params">(dataFile, ios::trunc)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) {</span><br><span class="line">            cerr &lt;&lt; <span class="string">"无法打开文件以清空内容。\n"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">"所有数据已被清除。\n"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">login</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"口令错误，不允许进入本系统!\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    ScoreManager manager;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        manager.<span class="built_in">displayMenu</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">"请选择您的操作(0-9)："</span>;</span><br><span class="line">        <span class="type">char</span> choice;</span><br><span class="line">        cin &gt;&gt; choice;</span><br><span class="line">        <span class="keyword">switch</span> (choice) {</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'0'</span>: manager.<span class="built_in">loadScores</span>(); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'1'</span>: manager.<span class="built_in">setSubjects</span>(); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'2'</span>: manager.<span class="built_in">inputScores</span>(); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'3'</span>: manager.<span class="built_in">outputScores</span>(); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'4'</span>: manager.<span class="built_in">queryScore</span>(); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'5'</span>: manager.<span class="built_in">sortScores</span>(); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'6'</span>: manager.<span class="built_in">statsScores</span>(); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'7'</span>: manager.<span class="built_in">modifyOrDeleteScores</span>(); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'8'</span>: manager.<span class="built_in">clearAllData</span>(); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'9'</span>: manager.<span class="built_in">saveScores</span>(); cout &lt;&lt; <span class="string">"数据已保存，退出系统。\n"</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">default</span>: cout &lt;&lt; <span class="string">"无效的输入，请重新输入。\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，对科目成绩的管理基本完善。在此的基础上，还可以添加对于综测成绩的管理。</p><p><strong>加入：</strong></p><ul><li><strong>单科GPA计算与评级</strong></li><li><strong>总GPA计算</strong></li><li><strong>课外活动分数</strong></li><li><strong>想品德成绩（该项默认为95分）</strong></li><li><strong>参考信电学院综测计算公式：</strong></li></ul><p><span class="math display">\[综合测评成绩=\frac{GPA×70 + 思想品德成绩 ×10+课外活动表现×20+附加分}{100}\]</span></p><h2 id="完整代码如下"><strong>完整代码如下：</strong></h2><p><strong>使用c++14:</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*******************************************************************</span></span><br><span class="line"><span class="comment">*               名    称：学生成绩管理系统1.1                      *</span></span><br><span class="line"><span class="comment">*               创建日期：2024-4-21                                *</span></span><br><span class="line"><span class="comment">*               最后修改：2024-4-22                                *</span></span><br><span class="line"><span class="comment">*               版    权：中国农业大学信息与电气工程学院           *</span></span><br><span class="line"><span class="comment">*               版 本 号：4.0                                      *</span></span><br><span class="line"><span class="comment">*******************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> string dataFile = <span class="string">"scores.txt"</span>;</span><br><span class="line"><span class="comment">// 登录函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">login</span><span class="params">()</span> </span>{</span><br><span class="line">string password;</span><br><span class="line">string correctPassword = <span class="string">"1234"</span>;</span><br><span class="line"><span class="type">int</span> attempts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (attempts &lt; <span class="number">3</span>) {</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入密码："</span>;</span><br><span class="line">cin &gt;&gt; password;</span><br><span class="line"><span class="keyword">if</span> (password == correctPassword) {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">cout &lt;&lt; <span class="string">"密码错误！还有 "</span> &lt;&lt; <span class="number">2</span> - attempts &lt;&lt; <span class="string">" 次机会。\n"</span>;</span><br><span class="line">}</span><br><span class="line">attempts++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//单学科的信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubjectInfo</span> {</span><br><span class="line"><span class="type">int</span> score;       <span class="comment">// 成绩</span></span><br><span class="line">string grade;    <span class="comment">// 等级</span></span><br><span class="line"><span class="type">double</span> gpa;      <span class="comment">// 绩点</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> {</span><br><span class="line"></span><br><span class="line">string id;  <span class="comment">// 学号</span></span><br><span class="line">string name;    <span class="comment">// 姓名</span></span><br><span class="line">string classId; <span class="comment">// 班级</span></span><br><span class="line">map&lt;string, SubjectInfo&gt; scores;<span class="comment">// 学科信息</span></span><br><span class="line"><span class="type">double</span> gpa; <span class="comment">// 绩点</span></span><br><span class="line"><span class="type">double</span> extracurricularActivitiesScore; <span class="comment">// 课外活动分数</span></span><br><span class="line"><span class="type">double</span> comprehensiveScore; <span class="comment">// 综测分数</span></span><br><span class="line"><span class="comment">// 更新综合测评成绩</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calculateComprehensiveScore</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="type">double</span> academicScore = gpa * <span class="number">25</span> * <span class="number">1.0</span>;  <span class="comment">// 获取基于 GPA 的学习成绩</span></span><br><span class="line"><span class="type">double</span> moralEducationScore = <span class="number">95</span>; <span class="comment">// 思想品德成绩固定为95分</span></span><br><span class="line">comprehensiveScore = (academicScore * <span class="number">0.7</span>) + (moralEducationScore * <span class="number">0.1</span>) + (extracurricularActivitiesScore * <span class="number">0.2</span>);</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> gparank;<span class="comment">//绩点排名</span></span><br><span class="line"><span class="type">int</span> comprehensiveRank;<span class="comment">//综测排名</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScoreManager</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">map&lt;string, Student&gt; students;  <span class="comment">// 学生数据</span></span><br><span class="line">map&lt;string, <span class="type">double</span>&gt; subjects;  <span class="comment">// 存储学科名称和学分</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayMenu</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"+++++++++++++++++++++++++++++++++++++++++++++++++++++++\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+                    学生成绩管理系统                 +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+ 1. 添加或重置学科                                   +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+ 2. 录入学生成绩                                     +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+ 3. 显示学生成绩                                     +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+ 4. 查询学生详细成绩                                 +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+ 5. 按GPA或综测成绩排序学生                          +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+ 6. 统计和分析学科成绩                               +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+ 7. 修改或删除学生数据                               +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+ 8. 保存当前数据到文件                               +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+ 9. 从文件加载学生数据                               +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+ 0. 退出系统                                         +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+ d. 清除数据                                         +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+++++++++++++++++++++++++++++++++++++++++++++++++++++++\n"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setSubjects</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"请选择您的操作(1或2)：\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"1.添加学科\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"2.重新设置学科\n"</span>;</span><br><span class="line"><span class="type">char</span> choicee;</span><br><span class="line">cin &gt;&gt; choicee;</span><br><span class="line"><span class="keyword">if</span> (choicee == <span class="string">'1'</span> || choicee == <span class="string">'2'</span>) {</span><br><span class="line"><span class="keyword">if</span> (choicee == <span class="string">'2'</span>) {</span><br><span class="line">subjects.<span class="built_in">clear</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">"原有学科已清空，请重新输入学科名称和学分：\n"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">string name;</span><br><span class="line"><span class="type">double</span> credit;</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入学科名称 (输入-1结束) : "</span>;</span><br><span class="line"><span class="built_in">getline</span>(cin, name);  <span class="comment">// 读取一行作为科目名称</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (name == <span class="string">"-1"</span>) {</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (subjects.<span class="built_in">find</span>(name) != subjects.<span class="built_in">end</span>()) {</span><br><span class="line">cout &lt;&lt; <span class="string">"“"</span> &lt;&lt; name &lt;&lt; <span class="string">"”已存在！\n"</span>;</span><br><span class="line"><span class="keyword">continue</span>;  <span class="comment">// 跳过后续的学分输入，请求用户重新输入科目名称</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"请输入“ "</span> &lt;&lt; name &lt;&lt; <span class="string">" ”所占学分: "</span>;</span><br><span class="line">cin &gt;&gt; credit;  <span class="comment">// 输入对应科目的学分</span></span><br><span class="line">cin.<span class="built_in">ignore</span>(numeric_limits&lt;streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储科目名称和学分</span></span><br><span class="line">subjects[name] = credit;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">cout &lt;&lt; <span class="string">"无效的输入。\n"</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"已设置的学科有："</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; subject : subjects) {</span><br><span class="line">cout &lt;&lt; subject.first &lt;&lt; <span class="string">": "</span> &lt;&lt; subject.second &lt;&lt; <span class="string">" 学分\n"</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inputScores</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"开始录入成绩。\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"------------------------------------\n"</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">Student student;</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入学号（输入-1结束输入）："</span>;</span><br><span class="line">cin &gt;&gt; student.id;</span><br><span class="line"><span class="keyword">if</span> (student.id == <span class="string">"-1"</span>) <span class="keyword">break</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入姓名："</span>;</span><br><span class="line">cin &gt;&gt; student.name;</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入班级："</span>;</span><br><span class="line">cin &gt;&gt; student.classId;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; subject : subjects) {</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line"><span class="type">int</span> sco;</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入学科： "</span> &lt;&lt; subject.first &lt;&lt; <span class="string">" 的成绩："</span>;</span><br><span class="line">cin &gt;&gt; sco;</span><br><span class="line"><span class="keyword">if</span> (sco &gt;= <span class="number">0</span> &amp;&amp; sco &lt;= <span class="number">100</span>) {</span><br><span class="line">student.scores[subject.first].score = sco;</span><br><span class="line"><span class="keyword">break</span>;  <span class="comment">// 成绩有效，跳出内部循环</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">cout &lt;&lt; <span class="string">"无效成绩，请输入0-100之间的数值。\n"</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入课外活动分数："</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line"><span class="type">int</span> tmp;</span><br><span class="line">cin &gt;&gt; tmp;</span><br><span class="line"><span class="keyword">if</span> (tmp &lt;= <span class="number">0</span> || tmp &gt; <span class="number">50</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">"课外活动分数应在0-50之间，请重新输入："</span>;</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">student.extracurricularActivitiesScore = tmp;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">students[student.id] = student; <span class="comment">// 将学生添加到映射中</span></span><br><span class="line">cout &lt;&lt; <span class="string">"------------------------------------\n"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">updateStudentRecords</span>();</span><br><span class="line">}</span><br><span class="line"><span class="comment">//flag 1 各科成绩 2 综测成绩</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outputScores</span><span class="params">(<span class="type">int</span> flag)</span> </span>{</span><br><span class="line">flag--;</span><br><span class="line">cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (students.<span class="built_in">empty</span>()) {</span><br><span class="line">cout &lt;&lt; <span class="string">"没有数据显示。\n"</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (!flag)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; left &lt;&lt; <span class="built_in">setw</span>(<span class="number">17</span>) &lt;&lt; <span class="string">"学号"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"姓名"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"班级"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; subject : subjects) {</span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; subject.first;</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"GPA"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">5</span>) &lt;&lt; <span class="string">"GPA排名"</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : students) {</span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">17</span>) &lt;&lt; pair.second.id &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; pair.second.name &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; pair.second.classId;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; subject : subjects) {</span><br><span class="line"><span class="keyword">auto</span> it = pair.second.scores.<span class="built_in">find</span>(subject.first);</span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; it-&gt;second.score;</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; pair.second.gpa &lt;&lt; pair.second.gparank &lt;&lt; <span class="string">"/"</span> &lt;&lt; students.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">17</span>) &lt;&lt; <span class="string">"学号"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"姓名"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"班级"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"绩点"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"绩点排名"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">15</span>) &lt;&lt; <span class="string">"课外活动分数"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"综测分数"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"综测排名"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : students) {</span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">17</span>) &lt;&lt; pair.second.id &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; pair.second.name &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; pair.second.classId &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; pair.second.gpa &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; pair.second.gparank &lt;&lt; <span class="built_in">setw</span>(<span class="number">15</span>) &lt;&lt; pair.second.extracurricularActivitiesScore &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; pair.second.comprehensiveScore &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; pair.second.comprehensiveRank &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">queryScore</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>);</span><br><span class="line">string id;</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入学号："</span>;</span><br><span class="line">cin &gt;&gt; id;</span><br><span class="line"><span class="built_in">queryScore</span>(id);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">queryScore</span><span class="params">(string id)</span> </span>{</span><br><span class="line">cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (students.<span class="built_in">find</span>(id) == students.<span class="built_in">end</span>()) {</span><br><span class="line">cout &lt;&lt; <span class="string">"学号不存在！\n"</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">Student&amp; student = students[id];</span><br><span class="line">cout &lt;&lt; <span class="string">"学号: "</span> &lt;&lt; student.id &lt;&lt; <span class="string">" 姓名: "</span> &lt;&lt; student.name &lt;&lt; <span class="string">" 班级: "</span> &lt;&lt; student.classId &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"成绩如下：\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"学科名称"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">7</span>) &lt;&lt; <span class="string">"成绩"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">7</span>) &lt;&lt; <span class="string">"等级"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">7</span>) &lt;&lt; <span class="string">"绩点"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; score : student.scores) {</span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; score.first &lt;&lt; <span class="built_in">setw</span>(<span class="number">7</span>) &lt;&lt; score.second.score &lt;&lt; <span class="built_in">setw</span>(<span class="number">7</span>) &lt;&lt; score.second.grade &lt;&lt; <span class="built_in">setw</span>(<span class="number">7</span>) &lt;&lt; score.second.gpa &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; <span class="string">"课外活动分数"</span> &lt;&lt; student.extracurricularActivitiesScore &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"绩点"</span> &lt;&lt; student.gpa &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"综测分数"</span> &lt;&lt; student.comprehensiveScore &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"总绩点排名"</span> &lt;&lt; student.gparank &lt;&lt; <span class="string">"/"</span> &lt;&lt; students.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"总综测排名"</span> &lt;&lt; student.comprehensiveRank &lt;&lt; <span class="string">"/"</span> &lt;&lt; students.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortAndOutput</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>);</span><br><span class="line">string option;</span><br><span class="line">cout &lt;&lt; <span class="string">"请选择排序选项：1.按 GPA 排序 2.按综测成绩排序\n"</span>;</span><br><span class="line">cin &gt;&gt; option;</span><br><span class="line">vector&lt;pair&lt;string, Student&gt;&gt; <span class="built_in">sortedStudents</span>(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//  GPA</span></span><br><span class="line"><span class="keyword">if</span> (option == <span class="string">"1"</span>) {</span><br><span class="line"><span class="built_in">sort</span>(sortedStudents.<span class="built_in">begin</span>(), sortedStudents.<span class="built_in">end</span>(),</span><br><span class="line">[](<span class="type">const</span> pair&lt;string, Student&gt;&amp; a, <span class="type">const</span> pair&lt;string, Student&gt;&amp; b) {<span class="keyword">return</span> a.second.gpa &gt; b.second.gpa;</span><br><span class="line">});</span><br><span class="line">cout &lt;&lt; <span class="string">"按 GPA 排序的学生信息：\n"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (option == <span class="string">"2"</span>) {</span><br><span class="line"><span class="built_in">sort</span>(sortedStudents.<span class="built_in">begin</span>(), sortedStudents.<span class="built_in">end</span>(),</span><br><span class="line">[](<span class="type">const</span> pair&lt;string, Student&gt;&amp; a, <span class="type">const</span> pair&lt;string, Student&gt;&amp; b) {</span><br><span class="line"><span class="keyword">return</span> a.second.comprehensiveScore &gt; b.second.comprehensiveScore;</span><br><span class="line">});</span><br><span class="line">cout &lt;&lt; <span class="string">"按综测成绩排序的学生信息：\n"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">cout &lt;&lt; <span class="string">"无效的排序选项。\n"</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">17</span>) &lt;&lt; <span class="string">"学号"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"姓名"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"班级"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"GPA"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"综测成绩"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"绩点排名"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"综测排名"</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 输出排序后的学生信息</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : sortedStudents) {</span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">17</span>) &lt;&lt; pair.second.id &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; pair.second.name &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; pair.second.classId &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; pair.second.gpa &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; pair.second.comprehensiveScore &lt;&lt; <span class="built_in">setw</span>(<span class="number">3</span>) &lt;&lt; pair.second.gparank &lt;&lt; <span class="string">"/"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; students.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">setw</span>(<span class="number">3</span>) &lt;&lt; pair.second.comprehensiveRank &lt;&lt; <span class="string">"/"</span> &lt;&lt; students.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">statsScores</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (students.<span class="built_in">empty</span>()) {</span><br><span class="line">cout &lt;&lt; <span class="string">"没有学生数据可以分析。\n"</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储每个科目的成绩数据</span></span><br><span class="line">map&lt;string, vector&lt;<span class="type">int</span>&gt; &gt; subjectScores;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : students) {</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; score : pair.second.scores) {</span><br><span class="line">subjectScores[score.first].<span class="built_in">push_back</span>(score.second.score);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出每个科目的成绩分析</span></span><br><span class="line">cout &lt;&lt; <span class="string">"学科成绩分析：\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"科目"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"最低分"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"最高分"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"平均分"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"及格率"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; subject : subjectScores) {</span><br><span class="line"><span class="type">int</span> minScore = INT_MAX;</span><br><span class="line"><span class="type">int</span> maxScore = INT_MIN;</span><br><span class="line"><span class="type">double</span> totalScore = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> passCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> score : subject.second) {</span><br><span class="line"><span class="keyword">if</span> (score &lt; minScore) minScore = score;</span><br><span class="line"><span class="keyword">if</span> (score &gt; maxScore) maxScore = score;</span><br><span class="line">totalScore += score;</span><br><span class="line"><span class="keyword">if</span> (score &gt;= <span class="number">60</span>) passCount++;  <span class="comment">// 60 分及格</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> averageScore = totalScore / subject.second.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">double</span> passRate = <span class="number">100.0</span> * passCount / subject.second.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; subject.first &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; minScore &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; maxScore &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; averageScore &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; passRate &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算单个科目的 GPA 和等级</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calculateSubjectGPAAndGrade</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : students) {</span><br><span class="line"><span class="built_in">calculateGPAAndGrade</span>(pair.second);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">calculateGPAAndGrade</span><span class="params">(Student&amp; student)</span> </span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : student.scores) {</span><br><span class="line"><span class="type">int</span> score = pair.second.score;</span><br><span class="line"><span class="keyword">auto</span>&amp; info = pair.second;</span><br><span class="line"><span class="keyword">if</span> (score &gt;= <span class="number">95</span>) {</span><br><span class="line">info.gpa = <span class="number">4.0</span>; info.grade = <span class="string">"A+"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">90</span>) {</span><br><span class="line">info.gpa = <span class="number">4.0</span>; info.grade = <span class="string">"A"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">85</span>) {</span><br><span class="line">info.gpa = <span class="number">3.7</span>; info.grade = <span class="string">"A-"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">82</span>) {</span><br><span class="line">info.gpa = <span class="number">3.3</span>; info.grade = <span class="string">"B+"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">78</span>) {</span><br><span class="line">info.gpa = <span class="number">3.0</span>; info.grade = <span class="string">"B"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">75</span>) {</span><br><span class="line">info.gpa = <span class="number">2.7</span>; info.grade = <span class="string">"B-"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">72</span>) {</span><br><span class="line">info.gpa = <span class="number">2.3</span>; info.grade = <span class="string">"C+"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">68</span>) {</span><br><span class="line">info.gpa = <span class="number">2.0</span>; info.grade = <span class="string">"C"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">64</span>) {</span><br><span class="line">info.gpa = <span class="number">1.5</span>; info.grade = <span class="string">"D+"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span>) {</span><br><span class="line">info.gpa = <span class="number">1.0</span>; info.grade = <span class="string">"D"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">info.gpa = <span class="number">0.0</span>; info.grade = <span class="string">"F"</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算每个学生的总绩点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calculateTotalGPA</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : students) {</span><br><span class="line"><span class="type">double</span> totalGPA = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> totalCredits = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">calculateGPAAndGrade</span>(pair.second);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; spair : pair.second.scores) {</span><br><span class="line"><span class="type">double</span> credits = subjects[spair.first];  <span class="comment">// 获取科目对应的学分</span></span><br><span class="line">totalGPA += spair.second.gpa * credits;</span><br><span class="line">totalCredits += credits;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (totalCredits != <span class="number">0</span>) { <span class="comment">// 防止除以零</span></span><br><span class="line">pair.second.gpa = totalGPA / totalCredits;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">pair.second.gpa = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算绩点排名</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calculateGPARank</span><span class="params">()</span> </span>{</span><br><span class="line">vector&lt; pair&lt;string, <span class="type">double</span>&gt; &gt; gpas;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : students) {</span><br><span class="line">gpas.<span class="built_in">emplace_back</span>(pair.first, pair.second.gpa);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">sort</span>(gpas.<span class="built_in">begin</span>(), gpas.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="keyword">auto</span>&amp; a, <span class="type">const</span> <span class="keyword">auto</span>&amp; b) {<span class="keyword">return</span> a.second &gt; b.second; });</span><br><span class="line"><span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : gpas) {</span><br><span class="line">students[pair.first].gparank = rank++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算综测排名</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calculateComprehensiveRank</span><span class="params">()</span> </span>{</span><br><span class="line">vector&lt; pair&lt;string, <span class="type">double</span>&gt; &gt; comprehensiveScores;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : students) {</span><br><span class="line">pair.second.<span class="built_in">calculateComprehensiveScore</span>();  <span class="comment">// 确保最新的综测分数被计算</span></span><br><span class="line">comprehensiveScores.<span class="built_in">emplace_back</span>(pair.first, pair.second.comprehensiveScore);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">sort</span>(comprehensiveScores.<span class="built_in">begin</span>(), comprehensiveScores.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="keyword">auto</span>&amp; a, <span class="type">const</span> <span class="keyword">auto</span>&amp; b) {<span class="keyword">return</span> a.second &gt; b.second; });</span><br><span class="line"><span class="type">int</span> rank = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : comprehensiveScores) {</span><br><span class="line">students[pair.first].comprehensiveRank = rank++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数更新所有学生信息和排名</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateStudentRecords</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="built_in">calculateTotalGPA</span>();</span><br><span class="line"><span class="built_in">calculateGPARank</span>();</span><br><span class="line"><span class="built_in">calculateComprehensiveRank</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyOrDeleteScores</span><span class="params">()</span> </span>{</span><br><span class="line">string id;</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入学号："</span>;</span><br><span class="line">cin &gt;&gt; id;</span><br><span class="line"><span class="keyword">if</span> (students.<span class="built_in">find</span>(id) == students.<span class="built_in">end</span>()) {</span><br><span class="line">cout &lt;&lt; <span class="string">"学号不存在！\n"</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Student&amp; student = students[id];</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"当前学生数据：\n"</span>;</span><br><span class="line"><span class="built_in">queryScore</span>(id);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"选择操作：\n1. 修改学科成绩\n2. 修改课外活动分数\n输入 'delete' 删除学生记录："</span>;</span><br><span class="line">string choice;</span><br><span class="line">cin &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (choice == <span class="string">"delete"</span>) {</span><br><span class="line">students.<span class="built_in">erase</span>(id);</span><br><span class="line">cout &lt;&lt; <span class="string">"学生记录已删除。\n"</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (choice == <span class="string">"1"</span>) {</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入要修改的科目名称："</span>;</span><br><span class="line">string subject;</span><br><span class="line">cin &gt;&gt; subject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (student.scores.<span class="built_in">find</span>(subject) == student.scores.<span class="built_in">end</span>()) {</span><br><span class="line">cout &lt;&lt; <span class="string">"科目不存在！\n"</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> newScore;</span><br><span class="line">cout &lt;&lt; <span class="string">"输入新成绩："</span>;</span><br><span class="line">cin &gt;&gt; newScore;</span><br><span class="line"></span><br><span class="line">student.scores[subject].score = newScore;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"成绩已更新。\n"</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="string">"2"</span>) {</span><br><span class="line"><span class="type">double</span> newActivitiesScore;</span><br><span class="line">cout &lt;&lt; <span class="string">"输入新的课外活动分数："</span>;</span><br><span class="line">cin &gt;&gt; newActivitiesScore;</span><br><span class="line">student.extracurricularActivitiesScore = newActivitiesScore;</span><br><span class="line">cout &lt;&lt; <span class="string">"课外活动分数已更新。\n"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">cout &lt;&lt; <span class="string">"无效输入。\n"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">updateStudentRecords</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loadScores</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="function">ifstream <span class="title">file</span><span class="params">(dataFile)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) {</span><br><span class="line">cerr &lt;&lt; <span class="string">"无法打开文件 "</span> &lt;&lt; dataFile &lt;&lt; <span class="string">" 进行读取。\n"</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">string line;</span><br><span class="line"><span class="built_in">getline</span>(file, line);  <span class="comment">// 读取表头</span></span><br><span class="line"><span class="function">istringstream <span class="title">header</span><span class="params">(line)</span></span>;</span><br><span class="line">string token;</span><br><span class="line">vector&lt; pair&lt;string, <span class="type">double</span>&gt; &gt; Tmp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳过前三个标题</span></span><br><span class="line">header &gt;&gt; token &gt;&gt; token &gt;&gt; token;</span><br><span class="line"><span class="comment">// 读取学科和学分信息</span></span><br><span class="line"><span class="keyword">while</span> (header &gt;&gt; token) {</span><br><span class="line"><span class="keyword">if</span> (token == <span class="string">"课外活动分数"</span>) <span class="keyword">break</span>;</span><br><span class="line">string tmp = token;<span class="comment">// 保留学科</span></span><br><span class="line">header &gt;&gt; token; <span class="comment">// 读取学分</span></span><br><span class="line">subjects[tmp] = <span class="built_in">stod</span>(token);</span><br><span class="line">Tmp.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(tmp, <span class="built_in">stod</span>(token)));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Student student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(file, line)) {</span><br><span class="line"><span class="keyword">if</span> (line.<span class="built_in">empty</span>()) {</span><br><span class="line"><span class="comment">// 当遇到空行时完成了一个学生的所有输入</span></span><br><span class="line"><span class="keyword">if</span> (!student.id.<span class="built_in">empty</span>()) {</span><br><span class="line">students[student.id] = student;  <span class="comment">// 保存当前学生的数据</span></span><br><span class="line">student = <span class="built_in">Student</span>(); <span class="comment">// 重置学生对象</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">iss &gt;&gt; student.id &gt;&gt; student.name &gt;&gt; student.classId;</span><br><span class="line">string subject;</span><br><span class="line">SubjectInfo info;</span><br><span class="line"><span class="type">int</span> i = subjects.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span> (i--) {</span><br><span class="line">iss &gt;&gt; info.score &gt;&gt; info.gpa;</span><br><span class="line">subject = Tmp[subjects.<span class="built_in">size</span>() - i - <span class="number">1</span>].first;</span><br><span class="line">student.scores[subject] = info;</span><br><span class="line">}</span><br><span class="line">iss &gt;&gt; student.extracurricularActivitiesScore;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保文件结束时最后一个学生也被添加</span></span><br><span class="line"><span class="keyword">if</span> (!student.id.<span class="built_in">empty</span>() &amp;&amp; !student.name.<span class="built_in">empty</span>() &amp;&amp; !student.classId.<span class="built_in">empty</span>()) {</span><br><span class="line">students[student.id] = student;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">"数据已读取。读取数据如下：\n"</span>;</span><br><span class="line"><span class="built_in">updateStudentRecords</span>();</span><br><span class="line"><span class="built_in">outputScores</span>(<span class="number">1</span>); <span class="comment">// 显示读入的数据</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">saveScores</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"是否保存数据？ 1.保存 2.不保存\n"</span>;</span><br><span class="line"><span class="type">char</span> choice;</span><br><span class="line">cin &gt;&gt; choice;</span><br><span class="line"><span class="keyword">if</span> (choice == <span class="string">'1'</span>) {</span><br><span class="line"><span class="function">ofstream <span class="title">file</span><span class="params">(dataFile)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) {</span><br><span class="line">cerr &lt;&lt; <span class="string">"无法打开文件 '"</span> &lt;&lt; dataFile &lt;&lt; <span class="string">"' 进行写入。\n"</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入表头</span></span><br><span class="line">file &lt;&lt; left &lt;&lt; <span class="built_in">setw</span>(<span class="number">17</span>) &lt;&lt; <span class="string">"学号"</span> &lt;&lt; <span class="string">"\t\t\t"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"姓名"</span> &lt;&lt; <span class="string">"\t\t"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">"班级"</span> &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; subject : subjects) {</span><br><span class="line">file &lt;&lt; <span class="string">"\t\t"</span> &lt;&lt; subject.first &lt;&lt; <span class="string">"\t\t"</span> &lt;&lt; subject.second;</span><br><span class="line">}</span><br><span class="line">file &lt;&lt; <span class="string">"\t\t"</span> &lt;&lt; <span class="string">"课外活动分数"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入学生数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : students) {</span><br><span class="line"><span class="type">const</span> Student&amp; student = pair.second;</span><br><span class="line">file &lt;&lt; left &lt;&lt; <span class="built_in">setw</span>(<span class="number">17</span>) &lt;&lt; student.id &lt;&lt; <span class="string">"\t\t"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; student.name &lt;&lt; <span class="string">"\t\t"</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; student.classId &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; subject : subjects) {</span><br><span class="line"><span class="keyword">auto</span> it = student.scores.<span class="built_in">find</span>(subject.first);</span><br><span class="line">file &lt;&lt; <span class="string">"\t\t"</span> &lt;&lt; it-&gt;second.score; <span class="comment">// 写入学科成绩</span></span><br><span class="line">file &lt;&lt; <span class="string">"\t\t"</span> &lt;&lt; it-&gt;second.gpa; <span class="comment">// 写入gpa</span></span><br><span class="line">}</span><br><span class="line">file &lt;&lt; <span class="string">"\t\t"</span> &lt;&lt; student.extracurricularActivitiesScore &lt;&lt; endl;</span><br><span class="line">file &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">"--------------数据已保存。---------------\n"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="string">'2'</span>) {</span><br><span class="line">cout &lt;&lt; <span class="string">"数据未保存，退出系统。\n"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">cout &lt;&lt; <span class="string">"无效的输入。\n"</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearAllData</span><span class="params">()</span> </span>{</span><br><span class="line">students.<span class="built_in">clear</span>();</span><br><span class="line">subjects.<span class="built_in">clear</span>();</span><br><span class="line"><span class="function">ofstream <span class="title">file</span><span class="params">(dataFile, ios::trunc)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) {</span><br><span class="line">cerr &lt;&lt; <span class="string">"无法打开文件以清空内容。\n"</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">"所有数据已被清除。\n"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">login</span>()) {</span><br><span class="line">cout &lt;&lt; <span class="string">"口令错误，不允许进入本系统!\n"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">ScoreManager manager;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">manager.<span class="built_in">displayMenu</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">"请选择您的操作(0-9)："</span>;</span><br><span class="line"><span class="type">char</span> choice;</span><br><span class="line">cin &gt;&gt; choice;</span><br><span class="line"><span class="keyword">switch</span> (choice) {</span><br><span class="line"><span class="keyword">case</span> <span class="string">'1'</span>:</span><br><span class="line">manager.<span class="built_in">setSubjects</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'2'</span>:</span><br><span class="line">manager.<span class="built_in">inputScores</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'3'</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">"选择输出格式（1：各科成绩，2：综测成绩）："</span>;</span><br><span class="line">cin &gt;&gt; choice;</span><br><span class="line">manager.<span class="built_in">outputScores</span>(choice - <span class="string">'0'</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'4'</span>:</span><br><span class="line">manager.<span class="built_in">queryScore</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'5'</span>:</span><br><span class="line">manager.<span class="built_in">sortAndOutput</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'6'</span>:</span><br><span class="line">manager.<span class="built_in">statsScores</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'7'</span>:</span><br><span class="line">manager.<span class="built_in">modifyOrDeleteScores</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'8'</span>:</span><br><span class="line">manager.<span class="built_in">saveScores</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'9'</span>:</span><br><span class="line">manager.<span class="built_in">loadScores</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'0'</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">"已退出系统。\n"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">manager.<span class="built_in">clearAllData</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">"无效的选择，请重新输入。\n"</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最终版测试数据可以使用附件<a href="https://wwl.lanzoue.com/iggdn1w66opa">score.txt</a>。</p><p>dev c++<a href="https://wwl.lanzoue.com/iVUmt1y1h33a">下载地址</a>密码：<strong>foex</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> c/c++ </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多机调度问题和多处最优服务次序问题</title>
      <link href="/2024/04/20/duo-ji-diao-du-wen-ti-he-duo-chu-zui-you-fu-wu-ci-xu-wen-ti/"/>
      <url>/2024/04/20/duo-ji-diao-du-wen-ti-he-duo-chu-zui-you-fu-wu-ci-xu-wen-ti/</url>
      
        <content type="html"><![CDATA[<blockquote><p>贪心算法(又名贪婪法)，是寻找<strong>最优解问题</strong>的常用方法，这种方法模式一般将求解过程分成<strong>若干个步骤</strong>，但每个步骤都应用贪心原则，选取当前状态下<strong>最好/最优的选择</strong>（局部最有利的选择），并以此希望最后堆叠出的结果也是最好/最优的解。{看着这个名字，贪心，贪婪这两字的内在含义最为关键。这就好像一个贪婪的人，他事事都想要眼前看到最好的那个，看不到长远的东西，也不为最终的结果和将来着想，贪图眼前局部的利益最大化，有点走一步看一步的感觉。}</p><p>但是要注意的是，贪心算法不一定能得到全局的最优解，关键是<strong>贪心策略的选择</strong>。</p></blockquote><h2 id="多机调度问题">多机调度问题</h2><h3 id="问题描述">问题描述</h3><p>要求给出一种作业调度方案，使所给的 <span class="math inline">\(n\)</span> 个作业（假定作业数量 <span class="math inline">\(n\)</span>不超过20）在尽可能短的时间内由m台机器加工处理完成。约定，每个作业均可在任何一台机器上加工处理，但未完工前不允许中断处理。作业不能拆分成更小的子作业。</p><h3 id="输入格式">输入格式</h3><p>第一行包含两个整数 <span class="math inline">\(m\)</span> 和 <span class="math inline">\(n\)</span> ，空格分开。 <span class="math inline">\(m\)</span> 表示机器的数量，<span class="math inline">\(n\)</span> 表示作业的数量。</p><p>第二行包含 <span class="math inline">\(n\)</span>个整数，表示每个作业的完成时间。</p><h3 id="输出格式">输出格式</h3><p>先输出：</p><p>将机器 <span class="math inline">\(M_i\)</span> 从 <span class="math inline">\(time1\)</span> 到 <span class="math inline">\(time2\)</span> 的时间段分配给作业 <span class="math inline">\(N_j\)</span></p><p>…</p><p>最后输出：处理完成所有作业需要的最短时间为 <span class="math inline">\(time\)</span> 。</p><p>每个结果占一行。</p><h3 id="示例">示例</h3><h4 id="示例1">示例1</h4><p>输入(input)： 3 5</p><p>2 14 6 16 3</p><p>输出(output)：</p><p>将机器1从0到16的时间段分配给作业4</p><p>将机器2从0到14的时间段分配给作业2</p><p>将机器3从0到6的时间段分配给作业3</p><p>将机器3从6到9的时间段分配给作业5</p><p>将机器3从9到11的时间段分配给作业1</p><p>处理完成所有作业需要的最短时间为16</p><h4 id="示例2">示例2</h4><p>输入(input)：</p><p>7 3</p><p>6 8 18</p><p>输出(output)： 将机器1从0到18的时间段分配给作业3</p><p>将机器2从0到8的时间段分配给作业2</p><p>将机器3从0到6的时间段分配给作业1</p><p>处理完成所有作业需要的最短时间为18</p><h3 id="问题分析">问题分析</h3><p>如果 <span class="math inline">\(n\leq m\)</span>：那么每台机器分配一个作业即可。</p><p>如果 <span class="math inline">\(n&gt;m\)</span> ：采取贪心策略。贪心策略是优先处理加工时间长作业，即把处理时间最长的作业分配给最先空闲的机器，这样可以保证处理时间长的作业优先处理，从而在整体上获得尽可能短的处理时间。</p><p>比如下面这个示例： 输入(input)：</p><p>3 7</p><p>2 14 4 16 6 5 3</p><p>输出(output)：</p><p>将机器1从0到16的时间段分配给作业4</p><p>将机器2从0到14的时间段分配给作业2</p><p>将机器3从0到6的时间段分配给作业5</p><p>将机器3从6到11的时间段分配给作业6</p><p>将机器3从11到15的时间段分配给作业3</p><p>将机器2从14到17的时间段分配给作业7</p><p>将机器3从15到17的时间段分配给作业1</p><p>处理完成所有作业需要的最短时间为17</p><p>用图像表示示例中多台机器处理的流程如下：</p><p><img src="../../../../images/多机调度问题和多处最优服务次序问题/1.jpg"></p><h3 id="代码实现">代码实现</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Job</span> {</span><br><span class="line">    <span class="type">int</span> id; <span class="comment">// 记录作业编号</span></span><br><span class="line">    <span class="type">int</span> time; <span class="comment">// 记录作业时长 </span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(Job a, Job b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a.time &gt; b.time;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> m, n;   cin &gt;&gt; m &gt;&gt; n; <span class="comment">// m为机器数量,n为作业数量</span></span><br><span class="line">    <span class="function">vector&lt;Job&gt; <span class="title">jobs</span><span class="params">(n)</span></span>; <span class="comment">// 每个作业完成需要的时间和对应的编号</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        cin &gt;&gt; jobs[i].time;</span><br><span class="line">        jobs[i].id = i + <span class="number">1</span>; </span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">sort</span>(jobs.<span class="built_in">begin</span>(), jobs.<span class="built_in">end</span>(), compare); <span class="comment">// 对作业时长降序排序 </span></span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">subtime</span><span class="params">(m, <span class="number">0</span>)</span></span>; <span class="comment">// 记录每个机器的工作时长,并初始化为0 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="type">int</span> select = <span class="number">0</span>; <span class="comment">// 参数select表示选择哪一台机器来处理jobs[i].id作业 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) { </span><br><span class="line">            <span class="keyword">if</span>(subtime[j] &lt; subtime[select]) { <span class="comment">// 分配给当前所有机器中处理工作时长最小的机器 </span></span><br><span class="line">                select = j; <span class="comment">// 选择机器进行工作</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        subtime[select] += jobs[i].time;</span><br><span class="line">        cout &lt;&lt; <span class="string">"将机器"</span> &lt;&lt; select + <span class="number">1</span> &lt;&lt; <span class="string">"从"</span> &lt;&lt; subtime[select] - jobs[i].time &lt;&lt; <span class="string">"到"</span> &lt;&lt; subtime[select] &lt;&lt; <span class="string">"的时间段分配给作业"</span> &lt;&lt; jobs[i].id &lt;&lt; endl; </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sumtime = subtime[<span class="number">0</span>]; <span class="comment">// 记录总时长</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">        <span class="keyword">if</span>(sumtime &lt; subtime[i]) {</span><br><span class="line">        sumtime = subtime[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"处理完成所有作业需要的最短时间为"</span> &lt;&lt; sumtime &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="多处最优服务次序问题">多处最优服务次序问题</h2><h3 id="问题描述-1">问题描述</h3><p>设有 <span class="math inline">\(n\)</span>个顾客同时等待一项服务。顾客 <span class="math inline">\(i\)</span>需要的服务时间为 <span class="math inline">\(t_i\)</span>，<span class="math inline">\(1\leq i\leq n\)</span>, 。共有 <span class="math inline">\(s\)</span> 处可以提供此项服务。应如何安排 <span class="math inline">\(n\)</span>个顾客的服务次序才能使平均等待时间达到最小？平均等待时间是 <span class="math inline">\(n\)</span> 个顾客等待服务时间的总和除以 <span class="math inline">\(n\)</span>。</p><p><span class="math inline">\(j\)</span> 处第 <span class="math inline">\(k\)</span> 个顾客的等待时间 = 前面 <span class="math inline">\(k-1\)</span> 个顾客总共服务时间 + 第 <span class="math inline">\(k\)</span> 个顾客的服务时间。</p><p>比如某处第一个顾客的等待时间 = 该顾客自己所需要的服务时间。</p><h3 id="输入格式-1">输入格式</h3><p>第一行包含两个整数 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(s\)</span> ，空格分开。 <span class="math inline">\(n\)</span> 表示顾客的数量，<span class="math inline">\(s\)</span> 表示服务处的数量。</p><p>第二行包含 <span class="math inline">\(n\)</span>个整数，表示每个顾客需要的服务时间。</p><h3 id="输出格式-1">输出格式</h3><p>一行：最小平均等待时间（小数点后保留3位）。</p><h3 id="示例-1">示例</h3><p>输入(input)：</p><p>10 2</p><p>56 12 1 99 1000 234 33 55 99 812</p><p>输出(output)：</p><p>336.000</p><h3 id="问题分析-1">问题分析</h3><p>和多机调度问题类似，这道题目的贪心策略是优先服务需要服务时间短的人，这样可以保证每个人的平均等待时间最小。</p><h3 id="代码实现-1">代码实现</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> n, s;cin &gt;&gt; n &gt;&gt; s; <span class="comment">// 有n个顾客和s个服务地点</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">time</span><span class="params">(n)</span></span>; <span class="comment">// 每个顾客需要的时间 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        cin &gt;&gt; time[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(time.<span class="built_in">begin</span>(), time.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">subtime</span><span class="params">(s, <span class="number">0</span>)</span></span>; <span class="comment">// 记录每个服务地点的服务时长 </span></span><br><span class="line">    <span class="type">int</span> totalwait_time = <span class="number">0</span>; <span class="comment">// 记录所有人等待总时长</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="type">int</span> select = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; s; j++) {</span><br><span class="line">            <span class="keyword">if</span>(subtime[j] &lt; subtime[select]) {</span><br><span class="line">                select = j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        totalwait_time = totalwait_time + subtime[select] + time[i]; <span class="comment">// 一个人的等待时间 = 前面人的时间 + 自己的时间 </span></span><br><span class="line">        subtime[select] += time[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.3lf"</span>, <span class="number">1.0</span> * totalwait_time / n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> c/c++ </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多元微积分部分历年期末试卷</title>
      <link href="/2024/04/17/duo-yuan-wei-ji-fen-bu-fen-li-nian-qi-mo-shi-juan/"/>
      <url>/2024/04/17/duo-yuan-wei-ji-fen-bu-fen-li-nian-qi-mo-shi-juan/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iNZeg1ve0y2d">下载压缩包点这里</a></p><p><span class="math inline">\(ps\)</span> ：有更新的试卷或答案可以发邮箱 3187248635@qq.com 联系我们~</p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 多元微积分期末试卷 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 试卷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八节 一般周期函数的傅里叶级数</title>
      <link href="/2024/04/17/duo-yuan-wei-ji-fen-12-8-yi-ban-zhou-qi-han-shu-de-fu-li-xie-ji-shu/"/>
      <url>/2024/04/17/duo-yuan-wei-ji-fen-12-8-yi-ban-zhou-qi-han-shu-de-fu-li-xie-ji-shu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iPhKR1vdvfna">下载PDF点这里</a></p><p><img src="../../../../images/多元微积分12-8一般周期函数的傅里叶级数/96.jpg"></p><p><img src="../../../../images/多元微积分12-8一般周期函数的傅里叶级数/97.jpg"></p><p><img src="../../../../images/多元微积分12-8一般周期函数的傅里叶级数/98.jpg"></p><p><img src="../../../../images/多元微积分12-8一般周期函数的傅里叶级数/99.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十二章 无穷级数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 傅里叶级数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七节 傅里叶级数</title>
      <link href="/2024/04/17/duo-yuan-wei-ji-fen-12-7-fu-li-xie-ji-shu/"/>
      <url>/2024/04/17/duo-yuan-wei-ji-fen-12-7-fu-li-xie-ji-shu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iRay91vdukab">下载PDF点这里</a></p><p><img src="../../../../images/多元微积分12-7傅里叶级数/87.jpg"></p><p><img src="../../../../images/多元微积分12-7傅里叶级数/88.jpg"></p><p><img src="../../../../images/多元微积分12-7傅里叶级数/89.jpg"></p><p><img src="../../../../images/多元微积分12-7傅里叶级数/90.jpg"></p><p><img src="../../../../images/多元微积分12-7傅里叶级数/91.jpg"></p><p><img src="../../../../images/多元微积分12-7傅里叶级数/92.jpg"></p><p><img src="../../../../images/多元微积分12-7傅里叶级数/93.jpg"></p><p><img src="../../../../images/多元微积分12-7傅里叶级数/94.jpg"></p><p><img src="../../../../images/多元微积分12-7傅里叶级数/95.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十二章 无穷级数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 傅里叶级数 </tag>
            
            <tag> 延拓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五节 函数的幂级数展开式的应用</title>
      <link href="/2024/04/17/duo-yuan-wei-ji-fen-12-5-han-shu-de-mi-ji-shu-zhan-kai-shi-de-ying-yong/"/>
      <url>/2024/04/17/duo-yuan-wei-ji-fen-12-5-han-shu-de-mi-ji-shu-zhan-kai-shi-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iySGx1vdu81a">下载PDF点这里</a></p><p><img src="../../../../images/多元微积分12-5函数的幂级数展开式的应用/77.jpg"></p><p><img src="../../../../images/多元微积分12-5函数的幂级数展开式的应用/78.jpg"></p><p><img src="../../../../images/多元微积分12-5函数的幂级数展开式的应用/79.jpg"></p><p><img src="../../../../images/多元微积分12-5函数的幂级数展开式的应用/80.jpg"></p><p><img src="../../../../images/多元微积分12-5函数的幂级数展开式的应用/81.jpg"></p><p><img src="../../../../images/多元微积分12-5函数的幂级数展开式的应用/82.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十二章 无穷级数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 幂级数 </tag>
            
            <tag> 欧拉公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四节 函数展开成幂级数</title>
      <link href="/2024/04/16/duo-yuan-wei-ji-fen-12-4-han-shu-zhan-kai-cheng-mi-ji-shu/"/>
      <url>/2024/04/16/duo-yuan-wei-ji-fen-12-4-han-shu-zhan-kai-cheng-mi-ji-shu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iCY3A1vdtvef">下载PDF点这里</a></p><p><img src="../../../../images/多元微积分12-4函数展开成幂级数/71.jpg"></p><p><img src="../../../../images/多元微积分12-4函数展开成幂级数/72.jpg"></p><p><img src="../../../../images/多元微积分12-4函数展开成幂级数/73.jpg"></p><p><img src="../../../../images/多元微积分12-4函数展开成幂级数/74.jpg"></p><p><img src="../../../../images/多元微积分12-4函数展开成幂级数/75.jpg"></p><p><img src="../../../../images/多元微积分12-4函数展开成幂级数/76.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十二章 无穷级数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 幂级数 </tag>
            
            <tag> 麦克劳林展开式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三节 幂级数</title>
      <link href="/2024/04/16/duo-yuan-wei-ji-fen-12-3-mi-ji-shu/"/>
      <url>/2024/04/16/duo-yuan-wei-ji-fen-12-3-mi-ji-shu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iTN0y1vdtieh">下载PDF点这里</a></p><p><img src="../../../../images/多元微积分12-3幂级数/63.jpg"></p><p><img src="../../../../images/多元微积分12-3幂级数/64.jpg"></p><p><img src="../../../../images/多元微积分12-3幂级数/65.jpg"></p><p><img src="../../../../images/多元微积分12-3幂级数/66.jpg"></p><p><img src="../../../../images/多元微积分12-3幂级数/67.jpg"></p><p><img src="../../../../images/多元微积分12-3幂级数/68.jpg"></p><p><img src="../../../../images/多元微积分12-3幂级数/69.jpg"></p><p><img src="../../../../images/多元微积分12-3幂级数/70.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十二章 无穷级数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 幂级数 </tag>
            
            <tag> 阿贝尔定理 </tag>
            
            <tag> 收敛半径 </tag>
            
            <tag> 收敛域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承方式理解的作业</title>
      <link href="/2024/04/16/ji-cheng-fang-shi-li-jie-de-zuo-ye/"/>
      <url>/2024/04/16/ji-cheng-fang-shi-li-jie-de-zuo-ye/</url>
      
        <content type="html"><![CDATA[<p><strong>目标：</strong>验证公用继承下基类的公用成员在派生类依然为公用成员</p><h2 id="测试用程序代码"><strong>测试用程序代码：</strong></h2><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> a2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dsp</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"A : public a1 =  "</span> &lt;&lt; a1 &lt;&lt; <span class="string">", protected a2 =  "</span> &lt;&lt; a2 &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> b1 = <span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">seta2</span><span class="params">(<span class="type">int</span> i)</span> </span>{</span><br><span class="line">a2 = i;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dsp</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"B : public a1 =  "</span> &lt;&lt; a1 &lt;&lt; <span class="string">", protected a2 =  "</span> &lt;&lt; a2 &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dsp</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"C : public a1 =  "</span> &lt;&lt; a1 &lt;&lt; <span class="string">", protected a2 =  "</span> &lt;&lt; a2 &lt;&lt; <span class="string">", public b1 =  "</span> &lt;&lt; b1 &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">(A&amp; d, B&amp; d1, C&amp; d2)</span> </span>{</span><br><span class="line">d.<span class="built_in">dsp</span>(); d1.<span class="built_in">dsp</span>(); d2.<span class="built_in">dsp</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">"----------------------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">A d;</span><br><span class="line">B d1;</span><br><span class="line">C d2;</span><br><span class="line"><span class="built_in">Show</span>(d, d1, d2);</span><br><span class="line">d1.a1 = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">Show</span>(d, d1, d2);</span><br><span class="line">d2.a1 = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">Show</span>(d, d1, d2);</span><br><span class="line">d1.<span class="built_in">seta2</span>(<span class="number">300</span>);</span><br><span class="line"><span class="built_in">Show</span>(d, d1, d2);</span><br><span class="line">d2.<span class="built_in">seta2</span>(<span class="number">400</span>);</span><br><span class="line"><span class="built_in">Show</span>(d, d1, d2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="出现现象"><strong>出现现象：</strong></h2><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">A : public a1 =  10, protected a2 =  20</span><br><span class="line">B : public a1 =  10, protected a2 =  20</span><br><span class="line">C : public a1 =  10, protected a2 =  20, public b1 =  30</span><br><span class="line">----------------------</span><br><span class="line">A : public a1 =  10, protected a2 =  20</span><br><span class="line">B : public a1 =  100, protected a2 =  20</span><br><span class="line">C : public a1 =  10, protected a2 =  20, public b1 =  30</span><br><span class="line">----------------------</span><br><span class="line">A : public a1 =  10, protected a2 =  20</span><br><span class="line">B : public a1 =  100, protected a2 =  20</span><br><span class="line">C : public a1 =  200, protected a2 =  20, public b1 =  30</span><br><span class="line">----------------------</span><br><span class="line">A : public a1 =  10, protected a2 =  20</span><br><span class="line">B : public a1 =  100, protected a2 =  300</span><br><span class="line">C : public a1 =  200, protected a2 =  20, public b1 =  30</span><br><span class="line">----------------------</span><br><span class="line">A : public a1 =  10, protected a2 =  20</span><br><span class="line">B : public a1 =  100, protected a2 =  300</span><br><span class="line">C : public a1 =  200, protected a2 =  400, public b1 =  30</span><br><span class="line">----------------------</span><br></pre></td></tr></tbody></table></figure><h2 id="分析">分析：</h2><ol type="1"><li><p><strong>初始化</strong>：</p><ul><li><p>所有对象 (<code>d</code>, <code>d1</code>, <code>d2</code>) 的<code>a1</code> 初始化为 10，<code>a2</code> 初始化为20。<code>d1</code> 和 <code>d2</code> 中的 <code>b1</code> 初始化为30。</p><p>输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">A : public a1 =  10, protected a2 =  20</span><br><span class="line">B : public a1 =  10, protected a2 =  20</span><br><span class="line">C : public a1 =  10, protected a2 =  20, public b1 =  30</span><br><span class="line">----------------------</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>修改 <code>d1.a1</code> 为 100</strong>：</p><ul><li><p>只影响 <code>d1</code> 对象</p><p>输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">A : public a1 =  10, protected a2 =  20</span><br><span class="line">B : public a1 =  100, protected a2 =  20</span><br><span class="line">C : public a1 =  10, protected a2 =  20, public b1 =  30</span><br><span class="line">----------------------</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>修改 <code>d2.a1</code> 为 200</strong>：</p><ul><li><p>只影响 <code>d2</code> 对象</p><p>输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">A : public a1 =  10, protected a2 =  20</span><br><span class="line">B : public a1 =  100, protected a2 =  20</span><br><span class="line">C : public a1 =  200, protected a2 =  20, public b1 =  30</span><br><span class="line">----------------------</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>调用 <code>d1.seta2(300)</code></strong></p><p>设置了 <code>d1</code> 对象中的 <code>a2</code> 值为 300。</p><p>输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">A : public a1 =  10, protected a2 =  20</span><br><span class="line">B : public a1 =  100, protected a2 =  300</span><br><span class="line">C : public a1 =  200, protected a2 =  20, public b1 =  30</span><br><span class="line">----------------------</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>调用<code>d2.seta2(400)</code></strong></p><p>设置了 <code>d2</code> 对象中的 <code>a2</code> 值为 400。</p><p>输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">A : public a1 =  10, protected a2 =  20</span><br><span class="line">B : public a1 =  100, protected a2 =  300</span><br><span class="line">C : public a1 =  200, protected a2 =  400, public b1 =  30</span><br><span class="line">----------------------</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="结论"><strong>结论：</strong></h2><ul><li>每个对象维护自己独立的成员变量（包括继承的变量）状态。</li><li>受保护的成员虽然在类及其子类之间可以访问和修改，但它们的状态是在每个对象级别上独立管理的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> c/c++ </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第二节 边际分布与随机变量的独立性</title>
      <link href="/2024/04/13/gai-lu-lun-3-2-bian-ji-fen-bu-yu-sui-ji-bian-liang-de-du-li-xing/"/>
      <url>/2024/04/13/gai-lu-lun-3-2-bian-ji-fen-bu-yu-sui-ji-bian-liang-de-du-li-xing/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iMuDz1uzldne">下载PDF点这里</a></p><p><img src="../../../../images/概率论3-2边际分布与随机变量的独立性/50.jpg"></p><p><img src="../../../../images/概率论3-2边际分布与随机变量的独立性/51.jpg"></p><p><img src="../../../../images/概率论3-2边际分布与随机变量的独立性/52.jpg"></p><p><img src="../../../../images/概率论3-2边际分布与随机变量的独立性/53.jpg"></p><p><img src="../../../../images/概率论3-2边际分布与随机变量的独立性/54.jpg"></p><p><img src="../../../../images/概率论3-2边际分布与随机变量的独立性/55.jpg"></p><p><img src="../../../../images/概率论3-2边际分布与随机变量的独立性/56.jpg"></p><p><img src="../../../../images/概率论3-2边际分布与随机变量的独立性/57.jpg"></p><p><img src="../../../../images/概率论3-2边际分布与随机变量的独立性/58.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第三章 多维随机变量及其分布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多维随机变量 </tag>
            
            <tag> 边际分布 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一节 多维随机变量及其联合分布</title>
      <link href="/2024/04/13/gai-lu-lun-3-1-duo-wei-sui-ji-bian-liang-ji-qi-lian-he-fen-bu/"/>
      <url>/2024/04/13/gai-lu-lun-3-1-duo-wei-sui-ji-bian-liang-ji-qi-lian-he-fen-bu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/imep41uzdauf">下载PDF点这里</a></p><p><img src="../../../../images/概率论3-1多维随机变量及其联合分布/43.jpg"></p><p><img src="../../../../images/概率论3-1多维随机变量及其联合分布/44.jpg"></p><p><img src="../../../../images/概率论3-1多维随机变量及其联合分布/45.jpg"></p><p><img src="../../../../images/概率论3-1多维随机变量及其联合分布/46.jpg"></p><p><img src="../../../../images/概率论3-1多维随机变量及其联合分布/47.jpg"></p><p><img src="../../../../images/概率论3-1多维随机变量及其联合分布/48.jpg"></p><p><img src="../../../../images/概率论3-1多维随机变量及其联合分布/49.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第三章 多维随机变量及其分布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多维随机变量 </tag>
            
            <tag> r项分布 </tag>
            
            <tag> 多维超几何分布 </tag>
            
            <tag> 多维均匀分布 </tag>
            
            <tag> 二元正态分布 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BST(二叉搜索树)</title>
      <link href="/2024/04/10/bst/"/>
      <url>/2024/04/10/bst/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p><strong>编写C++程序来实现执行以下操作：</strong></p><ol type="1"><li><p>向二叉搜索树中插入一个元素</p></li><li><p>从二叉搜索树中删除一个元素</p></li><li><p>显示所有叶子节点</p></li><li><p>遍历给定的二叉树</p><ul><li>深度优先算法<ul><li>中序遍历</li><li>前序遍历</li></ul></li></ul></li></ol><p><strong>程序描述：</strong></p><p>这个程序旨在通过各种操作来管理一个二叉搜索树（BST），如插入、删除、显示叶子节点和根据用户选择的方式遍历树。BST是一个基本的数据结构，它保持元素以排序的顺序存储，以便高效地进行搜索、插入和删除操作。每个节点包含一个键值和指向左右子节点的指针。节点的左子树仅包含键值小于该节点键值的节点，而右子树仅包含键值大于该节点键值的节点。</p><p><strong>该程序实现的操作包括：</strong></p><ul><li>插入：提示用户依次输入元素到BST中。</li><li>删除：询问用户要从BST中删除的特定元素。</li><li>显示叶子节点：遍历BST并显示所有叶子节点（没有子节点的节点）。</li><li>树遍历：允许用户选择中序遍历和前序遍历方法来遍历和显示树。</li></ul><h2 id="实现代码">实现代码</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义树的节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> key; <span class="comment">// 节点存储的值</span></span><br><span class="line">    Node* left, * right; <span class="comment">// 指向左子节点和右子节点的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点构造函数</span></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> item) {</span><br><span class="line">        key = item;</span><br><span class="line">        left = right = <span class="literal">nullptr</span>; <span class="comment">// 初始化时没有子节点</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉搜索树类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 插入新节点的辅助函数</span></span><br><span class="line">    <span class="function">Node* <span class="title">insert</span><span class="params">(Node* node, <span class="type">int</span> key)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Node</span>(key); <span class="comment">// 如果当前节点为空，创建新节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据二叉搜索树的性质进行递归插入</span></span><br><span class="line">        <span class="keyword">if</span> (key &lt; node-&gt;key)</span><br><span class="line">            node-&gt;left = <span class="built_in">insert</span>(node-&gt;left, key); <span class="comment">// 插入到左子树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node-&gt;key)</span><br><span class="line">            node-&gt;right = <span class="built_in">insert</span>(node-&gt;right, key); <span class="comment">// 插入到右子树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找并返回具有最小键值的节点的辅助函数</span></span><br><span class="line">    <span class="function">Node* <span class="title">minValueNode</span><span class="params">(Node* node)</span> </span>{</span><br><span class="line">        Node* current = node;</span><br><span class="line">        <span class="comment">// 持续向左子节点移动，直到找到最左侧节点</span></span><br><span class="line">        <span class="keyword">while</span> (current &amp;&amp; current-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点的辅助函数</span></span><br><span class="line">    <span class="function">Node* <span class="title">deleteNode</span><span class="params">(Node* root, <span class="type">int</span> key)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root; <span class="comment">// 如果根为空，直接返回</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据键值进行递归删除</span></span><br><span class="line">        <span class="keyword">if</span> (key &lt; root-&gt;key)</span><br><span class="line">            root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key); <span class="comment">// 从左子树删除</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key)</span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key); <span class="comment">// 从右子树删除</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 找到了要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span>) {</span><br><span class="line">                Node* temp = root-&gt;right;</span><br><span class="line">                <span class="keyword">delete</span> root; <span class="comment">// 删除当前节点</span></span><br><span class="line">                <span class="keyword">return</span> temp; <span class="comment">// 返回右子树</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span>) {</span><br><span class="line">                Node* temp = root-&gt;left;</span><br><span class="line">                <span class="keyword">delete</span> root; <span class="comment">// 删除当前节点</span></span><br><span class="line">                <span class="keyword">return</span> temp; <span class="comment">// 返回左子树</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 节点有两个子节点的情况</span></span><br><span class="line">            Node* temp = <span class="built_in">minValueNode</span>(root-&gt;right); <span class="comment">// 找到右子树中的最小节点</span></span><br><span class="line">            root-&gt;key = temp-&gt;key; <span class="comment">// 替换当前节点的键值</span></span><br><span class="line">            <span class="comment">// 删除右子树中的最小节点</span></span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, temp-&gt;key);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历的辅助函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="built_in">inorderTraversal</span>(root-&gt;left); <span class="comment">// 先左子树</span></span><br><span class="line">            cout &lt;&lt; root-&gt;key &lt;&lt; <span class="string">" "</span>; <span class="comment">// 再根节点</span></span><br><span class="line">            <span class="built_in">inorderTraversal</span>(root-&gt;right); <span class="comment">// 最后右子树</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历的辅助函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) {</span><br><span class="line">            cout &lt;&lt; root-&gt;key &lt;&lt; <span class="string">" "</span>; <span class="comment">// 先根节点</span></span><br><span class="line">            <span class="built_in">preorderTraversal</span>(root-&gt;left); <span class="comment">// 再左子树</span></span><br><span class="line">            <span class="built_in">preorderTraversal</span>(root-&gt;right); <span class="comment">// 最后右子树</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示所有叶子节点的辅助函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayLeafNodes</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) {</span><br><span class="line">                cout &lt;&lt; root-&gt;key &lt;&lt; <span class="string">" "</span>; <span class="comment">// 如果是叶子节点，打印其键值</span></span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 递归检查左右子树</span></span><br><span class="line">            <span class="built_in">displayLeafNodes</span>(root-&gt;left);</span><br><span class="line">            <span class="built_in">displayLeafNodes</span>(root-&gt;right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node* root; <span class="comment">// 树的根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">BST</span>() {</span><br><span class="line">        root = <span class="literal">nullptr</span>; <span class="comment">// 初始化时树为空</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入新节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> key)</span> </span>{</span><br><span class="line">        root = <span class="built_in">insert</span>(root, key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(<span class="type">int</span> key)</span> </span>{</span><br><span class="line">        root = <span class="built_in">deleteNode</span>(root, key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"InOrder Traversal: "</span>;</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"PreOrder Traversal: "</span>;</span><br><span class="line">        <span class="built_in">preorderTraversal</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示所有叶子节点的函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayLeafNodes</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Leaf nodes: "</span>;</span><br><span class="line">        <span class="built_in">displayLeafNodes</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    BST bst; <span class="comment">// 创建一个二叉搜索树实例</span></span><br><span class="line">    <span class="type">int</span> n, x;</span><br><span class="line">    <span class="type">bool</span> f = <span class="number">0</span>; <span class="comment">// 用于控制是否打印分隔线</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">if</span> (f) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"--------------------------------\n"</span>;</span><br><span class="line">        }</span><br><span class="line">        f = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1. Insert Element into BST\n2. Delete Element from BST\n3. Display all leaf nodes\n4. Traverse the BST\n5. Exit\n"</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">"Enter your choice: "</span>; cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">switch</span> (n)</span><br><span class="line">        {</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 插入元素</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"Enter key to insert: "</span>;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            bst.<span class="built_in">insert</span>(x);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 删除元素</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"Enter key to delete: "</span>;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            bst.<span class="built_in">deleteNode</span>(x);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// 显示所有叶子节点</span></span><br><span class="line">            bst.<span class="built_in">displayLeafNodes</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">// 选择遍历方法</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"Choose traversal method (1 for InOrder, 2 for PreOrder): "</span>;</span><br><span class="line">            <span class="type">int</span> m; cin &gt;&gt; m;</span><br><span class="line">            <span class="keyword">if</span> (m == <span class="number">1</span>) bst.<span class="built_in">inorderTraversal</span>(); <span class="comment">// 中序遍历</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">2</span>) bst.<span class="built_in">preorderTraversal</span>(); <span class="comment">// 前序遍历</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: <span class="comment">// 退出程序</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> c/c++ </category>
          
          <category> BST </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的组合作业2</title>
      <link href="/2024/04/07/lei-de-zu-he-zuo-ye/"/>
      <url>/2024/04/07/lei-de-zu-he-zuo-ye/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述">问题描述</h1><p>有代码如下。请运行程序，并按照要求完成如下任务。</p><p>1、请分析代码的运行结果，并画出程序运行期间，内存分配情况；</p><p>2、请在程序中添加<code>Point</code>的析构函数和<code>Line</code>的析构函数。在两个析构函数中只需要进行信息输出即可。请给出修改后的完整代码，并将自己添加的代码用红色标出；</p><p>3、运行加入析构函数后的代码，分析其运行结果，并说明其与未加析构函数的时候的结果的不同之处，并说明原因；</p><p>4、请将程序中语句<code>Line(Point pp1,Point pp2):p1(pp1),p2(pp2)</code>，修改为<code>Line(Point &amp;pp1,Point &amp;pp2):p1(pp1),p2(pp2)</code>。然后运行程序，说明修改前后程序的运行结果区别及其原因。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="built_in">Point</span>(<span class="type">int</span> a,<span class="type">int</span> b) </span><br><span class="line">    {</span><br><span class="line">        x=a;</span><br><span class="line">        y=b;</span><br><span class="line">        cout&lt;&lt;<span class="string">"构造了一个点"</span>&lt;&lt;<span class="string">"("</span>&lt;&lt;x&lt;&lt;<span class="string">","</span>&lt;&lt;y&lt;&lt;<span class="string">")"</span>&lt;&lt;endl;</span><br><span class="line">  }</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Getx</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">  }</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Gety</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">  }          </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">  cout&lt;&lt;<span class="string">"横坐标:"</span>&lt;&lt;x&lt;&lt;<span class="string">",纵坐标:"</span>&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">  }                               </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> x,y;</span><br><span class="line">}; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Point p1,p2;   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Line</span>(Point pp1,Point pp2):<span class="built_in">p1</span>(pp1),<span class="built_in">p2</span>(pp2) </span><br><span class="line">    { </span><br><span class="line">    cout&lt;&lt;<span class="string">"构造了一条线段"</span>&lt;&lt;endl;        </span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">length</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">  </span>{ </span><br><span class="line"><span class="type">double</span> len;   </span><br><span class="line"><span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">  x1=p1.<span class="built_in">Getx</span>();</span><br><span class="line">  y1=p1.<span class="built_in">Gety</span>();</span><br><span class="line">x2=p2.<span class="built_in">Getx</span>();</span><br><span class="line">y2=p2.<span class="built_in">Gety</span>();</span><br><span class="line">len=<span class="built_in">sqrt</span>((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)); </span><br><span class="line">cout&lt;&lt;<span class="string">"线段的长度是"</span>&lt;&lt;len&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slope</span><span class="params">()</span> <span class="comment">//计算线段的斜率</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">double</span> k; </span><br><span class="line"><span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">x1=p1.<span class="built_in">Getx</span>();</span><br><span class="line">y1=p1.<span class="built_in">Gety</span>();</span><br><span class="line">x2=p2.<span class="built_in">Getx</span>();  </span><br><span class="line">y2=p2.<span class="built_in">Gety</span>(); </span><br><span class="line">k=(y2-y1)/(x2-x1);</span><br><span class="line">cout&lt;&lt;<span class="string">"线段的斜率是"</span>&lt;&lt;k&lt;&lt;endl;  </span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout&lt;&lt;<span class="string">"线段的起点"</span>; </span><br><span class="line">p1.<span class="built_in">show</span>();</span><br><span class="line">cout&lt;&lt;<span class="string">"线段的终点"</span>;</span><br><span class="line">p2.<span class="built_in">show</span>();</span><br><span class="line">}     </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line"><span class="function">Point <span class="title">mp1</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span>,<span class="title">mp2</span><span class="params">(<span class="number">16</span>,<span class="number">16</span>)</span></span>;        </span><br><span class="line">  <span class="function">Line <span class="title">line</span><span class="params">(mp1,mp2)</span></span>;</span><br><span class="line">  line.<span class="built_in">display</span>();  </span><br><span class="line">line.<span class="built_in">length</span>();</span><br><span class="line">line.<span class="built_in">slope</span>();  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>运行后输出</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">构造了一个点(1,1)</span><br><span class="line">构造了一个点(16,16)</span><br><span class="line">构造了一条线段</span><br><span class="line">线段的起点横坐标:1,纵坐标:1</span><br><span class="line">线段的终点横坐标:16,纵坐标:16</span><br><span class="line">线段的长度是21.2132</span><br><span class="line">线段的斜率是1</span><br></pre></td></tr></tbody></table></figure><h2 id="程序的运行结果与内存分配情况">1.程序的运行结果与内存分配情况</h2><ol type="1"><li><p><strong>调用构造函数<code>Point(int a,int b)</code>创建两个<code>Point</code>对象：<code>mp1</code>和<code>mp2</code>。</strong></p><ul><li>对于<code>mp1(1,1)</code>，输出：<code>构造了一个点(1,1)</code></li><li>对于<code>mp2(16,16)</code>，输出：<code>构造了一个点(16,16)</code></li></ul></li><li><p><strong>调用构造函数<code>Line(Point &amp;pp1,Point &amp;pp2):p1(pp1),p2(pp2)</code>创建一个<code>Line</code>对象<code>line</code>。</strong></p><ul><li>输出：<code>构造了一条线段</code></li></ul><p>事实上这里的值传递调用了默认的拷贝构造函数，要想打印日志可以在<code>class Point:public</code>中添加拷贝构造函数：</p><p></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">   <span class="built_in">Point</span>(<span class="type">const</span> Point &amp;p) {</span><br><span class="line">       x = p.x;</span><br><span class="line">       y = p.y;</span><br><span class="line">       cout &lt;&lt; <span class="string">"拷贝构造了一个点("</span> &lt;&lt; x &lt;&lt; <span class="string">","</span> &lt;&lt; y &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p></p><p>此时会输出：</p><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">拷贝构造了一个点(16,16)</span><br><span class="line">拷贝构造了一个点(1,1)</span><br><span class="line">拷贝构造了一个点(1,1)</span><br><span class="line">拷贝构造了一个点(16,16)</span><br><span class="line">构造了一条线段</span><br></pre></td></tr></tbody></table></figure><p></p><p>可以看到这两个点分别被高倍构造了两次，这是由于构造函数<code>Line(Point &amp;pp1,Point &amp;pp2):p1(pp1),p2(pp2)</code>使用了初始化列表。</p><p>具体过程如下：</p><ol type="1"><li><p>在创建<code>Line</code>对象时，由于按值传递，<code>mp1</code>和<code>mp2</code>被拷贝到构造函数的形参<code>pp1</code>和<code>pp2</code>。输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">拷贝构造了一个点(16,16)</span><br><span class="line">拷贝构造了一个点(1,1)</span><br></pre></td></tr></tbody></table></figure></li><li><p>初始化列表中<code>p1(pp1)</code>和<code>p2(pp2)</code>又各引发了一次拷贝构造调用，以初始化<code>Line</code>对象的<code>p1</code>和<code>p2</code>成员。输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">拷贝构造了一个点(1,1)</span><br><span class="line">拷贝构造了一个点(16,16)</span><br></pre></td></tr></tbody></table></figure></li><li><p>输出<code>构造了一条线段</code></p></li></ol></li><li><p><strong>调用<code>line.display()</code>方法。</strong></p><ul><li>输出：<code>线段的起点</code>，随后<code>p1.show()</code>输出：<code>横坐标:1,纵坐标:1</code></li><li>输出：<code>线段的终点</code>，随后<code>p2.show()</code>输出：<code>横坐标:16,纵坐标:16</code></li></ul></li><li><p><strong>调用<code>line.length()</code>方法。</strong></p><ul><li>输出<code>线段的长度是21.2132</code></li></ul></li><li><p><strong>调用<code>line.slope()</code>方法。</strong></p><ul><li>输出：<code>线段的斜率是1</code></li></ul></li></ol><p><strong>内存中的分配情况如动图所示：</strong></p><figure><img src="../../../../images/类的组合作业2/p2.gif" alt="内存分配动图"><figcaption aria-hidden="true">内存分配动图</figcaption></figure><iframe width="800" height="1000" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=%23include%3Ciostream%3E%0A%23include%3Cmath.h%3E%0Ausing%20namespace%20std%3B%0Aclass%20Point%20%7B%0Apublic%3A%20%0A%20%20%20%20Point%28int%20a,int%20b%29%20%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20x%3Da%3B%0A%20%20%20%20%20%20%20%20y%3Db%3B%0A%20%20%20%20%20%20%20%20cout%3C%3C%22%E6%9E%84%E9%80%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E7%82%B9%22%3C%3C%22%28%22%3C%3Cx%3C%3C%22,%22%3C%3Cy%3C%3C%22%29%22%3C%3Cendl%3B%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20//%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%0A%20%20%20%20Point%28const%20Point%20%26p%29%20%7B%0A%20%20%20%20%20%20%20%20x%20%3D%20p.x%3B%0A%20%20%20%20%20%20%20%20y%20%3D%20p.y%3B%0A%20%20%20%20%20%20%20%20cout%20%3C%3C%20%22%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E7%82%B9%28%22%20%3C%3C%20x%20%3C%3C%20%22,%22%20%3C%3C%20y%20%3C%3C%20%22%29%22%20%3C%3C%20endl%3B%0A%20%20%20%20%7D%0A%20%20%20%20%20%20int%20Getx%28%29%20%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20return%20x%3B%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20int%20Gety%28%29%20%0A%20%20%20%20%7B%0A%20%20%20%20%20%20return%20y%3B%0A%20%20%20%20%20%20%7D%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20void%20show%28%29%20%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20cout%3C%3C%22%E6%A8%AA%E5%9D%90%E6%A0%87%3A%22%3C%3Cx%3C%3C%22,%E7%BA%B5%E5%9D%90%E6%A0%87%3A%22%3C%3Cy%3C%3Cendl%3B%0A%20%20%20%20%20%20%7D%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0Aprivate%3A%0A%20%20%20%20%20%20int%20x,y%3B%0A%7D%3B%20%0A%0Aclass%20Line%20%7B%0Aprivate%3A%0A%20%20%20%20%20%20Point%20p1,p2%3B%0Apublic%3A%0A%20%20%20%20%20%20Line%28Point%20pp1,Point%20pp2%29%3Ap1%28pp1%29,p2%28pp2%29%0A%20%20%20%20%7B%20%0A%20%20%20%20%20%20%20%20cout%3C%3C%22%E6%9E%84%E9%80%A0%E4%BA%86%E4%B8%80%E6%9D%A1%E7%BA%BF%E6%AE%B5%22%3C%3Cendl%3B%0A%20%20%20%20%7D%0A%20%20%20%20void%20length%28%29%20%20%0A%20%20%20%20%20%20%7B%20%0A%20%20%20%20%20%20%20%20double%20len%3B%20%20%20%0A%20%20%20%20%20%20%20%20int%20x1,y1,x2,y2%3B%0A%20%20%20%20%20%20%20%20%20%20x1%3Dp1.Getx%28%29%3B%0A%20%20%20%20%20%20%20%20%20%20y1%3Dp1.Gety%28%29%3B%0A%20%20%20%20%20%20%20%20x2%3Dp2.Getx%28%29%3B%0A%20%20%20%20%20%20%20%20y2%3Dp2.Gety%28%29%3B%0A%20%20%20%20%20%20%20%20len%3Dsqrt%28%28x2-x1%29*%28x2-x1%29%2B%28y2-y1%29*%28y2-y1%29%29%3B%20%0A%20%20%20%20%20%20%20%20cout%3C%3C%22%E7%BA%BF%E6%AE%B5%E7%9A%84%E9%95%BF%E5%BA%A6%E6%98%AF%22%3C%3Clen%3C%3Cendl%3B%0A%20%20%20%20%7D%0A%20%20%20%20void%20slope%28%29%20//%E8%AE%A1%E7%AE%97%E7%BA%BF%E6%AE%B5%E7%9A%84%E6%96%9C%E7%8E%87%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20double%20k%3B%20%0A%20%20%20%20%20%20%20%20int%20x1,y1,x2,y2%3B%0A%20%20%20%20%20%20%20%20x1%3Dp1.Getx%28%29%3B%0A%20%20%20%20%20%20%20%20y1%3Dp1.Gety%28%29%3B%0A%20%20%20%20%20%20%20%20x2%3Dp2.Getx%28%29%3B%20%20%0A%20%20%20%20%20%20%20%20y2%3Dp2.Gety%28%29%3B%20%0A%20%20%20%20%20%20%20%20k%3D%28y2-y1%29/%28x2-x1%29%3B%0A%20%20%20%20%20%20%20%20cout%3C%3C%22%E7%BA%BF%E6%AE%B5%E7%9A%84%E6%96%9C%E7%8E%87%E6%98%AF%22%3C%3Ck%3C%3Cendl%3B%20%20%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20void%20display%28%29%20%20%20%20%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20cout%3C%3C%22%E7%BA%BF%E6%AE%B5%E7%9A%84%E8%B5%B7%E7%82%B9%22%3B%20%0A%20%20%20%20%20%20%20%20p1.show%28%29%3B%0A%20%20%20%20%20%20%20%20cout%3C%3C%22%E7%BA%BF%E6%AE%B5%E7%9A%84%E7%BB%88%E7%82%B9%22%3B%0A%20%20%20%20%20%20%20%20p2.show%28%29%3B%0A%20%20%20%20%20%20%20%20%7D%20%20%20%20%20%0A%7D%3B%0A%0Aint%20main%28%29%0A%7B%20%0A%20%20%20%20Point%20mp1%281,1%29,mp2%2816,16%29%3B%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20Line%20line%28mp1,mp2%29%3B%0A%20%20%20%20%20%20line.display%28%29%3B%20%20%0A%20%20%20%20line.length%28%29%3B%0A%20%20%20%20line.slope%28%29%3B%20%20%0A%7D&amp;codeDivHeight=400&amp;codeDivWidth=350&amp;cumulative=false&amp;curInstr=0&amp;heapPrimitives=nevernest&amp;origin=opt-frontend.js&amp;py=cpp_g%2B%2B9.3.0&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false"></iframe><h2 id="添加析构函数">2. 添加析构函数</h2><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> a, <span class="type">int</span> b) {</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">        cout &lt;&lt; <span class="string">"构造了一个点"</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; x &lt;&lt; <span class="string">","</span> &lt;&lt; y &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">     <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">const</span> Point &amp;p) {</span><br><span class="line">        x = p.x;</span><br><span class="line">        y = p.y;</span><br><span class="line">        cout &lt;&lt; <span class="string">"拷贝构造了一个点("</span> &lt;&lt; x &lt;&lt; <span class="string">","</span> &lt;&lt; y &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">Point</span>() { <span class="comment">// 添加析构函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"销毁了一个点"</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; x &lt;&lt; <span class="string">","</span> &lt;&lt; y &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Getx</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Gety</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"横坐标:"</span> &lt;&lt; x &lt;&lt; <span class="string">",纵坐标:"</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Point p1, p2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Line</span>(Point pp1, Point pp2) : <span class="built_in">p1</span>(pp1), <span class="built_in">p2</span>(pp2) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"构造了一条线段"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">Line</span>() { <span class="comment">// 添加析构函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"销毁了一条线段"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">length</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">double</span> len;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">        x1 = p1.<span class="built_in">Getx</span>();</span><br><span class="line">        y1 = p1.<span class="built_in">Gety</span>();</span><br><span class="line">        x2 = p2.<span class="built_in">Getx</span>();</span><br><span class="line">        y2 = p2.<span class="built_in">Gety</span>();</span><br><span class="line">        len = <span class="built_in">sqrt</span>((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));</span><br><span class="line">        cout &lt;&lt; <span class="string">"线段的长度是"</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">slope</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">double</span> k;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">        x1 = p1.<span class="built_in">Getx</span>();</span><br><span class="line">        y1 = p1.<span class="built_in">Gety</span>();</span><br><span class="line">        x2 = p2.<span class="built_in">Getx</span>();</span><br><span class="line">        y2 = p2.<span class="built_in">Gety</span>();</span><br><span class="line">        k = (<span class="type">double</span>)(y2 - y1) / (x2 - x1);</span><br><span class="line">        cout &lt;&lt; <span class="string">"线段的斜率是"</span> &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"线段的起点"</span>;</span><br><span class="line">        p1.<span class="built_in">show</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">"线段的终点"</span>;</span><br><span class="line">        p2.<span class="built_in">show</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Point <span class="title">mp1</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span>, <span class="title">mp2</span><span class="params">(<span class="number">16</span>, <span class="number">16</span>)</span></span>;</span><br><span class="line">    <span class="function">Line <span class="title">line</span><span class="params">(mp1, mp2)</span></span>;</span><br><span class="line">    line.<span class="built_in">display</span>();</span><br><span class="line">    line.<span class="built_in">length</span>();</span><br><span class="line">    line.<span class="built_in">slope</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="运行加入析构函数后的代码">3. 运行加入析构函数后的代码</h2><p>运行后输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">构造了一个点(1,1)</span><br><span class="line">构造了一个点(16,16)</span><br><span class="line">拷贝构造了一个点(16,16)</span><br><span class="line">拷贝构造了一个点(1,1)</span><br><span class="line">拷贝构造了一个点(1,1)</span><br><span class="line">拷贝构造了一个点(16,16)</span><br><span class="line">构造了一条线段</span><br><span class="line">销毁了一个点(1,1)</span><br><span class="line">销毁了一个点(16,16)</span><br><span class="line">线段的起点横坐标:1,纵坐标:1</span><br><span class="line">线段的终点横坐标:16,纵坐标:16</span><br><span class="line">线段的长度是21.2132</span><br><span class="line">线段的斜率是1</span><br><span class="line">销毁了一条线段</span><br><span class="line">销毁了一个点(16,16)</span><br><span class="line">销毁了一个点(1,1)</span><br><span class="line">销毁了一个点(16,16)</span><br><span class="line">销毁了一个点(1,1)</span><br></pre></td></tr></tbody></table></figure><p>可以看到，当对象的生命周期结束时，会自动调用析构函数。</p><ol type="1"><li><p>由于构造函数<code>Line(Point pp1, Point pp2) : p1(pp1), p2(pp2)</code>为值传递，故在函数执行完后形参被销毁，输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">销毁了一个点(1,1)</span><br><span class="line">销毁了一个点(16,16)</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>Line</code>对象的析构，输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">销毁了一条线段</span><br><span class="line">销毁了一个点(16,16)</span><br><span class="line">销毁了一个点(1,1)</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>Point</code>对象的析构，输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">销毁了一个点(16,16)</span><br><span class="line">销毁了一个点(1,1)</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="修改line构造函数的参数为引用类型">4.修改<code>Line</code>构造函数的参数为引用类型</h2><p>将<code>Line(Point pp1,Point pp2):p1(pp1),p2(pp2)</code>，修改为<code>Line(Point &amp;pp1,Point &amp;pp2):p1(pp1),p2(pp2)</code></p><p>运行后输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">构造了一个点(1,1)</span><br><span class="line">构造了一个点(16,16)</span><br><span class="line">拷贝构造了一个点(1,1)</span><br><span class="line">拷贝构造了一个点(16,16)</span><br><span class="line">构造了一条线段</span><br><span class="line">线段的起点横坐标:1,纵坐标:1</span><br><span class="line">线段的终点横坐标:16,纵坐标:16</span><br><span class="line">线段的长度是21.2132</span><br><span class="line">线段的斜率是1</span><br><span class="line">销毁了一条线段</span><br><span class="line">销毁了一个点(16,16)</span><br><span class="line">销毁了一个点(1,1)</span><br><span class="line">销毁了一个点(16,16)</span><br><span class="line">销毁了一个点(1,1)</span><br></pre></td></tr></tbody></table></figure><p>可以看到，使用引用方法后，构造函数<code>Line(Point &amp;pp1,Point &amp;pp2):p1(pp1),p2(pp2)</code>在创建<code>pp1</code>,<code>pp2</code>时不会调用拷贝构造函数<code>Point(const Point &amp;p)</code>，所以只是在初始化列表中调用了拷贝构造函数<code>Point(const Point &amp;p)</code>，并且也不需要销毁临时变量。</p><p><strong>以下是程序运行动图：</strong> <img src="../../../../images/类的组合作业2/p3.gif" alt="gif"></p><iframe width="800" height="1000" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=%23include%3Ciostream%3E%0A%23include%3Cmath.h%3E%0Ausing%20namespace%20std%3B%0A%0Aclass%20Point%20%7B%0Apublic%3A%0A%20%20%20%20Point%28int%20a,%20int%20b%29%20%7B%0A%20%20%20%20%20%20%20%20x%20%3D%20a%3B%0A%20%20%20%20%20%20%20%20y%20%3D%20b%3B%0A%20%20%20%20%20%20%20%20cout%20%3C%3C%20%22%E6%9E%84%E9%80%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E7%82%B9%22%20%3C%3C%20%22%28%22%20%3C%3C%20x%20%3C%3C%20%22,%22%20%3C%3C%20y%20%3C%3C%20%22%29%22%20%3C%3C%20endl%3B%0A%20%20%20%20%7D%0A%20%20%20%20%20//%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%0A%20%20%20%20Point%28const%20Point%20%26p%29%20%7B%0A%20%20%20%20%20%20%20%20x%20%3D%20p.x%3B%0A%20%20%20%20%20%20%20%20y%20%3D%20p.y%3B%0A%20%20%20%20%20%20%20%20cout%20%3C%3C%20%22%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E7%82%B9%28%22%20%3C%3C%20x%20%3C%3C%20%22,%22%20%3C%3C%20y%20%3C%3C%20%22%29%22%20%3C%3C%20endl%3B%0A%20%20%20%20%7D%0A%20%20%20%20~Point%28%29%20%7B%20//%20%E6%B7%BB%E5%8A%A0%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%0A%20%20%20%20%20%20%20%20cout%20%3C%3C%20%22%E9%94%80%E6%AF%81%E4%BA%86%E4%B8%80%E4%B8%AA%E7%82%B9%22%20%3C%3C%20%22%28%22%20%3C%3C%20x%20%3C%3C%20%22,%22%20%3C%3C%20y%20%3C%3C%20%22%29%22%20%3C%3C%20endl%3B%0A%20%20%20%20%7D%0A%20%20%20%20int%20Getx%28%29%20%7B%0A%20%20%20%20%20%20%20%20return%20x%3B%0A%20%20%20%20%7D%0A%20%20%20%20int%20Gety%28%29%20%7B%0A%20%20%20%20%20%20%20%20return%20y%3B%0A%20%20%20%20%7D%0A%20%20%20%20void%20show%28%29%20%7B%0A%20%20%20%20%20%20%20%20cout%20%3C%3C%20%22%E6%A8%AA%E5%9D%90%E6%A0%87%3A%22%20%3C%3C%20x%20%3C%3C%20%22,%E7%BA%B5%E5%9D%90%E6%A0%87%3A%22%20%3C%3C%20y%20%3C%3C%20endl%3B%0A%20%20%20%20%7D%0Aprivate%3A%0A%20%20%20%20int%20x,%20y%3B%0A%7D%3B%0A%0Aclass%20Line%20%7B%0Aprivate%3A%0A%20%20%20%20Point%20p1,%20p2%3B%0Apublic%3A%0A%20%20%20%20Line%28Point%20%26pp1,%20Point%20%26pp2%29%20%3A%20p1%28pp1%29,%20p2%28pp2%29%20%7B%0A%20%20%20%20%20%20%20%20cout%20%3C%3C%20%22%E6%9E%84%E9%80%A0%E4%BA%86%E4%B8%80%E6%9D%A1%E7%BA%BF%E6%AE%B5%22%20%3C%3C%20endl%3B%0A%20%20%20%20%7D%0A%20%20%20%20~Line%28%29%20%7B%20//%20%E6%B7%BB%E5%8A%A0%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%0A%20%20%20%20%20%20%20%20cout%20%3C%3C%20%22%E9%94%80%E6%AF%81%E4%BA%86%E4%B8%80%E6%9D%A1%E7%BA%BF%E6%AE%B5%22%20%3C%3C%20endl%3B%0A%20%20%20%20%7D%0A%20%20%20%20void%20length%28%29%20%7B%0A%20%20%20%20%20%20%20%20double%20len%3B%0A%20%20%20%20%20%20%20%20int%20x1,%20y1,%20x2,%20y2%3B%0A%20%20%20%20%20%20%20%20x1%20%3D%20p1.Getx%28%29%3B%0A%20%20%20%20%20%20%20%20y1%20%3D%20p1.Gety%28%29%3B%0A%20%20%20%20%20%20%20%20x2%20%3D%20p2.Getx%28%29%3B%0A%20%20%20%20%20%20%20%20y2%20%3D%20p2.Gety%28%29%3B%0A%20%20%20%20%20%20%20%20len%20%3D%20sqrt%28%28x2%20-%20x1%29%20*%20%28x2%20-%20x1%29%20%2B%20%28y2%20-%20y1%29%20*%20%28y2%20-%20y1%29%29%3B%0A%20%20%20%20%20%20%20%20cout%20%3C%3C%20%22%E7%BA%BF%E6%AE%B5%E7%9A%84%E9%95%BF%E5%BA%A6%E6%98%AF%22%20%3C%3C%20len%20%3C%3C%20endl%3B%0A%20%20%20%20%7D%0A%20%20%20%20void%20slope%28%29%20%7B%0A%20%20%20%20%20%20%20%20double%20k%3B%0A%20%20%20%20%20%20%20%20int%20x1,%20y1,%20x2,%20y2%3B%0A%20%20%20%20%20%20%20%20x1%20%3D%20p1.Getx%28%29%3B%0A%20%20%20%20%20%20%20%20y1%20%3D%20p1.Gety%28%29%3B%0A%20%20%20%20%20%20%20%20x2%20%3D%20p2.Getx%28%29%3B%0A%20%20%20%20%20%20%20%20y2%20%3D%20p2.Gety%28%29%3B%0A%20%20%20%20%20%20%20%20k%20%3D%20%28double%29%28y2%20-%20y1%29%20/%20%28x2%20-%20x1%29%3B%0A%20%20%20%20%20%20%20%20cout%20%3C%3C%20%22%E7%BA%BF%E6%AE%B5%E7%9A%84%E6%96%9C%E7%8E%87%E6%98%AF%22%20%3C%3C%20k%20%3C%3C%20endl%3B%0A%20%20%20%20%7D%0A%20%20%20%20void%20display%28%29%20%7B%0A%20%20%20%20%20%20%20%20cout%20%3C%3C%20%22%E7%BA%BF%E6%AE%B5%E7%9A%84%E8%B5%B7%E7%82%B9%22%3B%0A%20%20%20%20%20%20%20%20p1.show%28%29%3B%0A%20%20%20%20%20%20%20%20cout%20%3C%3C%20%22%E7%BA%BF%E6%AE%B5%E7%9A%84%E7%BB%88%E7%82%B9%22%3B%0A%20%20%20%20%20%20%20%20p2.show%28%29%3B%0A%20%20%20%20%7D%0A%7D%3B%0A%0Aint%20main%28%29%20%7B%0A%20%20%20%20Point%20mp1%281,%201%29,%20mp2%2816,%2016%29%3B%0A%20%20%20%20Line%20line%28mp1,%20mp2%29%3B%0A%20%20%20%20line.display%28%29%3B%0A%20%20%20%20line.length%28%29%3B%0A%20%20%20%20line.slope%28%29%3B%0A%7D&amp;codeDivHeight=400&amp;codeDivWidth=350&amp;cumulative=false&amp;curInstr=0&amp;heapPrimitives=nevernest&amp;origin=opt-frontend.js&amp;py=cpp_g%2B%2B9.3.0&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false"></iframe>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> c/c++ </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字典树</title>
      <link href="/2024/04/05/zi-dian-shu/"/>
      <url>/2024/04/05/zi-dian-shu/</url>
      
        <content type="html"><![CDATA[<p>Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较。Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p><h2 id="题目描述">题目描述</h2><p>维护一个字符串集合，支持两种操作：</p><ol type="1"><li><code>I x</code> 向集合中插入一个字符串<code>x</code>；</li><li><code>Q x</code> 询问字符串<code>x</code>在集合中出现了多少次。</li></ol><p>共有<code>n</code>个操作，所有输入的字符串总长度不超过 <span class="math inline">\(10^5\)</span>，字符串仅<strong>包含小写英文字母</strong>。</p><h2 id="输入格式">输入格式</h2><p>第一行包含整数<code>n</code>，表示操作数。</p><p>接下来<code>n</code>行，每行包含一个操作指令，指令为 <code>I x</code>或 <code>Q x</code> 中的一种。</p><h2 id="输出格式">输出格式</h2><p>对于每个询问指令<code>Q x</code>，都要输出一个整数作为结果，表示<code>x</code>在集合中出现的次数。</p><p>每个结果占一行。</p><h2 id="数据范围">数据范围</h2><p><span class="math inline">\(1≤N≤2×10^4\)</span></p><h2 id="解答">解答</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_NODES = <span class="number">1e6</span> + <span class="number">10</span>; <span class="comment">// 最大节点数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> children[MAX_NODES][<span class="number">26</span>], wordCount[MAX_NODES], nextIndex; <span class="comment">// children数组存储节点的子节点, wordCount记录单词出现次数, nextIndex记录下一个可用的节点索引</span></span><br><span class="line"><span class="type">char</span> buffer[MAX_NODES];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向Trie树中插入一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertString</span><span class="params">(<span class="type">char</span> str[])</span> </span>{</span><br><span class="line">    <span class="type">int</span> node = <span class="number">0</span>; <span class="comment">// 从根节点开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++) { <span class="comment">// 遍历字符串的每个字符</span></span><br><span class="line">        <span class="type">int</span> charIndex = str[i] - <span class="string">'a'</span>; <span class="comment">// 将字符转换为索引（0到25）</span></span><br><span class="line">        <span class="keyword">if</span> (!children[node][charIndex]) children[node][charIndex] = ++nextIndex; <span class="comment">// 如果不存在这个字符的边，则创建一个新节点</span></span><br><span class="line">        node = children[node][charIndex]; <span class="comment">// 移动到下一个节点</span></span><br><span class="line">    }</span><br><span class="line">    wordCount[node]++; <span class="comment">// 在字符串的最后一个字符对应的节点上增加计数</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串在Trie树中出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchString</span><span class="params">(<span class="type">char</span> str[])</span> </span>{</span><br><span class="line">    <span class="type">int</span> node = <span class="number">0</span>; <span class="comment">// 从根节点开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++) { <span class="comment">// 遍历字符串的每个字符</span></span><br><span class="line">        <span class="type">int</span> charIndex = str[i] - <span class="string">'a'</span>; <span class="comment">// 将字符转换为索引</span></span><br><span class="line">        <span class="keyword">if</span> (!children[node][charIndex]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果这个字符在Trie树中不存在，则这个字符串不存在</span></span><br><span class="line">        node = children[node][charIndex]; <span class="comment">// 移动到下一个节点</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> wordCount[node]; <span class="comment">// 返回字符串最后一个字符对应的节点上的计数器的值</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> operations; cin &gt;&gt; operations; <span class="comment">// 操作的数量</span></span><br><span class="line">    <span class="keyword">while</span> (operations--) {</span><br><span class="line">        <span class="type">char</span> operationType[<span class="number">2</span>];</span><br><span class="line">        cin &gt;&gt; operationType &gt;&gt; buffer;</span><br><span class="line">        <span class="keyword">if</span> (operationType[<span class="number">0</span>] == <span class="string">'I'</span>) <span class="built_in">insertString</span>(buffer); <span class="comment">// 如果是插入操作，调用insertString函数</span></span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">searchString</span>(buffer) &lt;&lt; endl; <span class="comment">// 如果是查询操作，调用searchString函数并输出结果</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但若是只是想要AC这道题的话，使用<code>map</code>可能会更简单。</p><h2 id="代码如下">代码如下</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; counter; <span class="comment">// 使用map来存储字符串及其出现次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入字符串，并增加其计数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string&amp; str)</span> </span>{</span><br><span class="line">counter[str]++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">const</span> string&amp; str)</span> </span>{</span><br><span class="line"><span class="keyword">if</span> (counter.<span class="built_in">find</span>(str) != counter.<span class="built_in">end</span>())</span><br><span class="line"><span class="keyword">return</span> counter.<span class="built_in">at</span>(str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> n;cin &gt;&gt; n;</span><br><span class="line">    StringCounter sc;</span><br><span class="line">    <span class="keyword">while</span>(n--) {</span><br><span class="line">        string op, word;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; word;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">"I"</span>) {</span><br><span class="line">            sc.<span class="built_in">insert</span>(word);</span><br><span class="line">        } </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"Q"</span>) {</span><br><span class="line">            cout &lt;&lt; sc.<span class="built_in">search</span>(word) &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> c/c++ </category>
          
          <category> Tire树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tire </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP字符串</title>
      <link href="/2024/04/05/kmp/"/>
      <url>/2024/04/05/kmp/</url>
      
        <content type="html"><![CDATA[<p><strong>一个人能走的多远不在于他在顺境时能走的多快，而在于他在逆境时多久能找到曾经的自己。</strong>— <em>KMP</em></p><h2 id="题目描述">题目描述</h2><p>给定一个字符串<code>text</code>，以及一个子串<code>sub</code>，所有字符串中只包含大小写英文字母以及阿拉伯数字。</p><p>子串<code>sub</code>在字符串<code>text</code>中多次作为子串出现。</p><p>求出子串<code>sub</code>在字符串<code>text</code>中所有出现的位置的起始下标。</p><h2 id="输入格式">输入格式</h2><p>第一行输入整数<code>n</code>，表示字符串<code>sub</code>的长度。</p><p>第二行输入字符串<code>sub</code>。</p><p>第三行输入整数<code>m</code>，表示字符串<code>text</code>的长度。</p><p>第四行输入字符串<code>text</code>。</p><h2 id="输出格式">输出格式</h2><p>共一行，输出所有出现位置的起始下标（下标从<code>0</code>开始计数），整数之间用空格隔开。</p><h2 id="数据范围">数据范围</h2><p><span class="math inline">\(1≤n≤10^5\)</span>，<span class="math inline">\(1≤m≤10^6\)</span></p><p>可以先看<a href="https://www.bilibili.com/video/BV1Px411z7Yo?vd_source=02b4405e73478850578c2783699b3ee1">灯神的讲解</a>后，再来看代码。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nex[N], n, m; <span class="comment">// nex数组，n为子串长度，m为文本长度</span></span><br><span class="line"><span class="type">char</span> text[M], sub[N]; <span class="comment">// text为文本，sub为子串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 计算子串的next数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; sub[i] != sub[j + <span class="number">1</span>]) j = nex[j]; <span class="comment">// 当前字符不匹配，回溯</span></span><br><span class="line">        <span class="keyword">if</span> (sub[i] == sub[j + <span class="number">1</span>]) j++; <span class="comment">// 当前字符匹配，前进</span></span><br><span class="line">        nex[i] = j; <span class="comment">// 更新next数组</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在文本中查找子串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++) {</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; text[i] != sub[j + <span class="number">1</span>]) j = nex[j]; <span class="comment">// 文本与子串当前字符不匹配，根据next数组回溯</span></span><br><span class="line">        <span class="keyword">if</span> (text[i] == sub[j + <span class="number">1</span>]) j++; <span class="comment">// 当前字符匹配，前进</span></span><br><span class="line">        <span class="keyword">if</span> (j == n) { <span class="comment">// 找到一个子串的匹配</span></span><br><span class="line">            cout &lt;&lt; i - n &lt;&lt; <span class="string">' '</span>; <span class="comment">// 输出匹配的起始位置</span></span><br><span class="line">            j = nex[j]; <span class="comment">// 根据next数组继续搜索可能的下一个匹配</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; sub + <span class="number">1</span> &gt;&gt; m &gt;&gt; text + <span class="number">1</span>; <span class="comment">// 输入子串和文本，从数组的第1位开始存储字符串</span></span><br><span class="line">    <span class="built_in">kmp</span>(); <span class="comment">// 执行KMP算法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> c/c++ </category>
          
          <category> KMP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二节 常数项级数的审敛法</title>
      <link href="/2024/04/03/duo-yuan-wei-ji-fen-12-2-chang-shu-xiang-ji-shu-de-shen-lian-fa/"/>
      <url>/2024/04/03/duo-yuan-wei-ji-fen-12-2-chang-shu-xiang-ji-shu-de-shen-lian-fa/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iYU741tsnpli">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分12-2常数项级数的审敛法/51.jpg" alt="51.jpg"><figcaption aria-hidden="true">51.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-2常数项级数的审敛法/52.jpg" alt="52.jpg"><figcaption aria-hidden="true">52.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-2常数项级数的审敛法/53.jpg" alt="53.jpg"><figcaption aria-hidden="true">53.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-2常数项级数的审敛法/54.jpg" alt="54.jpg"><figcaption aria-hidden="true">54.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-2常数项级数的审敛法/55.jpg" alt="55.jpg"><figcaption aria-hidden="true">55.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-2常数项级数的审敛法/56.jpg" alt="56.jpg"><figcaption aria-hidden="true">56.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-2常数项级数的审敛法/57.jpg" alt="57.jpg"><figcaption aria-hidden="true">57.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-2常数项级数的审敛法/58.jpg" alt="58.jpg"><figcaption aria-hidden="true">58.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-2常数项级数的审敛法/59.jpg" alt="59.jpg"><figcaption aria-hidden="true">59.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-2常数项级数的审敛法/60.jpg" alt="60.jpg"><figcaption aria-hidden="true">60.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-2常数项级数的审敛法/61.jpg" alt="61.jpg"><figcaption aria-hidden="true">61.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-2常数项级数的审敛法/62.jpg" alt="62.jpg"><figcaption aria-hidden="true">62.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十二章 无穷级数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常数项级数 </tag>
            
            <tag> 比较审敛法 </tag>
            
            <tag> 比值审敛法 </tag>
            
            <tag> 根值审敛法 </tag>
            
            <tag> 极限审敛法 </tag>
            
            <tag> 莱布尼茨定理 </tag>
            
            <tag> 绝对收敛与条件收敛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一节 常数项级数的概念和性质</title>
      <link href="/2024/04/03/duo-yuan-wei-ji-fen-12-1-chang-shu-xiang-ji-shu-de-gai-nian-he-xing-zhi/"/>
      <url>/2024/04/03/duo-yuan-wei-ji-fen-12-1-chang-shu-xiang-ji-shu-de-gai-nian-he-xing-zhi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iqVpq1tslugb">下载PDF点这里</a></p><p><img src="../../../../images/多元微积分12-1常数项级数的概念和性质/44.jpg"></p><p><img src="../../../../images/多元微积分12-1常数项级数的概念和性质/45.jpg"></p><p><img src="../../../../images/多元微积分12-1常数项级数的概念和性质/46.jpg"></p><p><img src="../../../../images/多元微积分12-1常数项级数的概念和性质/47.jpg"></p><p><img src="../../../../images/多元微积分12-1常数项级数的概念和性质/48.jpg"></p><p><img src="../../../../images/多元微积分12-1常数项级数的概念和性质/49.jpg"></p><p><img src="../../../../images/多元微积分12-1常数项级数的概念和性质/50.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十二章 无穷级数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常数项级数 </tag>
            
            <tag> 柯西审敛原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>折半查找之范围查找</title>
      <link href="/2024/04/02/zhe-ban-cha-zhao-zhi-fan-wei-cha-zhao/"/>
      <url>/2024/04/02/zhe-ban-cha-zhao-zhi-fan-wei-cha-zhao/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>利用折半查找算法进行范围查找。所谓范围查找是要找出在给定值 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 之间的所有元素 <span class="math inline">\((a\leq b)\)</span> 。</p><h2 id="输入格式">输入格式</h2><p>（1）第1行是序列中的元素个数</p><p>（2）第2行是有序序列（数与数之间用空格分隔）</p><p>（3）第3行是下限和上限（用空格分隔）</p><h2 id="输出格式">输出格式</h2><p>指定范围内的所有元素（数与数之间用空格分隔）</p><h2 id="示例">示例</h2><p>输入（Input）：</p><p>8</p><p>1 3 4 6 7 8 9 15</p><p>5 10</p><p>输出（Output）：</p><p>6 7 8 9</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_SIZE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max, <span class="type">int</span> r[MAX_SIZE], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>{</span><br><span class="line">    <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r[mid] &lt; min) { <span class="comment">// 分治求解左侧范围</span></span><br><span class="line">        <span class="built_in">find</span>(min, max, r, mid, high);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r[mid] &gt; max) { <span class="comment">// 分治求解右侧范围</span></span><br><span class="line">        <span class="built_in">find</span>(min, max, r, low, mid);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> { <span class="comment">// 输出答案</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s; <span class="comment">// 利用栈将mid左侧数按原来数组的顺序输出</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = mid; r[i] &gt;= min &amp;&amp; i &gt;= low; i--) </span><br><span class="line">            s.<span class="built_in">push</span>(r[i]);</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,s.<span class="built_in">top</span>());</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = mid + <span class="number">1</span>; r[j] &lt;= max &amp;&amp; j &lt;= high; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, r[j]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="type">int</span> n;    cin &gt;&gt; n; <span class="comment">// 输入元素个数</span></span><br><span class="line"><span class="type">int</span> r[MAX_SIZE];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)    cin &gt;&gt; r[i];</span><br><span class="line"><span class="type">int</span> a, b;    cin &gt;&gt; a &gt;&gt; b; <span class="comment">// 输入查找范围的最小值和最大值</span></span><br><span class="line"><span class="built_in">find</span>(a, b, r, <span class="number">0</span>, n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> c/c++ </category>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 折半查找 </tag>
            
            <tag> 分治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六节 随机变量函数的分布</title>
      <link href="/2024/03/31/gai-lu-lun-2-6-sui-ji-bian-liang-han-shu-de-fen-bu/"/>
      <url>/2024/03/31/gai-lu-lun-2-6-sui-ji-bian-liang-han-shu-de-fen-bu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/ikUBk1tajnfi">下载PDF点这里</a></p><p><img src="../../../../images/概率论2-6随机变量函数的分布/37.jpg"></p><p><img src="../../../../images/概率论2-6随机变量函数的分布/38.jpg"></p><p><img src="../../../../images/概率论2-6随机变量函数的分布/39.jpg"></p><p><img src="../../../../images/概率论2-6随机变量函数的分布/40.jpg"></p><p><img src="../../../../images/概率论2-6随机变量函数的分布/41.jpg"></p><p><img src="../../../../images/概率论2-6随机变量函数的分布/42.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第二章 随机变量及其分布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随机变量函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五节 常用连续分布</title>
      <link href="/2024/03/31/gai-lu-lun-2-5-chang-yong-lian-xu-fen-bu/"/>
      <url>/2024/03/31/gai-lu-lun-2-5-chang-yong-lian-xu-fen-bu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/il4RZ1taj3gj">下载PDF点这里</a></p><p><img src="../../../../images/概率论2-5常用连续分布/30.jpg"></p><p><img src="../../../../images/概率论2-5常用连续分布/31.jpg"></p><p><img src="../../../../images/概率论2-5常用连续分布/32.jpg"></p><p><img src="../../../../images/概率论2-5常用连续分布/33.jpg"></p><p><img src="../../../../images/概率论2-5常用连续分布/34.jpg"></p><p><img src="../../../../images/概率论2-5常用连续分布/35.jpg"></p><p><img src="../../../../images/概率论2-5常用连续分布/36.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第二章 随机变量及其分布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正态分布 </tag>
            
            <tag> 均匀分布 </tag>
            
            <tag> 指数分布 </tag>
            
            <tag> 伽马分布 </tag>
            
            <tag> 贝塔分布 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四节 常用离散分布</title>
      <link href="/2024/03/31/gai-lu-lun-2-4-chang-yong-chi-san-fen-bu/"/>
      <url>/2024/03/31/gai-lu-lun-2-4-chang-yong-chi-san-fen-bu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iHSXq1tag0ob">下载PDF点这里</a></p><p><img src="../../../../images/概率论2-4常用离散分布/24.jpg"></p><p><img src="../../../../images/概率论2-4常用离散分布/25.jpg"></p><p><img src="../../../../images/概率论2-4常用离散分布/26.jpg"></p><p><img src="../../../../images/概率论2-4常用离散分布/27.jpg"></p><p><img src="../../../../images/概率论2-4常用离散分布/28.jpg"></p><p><img src="../../../../images/概率论2-4常用离散分布/29.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第二章 随机变量及其分布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二项分布 </tag>
            
            <tag> 泊松分布 </tag>
            
            <tag> 超几何分布 </tag>
            
            <tag> 几何分布 </tag>
            
            <tag> 负二项分布 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三节 随机变量的方差与标准差</title>
      <link href="/2024/03/31/gai-lu-lun-2-3-sui-ji-bian-liang-de-fang-chai-yu-biao-zhun-chai/"/>
      <url>/2024/03/31/gai-lu-lun-2-3-sui-ji-bian-liang-de-fang-chai-yu-biao-zhun-chai/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/i8jhi1tafi7g">下载PDF点这里</a></p><p><img src="../../../../images/概率论2-3随机变量的方差与标准差/21.jpg"></p><p><img src="../../../../images/概率论2-3随机变量的方差与标准差/22.jpg"></p><p><img src="../../../../images/概率论2-3随机变量的方差与标准差/23.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第二章 随机变量及其分布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方差 </tag>
            
            <tag> 标准差 </tag>
            
            <tag> 切比雪夫不等式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二节 随机变量的数学期望</title>
      <link href="/2024/03/31/gai-lu-lun-2-2-sui-ji-bian-liang-de-shu-xue-qi-wang/"/>
      <url>/2024/03/31/gai-lu-lun-2-2-sui-ji-bian-liang-de-shu-xue-qi-wang/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/i90XZ1tady7a">下载PDF点这里</a></p><p><img src="../../../../images/概率论2-2随机变量的数学期望/18.jpg"></p><p><img src="../../../../images/概率论2-2随机变量的数学期望/19.jpg"></p><p><img src="../../../../images/概率论2-2随机变量的数学期望/20.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第二章 随机变量及其分布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析程序运行过程，说明拷贝造函数的调用过程</title>
      <link href="/2024/03/31/fen-xi-kao-bei-gou-zao-han-shu-zuo-ye/"/>
      <url>/2024/03/31/fen-xi-kao-bei-gou-zao-han-shu-zuo-ye/</url>
      
        <content type="html"><![CDATA[<p><strong>代码：</strong></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i);</span><br><span class="line"><span class="built_in">Complex</span>(Complex&amp; c);</span><br><span class="line"><span class="function">Complex <span class="title">add</span><span class="params">(Complex c)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> real, image;</span><br><span class="line">};</span><br><span class="line">Complex::<span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) :<span class="built_in">real</span>(r), <span class="built_in">image</span>(i)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; <span class="string">"调用两个参数的构造函数"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">Complex::<span class="built_in">Complex</span>(Complex&amp; c)</span><br><span class="line">{</span><br><span class="line">real = c.real;</span><br><span class="line">image = c.image;</span><br><span class="line">cout &lt;&lt; <span class="string">"调用拷贝构造函数"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Complex::print</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"("</span> &lt;&lt; real &lt;&lt; <span class="string">","</span> &lt;&lt; image &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function">Complex <span class="title">Complex::add</span><span class="params">(Complex c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="function">Complex <span class="title">y</span><span class="params">(real + c.real, image + c.image)</span></span>;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Complex n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"n="</span>;</span><br><span class="line">n.<span class="built_in">print</span>();</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">5.6</span>, <span class="number">7.9</span>)</span></span>;</span><br><span class="line"><span class="function">Complex <span class="title">c</span><span class="params">(a)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"a="</span>;</span><br><span class="line">a.<span class="built_in">print</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">"c="</span>;</span><br><span class="line">c.<span class="built_in">print</span>();</span><br><span class="line"><span class="built_in">f</span>(b);</span><br><span class="line">c = a.<span class="built_in">add</span>(b);</span><br><span class="line">c.<span class="built_in">print</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>运行代码后显示：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">调用两个参数的构造函数</span><br><span class="line">调用两个参数的构造函数</span><br><span class="line">调用拷贝构造函数</span><br><span class="line">a=(3,4)</span><br><span class="line">c=(3,4)</span><br><span class="line">调用拷贝构造函数</span><br><span class="line">n=(5.6,7.9)</span><br><span class="line">调用拷贝构造函数</span><br><span class="line">调用两个参数的构造函数</span><br><span class="line">(8.6,11.9)</span><br></pre></td></tr></tbody></table></figure><p><strong>分析程序的主要运行过程：</strong></p><ol type="1"><li><p><strong>初始化对象 <span class="math inline">\(a\)</span></strong>:使用<code>Complex(double r, double i)</code>构造函数，传入<code>3.0</code>和<code>4.0</code>作为参数，初始化对象<span class="math inline">\(a\)</span>的成员变量<code>real</code>和<code>image</code>。输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">调用两个参数的构造函数</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>初始化对象 <span class="math inline">\(b\)</span></strong>:使用<code>Complex(double r, double i)</code>构造函数，传入<code>5.6</code>和<code>7.9</code>作为参数，初始化对象<span class="math inline">\(b\)</span>。输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">调用两个参数的构造函数</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>初始化对象 <span class="math inline">\(c\)</span>通过拷贝构造函数</strong>:使用拷贝构造函数<code>Complex(Complex&amp; c)</code>，以 <span class="math inline">\(a\)</span> 作为参数，初始化 <span class="math inline">\(c\)</span>，调用拷贝构造函数，使 <span class="math inline">\(c\)</span> 的成员变量的值与 <span class="math inline">\(a\)</span> 相同。输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">调用拷贝构造函数</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>打印对象 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(c\)</span>的值</strong>：调用<code>print</code>方法输出 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(c\)</span> 的值。输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">a=(3,4)</span><br><span class="line">c=(3,4)</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>调用函数<code>f</code></strong>：函数<code>f</code>接受一个<code>Complex</code>类型的参数。这里将对象<span class="math inline">\(b\)</span>传递给函数<code>f</code>。因为<code>f</code>的参数是按值传递的，所以这里会调用<code>Complex(Complex&amp; c)</code>拷贝构造函数，创建<span class="math inline">\(b\)</span> 的一个副本 <span class="math inline">\(n\)</span> ，然后在<code>f</code>中打印 <span class="math inline">\(n\)</span> 的值。输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">调用拷贝构造函数</span><br><span class="line">n=(5.6,7.9)</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>使用<code>add</code>方法</strong>：调用<code>a.add(b)</code>，这里将对象<span class="math inline">\(b\)</span>传递给函数<code>add</code>。因为<code>add</code>的参数是按值传递的，所以这里会调用<code>Complex(Complex&amp; c)</code>拷贝构造函数，输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">调用拷贝构造函数</span><br></pre></td></tr></tbody></table></figure><p>在<code>add</code>方法内部，创建了一个名为 <span class="math inline">\(y\)</span>​的临时对象，用于存储相加后的结果。这一步调用了两个参数的构造函数<code>Complex(double r, double i)</code>，输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">调用两个参数的构造函数</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>将<code>add</code>方法的返回值赋给对象 <span class="math inline">\(c\)</span></strong></p></li><li><p><strong>打印c的值</strong>。输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">(8.6,11.9)</span><br></pre></td></tr></tbody></table></figure></li></ol><p><strong>若将代码：</strong></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">Complex::add</span><span class="params">(Complex c)</span></span></span><br></pre></td></tr></tbody></table></figure><p><strong>改为：</strong></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">Complex::add</span><span class="params">(Complex &amp; c)</span></span>; </span><br></pre></td></tr></tbody></table></figure><p>即使用引用传递。</p><p><strong>此时输出：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">调用两个参数的构造函数</span><br><span class="line">调用拷贝构造函数</span><br><span class="line">a=(3,4)</span><br><span class="line">c=(3,4)</span><br><span class="line">调用拷贝构造函数</span><br><span class="line">n=(5.6,7.9)</span><br><span class="line">调用两个参数的构造函数</span><br><span class="line">(8.6,11.9)</span><br></pre></td></tr></tbody></table></figure><p>可以看到通过引用传递可以避免创建参数的副本，不会触发<code>Complex::Complex(Complex&amp; c)</code>拷贝构造函数，可以提高程序的效率。</p><p>亦可使用<code>operator+</code>来避免创建参数的副本。可将代码改为：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i);</span><br><span class="line"><span class="built_in">Complex</span>(<span class="type">const</span> Complex&amp; c);<span class="comment">//将拷贝构造函数的参数更改为const引用</span></span><br><span class="line"><span class="function">Complex <span class="title">add</span><span class="params">(Complex &amp;c)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; c);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> real, image;</span><br><span class="line">};</span><br><span class="line">Complex::<span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) :<span class="built_in">real</span>(r), <span class="built_in">image</span>(i)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; <span class="string">"调用两个参数的构造函数"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">Complex::<span class="built_in">Complex</span>(<span class="type">const</span> Complex&amp; c)</span><br><span class="line">{</span><br><span class="line">real = c.real;</span><br><span class="line">image = c.image;</span><br><span class="line">cout &lt;&lt; <span class="string">"调用拷贝构造函数"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Complex::print</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"("</span> &lt;&lt; real &lt;&lt; <span class="string">","</span> &lt;&lt; image &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">Complex Complex::<span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; c) {<span class="comment">//将add方法更改为operator+</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Complex</span>(real + c.real, image + c.image);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Complex n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"n="</span>;</span><br><span class="line">n.<span class="built_in">print</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">5.6</span>, <span class="number">7.9</span>)</span></span>;</span><br><span class="line"><span class="function">Complex <span class="title">c</span><span class="params">(a)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"a="</span>;</span><br><span class="line">a.<span class="built_in">print</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">"c="</span>;</span><br><span class="line">c.<span class="built_in">print</span>();</span><br><span class="line"><span class="built_in">f</span>(b);</span><br><span class="line">c = a + b;<span class="comment">//使用operator+</span></span><br><span class="line">c.<span class="built_in">print</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果与上面相同。</p><p>此外，这里的<code>c = a + b;</code>在c++11或优化的编译器中使用了移动赋值操作符<code>operator=(Complex&amp;&amp;)</code>赋值给<code>c</code>，但在老版本或者未优化的编译器中会调用拷贝赋值操作符，执行复制而占用空间。</p><p>要想实现日志效果，则可以在对象中添加<code>operator=</code></p><p><strong>拷贝赋值操作符：</strong></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Complex&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Complex&amp; c) {</span><br><span class="line">real = c.real;</span><br><span class="line">image = c.image;</span><br><span class="line">cout &lt;&lt; <span class="string">"调用拷贝赋值操作符"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p><strong>移动赋值操作符：</strong></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Complex&amp; <span class="keyword">operator</span>=(Complex&amp;&amp; c) <span class="keyword">noexcept</span> {</span><br><span class="line">real = c.real;</span><br><span class="line">image = c.image;</span><br><span class="line">cout &lt;&lt; <span class="string">"调用移动赋值操作符"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> c/c++ </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第一节 随机变量及其分布</title>
      <link href="/2024/03/31/gai-lu-lun-2-1-sui-ji-bian-liang-ji-qi-fen-bu/"/>
      <url>/2024/03/31/gai-lu-lun-2-1-sui-ji-bian-liang-ji-qi-fen-bu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iocz61t9vzlc">下载PDF点这里</a></p><p><img src="../../../../images/概率论2-1随机变量及其分布/14.jpg"></p><p><img src="../../../../images/概率论2-1随机变量及其分布/15.jpg"></p><p><img src="../../../../images/概率论2-1随机变量及其分布/16.jpg"></p><p><img src="../../../../images/概率论2-1随机变量及其分布/17.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第二章 随机变量及其分布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随机变量 </tag>
            
            <tag> 分布函数 </tag>
            
            <tag> 概率分布列 </tag>
            
            <tag> 概率密度函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计数问题-数位统计DP</title>
      <link href="/2024/03/30/ji-shu-wen-ti/"/>
      <url>/2024/03/30/ji-shu-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>给定两个整数 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> ，求 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 之间的所有数字中 <span class="math inline">\(0∼9\)</span> 的出现次数。</p><h2 id="输入格式">输入格式</h2><p>输入包含多组测试数据。</p><p>每组测试数据占一行，包含两个整数 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 。</p><p>当读入一行为 <code>0 0</code>时，表示输入终止，且该行不作处理。</p><h2 id="输出格式">输出格式</h2><p>每组数据输出一个结果，每个结果占一行。</p><p>每个结果包含十个用空格隔开的数字，第一个数字表示 <code>0</code>出现的次数，第二个数字表示 <code>1</code> 出现的次数，以此类推。</p><h2 id="解答">解答</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数字序列从第l位到第r位转换为一个整数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">toInt</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>{</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &gt;= r; --i)</span><br><span class="line">        result = result * <span class="number">10</span> + digits[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算10的x次方</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow10</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">    <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (x--) result *= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算在0到n范围内数字x出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countX</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> x)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果n为0，直接返回0</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; digits; <span class="comment">// 存储n的每一位数字</span></span><br><span class="line">    <span class="keyword">while</span> (n) { <span class="comment">// 分解n到digits向量中</span></span><br><span class="line">        digits.<span class="built_in">push_back</span>(n % <span class="number">10</span>);</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line">    n = digits.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 用于累计数字x出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span> - !x; i &gt;= <span class="number">0</span>; --i) {</span><br><span class="line">        <span class="comment">// 不考虑最高位为0的情况（当x=0时）</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>) {</span><br><span class="line">            <span class="comment">// 当前位之前的数字组合成的数对结果的贡献</span></span><br><span class="line">            cnt += <span class="built_in">toInt</span>(digits, n - <span class="number">1</span>, i + <span class="number">1</span>) * <span class="built_in">pow10</span>(i);</span><br><span class="line">            <span class="comment">// 如果x为0，需要减去当前位为0时的情况</span></span><br><span class="line">            <span class="keyword">if</span> (!x) cnt -= <span class="built_in">pow10</span>(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果当前位等于x，加上当前位右侧数字组成的数+1</span></span><br><span class="line">        <span class="keyword">if</span> (digits[i] == x)</span><br><span class="line">            cnt += <span class="built_in">toInt</span>(digits, i - <span class="number">1</span>, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果当前位大于x，加上10的i次方</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (digits[i] &gt; x)</span><br><span class="line">            cnt += <span class="built_in">pow10</span>(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; a &gt;&gt; b &amp;&amp; (a || b)) { <span class="comment">// 循环直到输入0 0</span></span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) <span class="built_in">swap</span>(a, b); <span class="comment">// 确保a&lt;=b</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">            cout &lt;&lt; <span class="built_in">countX</span>(b, i) - <span class="built_in">countX</span>(a - <span class="number">1</span>, i) &lt;&lt; <span class="string">" \n"</span>[i == <span class="number">9</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> c/c++ </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2024/03/30/kuai-su-pai-xu/"/>
      <url>/2024/03/30/kuai-su-pai-xu/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>给定你一个长度为<span class="math inline">\(n\)</span>的整数数列。</p><p>请你对这个数列按照从小到大进行排序并输出。</p><h2 id="输入格式">输入格式</h2><p>输入共两行，第一行包含整数<span class="math inline">\(n\)</span>，第二行包含<span class="math inline">\(n\)</span>个整数表示整个数列。</p><h2 id="输出格式">输出格式</h2><p>输出一行排好序的数列。</p><h2 id="解答">解答</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Q_sort函数实现快速排序，参数为数组q、排序开始位置l和结束位置r</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Q_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>; <span class="comment">// 如果开始位置大于等于结束位置，则不进行排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 快排模板</span></span><br><span class="line">    <span class="type">int</span> x = q[l + (r - l) / <span class="number">2</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>; <span class="comment">// 选择中间位置的值作为基准值x，初始化左右指针i和j</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) { <span class="comment">// 当左指针小于右指针时进行循环</span></span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span> (q[i] &lt; x); <span class="comment">// 左指针右移，直到找到一个大于等于x的值</span></span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span> (q[j] &gt; x); <span class="comment">// 右指针左移，直到找到一个小于等于x的值</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]); <span class="comment">// 如果左指针仍然小于右指针，则交换两个指针所指的值</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 递归调用Q_sort函数，对基准值左右的两部分分别进行排序</span></span><br><span class="line">    <span class="built_in">Q_sort</span>(q, l, j);</span><br><span class="line">    <span class="built_in">Q_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q[i]);</span><br><span class="line">    <span class="built_in">Q_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>); <span class="comment">// 调用Q_sort函数进行快速排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> c/c++ </category>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七节 斯托克斯公式 环流量与旋度</title>
      <link href="/2024/03/29/duo-yuan-wei-ji-fen-11-7-si-tuo-ke-si-gong-shi-huan-liu-liang-yu-xuan-du/"/>
      <url>/2024/03/29/duo-yuan-wei-ji-fen-11-7-si-tuo-ke-si-gong-shi-huan-liu-liang-yu-xuan-du/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/icn6t1t2pwsd">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分11-7斯托克斯公式-环流量与旋度/35.jpg" alt="35.jpg"><figcaption aria-hidden="true">35.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-7斯托克斯公式-环流量与旋度/36.jpg" alt="36.jpg"><figcaption aria-hidden="true">36.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-7斯托克斯公式-环流量与旋度/37.jpg" alt="37.jpg"><figcaption aria-hidden="true">37.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-7斯托克斯公式-环流量与旋度/38.jpg" alt="38.jpg"><figcaption aria-hidden="true">38.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-7斯托克斯公式-环流量与旋度/39.jpg" alt="39.jpg"><figcaption aria-hidden="true">39.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-7斯托克斯公式-环流量与旋度/40.jpg" alt="40.jpg"><figcaption aria-hidden="true">40.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十一章 曲线积分与曲面积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 曲线积分 </tag>
            
            <tag> 斯托克斯公式 </tag>
            
            <tag> 环流量 </tag>
            
            <tag> 散旋度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六节 高斯公式 通量与散度</title>
      <link href="/2024/03/29/duo-yuan-wei-ji-fen-11-6-gao-si-gong-shi-tong-liang-yu-san-du/"/>
      <url>/2024/03/29/duo-yuan-wei-ji-fen-11-6-gao-si-gong-shi-tong-liang-yu-san-du/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iwTT11t2njgb">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分11-6高斯公式-通量与散度/29.jpg" alt="29.jpg"><figcaption aria-hidden="true">29.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-6高斯公式-通量与散度/30.jpg" alt="30.jpg"><figcaption aria-hidden="true">30.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-6高斯公式-通量与散度/31.jpg" alt="31.jpg"><figcaption aria-hidden="true">31.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-6高斯公式-通量与散度/32.jpg" alt="32.jpg"><figcaption aria-hidden="true">32.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-6高斯公式-通量与散度/33.jpg" alt="33.jpg"><figcaption aria-hidden="true">33.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-6高斯公式-通量与散度/34.jpg" alt="34.jpg"><figcaption aria-hidden="true">34.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十一章 曲线积分与曲面积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 曲面积分 </tag>
            
            <tag> 高斯公式 </tag>
            
            <tag> 通量 </tag>
            
            <tag> 散度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五节 对坐标的曲面积分</title>
      <link href="/2024/03/29/duo-yuan-wei-ji-fen-11-5-dui-zuo-biao-de-qu-mian-ji-fen/"/>
      <url>/2024/03/29/duo-yuan-wei-ji-fen-11-5-dui-zuo-biao-de-qu-mian-ji-fen/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/i8v5k1t2liah">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分11-5对坐标的曲面积分/22.jpg" alt="22.jpg"><figcaption aria-hidden="true">22.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-5对坐标的曲面积分/23.jpg" alt="23.jpg"><figcaption aria-hidden="true">23.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-5对坐标的曲面积分/24.jpg" alt="24.jpg"><figcaption aria-hidden="true">24.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-5对坐标的曲面积分/25.jpg" alt="25.jpg"><figcaption aria-hidden="true">25.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-5对坐标的曲面积分/26.jpg" alt="26.jpg"><figcaption aria-hidden="true">26.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-5对坐标的曲面积分/27.jpg" alt="27.jpg"><figcaption aria-hidden="true">27.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-5对坐标的曲面积分/28.jpg" alt="28.jpg"><figcaption aria-hidden="true">28.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十一章 曲线积分与曲面积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 曲面积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四节 对面积的曲面积分</title>
      <link href="/2024/03/29/duo-yuan-wei-ji-fen-11-4-dui-mian-ji-de-qu-mian-ji-fen/"/>
      <url>/2024/03/29/duo-yuan-wei-ji-fen-11-4-dui-mian-ji-de-qu-mian-ji-fen/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iZgaD1t2kjxa">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分11-4对面积的曲面积分/18.jpg" alt="18.jpg"><figcaption aria-hidden="true">18.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-4对面积的曲面积分/19.jpg" alt="19.jpg"><figcaption aria-hidden="true">19.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-4对面积的曲面积分/20.jpg" alt="20.jpg"><figcaption aria-hidden="true">20.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-4对面积的曲面积分/21.jpg" alt="21.jpg"><figcaption aria-hidden="true">21.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十一章 曲线积分与曲面积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 曲面积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三节 格林公式及其应用</title>
      <link href="/2024/03/29/duo-yuan-wei-ji-fen-11-3-ge-lin-gong-shi-ji-qi-ying-yong/"/>
      <url>/2024/03/29/duo-yuan-wei-ji-fen-11-3-ge-lin-gong-shi-ji-qi-ying-yong/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/ikpPX1t0ivlg">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分11-3格林公式及其应用/8.jpg" alt="8.jpg"><figcaption aria-hidden="true">8.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-3格林公式及其应用/9.jpg" alt="9.jpg"><figcaption aria-hidden="true">9.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-3格林公式及其应用/10.jpg" alt="10.jpg"><figcaption aria-hidden="true">10.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-3格林公式及其应用/11.jpg" alt="11.jpg"><figcaption aria-hidden="true">11.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-3格林公式及其应用/12.jpg" alt="12.jpg"><figcaption aria-hidden="true">12.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-3格林公式及其应用/13.jpg" alt="13.jpg"><figcaption aria-hidden="true">13.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-3格林公式及其应用/14.jpg" alt="14.jpg"><figcaption aria-hidden="true">14.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-3格林公式及其应用/15.jpg" alt="15.jpg"><figcaption aria-hidden="true">15.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-3格林公式及其应用/16.jpg" alt="16.jpg"><figcaption aria-hidden="true">16.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-3格林公式及其应用/17.jpg" alt="17.jpg"><figcaption aria-hidden="true">17.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十一章 曲线积分与曲面积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 曲线积分 </tag>
            
            <tag> 格林公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二节 对坐标的曲线积分</title>
      <link href="/2024/03/29/duo-yuan-wei-ji-fen-11-2-dui-zuo-biao-de-qu-xian-ji-fen/"/>
      <url>/2024/03/29/duo-yuan-wei-ji-fen-11-2-dui-zuo-biao-de-qu-xian-ji-fen/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iatBx1t0ih6h">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分11-2对坐标的曲线积分/1.jpg" alt="1.jpg"><figcaption aria-hidden="true">1.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-2对坐标的曲线积分/2.jpg" alt="2.jpg"><figcaption aria-hidden="true">2.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-2对坐标的曲线积分/3.jpg" alt="3.jpg"><figcaption aria-hidden="true">3.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-2对坐标的曲线积分/4.jpg" alt="4.jpg"><figcaption aria-hidden="true">4.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-2对坐标的曲线积分/5.jpg" alt="5.jpg"><figcaption aria-hidden="true">5.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-2对坐标的曲线积分/6.jpg" alt="6.jpg"><figcaption aria-hidden="true">6.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-2对坐标的曲线积分/7.jpg" alt="7.jpg"><figcaption aria-hidden="true">7.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十一章 曲线积分与曲面积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 曲线积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一节 对弧长的曲线积分</title>
      <link href="/2024/03/29/duo-yuan-wei-ji-fen-11-1-dui-hu-chang-de-qu-xian-ji-fen/"/>
      <url>/2024/03/29/duo-yuan-wei-ji-fen-11-1-dui-hu-chang-de-qu-xian-ji-fen/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iFZJX1t0i3yb">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分11-1对弧长的曲线积分/147.jpg" alt="147.jpg"><figcaption aria-hidden="true">147.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-1对弧长的曲线积分/148.jpg" alt="148.jpg"><figcaption aria-hidden="true">148.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-1对弧长的曲线积分/149.jpg" alt="149.jpg"><figcaption aria-hidden="true">149.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-1对弧长的曲线积分/150.jpg" alt="150.jpg"><figcaption aria-hidden="true">150.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十一章 曲线积分与曲面积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 曲线积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言实现π的高精度计算</title>
      <link href="/2024/03/27/gao-jing-du-pi/"/>
      <url>/2024/03/27/gao-jing-du-pi/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">题目描述</h1><p>限制使用双向链表作存储结构，请根据用户输入的一个整数（该整数表示精确到小数点后的位数，可能要求精确到小数点后500 位），高精度计算PI值。可以利用反三角函数幂级展开式来进行计算。</p><h2 id="测试说明">测试说明</h2><p><strong>输入说明：</strong>输入的一个正整数n。输出说明：输出PI的值，精确到小数点后n位，最后输出一个回车。平台会对你编写的代码进行测试：</p><p><strong>测试输入：</strong>5</p><p><strong>预期输出：</strong>3.14159</p><h2 id="解答">解答</h2><p>以下是数组实现的方法： 显然使用数组，时间复杂度更低。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> r[<span class="number">2800</span> + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> i, k;</span><br><span class="line"><span class="type">int</span> b, d;</span><br><span class="line"><span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">3000</span>];</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line"><span class="type">int</span> n;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);n++;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2800</span>; i++)</span><br><span class="line">r[i] = <span class="number">2000</span>;</span><br><span class="line">    r[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">2800</span>; k &gt; <span class="number">0</span>; k -= <span class="number">14</span>) {</span><br><span class="line">d = <span class="number">0</span>;</span><br><span class="line">i = k;</span><br><span class="line"><span class="keyword">for</span> (;;) {</span><br><span class="line">    d += r[i] * <span class="number">10000</span>;</span><br><span class="line">    b = <span class="number">2</span> * i - <span class="number">1</span>;</span><br><span class="line">    r[i] = d % b;</span><br><span class="line">    d /= b;</span><br><span class="line">    i--;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    d *= i;</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> tmp = c + d / <span class="number">10000</span>;</span><br><span class="line">ans[j+<span class="number">3</span>] = tmp % <span class="number">10</span>;</span><br><span class="line">ans[j+<span class="number">2</span>] = (tmp / <span class="number">10</span>) % <span class="number">10</span>;</span><br><span class="line">ans[j+<span class="number">1</span>] = (tmp / <span class="number">100</span>) % <span class="number">10</span>;</span><br><span class="line">ans[j+<span class="number">0</span>] = tmp / <span class="number">1000</span>;</span><br><span class="line">j+=<span class="number">4</span>;</span><br><span class="line">c = d % <span class="number">10000</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>&amp;&amp;n&gt;<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>k次循环实际上实在迭代： <span class="math display">\[2\left(1+\frac{1}{3}\left(1+\frac{2}{5}\left(1+\ldots\left(1+\frac{2799}{2\cdot 2799+1}(1+0)\right) \ldots\right)\right)\right)\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> c/c++ </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 双向链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五节 独立性</title>
      <link href="/2024/03/25/gai-lu-lun-1-5-du-li-xing/"/>
      <url>/2024/03/25/gai-lu-lun-1-5-du-li-xing/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/imne81smk7xc">下载PDF点这里</a></p><p><img src="../../../../images/概率论1-5独立性/11.jpg"></p><p><img src="../../../../images/概率论1-5独立性/12.jpg"></p><p><img src="../../../../images/概率论1-5独立性/13.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第一章 随机事件与概率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 独立性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四节 条件概率</title>
      <link href="/2024/03/25/gai-lu-lun-1-4-tiao-jian-gai-lu/"/>
      <url>/2024/03/25/gai-lu-lun-1-4-tiao-jian-gai-lu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iJjON1smjmjc">下载PDF点这里</a></p><p><img src="../../../../images/概率论1-4条件概率/7.jpg"></p><p><img src="../../../../images/概率论1-4条件概率/8.jpg"></p><p><img src="../../../../images/概率论1-4条件概率/9.jpg"></p><p><img src="../../../../images/概率论1-4条件概率/10.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第一章 随机事件与概率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贝叶斯公式 </tag>
            
            <tag> 条件概率 </tag>
            
            <tag> 乘法公式 </tag>
            
            <tag> 波利亚罐模型 </tag>
            
            <tag> 全概率公式 </tag>
            
            <tag> 摸彩模型 </tag>
            
            <tag> 赌徒破产模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三节 概率的性质</title>
      <link href="/2024/03/25/gai-lu-lun-1-3-gai-lu-de-xing-zhi/"/>
      <url>/2024/03/25/gai-lu-lun-1-3-gai-lu-de-xing-zhi/</url>
      
        <content type="html"><![CDATA[<p><img src="../../../../images/概率论1-3概率的性质/6.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第一章 随机事件与概率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率加法公式 </tag>
            
            <tag> 匹配问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二节 概率的定义及其确定方法</title>
      <link href="/2024/03/25/gai-lu-lun-1-2-gai-lu-de-ding-yi-ji-qi-que-ding-fang-fa/"/>
      <url>/2024/03/25/gai-lu-lun-1-2-gai-lu-de-ding-yi-ji-qi-que-ding-fang-fa/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iUSrd1smi0di">下载PDF点这里</a></p><p><img src="../../../../images/概率论1-2概率的定义及其确定方法/4.jpg"></p><p><img src="../../../../images/概率论1-2概率的定义及其确定方法/5.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第一章 随机事件与概率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抽样模型 </tag>
            
            <tag> 盒子模型 </tag>
            
            <tag> 抽签问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一节 随机事件及其运算</title>
      <link href="/2024/03/25/gai-lu-lun-1-1-sui-ji-shi-jian-ji-qi-gai-lu/"/>
      <url>/2024/03/25/gai-lu-lun-1-1-sui-ji-shi-jian-ji-qi-gai-lu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iUNnj1smhbch">下载PDF点这里</a></p><p><img src="../../../../images/概率论1-1随机事件及其概率/2.jpg"></p><p><img src="../../../../images/概率论1-1随机事件及其概率/3.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第一章 随机事件与概率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随机事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一节 定积分的概念与性质</title>
      <link href="/2024/03/25/yi-yuan-wei-ji-fen-5-1-ding-ji-fen-de-gai-nian-yu-xing-zhi/"/>
      <url>/2024/03/25/yi-yuan-wei-ji-fen-5-1-ding-ji-fen-de-gai-nian-yu-xing-zhi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iWt1b1smez5g">下载PDF点这里</a></p><figure><img src="../../../../images/一元微积分5-1定积分的概念与性质/101.jpg" alt="101.jpg"><figcaption aria-hidden="true">101.jpg</figcaption></figure><figure><img src="../../../../images/一元微积分5-1定积分的概念与性质/102.jpg" alt="102.jpg"><figcaption aria-hidden="true">102.jpg</figcaption></figure><figure><img src="../../../../images/一元微积分5-1定积分的概念与性质/103.jpg" alt="103.jpg"><figcaption aria-hidden="true">103.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 一元微积分 </category>
          
          <category> 第五章 定积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 定积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法(Java实现)</title>
      <link href="/2024/03/25/shu-ju-jie-gou-yu-suan-fa/"/>
      <url>/2024/03/25/shu-ju-jie-gou-yu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="一.-初识算法">一. 初识算法</h1><h2 id="什么是算法">1.1 什么是算法？</h2><p><strong>定义</strong></p><p>在数学和计算机科学领域，算法是一系列有限的严谨指令，通常用于解决一类特定问题或执行计算</p><blockquote><p>In mathematics and computer science, an <strong>algorithm</strong>(/ˈælɡərɪðəm/) is a finite sequence of rigorous instructions, typicallyused to solve a class of specific problems or to perform acomputation.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p></blockquote><p><strong>Introduction to Algorithm<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></strong></p><p>不正式的说，算法就是任何定义优良的计算过程：接收一些值作为输入，在有限的时间内，产生一些值作为输出。</p><blockquote><p>Informally, an algorithm is any well-defined computational procedurethat takes some value, or set of values, as input and produces somevalue, or set of values, as output in a finite amount of time.</p></blockquote><h2 id="什么是数据结构">1.2 什么是数据结构？</h2><p><strong>定义</strong></p><p>在计算机科学领域，数据结构是一种数据组织、管理和存储格式，通常被选择用来高效访问数据</p><blockquote><p>In computer science, a <strong>data structure</strong> is a dataorganization, management, and storage format that is usually chosen forefficient access to data</p></blockquote><p><strong>Introduction to Algorithm<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></strong></p><p>数据结构是一种存储和组织数据的方式，旨在便于访问和修改</p><blockquote><p>A data structure is a way to store and organize data in order tofacilitate access and modifications</p></blockquote><p>可以说，<strong>程序 = 数据结构 +算法</strong>，它们是每一位程序员的基本功，下来我们通过对一个非常著名的二分查找算法的讲解来认识一下算法</p><h2 id="二分查找-3">1.3 二分查找 <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></h2><p>二分查找算法也称折半查找，是一种非常高效的工作于有序数组的查找算法。后续的课程中还会学习更多的查找算法，但在此之前，不妨用它作为入门。</p><h3 id="基础版">1) 基础版</h3><p>需求：在<strong>有序</strong>数组 <span class="math inline">\(A\)</span> 内，查找值 <span class="math inline">\(target\)</span></p><ul><li>如果找到返回索引</li><li>如果找不到返回 <span class="math inline">\(-1\)</span></li></ul><p>算法描述</p><table><colgroup><col style="width: 6%"><col style="width: 93%"></colgroup><tbody><tr class="odd"><td>前提</td><td>给定一个内含 <span class="math inline">\(n\)</span> 个元素的有序数组<span class="math inline">\(A\)</span>，满足 <span class="math inline">\(A_{0}\leq A_{1}\leq A_{2}\leq \cdots \leqA_{n-1}\)</span>，一个待查值 <span class="math inline">\(target\)</span></td></tr><tr class="even"><td>1</td><td>设置 <span class="math inline">\(i=0\)</span>，<span class="math inline">\(j=n-1\)</span></td></tr><tr class="odd"><td>2</td><td>如果 <span class="math inline">\(i \gtj\)</span>，结束查找，没找到</td></tr><tr class="even"><td>3</td><td>设置 <span class="math inline">\(m = floor(\frac {i+j}{2})\)</span>，<span class="math inline">\(m\)</span> 为中间索引，<span class="math inline">\(floor\)</span> 是向下取整（<span class="math inline">\(\leq \frac {i+j}{2}\)</span> 的最小整数）</td></tr><tr class="odd"><td>4</td><td>如果 <span class="math inline">\(target &lt; A_{m}\)</span> 设置<span class="math inline">\(j = m - 1\)</span>，跳到第2步</td></tr><tr class="even"><td>5</td><td>如果 <span class="math inline">\(A_{m} &lt; target\)</span> 设置<span class="math inline">\(i = m + 1\)</span>，跳到第2步</td></tr><tr class="odd"><td>6</td><td>如果 <span class="math inline">\(A_{m} =target\)</span>，结束查找，找到了</td></tr></tbody></table><blockquote><p><strong><em>P.S.</em></strong></p><ul><li>对于一个算法来讲，都有较为严谨的描述，上面是一个例子</li><li>后续讲解时，以简明直白为目标，不会总以上面的方式来描述算法</li></ul></blockquote><p>java 实现</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) {<span class="comment">// 在左边</span></span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) {<span class="comment">// 在右边</span></span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><span class="math inline">\(i,j\)</span> 对应着搜索区间 <span class="math inline">\([0,a.length-1]\)</span>（注意是闭合的区间），<span class="math inline">\(i&lt;=j\)</span>意味着搜索区间内还有未比较的元素，<span class="math inline">\(i,j\)</span> 指向的元素也可能是比较的目标<ul><li>思考：如果不加 <span class="math inline">\(i==j\)</span>行不行？</li><li>回答：不行，因为这意味着 <span class="math inline">\(i,j\)</span>指向的元素会漏过比较</li></ul></li><li><span class="math inline">\(m\)</span>对应着中间位置，中间位置左边和右边的元素可能不相等（差一个），不会影响结果</li><li>如果某次未找到，那么缩小后的区间内不包含 <span class="math inline">\(m\)</span></li></ul><h3 id="改变版">2) 改变版</h3><p>另一种写法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) {<span class="comment">// 在左边</span></span><br><span class="line">            j = m;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) {<span class="comment">// 在右边</span></span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><span class="math inline">\(i,j\)</span> 对应着搜索区间 <span class="math inline">\([0,a.length)\)</span>（注意是左闭右开的区间），<span class="math inline">\(i&lt;j\)</span>意味着搜索区间内还有未比较的元素，<span class="math inline">\(j\)</span>指向的<strong>一定不是</strong>查找目标<ul><li>思考：为啥这次不加 <span class="math inline">\(i==j\)</span>的条件了？</li><li>回答：这回 <span class="math inline">\(j\)</span>指向的不是查找目标，如果还加 <span class="math inline">\(i==j\)</span>条件，就意味着 <span class="math inline">\(j\)</span>指向的还会再次比较，找不到时，会死循环</li></ul></li><li>如果某次要缩小右边界，那么 <span class="math inline">\(j=m\)</span>，因为此时的 <span class="math inline">\(m\)</span>已经<strong>不是</strong>查找目标了</li></ul><h2 id="衡量算法好坏">1.4 衡量算法好坏</h2><p><strong>时间复杂度</strong></p><p>下面的查找算法也能得出与之前二分查找一样的结果，那你能说出它差在哪里吗？</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> k)</span> {</span><br><span class="line">    <span class="keyword">for</span> (</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        i &lt; a.length;</span><br><span class="line">        i++</span><br><span class="line">    ) {</span><br><span class="line">        <span class="keyword">if</span> (a[i] == k) {</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>考虑最坏情况下（没找到）例如 <code>[1,2,3,4]</code> 查找 5</p><ul><li><code>int i = 0</code> 只执行一次</li><li><code>i &lt; a.length</code> 受数组元素个数 <span class="math inline">\(n\)</span> 的影响，比较 <span class="math inline">\(n+1\)</span> 次</li><li><code>i++</code> 受数组元素个数 <span class="math inline">\(n\)</span> 的影响，自增 <span class="math inline">\(n\)</span> 次</li><li><code>a[i] == k</code> 受元素个数 <span class="math inline">\(n\)</span> 的影响，比较 <span class="math inline">\(n\)</span> 次</li><li><code>return -1</code>，执行一次</li></ul><p>粗略认为每行代码执行时间是 <span class="math inline">\(t\)</span>，假设 <span class="math inline">\(n=4\)</span> 那么</p><ul><li>总执行时间是 <span class="math inline">\((1+4+1+4+4+1)*t =15t\)</span></li><li>可以推导出更一般地公式为，<span class="math inline">\(T =(3*n+3)t\)</span></li></ul><p>如果套用二分查找算法，还是 <code>[1,2,3,4]</code> 查找 5</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) {<span class="comment">// 在左边</span></span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) {<span class="comment">// 在右边</span></span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>int i = 0, j = a.length - 1</code> 各执行 1 次</li><li><code>i &lt;= j</code> 比较 <span class="math inline">\(floor(\log_{2}(n)+1)\)</span> 再加 1 次</li><li><code>(i + j) &gt;&gt;&gt; 1</code> 计算 <span class="math inline">\(floor(\log_{2}(n)+1)\)</span> 次</li><li>接下来 <code>if() else if() else</code> 会执行 <span class="math inline">\(3* floor(\log_{2}(n)+1)\)</span> 次，分别为<ul><li>if 比较</li><li>else if 比较</li><li>else if 比较成立后的赋值语句</li></ul></li><li><code>return -1</code>，执行一次</li></ul><p>结果：</p><ul><li>总执行时间为 <span class="math inline">\((2 + (1+3) + 3 + 3 * 3+1)*t = 19t\)</span></li><li>更一般地公式为 <span class="math inline">\((4 + 5 *floor(\log_{2}(n)+1))*t\)</span></li></ul><blockquote><p><strong>注意：</strong></p><p>左侧未找到和右侧未找到结果不一样，这里不做分析</p></blockquote><p>两个算法比较，可以看到 <span class="math inline">\(n\)</span>在较小的时候，二者花费的次数差不多</p><p><img src="../../../../images/StrJava/image-20221108095747933.png" alt="image-20221108095747933" style="zoom:50%;"></p><p>但随着 <span class="math inline">\(n\)</span> 越来越大，比如说 <span class="math inline">\(n=1000\)</span> 时，用二分查找算法（红色）也就是<span class="math inline">\(54t\)</span>，而蓝色算法则需要 <span class="math inline">\(3003t\)</span></p><p><img src="../../../../images/StrJava/image-20221108100014451.png" alt="image-20221108100014451" style="zoom:50%;"></p><blockquote><p>画图采用的是 <a href="https://www.desmos.com/calculator?lang=zh-CN">Desmos |图形计算器</a></p></blockquote><p>计算机科学中，<strong>时间复杂度</strong>是用来衡量：一个算法的执行，随数据规模增大，而增长的时间成本</p><ul><li>不依赖于环境因素</li></ul><p>如何表示时间复杂度呢？</p><ul><li>假设算法要处理的数据规模是 <span class="math inline">\(n\)</span>，代码总的执行行数用函数 <span class="math inline">\(f(n)\)</span> 来表示，例如：<ul><li>线性查找算法的函数 <span class="math inline">\(f(n) = 3*n +3\)</span></li><li>二分查找算法的函数 <span class="math inline">\(f(n) =(floor(log_2(n)) + 1) * 5 + 4\)</span></li></ul></li><li>为了对 <span class="math inline">\(f(n)\)</span>进行化简，应当抓住主要矛盾，找到一个变化趋势与之相近的表示法</li></ul><p><strong>大 <span class="math inline">\(O\)</span> 表示法<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></strong></p><figure><img src="../../../../images/StrJava/image-20221108103846566.png" alt="image-20221108103846566"><figcaption aria-hidden="true">image-20221108103846566</figcaption></figure><p>其中</p><ul><li><span class="math inline">\(c, c_1, c_2\)</span> 都为一个常数</li><li><span class="math inline">\(f(n)\)</span> 是实际执行代码行数与 n的函数</li><li><span class="math inline">\(g(n)\)</span> 是经过化简，变化趋势与<span class="math inline">\(f(n)\)</span> 一致的 n 的函数</li></ul><p><strong>渐进上界</strong></p><p>渐进上界（asymptotic upper bound）：从某个常数 <span class="math inline">\(n_0\)</span>开始，<span class="math inline">\(c*g(n)\)</span> 总是位于 <span class="math inline">\(f(n)\)</span> 上方，那么记作 <span class="math inline">\(O(g(n))\)</span></p><ul><li>代表算法执行的最差情况</li></ul><p>例1</p><ul><li><span class="math inline">\(f(n) = 3*n+3\)</span></li><li><span class="math inline">\(g(n) = n\)</span></li><li>取 <span class="math inline">\(c=4\)</span>，在<span class="math inline">\(n_0=3\)</span> 之后，<span class="math inline">\(g(n)\)</span> 可以作为 <span class="math inline">\(f(n)\)</span> 的渐进上界，因此表示法写作 <span class="math inline">\(O(n)\)</span></li></ul><p>例2</p><ul><li><span class="math inline">\(f(n) = 5*floor(log_2(n)) +9\)</span></li><li><span class="math inline">\(g(n) = log_2(n)\)</span></li><li><span class="math inline">\(O(log_2(n))\)</span></li></ul><p>已知 <span class="math inline">\(f(n)\)</span> 来说，求 <span class="math inline">\(g(n)\)</span></p><ul><li>表达式中相乘的常量，可以省略，如<ul><li><span class="math inline">\(f(n) = 100*n^2\)</span> 中的 <span class="math inline">\(100\)</span></li></ul></li><li>多项式中数量规模更小（低次项）的表达式，如<ul><li><span class="math inline">\(f(n)=n^2+n\)</span> 中的 <span class="math inline">\(n\)</span></li><li><span class="math inline">\(f(n) = n^3 + n^2\)</span> 中的 <span class="math inline">\(n^2\)</span></li></ul></li><li>不同底数的对数，渐进上界可以用一个对数函数 <span class="math inline">\(\log n\)</span> 表示<ul><li>例如：<span class="math inline">\(log_2(n)\)</span> 可以替换为 <span class="math inline">\(log_{10}(n)\)</span>，因为 <span class="math inline">\(log_2(n) =\frac{log_{10}(n)}{log_{10}(2)}\)</span>，相乘的常量 <span class="math inline">\(\frac{1}{log_{10}(2)}\)</span> 可以省略</li></ul></li><li>类似的，对数的常数次幂可省略<ul><li>如：<span class="math inline">\(log(n^c) = c * log(n)\)</span></li></ul></li></ul><p><strong>常见大 <span class="math inline">\(O\)</span>表示法</strong></p><figure><img src="../../../../images/StrJava/image-20221108114915524.png" alt="image-20221108114915524"><figcaption aria-hidden="true">image-20221108114915524</figcaption></figure><p>按时间复杂度从低到高</p><ul><li>黑色横线 <span class="math inline">\(O(1)\)</span>，常量时间，意味着算法时间并不随数据规模而变化</li><li>绿色 <span class="math inline">\(O(log(n))\)</span>，对数时间</li><li>蓝色 <span class="math inline">\(O(n)\)</span>，线性时间，算法时间与数据规模成正比</li><li>橙色 <span class="math inline">\(O(n*log(n))\)</span>，拟线性时间</li><li>红色 <span class="math inline">\(O(n^2)\)</span> 平方时间</li><li>黑色朝上 <span class="math inline">\(O(2^n)\)</span> 指数时间</li><li>没画出来的 <span class="math inline">\(O(n!)\)</span></li></ul><p><strong>渐进下界</strong></p><p>渐进下界（asymptotic lower bound）：从某个常数 <span class="math inline">\(n_0\)</span>开始，<span class="math inline">\(c*g(n)\)</span> 总是位于 <span class="math inline">\(f(n)\)</span> 下方，那么记作 <span class="math inline">\(\Omega(g(n))\)</span></p><p><strong>渐进紧界</strong></p><p>渐进紧界（asymptotic tight bounds）：从某个常数 <span class="math inline">\(n_0\)</span>开始，<span class="math inline">\(f(n)\)</span> 总是在 <span class="math inline">\(c_1*g(n)\)</span> 和 <span class="math inline">\(c_2*g(n)\)</span> 之间，那么记作 <span class="math inline">\(\Theta(g(n))\)</span></p><p><strong>空间复杂度</strong></p><p>与时间复杂度类似，一般也使用大 <span class="math inline">\(O\)</span>表示法来衡量：一个算法执行随数据规模增大，而增长的<strong>额外</strong>空间成本</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchBasic</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;    <span class="comment">// 设置指针和初值</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) {                <span class="comment">// i~j 范围内有东西</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; a[m]) {         <span class="comment">// 目标在左边</span></span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) { <span class="comment">// 目标在右边</span></span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {                    <span class="comment">// 找到了</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>二分查找性能</strong></p><p>下面分析二分查找算法的性能</p><p>时间复杂度</p><ul><li>最坏情况：<span class="math inline">\(O(\log n)\)</span></li><li>最好情况：如果待查找元素恰好在数组中央，只需要循环一次 <span class="math inline">\(O(1)\)</span></li></ul><p>空间复杂度</p><ul><li>需要常数个指针 <span class="math inline">\(i,j,m\)</span>，因此额外占用的空间是 <span class="math inline">\(O(1)\)</span></li></ul><h2 id="再看二分查找">1.5 再看二分查找</h2><h3 id="平衡版">1) 平衡版</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchBalance</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span> &lt; j - i) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) {</span><br><span class="line">            j = m;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            i = m;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (a[i] == target) ? i : -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>思想：</p><ol type="1"><li>左闭右开的区间，<span class="math inline">\(i\)</span>指向的可能是目标，而 <span class="math inline">\(j\)</span>指向的不是目标</li><li>不奢望循环内通过 <span class="math inline">\(m\)</span> 找出目标,缩小区间直至剩 1 个, 剩下的这个可能就是要找的（通过 <span class="math inline">\(i\)</span>）<ul><li><span class="math inline">\(j - i &gt; 1\)</span>的含义是，在范围内待比较的元素个数 &gt; 1</li></ul></li><li>改变 <span class="math inline">\(i\)</span>边界时，它指向的可能是目标，因此不能 <span class="math inline">\(m+1\)</span></li><li>循环内的平均比较次数减少了</li><li>时间复杂度 <span class="math inline">\(\Theta(log(n))\)</span></li></ol><h3 id="java-版">2) Java 版</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch0</span><span class="params">(<span class="type">long</span>[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex,</span></span><br><span class="line"><span class="params">                                     <span class="type">long</span> key)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> fromIndex;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> toIndex - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">midVal</span> <span class="operator">=</span> a[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (midVal &lt; key)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; key)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// key found</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found.</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>例如 <span class="math inline">\([1,3,5,6]\)</span> 要插入 <span class="math inline">\(2\)</span>那么就是找到一个位置，这个位置左侧元素都比它小<ul><li>等循环结束，若没找到，low 左侧元素肯定都比 target 小，因此 low即插入点</li></ul></li><li>插入点取负是为了与找到情况区分</li><li>-1 是为了把索引 0 位置的插入点与找到的情况进行区分</li></ul><h3 id="leftmost-与-rightmost">3) Leftmost 与 Rightmost</h3><p>有时我们希望返回的是最左侧的重复元素，如果用 Basic 二分查找</p><ul><li><p>对于数组 <span class="math inline">\([1, 2, 3, 4, 4, 5, 6,7]\)</span>，查找元素4，结果是索引3</p></li><li><p>对于数组 <span class="math inline">\([1, 2, 4, 4, 4, 5, 6,7]\)</span>，查找元素4，结果也是索引3，并不是最左侧的元素</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchLeftmost1</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) {</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) {</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            candidate = m; <span class="comment">// 记录候选位置</span></span><br><span class="line">            j = m - <span class="number">1</span>;     <span class="comment">// 继续向左</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果希望返回的是最右侧元素</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchRightmost1</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) {</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) {</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            candidate = m; <span class="comment">// 记录候选位置</span></span><br><span class="line">            i = m + <span class="number">1</span>;   <span class="comment">// 继续向右</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>应用</strong></p><p>对于 Leftmost 与 Rightmost，可以返回一个比 -1 更有用的值</p><p>Leftmost 改为</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchLeftmost</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= a[m]) {</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> i; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>leftmost 返回值的另一层含义：<span class="math inline">\(\lttarget\)</span> 的元素个数</li><li>小于等于中间值，都要向左找</li></ul><p>Rightmost 改为</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchRightmost</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) {</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>大于等于中间值，都要向右找</li></ul><p>几个名词</p><figure><img src="../../../../images/StrJava/image-20221125174155058.png" alt="image-20221125174155058"><figcaption aria-hidden="true">image-20221125174155058</figcaption></figure><p><strong>范围查询</strong>：</p><ul><li>查询 <span class="math inline">\(x \lt 4\)</span>，<span class="math inline">\(0 .. leftmost(4) - 1\)</span></li><li>查询 <span class="math inline">\(x \leq 4\)</span>，<span class="math inline">\(0 .. rightmost(4)\)</span></li><li>查询 <span class="math inline">\(4 \lt x\)</span>，$rightmost(4) + 1.. $</li><li>查询 <span class="math inline">\(4 \leq x\)</span>， <span class="math inline">\(leftmost(4) .. \infty\)</span></li><li>查询 <span class="math inline">\(4 \leq x \leq 7\)</span>，<span class="math inline">\(leftmost(4) .. rightmost(7)\)</span></li><li>查询 <span class="math inline">\(4 \lt x \lt 7\)</span>，<span class="math inline">\(rightmost(4)+1 .. leftmost(7)-1\)</span></li></ul><p><strong>求排名</strong>：<span class="math inline">\(leftmost(target)+ 1\)</span></p><ul><li><span class="math inline">\(target\)</span> 可以不存在，如：<span class="math inline">\(leftmost(5)+1 = 6\)</span></li><li><span class="math inline">\(target\)</span> 也可以存在，如：<span class="math inline">\(leftmost(4)+1 = 3\)</span></li></ul><p><strong>求前任（predecessor）</strong>：<span class="math inline">\(leftmost(target) - 1\)</span></p><ul><li><span class="math inline">\(leftmost(3) - 1 = 1\)</span>，前任 <span class="math inline">\(a_1 = 2\)</span></li><li><span class="math inline">\(leftmost(4) - 1 = 1\)</span>，前任 <span class="math inline">\(a_1 = 2\)</span></li></ul><p><strong>求后任（successor）</strong>：<span class="math inline">\(rightmost(target)+1\)</span></p><ul><li><span class="math inline">\(rightmost(5) + 1 = 5\)</span>，后任<span class="math inline">\(a_5 = 7\)</span></li><li><span class="math inline">\(rightmost(4) + 1 = 5\)</span>，后任<span class="math inline">\(a_5 = 7\)</span></li></ul><p><strong>求最近邻居</strong>：</p><ul><li>前任和后任距离更近者</li></ul><h2 id="习题">习题</h2><h3 id="时间复杂度估算">1) 时间复杂度估算</h3><p>用函数 <span class="math inline">\(f(n)\)</span>表示算法效率与数据规模的关系，假设每次解决问题需要 1 微秒（<span class="math inline">\(10^{-6}\)</span> 秒），进行估算：</p><ol type="1"><li>如果 <span class="math inline">\(f(n) = n^2\)</span> 那么 1秒能解决多少次问题？1 天呢？</li><li>如果 <span class="math inline">\(f(n) = log_2(n)\)</span> 那么 1秒能解决多少次问题？1 天呢？</li><li>如果 <span class="math inline">\(f(n) = n!\)</span> 那么 1秒能解决多少次问题？1 天呢？</li></ol><p><strong>参考解答</strong></p><ol type="1"><li>1秒 <span class="math inline">\(\sqrt{10^6} = 1000\)</span> 次，1 天<span class="math inline">\(\sqrt{10^6 * 3600 * 24} \approx293938\)</span> 次</li><li>1秒 $2^{1,000,000} $ 次，一天 <span class="math inline">\(2^{86,400,000,000}\)</span></li><li>推算如下<ul><li><span class="math inline">\(10! = 3,628,800\)</span> 1秒能解决 <span class="math inline">\(1,000,000\)</span> 次，因此次数为 9 次</li><li><span class="math inline">\(14!=87,178,291,200\)</span>，一天能解决<span class="math inline">\(86,400,000,000\)</span> 次，因此次数为 13次</li></ul></li></ol><h3 id="耗时估算">2) 耗时估算</h3><p>一台机器对200个单词进行排序花了200秒(使用冒泡排序)，那么花费800秒，大概可以对多少个单词进行排序</p><ol type="a"><li><p>400</p></li><li><p>600</p></li><li><p>800</p></li><li><p>1600</p></li></ol><p><strong>答案</strong></p><ul><li>a</li></ul><p><strong>解释</strong></p><ul><li>冒泡排序时间复杂度是 <span class="math inline">\(O(N^2)\)</span></li><li>时间增长 4 倍，而因此能处理的数据量是原来的 <span class="math inline">\(\sqrt{4} = 2\)</span> 倍</li></ul><h3 id="e01.-二分查找-leetcode-704">3) E01. 二分查找-Leetcode 704</h3><p><strong>要点</strong>：减而治之，可以用递归或非递归实现</p><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回-1</p><p>例如</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>], target = <span class="number">9</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: <span class="number">9</span> 出现在 nums 中并且下标为 <span class="number">4</span></span><br><span class="line">    </span><br><span class="line">输入: nums = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>], target = <span class="number">2</span></span><br><span class="line">输出: -<span class="number">1</span></span><br><span class="line">解释: <span class="number">2</span> 不存在 nums 中因此返回 -<span class="number">1</span>    </span><br></pre></td></tr></tbody></table></figure><p><strong>参考答案</strong>：略，可以用讲过的任意一种二分求解</p><h3 id="e02.-搜索插入位置-leetcode-35">4) E02. 搜索插入位置-Leetcode35</h3><p><strong>要点</strong>：理解谁代表插入位置</p><p>给定一个排序数组和一个目标值</p><ul><li>在数组中找到目标值，并返回其索引</li><li>如果目标值不存在于数组中，返回它将会被按顺序插入的位置</li></ul><p>例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">输入: nums = [1,3,5,6], target = 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></tbody></table></figure><p><strong>参考答案1</strong>：用二分查找基础版代码改写，基础版中，找到返回m，没找到 i 代表插入点，因此有</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) {</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) {</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">// 原始 return -1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>参考答案2</strong>：用二分查找平衡版改写，平衡版中</p><ul><li>如果 target == a[i] 返回 i 表示找到</li><li>如果 target &lt; a[i]，例如 target = 2，a[i] = 3，这时就应该在 i位置插入 2</li><li>如果 a[i] &lt; target，例如 a[i] = 3，target = 4，这时就应该在 i+1位置插入 4</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span> &lt; j - i) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) {</span><br><span class="line">            j = m;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            i = m;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (target &lt;= a[i]) ? i : i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 原始 (target == a[i]) ? i : -1;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>参考答案3</strong>：用 leftmost版本解，返回值即为插入位置（并能处理元素重复的情况）</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= a[m]) {</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        } </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="e03.-搜索开始结束位置-leetcode-34">5) E03.搜索开始结束位置-Leetcode 34</h3><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题</p><p>例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br><span class="line"></span><br><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br><span class="line"></span><br><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></tbody></table></figure><p><strong>参考答案</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) {</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) {</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            candidate = m;</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) {</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) {</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            candidate = m;</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) {</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> left(nums, target);</span><br><span class="line">    <span class="keyword">if</span>(x == -<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] {-<span class="number">1</span>, -<span class="number">1</span>};</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] {x, right(nums, target)};</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="二.-基础数据结构">二. 基础数据结构</h1><h2 id="数组">2.1 数组</h2><h3 id="概述">1) 概述</h3><p><strong>定义</strong></p><p>在计算机科学中，数组是由一组元素（值或变量）组成的数据结构，每个元素有至少一个索引或键来标识</p><blockquote><p>In computer science, an <strong>array</strong> is a data structureconsisting of a collection of <em>elements</em> (values or variables),each identified by at least one <em>array index</em> or <em>key</em></p></blockquote><p>因为数组内的元素是<strong>连续存储</strong>的，所以数组中元素的地址，可以通过其索引计算出来，例如：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>}</span><br></pre></td></tr></tbody></table></figure><p>知道了数组的<strong>数据</strong>起始地址 <span class="math inline">\(BaseAddress\)</span>，就可以由公式 <span class="math inline">\(BaseAddress + i * size\)</span> 计算出索引 <span class="math inline">\(i\)</span> 元素的地址</p><ul><li><span class="math inline">\(i\)</span> 即索引，在 Java、C等语言都是从 0 开始</li><li><span class="math inline">\(size\)</span> 是每个元素占用字节，例如<span class="math inline">\(int\)</span> 占 <span class="math inline">\(4\)</span>，<span class="math inline">\(double\)</span> 占 <span class="math inline">\(8\)</span></li></ul><p><strong>小测试</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] array = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>}</span><br></pre></td></tr></tbody></table></figure><p>已知 array 的<strong>数据</strong>的起始地址是 0x7138f94c8，那么元素3 的地址是什么？</p><blockquote><p>答：0x7138f94c8 + 2 * 1 = 0x7138f94ca</p></blockquote><p><strong>空间占用</strong></p><p>Java 中数组结构为</p><ul><li>8 字节 markword</li><li>4 字节 class 指针（压缩 class 指针的情况）</li><li>4 字节 数组大小（决定了数组最大容量是 <span class="math inline">\(2^{32}\)</span>）</li><li>数组元素 + 对齐字节（java 中所有对象大小都是 8 字节的整数倍<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>，不足的要用对齐字节补足）</li></ul><p>例如</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br></pre></td></tr></tbody></table></figure><p>的大小为 40 个字节，组成如下</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">8 + 4 + 4 + 5*4 + 4(alignment)</span><br></pre></td></tr></tbody></table></figure><p><strong>随机访问性能</strong></p><p>即根据索引查找元素，时间复杂度是 <span class="math inline">\(O(1)\)</span></p><h3 id="动态数组">2) 动态数组</h3><p><strong>java 版本</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicArray</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 逻辑大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">8</span>; <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] array = {};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向最后位置 [size] 添加元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 待添加元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> element)</span> {</span><br><span class="line">        add(size, element);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向 [0 .. size] 位置添加元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index   索引位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 待添加元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> element)</span> {</span><br><span class="line">        checkAndGrow();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size) {</span><br><span class="line">            <span class="comment">// 向后挪动, 空出待插入位置</span></span><br><span class="line">            System.arraycopy(array, index,</span><br><span class="line">                    array, index + <span class="number">1</span>, size - index);</span><br><span class="line">        }</span><br><span class="line">        array[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkAndGrow</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 容量检查</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">            array = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (size == capacity) {</span><br><span class="line">            <span class="comment">// 进行扩容, 1.5 1.618 2</span></span><br><span class="line">            capacity += capacity &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] newArray = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">            System.arraycopy(array, <span class="number">0</span>,</span><br><span class="line">                    newArray, <span class="number">0</span>, size);</span><br><span class="line">            array = newArray;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从 [0 .. size) 范围删除元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 被删除元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> { <span class="comment">// [0..size)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">removed</span> <span class="operator">=</span> array[index];</span><br><span class="line">        <span class="keyword">if</span> (index &lt; size - <span class="number">1</span>) {</span><br><span class="line">            <span class="comment">// 向前挪动</span></span><br><span class="line">            System.arraycopy(array, index + <span class="number">1</span>,</span><br><span class="line">                    array, index, size - index - <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> removed;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引位置, 在 [0..size) 区间内</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 该索引位置的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历方法1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumer 遍历要执行的操作, 入参: 每个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foreach</span><span class="params">(Consumer&lt;Integer&gt; consumer)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            <span class="comment">// 提供 array[i]</span></span><br><span class="line">            <span class="comment">// 返回 void</span></span><br><span class="line">            consumer.accept(array[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历方法2 - 迭代器遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;Integer&gt;() {</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> { <span class="comment">// 有没有下一个元素</span></span><br><span class="line">                <span class="keyword">return</span> i &lt; size;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> { <span class="comment">// 返回当前元素,并移动到下一个元素</span></span><br><span class="line">                <span class="keyword">return</span> array[i++];</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历方法3 - stream 遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> stream 流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> IntStream <span class="title function_">stream</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> IntStream.of(Arrays.copyOfRange(array, <span class="number">0</span>, size));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>这些方法实现，都简化了 index 的有效性判断，假设输入的 index都是合法的</li></ul><p><strong>插入或删除性能</strong></p><p>头部位置，时间复杂度是 <span class="math inline">\(O(n)\)</span></p><p>中间位置，时间复杂度是 <span class="math inline">\(O(n)\)</span></p><p>尾部位置，时间复杂度是 <span class="math inline">\(O(1)\)</span>（均摊来说）</p><h3 id="二维数组">3) 二维数组</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] array = {</span><br><span class="line">    {<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>},</span><br><span class="line">    {<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>},</span><br><span class="line">    {<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>},</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>内存图如下</p><p><img src="../../../../images/StrJava/image-20221104114132056.png" alt="image-20221104114132056" style="zoom:67%;"></p><ul><li><p>二维数组占 32 个字节，其中 array[0]，array[1]，array[2]三个元素分别保存了指向三个一维数组的引用</p></li><li><p>三个一维数组各占 40 个字节</p></li><li><p>它们在内层布局上是<strong>连续</strong>的</p></li></ul><p>更一般的，对一个二维数组 <span class="math inline">\(Array[m][n]\)</span></p><ul><li><span class="math inline">\(m\)</span> 是外层数组的长度，可以看作row 行</li><li><span class="math inline">\(n\)</span> 是内层数组的长度，可以看作column 列</li><li>当访问 <span class="math inline">\(Array[i][j]\)</span>，<span class="math inline">\(0\leq i \lt m, 0\leq j \lt n\)</span>时，就相当于<ul><li>先找到第 <span class="math inline">\(i\)</span>个内层数组（行）</li><li>再找到此内层数组中第 <span class="math inline">\(j\)</span>个元素（列）</li></ul></li></ul><p><strong>小测试</strong></p><p>Java环境下（不考虑类指针和引用压缩，此为默认情况），有下面的二维数组</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[][] array = {</span><br><span class="line">    {<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>},</span><br><span class="line">    {<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>},</span><br><span class="line">    {<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>},</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>已知 array <strong>对象</strong>起始地址是 0x1000，那么 23这个元素的地址是什么？</p><blockquote><p>答：</p><ul><li>起始地址 0x1000</li><li>外层数组大小：16字节对象头 + 3元素 * 每个引用4字节 + 4 对齐字节 = 32= 0x20</li><li>第一个内层数组大小：16字节对象头 + 5元素 * 每个byte1字节 + 3对齐字节 = 24 = 0x18</li><li>第二个内层数组，16字节对象头 = 0x10，待查找元素索引为 2</li><li>最后结果 = 0x1000 + 0x20 + 0x18 + 0x10 + 2*1 = 0x104a</li></ul></blockquote><h3 id="局部性原理">4) 局部性原理</h3><p>这里只讨论空间局部性</p><ul><li>cpu读取内存（速度慢）数据后，会将其放入高速缓存（速度快）当中，如果后来的计算再用到此数据，在缓存中能读到的话，就不必读内存了</li><li>缓存的最小存储单位是缓存行（cache line），一般是 64bytes，一次读的数据少了不划算啊，因此最少读 64 bytes填满一个缓存行，因此读入某个数据时也会读取其<strong>临近的数据</strong>，这就是所谓<strong>空间局部性</strong></li></ul><p><strong>对效率的影响</strong></p><p>比较下面 ij 和 ji 两个方法的执行效率</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">columns</span> <span class="operator">=</span> <span class="number">14</span>;</span><br><span class="line"><span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[rows][columns];</span><br><span class="line"></span><br><span class="line"><span class="type">StopWatch</span> <span class="variable">sw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">sw.start(<span class="string">"ij"</span>);</span><br><span class="line">ij(a, rows, columns);</span><br><span class="line">sw.stop();</span><br><span class="line">sw.start(<span class="string">"ji"</span>);</span><br><span class="line">ji(a, rows, columns);</span><br><span class="line">sw.stop();</span><br><span class="line">System.out.println(sw.prettyPrint());</span><br></pre></td></tr></tbody></table></figure><p>ij 方法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ij</span><span class="params">(<span class="type">int</span>[][] a, <span class="type">int</span> rows, <span class="type">int</span> columns)</span> {</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; columns; j++) {</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>ji 方法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ji</span><span class="params">(<span class="type">int</span>[][] a, <span class="type">int</span> rows, <span class="type">int</span> columns)</span> {</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; columns; j++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) {</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>执行结果</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line">StopWatch '': running time = 96283300 ns</span><br><span class="line">---------------------------------------------</span><br><span class="line">ns         %     Task name</span><br><span class="line">---------------------------------------------</span><br><span class="line">016196200  017%  ij</span><br><span class="line">080087100  083%  ji</span><br></pre></td></tr></tbody></table></figure><p>可以看到 ij 的效率比 ji 快很多，为什么呢？</p><ul><li>缓存是有限的，当新数据来了后，一些旧的缓存行数据就会被覆盖</li><li>如果不能充分利用缓存的数据，就会造成效率低下</li></ul><p>以 ji 执行为例，第一次内循环要读入 <span class="math inline">\([0,0]\)</span> 这条数据，由于局部性原理，读入<span class="math inline">\([0,0]\)</span> 的同时也读入了 <span class="math inline">\([0,1] ... [0,13]\)</span>，如图所示</p><figure><img src="../../../../images/StrJava/image-20221104164329026.png" alt="image-20221104164329026"><figcaption aria-hidden="true">image-20221104164329026</figcaption></figure><p>但很遗憾，第二次内循环要的是 <span class="math inline">\([1,0]\)</span>这条数据，缓存中没有，于是再读入了下图的数据</p><figure><img src="../../../../images/StrJava/image-20221104164716282.png" alt="image-20221104164716282"><figcaption aria-hidden="true">image-20221104164716282</figcaption></figure><p>这显然是一种浪费，因为 <span class="math inline">\([0,1] ...[0,13]\)</span> 包括 <span class="math inline">\([1,1] ...[1,13]\)</span>这些数据虽然读入了缓存，却没有及时用上，而缓存的大小是有限的，等执行到第九次内循环时</p><figure><img src="../../../../images/StrJava/image-20221104164947154.png" alt="image-20221104164947154"><figcaption aria-hidden="true">image-20221104164947154</figcaption></figure><p>缓存的第一行数据已经被新的数据 <span class="math inline">\([8,0] ...[8,13]\)</span> 覆盖掉了，以后如果再想读，比如 <span class="math inline">\([0,1]\)</span>，又得到内存去读了</p><p>同理可以分析 ij 函数则能充分利用局部性原理加载到的缓存数据</p><p><strong>举一反三</strong></p><ol type="1"><li><p>I/O 读写时同样可以体现局部性原理</p></li><li><p>数组可以充分利用局部性原理，那么链表呢？</p><blockquote><p>答：链表不行，因为链表的元素并非相邻存储</p></blockquote></li></ol><h3 id="越界检查">5) 越界检查</h3><p>java 中对数组元素的读写都有越界检查，类似于下面的代码</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_within_bounds</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span>        </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= index &amp;&amp; index &lt; <span class="built_in">length</span>(); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>代码位置：<code>openjdk\src\hotspot\share\oops\arrayOop.hpp</code></li></ul><p>只不过此检查代码，不需要由程序员自己来调用，JVM 会帮我们调用</p><h3 id="习题-1">习题</h3><h4 id="e01.-合并有序数组---对应-leetcode-88">E01. 合并有序数组 - 对应Leetcode 88</h4><p>将数组内两个区间内的有序元素合并</p><p>例</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[1, 5, 6, 2, 4, 10, 11]</span><br></pre></td></tr></tbody></table></figure><p>可以视作两个有序区间</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[1, 5, 6] 和 [2, 4, 10, 11]</span><br></pre></td></tr></tbody></table></figure><p>合并后，结果仍存储于原有空间</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[1, 2, 4, 5, 6, 10, 11]</span><br></pre></td></tr></tbody></table></figure><p><strong>方法1</strong></p><p>递归</p><ul><li>每次递归把更小的元素复制到结果数组</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">merge(left=[<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>],right=[<span class="number">2</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">11</span>],a2=[]){</span><br><span class="line">    merge(left=[<span class="number">5</span>,<span class="number">6</span>],right=[<span class="number">2</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">11</span>],a2=[<span class="number">1</span>]){</span><br><span class="line">        merge(left=[<span class="number">5</span>,<span class="number">6</span>],right=[<span class="number">4</span>,<span class="number">10</span>,<span class="number">11</span>],a2=[<span class="number">1</span>,<span class="number">2</span>]){</span><br><span class="line">            merge(left=[<span class="number">5</span>,<span class="number">6</span>],right=[<span class="number">10</span>,<span class="number">11</span>],a2=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]){</span><br><span class="line">                merge(left=[<span class="number">6</span>],right=[<span class="number">10</span>,<span class="number">11</span>],a2=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>]){</span><br><span class="line">                    merge(left=[],right=[<span class="number">10</span>,<span class="number">11</span>],a2=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]){</span><br><span class="line"><span class="comment">// 拷贝10，11</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span> i, <span class="type">int</span> iEnd, <span class="type">int</span> j, <span class="type">int</span> jEnd,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span>[] a2, <span class="type">int</span> k)</span> {</span><br><span class="line">    <span class="keyword">if</span> (i &gt; iEnd) {</span><br><span class="line">        System.arraycopy(a1, j, a2, k, jEnd - j + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (j &gt; jEnd) {</span><br><span class="line">        System.arraycopy(a1, i, a2, k, iEnd - i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (a1[i] &lt; a1[j]) {</span><br><span class="line">        a2[k] = a1[i];</span><br><span class="line">        merge(a1, i + <span class="number">1</span>, iEnd, j, jEnd, a2, k + <span class="number">1</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        a2[k] = a1[j];</span><br><span class="line">        merge(a1, i, iEnd, j + <span class="number">1</span>, jEnd, a2, k + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a1 = {<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">11</span>};</span><br><span class="line"><span class="type">int</span>[] a2 = <span class="keyword">new</span> <span class="title class_">int</span>[a1.length];</span><br><span class="line">merge(a1, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, a2, <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure><p><strong>方法2</strong></p><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span> i, <span class="type">int</span> iEnd,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> j, <span class="type">int</span> jEnd,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span>[] a2)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= iEnd &amp;&amp; j &lt;= jEnd) {</span><br><span class="line">        <span class="keyword">if</span> (a1[i] &lt; a1[j]) {</span><br><span class="line">            a2[k] = a1[i];</span><br><span class="line">            i++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            a2[k] = a1[j];</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        k++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (i &gt; iEnd) {</span><br><span class="line">        System.arraycopy(a1, j, a2, k, jEnd - j + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (j &gt; jEnd) {</span><br><span class="line">        System.arraycopy(a1, i, a2, k, iEnd - i + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a1 = {<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">11</span>};</span><br><span class="line"><span class="type">int</span>[] a2 = <span class="keyword">new</span> <span class="title class_">int</span>[a3.length];</span><br><span class="line">merge(a1, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, a2);</span><br></pre></td></tr></tbody></table></figure><h2 id="链表">2.2 链表</h2><h3 id="概述-1">1) 概述</h3><p><strong>定义</strong></p><p>在计算机科学中，链表是数据元素的线性集合，其每个元素都指向下一个元素，元素存储上并不连续</p><blockquote><p>In computer science, a <strong>linked list</strong> is a linearcollection of data elements whose order is not given by their physicalplacement in memory. Instead, each element points to the next.</p></blockquote><p>可以分类为<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p><ul><li>单向链表，每个元素只知道其下一个元素是谁</li></ul><figure><img src="../../../../images/StrJava/image-20221110083407176.png" alt="image-20221110083407176"><figcaption aria-hidden="true">image-20221110083407176</figcaption></figure><ul><li>双向链表，每个元素知道其上一个元素和下一个元素</li></ul><figure><img src="../../../../images/StrJava/image-20221110083427372.png" alt="image-20221110083427372"><figcaption aria-hidden="true">image-20221110083427372</figcaption></figure><ul><li>循环链表，通常的链表尾节点 tail 指向的都是 null，而循环链表的 tail指向的是头节点 head</li></ul><figure><img src="../../../../images/StrJava/image-20221110083538273.png" alt="image-20221110083538273"><figcaption aria-hidden="true">image-20221110083538273</figcaption></figure><p>链表内还有一种特殊的节点称为哨兵（Sentinel）节点，也叫做哑元（Dummy）节点，它不存储数据，通常用作头尾，用来简化边界判断，如下图所示</p><figure><img src="../../../../images/StrJava/image-20221110084611550.png" alt="image-20221110084611550"><figcaption aria-hidden="true">image-20221110084611550</figcaption></figure><p><strong>随机访问性能</strong></p><p>根据 index 查找，时间复杂度 <span class="math inline">\(O(n)\)</span></p><p><strong>插入或删除性能</strong></p><ul><li>起始位置：<span class="math inline">\(O(1)\)</span></li><li>结束位置：如果已知 tail 尾节点是 <span class="math inline">\(O(1)\)</span>，不知道 tail 尾节点是 <span class="math inline">\(O(n)\)</span></li><li>中间位置：根据 index 查找时间 + <span class="math inline">\(O(1)\)</span></li></ul><h3 id="单向链表">2) 单向链表</h3><p>根据单向链表的定义，首先定义一个存储 value 和 next 指针的类Node，和一个描述头部节点的引用</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node head; <span class="comment">// 头部节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> { <span class="comment">// 节点类</span></span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value, Node next)</span> {</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Node定义为内部类，是为了对外<strong>隐藏</strong>实现细节，没必要让类的使用者关心Node 结构</li><li>定义为 static 内部类，是因为 Node <strong>不需要</strong>与SinglyLinkedList 实例相关，多个 SinglyLinkedList实例能共用 Node类定义</li></ul><p><strong>头部添加</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line"><span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="built_in">this</span>.head);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 this.head == null，新增节点指向 null，并作为新的 this.head</li><li>如果 this.head != null，新增节点指向原来的 this.head，并作为新的this.head<ul><li>注意赋值操作执行顺序是从右到左</li></ul></li></ul><p><strong>while 遍历</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 做一些事</span></span><br><span class="line">            curr = curr.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>for 遍历</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="built_in">this</span>.head; curr != <span class="literal">null</span>; curr = curr.next) {</span><br><span class="line">            <span class="comment">// 做一些事</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>以上两种遍历都可以把<strong>要做的事</strong>以 Consumer函数的方式传递进来<ul><li>Consumer的规则是<strong>一个参数</strong>，<strong>无返回值</strong>，因此像System.out::println 方法等都是 Consumer</li><li>调用 Consumer 时，将当前节点 curr.value 作为参数传递给它</li></ul></li></ul><p><strong>迭代器遍历</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">NodeIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;Integer&gt; {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> curr != <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> curr.value;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NodeIterator</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>hasNext 用来判断是否还有必要调用 next</li><li>next 做两件事<ul><li>返回当前节点的 value</li><li>指向下一个节点</li></ul></li><li>NodeIterator 要定义为<strong>非 static 内部类</strong>，是因为它与SinglyLinkedList 实例相关，是对某个 SinglyLinkedList 实例的迭代</li></ul><p><strong>递归遍历</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> {</span><br><span class="line">        recursion(<span class="built_in">this</span>.head);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recursion</span><span class="params">(Node curr)</span> {</span><br><span class="line">        <span class="keyword">if</span> (curr == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 前面做些事</span></span><br><span class="line">        recursion(curr.next);</span><br><span class="line">        <span class="comment">// 后面做些事</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>尾部添加</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findLast</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.head == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        Node curr;</span><br><span class="line">        <span class="keyword">for</span> (curr = <span class="built_in">this</span>.head; curr.next != <span class="literal">null</span>; ) {</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> findLast();</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>) {</span><br><span class="line">            addFirst(value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        last.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>注意，找最后一个节点，终止条件是 curr.next == null</li><li>分成两个方法是为了代码清晰，而且 findLast() 之后还能复用</li></ul><p><strong>尾部添加多个</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span>... rest)</span> {</span><br><span class="line">        </span><br><span class="line">        <span class="type">Node</span> <span class="variable">sublist</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(first, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> sublist;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : rest) {</span><br><span class="line">            curr.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>);</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> findLast();</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>) {</span><br><span class="line">            <span class="built_in">this</span>.head = sublist;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        last.next = sublist;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>先串成一串 sublist</li><li>再作为一个整体添加</li></ul><p><strong>根据索引获取</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">findNode</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="built_in">this</span>.head; curr != <span class="literal">null</span>; curr = curr.next, i++) {</span><br><span class="line">            <span class="keyword">if</span> (index == i) {</span><br><span class="line">                <span class="keyword">return</span> curr;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> IllegalArgumentException <span class="title function_">illegalIndex</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">"index [%d] 不合法%n"</span>, index));</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findNode(index);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>同样，分方法可以实现复用</li></ul><p><strong>插入</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) {</span><br><span class="line">            addFirst(value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>); <span class="comment">// 找到上一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>) { <span class="comment">// 找不到</span></span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        }</span><br><span class="line">        prev.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, prev.next);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>插入包括下面的删除，都必须找到上一个节点</li></ul><p><strong>删除</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.head != <span class="literal">null</span>) {</span><br><span class="line">                <span class="built_in">this</span>.head = <span class="built_in">this</span>.head.next;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>);</span><br><span class="line">        Node curr;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; (curr = prev.next) != <span class="literal">null</span>) {</span><br><span class="line">            prev.next = curr.next;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>第一个 if 块对应着 removeFirst 情况</li><li>最后一个 if 块对应着至少得两个节点的情况<ul><li>不仅仅判断上一个节点非空，还要保证当前节点非空</li></ul></li></ul><h3 id="单向链表带哨兵">3) 单向链表（带哨兵）</h3><p>观察之前单向链表的实现，发现每个方法内几乎都有判断是不是 head这样的代码，能不能简化呢？</p><p>用一个不参与数据存储的特殊 Node作为哨兵，它一般被称为哨兵或哑元，拥有哨兵节点的链表称为带头链表</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedListSentinel</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Integer.MIN_VALUE, <span class="literal">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>具体存什么值无所谓，因为不会用到它的值</li></ul><p>加入哨兵节点后，代码会变得比较简单，先看几个工具方法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedListSentinel</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据索引获取节点</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findNode</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="built_in">this</span>.head; curr != <span class="literal">null</span>; curr = curr.next, i++) {</span><br><span class="line">            <span class="keyword">if</span> (i == index) {</span><br><span class="line">                <span class="keyword">return</span> curr;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取最后一个节点</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findLast</span><span class="params">()</span> {</span><br><span class="line">        Node curr;</span><br><span class="line">        <span class="keyword">for</span> (curr = <span class="built_in">this</span>.head; curr.next != <span class="literal">null</span>; ) {</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>findNode 与之前类似，只是 i 初始值设置为 -1 对应哨兵，实际传入的index 也是 <span class="math inline">\([-1, \infty)\)</span></li><li>findLast 绝不会返回 null了，就算没有其它节点，也会返回哨兵作为最后一个节点</li></ul><p>这样，代码简化为</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedListSentinel</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> findLast();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        改动前</span></span><br><span class="line"><span class="comment">        if (last == null) {</span></span><br><span class="line"><span class="comment">            this.head = new Node(value, null);</span></span><br><span class="line"><span class="comment">            return;</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        last.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        改动前</span></span><br><span class="line"><span class="comment">        if (index == 0) {</span></span><br><span class="line"><span class="comment">            this.head = new Node(value, this.head);</span></span><br><span class="line"><span class="comment">            return;</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// index 传入 0 时，返回的是哨兵</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span>) {</span><br><span class="line">            prev.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, prev.next);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        改动前</span></span><br><span class="line"><span class="comment">        if (index == 0) {</span></span><br><span class="line"><span class="comment">            if (this.head != null) {</span></span><br><span class="line"><span class="comment">                this.head = this.head.next;</span></span><br><span class="line"><span class="comment">                return;</span></span><br><span class="line"><span class="comment">            } else {</span></span><br><span class="line"><span class="comment">                throw illegalIndex(index);</span></span><br><span class="line"><span class="comment">            }</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// index 传入 0 时，返回的是哨兵</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>);</span><br><span class="line">        Node curr;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; (curr = prev.next) != <span class="literal">null</span>) {</span><br><span class="line">            prev.next = curr.next;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        改动前</span></span><br><span class="line"><span class="comment">        this.head = new Node(value, this.head);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="built_in">this</span>.head.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="built_in">this</span>.head.next);</span><br><span class="line">        <span class="comment">// 也可以视为 insert 的特例, 即 insert(0, value);</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>对于删除，前面说了【最后一个 if块对应着至少得两个节点的情况】，现在有了哨兵，就凑足了两个节点</li></ul><h3 id="双向链表带哨兵">4) 双向链表（带哨兵）</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoublyLinkedListSentinel</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoublyLinkedListSentinel</span><span class="params">()</span> {</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="number">666</span>, <span class="literal">null</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="number">888</span>, <span class="literal">null</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findNode</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head; p != tail; p = p.next, i++) {</span><br><span class="line">            <span class="keyword">if</span> (i == index) {</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">        insert(<span class="number">0</span>, value);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeFirst</span><span class="params">()</span> {</span><br><span class="line">        remove(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">added</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(prev, value, tail);</span><br><span class="line">        prev.next = added;</span><br><span class="line">        tail.prev = added;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeLast</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">removed</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        <span class="keyword">if</span> (removed == head) {</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> removed.prev;</span><br><span class="line">        prev.next = tail;</span><br><span class="line">        tail.prev = prev;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> prev.next;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">inserted</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(prev, value, next);</span><br><span class="line">        prev.next = inserted;</span><br><span class="line">        next.prev = inserted;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">removed</span> <span class="operator">=</span> prev.next;</span><br><span class="line">        <span class="keyword">if</span> (removed == tail) {</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> removed.next;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IllegalArgumentException <span class="title function_">illegalIndex</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                String.format(<span class="string">"index [%d] 不合法%n"</span>, index));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;Integer&gt;() {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head.next;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> p != tail;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> p.value;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">        Node prev;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Node prev, <span class="type">int</span> value, Node next)</span> {</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="环形链表带哨兵">5) 环形链表（带哨兵）</h3><p>双向环形链表带哨兵，这时哨兵<strong>既作为头，也作为尾</strong></p><figure><img src="../../../../images/StrJava/image-20221229144232651.png" alt="image-20221229144232651"><figcaption aria-hidden="true">image-20221229144232651</figcaption></figure><figure><img src="../../../../images/StrJava/image-20221229143756065.png" alt="image-20221229143756065"><figcaption aria-hidden="true">image-20221229143756065</figcaption></figure><figure><img src="../../../../images/StrJava/image-20221229153338425.png" alt="image-20221229153338425"><figcaption aria-hidden="true">image-20221229153338425</figcaption></figure><figure><img src="../../../../images/StrJava/image-20221229154248800.png" alt="image-20221229154248800"><figcaption aria-hidden="true">image-20221229154248800</figcaption></figure><p>参考实现</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoublyLinkedListSentinel</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;&gt;() {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> sentinel.next;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> p != sentinel;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> p.value;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">        Node prev;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Node prev, <span class="type">int</span> value, Node next)</span> {</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">sentinel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, -<span class="number">1</span>, <span class="literal">null</span>); <span class="comment">// 哨兵</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoublyLinkedListSentinel</span><span class="params">()</span> {</span><br><span class="line">        sentinel.next = sentinel;</span><br><span class="line">        sentinel.prev = sentinel;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加到第一个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 待添加值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> sentinel.next;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> sentinel;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">added</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(prev, value, next);</span><br><span class="line">        prev.next = added;</span><br><span class="line">        next.prev = added;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加到最后一个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 待添加值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> sentinel.prev;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> sentinel;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">added</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(prev, value, next);</span><br><span class="line">        prev.next = added;</span><br><span class="line">        next.prev = added;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除第一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeFirst</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">removed</span> <span class="operator">=</span> sentinel.next;</span><br><span class="line">        <span class="keyword">if</span> (removed == sentinel) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"非法"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">a</span> <span class="operator">=</span> sentinel;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">b</span> <span class="operator">=</span> removed.next;</span><br><span class="line">        a.next = b;</span><br><span class="line">        b.prev = a;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除最后一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeLast</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">removed</span> <span class="operator">=</span> sentinel.prev;</span><br><span class="line">        <span class="keyword">if</span> (removed == sentinel) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"非法"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">a</span> <span class="operator">=</span> removed.prev;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">b</span> <span class="operator">=</span> sentinel;</span><br><span class="line">        a.next = b;</span><br><span class="line">        b.prev = a;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据值删除节点</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;假定 value 在链表中作为 key, 有唯一性&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 待删除值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeByValue</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">removed</span> <span class="operator">=</span> findNodeByValue(value);</span><br><span class="line">        <span class="keyword">if</span> (removed != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> removed.prev;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> removed.next;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findNodeByValue</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> sentinel.next;</span><br><span class="line">        <span class="keyword">while</span> (p != sentinel) {</span><br><span class="line">            <span class="keyword">if</span> (p.value == value) {</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            }</span><br><span class="line">            p = p.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="习题-2">习题</h3><h4 id="e01.-反转单向链表-leetcode-206">E01. 反转单向链表-Leetcode206</h4><p>对应力扣题目 <a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表 -力扣（LeetCode）</a></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br><span class="line"></span><br><span class="line">输入：[1,2]</span><br><span class="line">输出：[2,1]</span><br><span class="line"></span><br><span class="line">输入：[]</span><br><span class="line">输出：[]</span><br></pre></td></tr></tbody></table></figure><p><strong>方法1</strong></p><p>构造一个新链表，从<strong>旧链表</strong>依次拿到每个节点，创建新节点添加至<strong>新链表</strong>头部，完成后新链表即是倒序的</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode o1)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> o1;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">        n1 = <span class="keyword">new</span> <span class="title class_">ListNode</span>(p.val, n1);</span><br><span class="line">        p = p.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> n1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>评价：简单直白，就是得新创建节点对象</p><p><strong>方法2</strong></p><p>与方法1类似，构造一个新链表，从<strong>旧链表头部</strong>移除节点，添加到<strong>新链表头部</strong>，完成后新链表即是倒序的，区别在于原题目未提供节点外层的容器类，这里提供一个，另外一个区别是并不去构造新节点</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">List</span> {</span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">List</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="built_in">this</span>.head = head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeFirst</span><span class="params">()</span>{</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="literal">null</span>) {</span><br><span class="line">            head = first.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(ListNode first)</span> {</span><br><span class="line">        first.next = head;</span><br><span class="line">        head = first;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> {</span><br><span class="line">    <span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">List</span>(head);</span><br><span class="line">    <span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">List</span>(<span class="literal">null</span>);</span><br><span class="line">    ListNode first;</span><br><span class="line">    <span class="keyword">while</span> ((first = list1.removeFirst()) != <span class="literal">null</span>) {</span><br><span class="line">        list2.addFirst(first);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> list2.head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>评价：更加面向对象，如果实际写代码而非刷题，更多会这么做</p><p><strong>方法3</strong></p><p>递归，在<strong>归</strong>时让 <span class="math inline">\(5\rightarrow 4\)</span>，<span class="math inline">\(4 \rightarrow3\)</span> ...</p><p>首先，写一个递归方法，返回值用来拿到最后一个节点</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode p)</span> {</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> || p.next == <span class="literal">null</span>) { <span class="comment">// 不足两个节点</span></span><br><span class="line">        <span class="keyword">return</span> p; <span class="comment">// 最后一个节点</span></span><br><span class="line">    }</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverseList(p.next);</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>注意1：递归终止条件是 curr.next ==null，目的是到最后一个节点就结束递归，与之前递归遍历不一样</li><li>注意2：需要考虑空链表即 p == null 的情况</li></ul><p>可以先测试一下</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">o5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">o4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>, o5);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">o3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>, o4);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>, o3);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>, o2);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E01Leetcode206</span>().reverseList(o1);</span><br><span class="line">System.out.println(n1);</span><br></pre></td></tr></tbody></table></figure><p>会打印</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[5]</span><br></pre></td></tr></tbody></table></figure><p>下面为<strong>伪码</strong>调用过程，假设节点分别是 <span class="math inline">\(1 \rightarrow 2 \rightarrow 3 \rightarrow 4\rightarrow 5 \rightarrow null\)</span>，先忽略返回值</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">reverseList(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>) {</span><br><span class="line">    reverseList(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">2</span>) {</span><br><span class="line">    reverseList(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">3</span>) {</span><br><span class="line">    reverseList(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">4</span>) {</span><br><span class="line">    reverseList(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">5</span>) {</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> || p.next == <span class="literal">null</span>) {</span><br><span class="line">                        <span class="keyword">return</span> p; <span class="comment">// 返回5</span></span><br><span class="line">                    }</span><br><span class="line">}</span><br><span class="line">                <span class="comment">// 此时p是4, p.next是5</span></span><br><span class="line">}</span><br><span class="line">            <span class="comment">// 此时p是3, p.next是4</span></span><br><span class="line">}</span><br><span class="line">        <span class="comment">// 此时p是2, p.next是3</span></span><br><span class="line">}</span><br><span class="line">    <span class="comment">// 此时p是1, p.next是2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来，从 p = 4 开始，要让 <span class="math inline">\(5 \rightarrow4\)</span>，<span class="math inline">\(4 \rightarrow 3\)</span> ...</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">reverseList(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>) {</span><br><span class="line">    reverseList(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">2</span>) {</span><br><span class="line">    reverseList(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">3</span>) {</span><br><span class="line">    reverseList(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">4</span>) {</span><br><span class="line">    reverseList(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">5</span>) {</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> || p.next == <span class="literal">null</span>) {</span><br><span class="line">                        <span class="keyword">return</span> p; <span class="comment">// 返回5</span></span><br><span class="line">                    }</span><br><span class="line">}</span><br><span class="line">                <span class="comment">// 此时p是4, p.next是5, 要让5指向4,代码写成 p.next.next=p</span></span><br><span class="line">                <span class="comment">// 还要注意4要指向 null, 否则就死链了</span></span><br><span class="line">}</span><br><span class="line">            <span class="comment">// 此时p是3, p.next是4</span></span><br><span class="line">}</span><br><span class="line">        <span class="comment">// 此时p是2, p.next是3</span></span><br><span class="line">}</span><br><span class="line">    <span class="comment">// 此时p是1, p.next是2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最终代码为：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode p)</span> {    </span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> || p.next == <span class="literal">null</span>) { <span class="comment">// 不足两个节点</span></span><br><span class="line">        <span class="keyword">return</span> p; <span class="comment">// 最后一个节点</span></span><br><span class="line">    }</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverseList(p.next);</span><br><span class="line">    p.next.next = p;</span><br><span class="line">    p.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Q：为啥不能在<strong>递</strong>的过程中倒序？</p><p>A：比如</p><ul><li>$ 1 $ 如果递的过程中让 <span class="math inline">\(2 \rightarrow1\)</span> 那么此时 <span class="math inline">\(2 \rightarrow 3\)</span>就被覆盖，不知道接下来递给谁</li><li>而归的时候让 <span class="math inline">\(3 \rightarrow 2\)</span>不会影响上一层的 <span class="math inline">\(1 \rightarrow2\)</span></li></ul><p>评价：单向链表没有 prev指针，但利用递归的特性【记住了】链表每次调用时相邻两个节点是谁</p><p><strong>方法4</strong></p><p>从链表每次拿到第二个节点，将其从链表断开，插入头部，直至它为 null结束</p><ol type="1"><li>设置指针o1(旧头)、n1(新头)、o2(旧老二)，分别指向第一，第一，第二节点</li></ol><p><span class="math inline">\(\frac{n1 \ o1}{1} \rightarrow\frac{o2}{2} \rightarrow 3 \rightarrow 4 \rightarrow 5 \rightarrownull\)</span></p><ol start="2" type="1"><li>将 o2 节点从链表断开，即 o1 节点指向第三节点</li></ol><p>$ null$ ，<span class="math inline">\(\frac{o2}{2}\)</span></p><ol start="3" type="1"><li>o2 节点链入链表头部，即</li></ol><p><span class="math inline">\(\frac{o2}{2} \rightarrow \frac{n1 \o1}{1} \rightarrow 3 \rightarrow 4 \rightarrow 5 \rightarrownull\)</span></p><ol start="4" type="1"><li>n1 指向 o2</li></ol><p><span class="math inline">\(\frac{n1 \ o2}{2} \rightarrow\frac{o1}{1} \rightarrow 3 \rightarrow 4 \rightarrow 5 \rightarrownull\)</span></p><ol start="5" type="1"><li>o2 指向 o1 的下一个节点，即</li></ol><p><span class="math inline">\(\frac{n1}{2} \rightarrow \frac{o1}{1}\rightarrow \frac{o2}{3} \rightarrow 4 \rightarrow 5 \rightarrownull\)</span></p><ol start="6" type="1"><li><p>重复以上 <span class="math inline">\(2\sim5\)</span> 步，直到 o2指向 null</p></li><li><p>还应当考虑边界条件，即链表中不满两个元素时，无需走以上逻辑</p></li></ol><p>参考答案</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode o1)</span> {    </span><br><span class="line">    <span class="keyword">if</span> (o1 == <span class="literal">null</span> || o1.next == <span class="literal">null</span>) { <span class="comment">// 不足两个节点</span></span><br><span class="line">        <span class="keyword">return</span> o1;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">o2</span> <span class="operator">=</span> o1.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> o1;</span><br><span class="line">    <span class="keyword">while</span> (o2 != <span class="literal">null</span>) {</span><br><span class="line">        o1.next = o2.next; </span><br><span class="line">        o2.next = n1;</span><br><span class="line">        n1 = o2;</span><br><span class="line">        o2 = o1.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> n1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>方法5</strong></p><p>要点：把链表分成两部分，思路就是不断从链表2的头，往链表1的头搬移</p><ol type="1"><li>n1 指向 null，代表<strong>新链表</strong>一开始没有元素，o1指向<strong>原链表</strong>的首节点</li></ol><p><span class="math inline">\(\frac{n1}{null}\)</span>，<span class="math inline">\(\frac{o1}{1} \rightarrow 2 \rightarrow 3\rightarrow 4 \rightarrow 5 \rightarrow null\)</span></p><ol start="2" type="1"><li>开始循环，o2 指向<strong>原链表</strong>次节点</li></ol><p><span class="math inline">\(\frac{n1}{null}\)</span>，<span class="math inline">\(\frac{o1}{1} \rightarrow \frac{o2}{2} \rightarrow3 \rightarrow 4 \rightarrow 5 \rightarrow null\)</span></p><ol start="3" type="1"><li>搬移</li></ol><p><span class="math inline">\(\frac{o1}{1} \rightarrow\frac{n1}{null}\)</span> ， <span class="math inline">\(\frac{o2}{2}\rightarrow 3 \rightarrow 4 \rightarrow 5 \rightarrow null\)</span></p><ol start="4" type="1"><li>指针复位</li></ol><p><span class="math inline">\(\frac{n1}{1} \rightarrow null\)</span> ，<span class="math inline">\(\frac{o1 \ o2}{2} \rightarrow 3 \rightarrow4 \rightarrow 5 \rightarrow null\)</span></p><ol start="5" type="1"><li>重复 <span class="math inline">\(2\sim4\)</span> 步</li><li>当 o1 = null 时退出循环</li></ol><p><strong>参考答案</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode o1)</span> {</span><br><span class="line">    <span class="keyword">if</span> (o1 == <span class="literal">null</span> || o1.next == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> o1;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (o1 != <span class="literal">null</span>) {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">o2</span> <span class="operator">=</span> o1.next;</span><br><span class="line">        o1.next = n1;</span><br><span class="line">        n1 = o1;</span><br><span class="line">        o1 = o2;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> n1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>评价：本质上与方法2 相同，只是方法2更为面向对象</p><h4 id="e02.-根据值删除节点-leetcode-203">E02. 根据值删除节点-Leetcode203</h4><p>例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2,6,3,6], val = 6</span><br><span class="line">输出：[1,2,3]</span><br><span class="line"></span><br><span class="line">输入：head = [], val = 1</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">输入：head = [7,7,7,7], val = 7</span><br><span class="line">输出：[]</span><br></pre></td></tr></tbody></table></figure><p><strong>方法1</strong></p><p>图中 s 代表 sentinel哨兵（如果不加哨兵，则删除第一个节点要特殊处理），例如要删除 6</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">p1   p2</span><br><span class="line">s -&gt; 1 -&gt; 2 -&gt; 6 -&gt; 3 -&gt; 6 -&gt; null</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 p2 不等于目标，则 p1，p2 不断后移</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"> p1   p2</span><br><span class="line">s -&gt; 1 -&gt; 2 -&gt; 6 -&gt; 3 -&gt; 6 -&gt; null</span><br><span class="line"></span><br><span class="line">   p1   p2</span><br><span class="line">s -&gt; 1 -&gt; 2 -&gt; 6 -&gt; 3 -&gt; 6 -&gt; null</span><br></pre></td></tr></tbody></table></figure><ul><li>p2 == 6，删除它，注意 p1 此时保持不变，p2 后移</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">   p1   p2</span><br><span class="line">s -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 6 -&gt; null</span><br></pre></td></tr></tbody></table></figure><ul><li>p2 不等于目标，则 p1，p2 不断后移</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">      p1   p2</span><br><span class="line">s -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 6 -&gt; null</span><br></pre></td></tr></tbody></table></figure><ul><li>p2 == 6，删除它，注意 p1 此时保持不变，p2 后移</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">      p1   p2</span><br><span class="line">s -&gt; 1 -&gt; 2 -&gt; 3 -&gt; null</span><br></pre></td></tr></tbody></table></figure><ul><li>p2 == null 退出循环</li></ul><p>最后代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">sentinel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> sentinel;</span><br><span class="line">    ListNode p2;</span><br><span class="line">    <span class="keyword">while</span> ((p2 = p1.next) != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (p2.val == val) {</span><br><span class="line">            p1.next = p2.next;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sentinel.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>方法2</strong></p><p>思路，递归函数负责返回：从当前节点（我）开始，完成删除的子链表</p><ol type="1"><li>若我与 v 相等，应该返回下一个节点递归结果</li><li>若我与 v 不等，应该返回我，但我的 next应该更新（让我能带上后续删过的子链表）</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">removeElements(ListNode p=<span class="number">1</span>, <span class="type">int</span> v=<span class="number">6</span>){</span><br><span class="line">    <span class="number">1.</span>next=removeElements(ListNode p=<span class="number">2</span>, <span class="type">int</span> v=<span class="number">6</span>){</span><br><span class="line">    <span class="number">2.</span>next=removeElements(ListNode p=<span class="number">6</span>, <span class="type">int</span> v=<span class="number">6</span>){</span><br><span class="line">    removeElements(ListNode p=<span class="number">3</span>, <span class="type">int</span> v=<span class="number">6</span>){</span><br><span class="line">    <span class="number">3.</span>next=removeElements(ListNode p=<span class="number">6</span>, <span class="type">int</span> v=<span class="number">6</span>){</span><br><span class="line">    removeElements(ListNode p=<span class="literal">null</span>, <span class="type">int</span> v=<span class="number">6</span>){</span><br><span class="line">    <span class="comment">// 没有节点,返回</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">                <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> {</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (head.val == val) {</span><br><span class="line">        <span class="keyword">return</span> removeElements(head.next, val);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        head.next = removeElements(head.next, val);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e03.-删除倒数节点-leetcode-19">E03. 删除倒数节点-Leetcode19</h4><p>例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br><span class="line"></span><br><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></tbody></table></figure><p>另外题目提示</p><ul><li>链表至少一个节点</li><li>n 只会在合理范围</li></ul><p><strong>方法1</strong></p><p>思路，写一个递归函数，用来返回下一个节点的倒数序号</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">recursion(ListNode p=<span class="number">1</span>, <span class="type">int</span> n=<span class="number">2</span>) {</span><br><span class="line">    recursion(ListNode p=<span class="number">2</span>, <span class="type">int</span> n=<span class="number">2</span>) {</span><br><span class="line">    recursion(ListNode p=<span class="number">3</span>, <span class="type">int</span> n=<span class="number">2</span>) {</span><br><span class="line">    recursion(ListNode p=<span class="number">4</span>, <span class="type">int</span> n=<span class="number">2</span>) {</span><br><span class="line">    recursion(ListNode p=<span class="number">5</span>, <span class="type">int</span> n=<span class="number">2</span>) {</span><br><span class="line">    recursion(ListNode p=<span class="literal">null</span>, <span class="type">int</span> n=<span class="number">2</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 最内层序号0</span></span><br><span class="line">}</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 上一次返回值+1</span></span><br><span class="line">}</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line">            <span class="keyword">if</span>(返回值 == n == <span class="number">2</span>) {</span><br><span class="line">                <span class="comment">// 删除 next</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">}</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">}</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但上述代码有一个问题，就是若删除的是第一个节点，它没有上一个节点，因此可以加一个哨兵来解决</p><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">sentinel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">    recursion(sentinel, n);</span><br><span class="line">    <span class="keyword">return</span> sentinel.next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">recursion</span><span class="params">(ListNode p, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">nth</span> <span class="operator">=</span> recursion(p.next, n);</span><br><span class="line">    <span class="keyword">if</span> (nth == n) {</span><br><span class="line">        p.next = p.next.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> nth + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Q：p.next.next 不怕空指针吗？</p><p>A：</p><ul><li>p 是待删除节点的上一个节点，如果能递归回到 p，那么 p.next肯定有值，不会是 null</li><li>且题目说明了 n &gt;=1，不会因为 nth == 0 而让 p.next 指向最后的null</li></ul><p><strong>方法2</strong></p><p>快慢指针，p1 指向待删节点的上一个，p2 先走 n + 1 步</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">i=<span class="number">0</span></span><br><span class="line">p2</span><br><span class="line">s -&gt; <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">     i=<span class="number">1</span></span><br><span class="line">     p2</span><br><span class="line">s -&gt; <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">          i=<span class="number">2</span></span><br><span class="line">          p2</span><br><span class="line">s -&gt; <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">               i=<span class="number">3</span> 从此开始 p1 p2 依次向右平移, 直到 p2 移动到末尾</span><br><span class="line">p1             p2</span><br><span class="line">s -&gt; <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">               p1             p2</span><br><span class="line">s -&gt; <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="literal">null</span></span><br></pre></td></tr></tbody></table></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> s;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) {</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="literal">null</span>) {</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    }</span><br><span class="line">    p1.next = p1.next.next;</span><br><span class="line">    <span class="keyword">return</span> s.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>方法3</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="type">Composite</span> <span class="variable">c</span> <span class="operator">=</span> recursion(head, n);</span><br><span class="line">    <span class="keyword">return</span> c.node;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Composite</span> {</span><br><span class="line">    ListNode node;</span><br><span class="line">    <span class="type">int</span> nth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Composite</span><span class="params">(ListNode node, <span class="type">int</span> nth)</span> {</span><br><span class="line">        <span class="built_in">this</span>.node = node;</span><br><span class="line">        <span class="built_in">this</span>.nth = nth;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Composite <span class="title function_">recursion</span><span class="params">(ListNode p, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="literal">null</span>, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">Composite</span> <span class="variable">c</span> <span class="operator">=</span> recursion(p.next, n);</span><br><span class="line">    <span class="keyword">if</span> (c.nth != n) {</span><br><span class="line">        p.next = c.node;</span><br><span class="line">        c.node = p;</span><br><span class="line">    }</span><br><span class="line">    c.nth +=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e04.-有序链表去重-leetcode-83">E04. 有序链表去重-Leetcode83</h4><p>例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,1,2]</span><br><span class="line">输出：[1,2]</span><br><span class="line"></span><br><span class="line">输入：head = [1,1,2,3,3]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></tbody></table></figure><p>注意：<strong>重复元素保留一个</strong></p><p><strong>方法1</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">p1   p2</span><br><span class="line">1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 3 -&gt; null</span><br></pre></td></tr></tbody></table></figure><ul><li>p1.val == p2.val 那么删除 p2，注意 p1 此时保持不变</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">p1   p2</span><br><span class="line">1 -&gt; 2 -&gt; 3 -&gt; 3 -&gt; null</span><br></pre></td></tr></tbody></table></figure><ul><li>p1.val != p2.val 那么 p1，p2 向后移动</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">     p1   p2</span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">3</span> -&gt; <span class="literal">null</span></span><br><span class="line">         </span><br><span class="line">          p1   p2</span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">3</span> -&gt; <span class="literal">null</span>     </span><br></pre></td></tr></tbody></table></figure><ul><li>p1.val == p2.val 那么删除 p2</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">          p1   p2</span><br><span class="line">1 -&gt; 2 -&gt; 3 -&gt; null   </span><br></pre></td></tr></tbody></table></figure><ul><li>当 p2 == null 退出循环</li></ul><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> {</span><br><span class="line">    <span class="comment">// 链表节点 &lt; 2</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 链表节点 &gt;= 2</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head;</span><br><span class="line">    ListNode p2;</span><br><span class="line">    <span class="keyword">while</span> ((p2 = p1.next) != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (p1.val == p2.val) {</span><br><span class="line">            p1.next = p2.next;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>方法2</strong></p><p>递归函数负责返回：从当前节点（我）开始，完成去重的链表</p><ol type="1"><li>若我与 next 重复，返回 next</li><li>若我与 next 不重复，返回我，但 next 应当更新</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">deleteDuplicates(ListNode p=<span class="number">1</span>) {</span><br><span class="line">    deleteDuplicates(ListNode p=<span class="number">1</span>) {</span><br><span class="line">        <span class="number">1.</span>next=deleteDuplicates(ListNode p=<span class="number">2</span>) {</span><br><span class="line">            <span class="number">2.</span>next=deleteDuplicates(ListNode p=<span class="number">3</span>) {</span><br><span class="line">                deleteDuplicates(ListNode p=<span class="number">3</span>) {</span><br><span class="line"><span class="comment">// 只剩一个节点，返回</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">                }                </span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode p)</span> {</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> || p.next == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(p.val == p.next.val) {</span><br><span class="line">        <span class="keyword">return</span> deleteDuplicates(p.next);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        p.next = deleteDuplicates(p.next);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e05.-有序链表去重-leetcode-82">E05. 有序链表去重-Leetcode82</h4><p>例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,3,4,4,5]</span><br><span class="line">输出：[1,2,5]</span><br><span class="line"></span><br><span class="line">输入：head = [1,1,1,2,3]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></tbody></table></figure><p>注意：<strong>重复元素一个不留</strong></p><p><strong>方法1</strong></p><p>递归函数负责返回：从当前节点（我）开始，完成去重的链表</p><ol type="1"><li>若我与 next重复，一直找到下一个不重复的节点，以它的返回结果为准</li><li>若我与 next 不重复，返回我，同时更新 next</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">deleteDuplicates(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>) {</span><br><span class="line">    <span class="comment">// 找下个不重复的</span></span><br><span class="line">deleteDuplicates(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>) {</span><br><span class="line">        deleteDuplicates(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>) {</span><br><span class="line">deleteDuplicates(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">2</span>) {</span><br><span class="line">                <span class="number">2.</span>next=deleteDuplicates(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">3</span>) {</span><br><span class="line"><span class="comment">// 只剩一个节点，返回</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">}</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode p)</span> {</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> || p.next == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (p.val == p.next.val) {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">x</span> <span class="operator">=</span> p.next.next;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="literal">null</span> &amp;&amp; x.val == p.val) {</span><br><span class="line">            x = x.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> deleteDuplicates(x);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        p.next = deleteDuplicates(p.next);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>方法2</strong></p><p>p1 是待删除的上一个节点，每次循环对比 p2、p3 的值</p><ul><li>如果 p2 与 p3 的值重复，那么 p3 继续后移，直到找到与 p2不重复的节点，p1 指向 p3 完成删除</li><li>如果 p2 与 p3 的值不重复，p1，p2，p3向后平移一位，继续上面的操作</li><li>p2 或 p3 为 null 退出循环<ul><li>p2 为 null 的情况，比如链表为 1 1 1 null</li></ul></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">p1 p2 p3</span><br><span class="line">s, 1, 1, 1, 2, 3, null</span><br><span class="line"></span><br><span class="line">p1 p2    p3</span><br><span class="line">s, 1, 1, 1, 2, 3, null</span><br><span class="line"></span><br><span class="line">p1 p2       p3</span><br><span class="line">s, 1, 1, 1, 2, 3, null</span><br><span class="line"></span><br><span class="line">p1 p3</span><br><span class="line">s, 2, 3, null</span><br><span class="line"></span><br><span class="line">p1 p2 p3</span><br><span class="line">s, 2, 3, null</span><br><span class="line"></span><br><span class="line">   p1 p2 p3</span><br><span class="line">s, 2, 3, null</span><br></pre></td></tr></tbody></table></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> {</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> s;</span><br><span class="line">    ListNode p2;</span><br><span class="line">    ListNode p3;</span><br><span class="line">    <span class="keyword">while</span> ((p2 = p1.next) != <span class="literal">null</span> &amp;&amp; (p3 = p2.next) != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (p2.val == p3.val) {</span><br><span class="line">            <span class="keyword">while</span> ((p3 = p3.next) != <span class="literal">null</span> </span><br><span class="line">                   &amp;&amp; p3.val == p2.val) {</span><br><span class="line">            }</span><br><span class="line">            p1.next = p3;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e06.-合并有序链表-leetcode-21">E06. 合并有序链表-Leetcode21</h4><p>例</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br><span class="line">    </span><br><span class="line">输入：l1 = [], l2 = []</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">输入：l1 = [], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></tbody></table></figure><p><strong>方法1</strong></p><ul><li>谁小，把谁链给 p，p 和小的都向后平移一位</li><li>当 p1、p2 有一个为 null，退出循环，把不为 null 的链给 p</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">p1</span><br><span class="line">1389null</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">24null</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">snull</span><br></pre></td></tr></tbody></table></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode p1, ListNode p2)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> s;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (p1.val &lt; p2.val) {</span><br><span class="line">            p.next = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            p.next = p2;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        }</span><br><span class="line">        p = p.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (p1 != <span class="literal">null</span>) {</span><br><span class="line">        p.next = p1;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (p2 != <span class="literal">null</span>) {</span><br><span class="line">        p.next = p2;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>可以自行验证<strong>例</strong>中后两种情况</li></ul><p><strong>方法2</strong></p><p>递归函数应该返回</p><ul><li>更小的那个链表节点，并把它剩余节点与另一个链表再次递归</li><li>返回之前，更新此节点的 next</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">mergeTwoLists(p1=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>], p2=[<span class="number">2</span>,<span class="number">4</span>]) {</span><br><span class="line">    <span class="number">1.</span>next=mergeTwoLists(p1=[<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>], p2=[<span class="number">2</span>,<span class="number">4</span>]) {</span><br><span class="line">        <span class="number">2.</span>next=mergeTwoLists(p1=[<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>], p2=[<span class="number">4</span>]) {            </span><br><span class="line">            <span class="number">3.</span>next=mergeTwoLists(p1=[<span class="number">8</span>,<span class="number">9</span>], p2=[<span class="number">4</span>]) {</span><br><span class="line">                <span class="number">4.</span>next=mergeTwoLists(p1=[<span class="number">8</span>,<span class="number">9</span>], p2=<span class="literal">null</span>) {</span><br><span class="line">                    <span class="keyword">return</span> [<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    }</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e07.-合并多个有序链表-leetcode-23">E07.合并多个有序链表-Leetcode 23</h4><p>例</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></tbody></table></figure><p><strong>方法1</strong></p><p>递归</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> {</span><br><span class="line">    <span class="keyword">if</span> (lists.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> split(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">split</span><span class="params">(ListNode[] lists, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">    System.out.println(i + <span class="string">" "</span> + j);</span><br><span class="line">    <span class="keyword">if</span> (j == i) {</span><br><span class="line">        <span class="keyword">return</span> lists[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(</span><br><span class="line">        split(lists, i, m),</span><br><span class="line">        split(lists, m + <span class="number">1</span>, j)</span><br><span class="line">    );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>还可以用优先级队列求解，这个放在后面讲</p><h4 id="e08.-查找链表中间节点-leetcode-876">E08.查找链表中间节点-Leetcode 876</h4><p>例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5]</span><br><span class="line">输出：此列表中的结点 3 (序列化形式：[3,4,5])</span><br><span class="line"></span><br><span class="line">输入：[1,2,3,4,5,6]</span><br><span class="line">输出：此列表中的结点 4 (序列化形式：[4,5,6])</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>偶数</strong>节点时，中间点是靠右的那个</li></ul><p>解法：快慢指针，快指针一次走两步，慢指针一次走一步，当快指针到链表结尾时，慢指针恰好走到链表的一半</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head;<span class="comment">// 慢指针，中间点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> head;<span class="comment">// 快指针</span></span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="literal">null</span> &amp;&amp; p2.next != <span class="literal">null</span>) {</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e09.-回文链表-leetcode-234">E09. 回文链表-Leetcode 234</h4><p>所谓回文指正着读、反着读，结果一样，例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[1,2,2,1]</span><br><span class="line">[1,2,3,2,1]</span><br></pre></td></tr></tbody></table></figure><p>它们都是回文链表，不是回文的例子</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[1,2,3,1]  --反过来--&gt;  [1,3,2,1]</span><br></pre></td></tr></tbody></table></figure><p>解法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    步骤1. 找中间点</span></span><br><span class="line"><span class="comment">    步骤2. 中间点后半个链表反转</span></span><br><span class="line"><span class="comment">    步骤3. 反转后链表与原链表逐一比较</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">middle</span> <span class="operator">=</span> middle(head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverse(middle);</span><br><span class="line">    <span class="keyword">while</span> (newHead != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (newHead.val != head.val) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        newHead = newHead.next;</span><br><span class="line">        head = head.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode o1)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (o1 != <span class="literal">null</span>) {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">o2</span> <span class="operator">=</span> o1.next;</span><br><span class="line">        o1.next = n1;</span><br><span class="line">        n1 = o1;</span><br><span class="line">        o1 = o2;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> n1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">middle</span><span class="params">(ListNode head)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head; <span class="comment">// 慢</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> head; <span class="comment">// 快</span></span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="literal">null</span> &amp;&amp; p2.next != <span class="literal">null</span>) {</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>优化后解法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode h1)</span> {</span><br><span class="line">    <span class="keyword">if</span> (h1 == <span class="literal">null</span> || h1.next == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> h1; <span class="comment">// 慢指针，中间点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> h1; <span class="comment">// 快指针</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">// 新头</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">o1</span> <span class="operator">=</span> h1;<span class="comment">// 旧头</span></span><br><span class="line">    <span class="comment">// 快慢指针找中间点</span></span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="literal">null</span> &amp;&amp; p2.next != <span class="literal">null</span>) {</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反转前半部分</span></span><br><span class="line">        o1.next = n1;</span><br><span class="line">        n1 = o1;</span><br><span class="line">        o1 = p1;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (p2 != <span class="literal">null</span>) { <span class="comment">// 节点数为奇数</span></span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 同步比较新头和后半部分</span></span><br><span class="line">    <span class="keyword">while</span> (n1 != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (n1.val != p1.val) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e10.-环形链表-leetcode-141">E10. 环形链表-Leetcode 141</h4><p>本题以及下题，实际是 Floyd's Tortoise and Hare Algorithm （Floyd龟兔赛跑算法）<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a></p><blockquote><p>除了 Floyd 判环算法外，还有其它的判环算法，详见https://en.wikipedia.org/wiki/Cycle_detection</p></blockquote><p><img src="../../../../images/StrJava/image-20221229190646563.png" alt="image-20221229190646563" style="zoom: 50%;"></p><p>如果链表上存在环，那么在环上以不同速度前进的两个指针必定会在某个时刻相遇。算法分为两个阶段</p><p>阶段1</p><ul><li>龟一次走一步，兔子一次走两步</li><li>当兔子能走到终点时，不存在环</li><li>当兔子能追上龟时，可以判断存在环</li></ul><p>阶段2</p><ul><li>从它们第一次相遇开始，龟回到起点，兔子保持原位不变</li><li>龟和兔子一次都走一步</li><li>当再次相遇时，地点就是环的入口</li></ul><p>为什么呢？</p><ul><li>设起点到入口走 a 步（本例是 7），绕环一圈长度为 b（本例是 5），</li><li>那么<strong>从起点开始，走 a + 绕环 n圈，都能找到环入口</strong></li><li>第一次相遇时<ul><li>兔走了 a + 绕环 n 圈（本例 2 圈） + k，k是它们相遇距环入口位置（本例 3，不重要）</li><li>龟走了 a + 绕环 n 圈（本例 0 圈） + k，当然它绕的圈数比兔少</li><li>兔走的距离是龟的两倍，所以<strong>龟走的</strong> = 兔走的 - 龟走的= <strong>绕环 n 圈</strong></li></ul></li><li>而前面分析过，如果走 a + 绕环 n圈，都能找到环入口，因此从相遇点开始，再走 a 步，就是环入口</li></ul><p>阶段1 参考代码（判断是否有环）</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// 兔</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> head; <span class="comment">// 龟</span></span><br><span class="line">    <span class="keyword">while</span> (h != <span class="literal">null</span> &amp;&amp; h.next != <span class="literal">null</span>) {</span><br><span class="line">        t = t.next;</span><br><span class="line">        h = h.next.next;</span><br><span class="line">        <span class="keyword">if</span>(h == t){</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e11.-环形链表-leetcode-142">E11. 环形链表-Leetcode 142</h4><p>阶段2 参考代码（找到环入口）</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> head; <span class="comment">// 龟</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// 兔</span></span><br><span class="line">    <span class="keyword">while</span> (h != <span class="literal">null</span> &amp;&amp; h.next != <span class="literal">null</span>) {</span><br><span class="line">        t = t.next;</span><br><span class="line">        h = h.next.next;</span><br><span class="line">        <span class="keyword">if</span> (h == t) {</span><br><span class="line">            t = head;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                <span class="keyword">if</span> (h == t) {</span><br><span class="line">                    <span class="keyword">return</span> h;</span><br><span class="line">                }</span><br><span class="line">                h = h.next;</span><br><span class="line">                t = t.next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>还有一道扩展题目，也可以用判环算法思想来解：就是 287题，寻找重复数</li></ul><h4 id="ex1.-删除节点-leetcode-237">Ex1. 删除节点-Leetcode 237</h4><p>这道题目比较简单，留给大家自己练习</p><p>例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [4,5,1,9], node = 5</span><br><span class="line">输出：[4,1,9]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：head = [4,5,1,9], node = 1</span><br><span class="line">输出：[4,5,9]</span><br></pre></td></tr></tbody></table></figure><p>注意：被删除的节点<strong>不是</strong>末尾节点</p><p><strong>参考答案</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ex1Leetcode237</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 待删除节点, 题目已说明肯定不是最后一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(ListNode node)</span> {</span><br><span class="line">        node.val = node.next.val;<span class="comment">// 下一个节点值赋值给待"删除"节点</span></span><br><span class="line">        node.next = node.next.next;<span class="comment">// 把下一个节点删除</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">o5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">o4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>, o5);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">o3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>, o4);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>, o3);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>, o2);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">E0xLeetcode237</span>().deleteNode(o3);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[1,2,3,4,5]</span><br><span class="line">[1,2,4,5]</span><br></pre></td></tr></tbody></table></figure><h4 id="ex2.-共尾链表-leetcode-160">Ex2. 共尾链表-Leetcode 160</h4><p>原题叫做<strong>相交</strong>链表，个人觉得用<strong>共尾</strong>链表更形象些，此题更像是一道脑筋急转弯，留给大家练习</p><p>例如，下图的两个链表 [1, 2, 4, 5] 与 [3, 4, 5] 它们中 [4, 5]是相同的，此时应返回节点 4</p><figure><img src="../../../../images/StrJava/image-20221228081715799.png" alt="image-20221228081715799"><figcaption aria-hidden="true">image-20221228081715799</figcaption></figure><p>非共尾的情况，如下图所示，此时返回 null</p><figure><img src="../../../../images/StrJava/image-20221228082002730.png" alt="image-20221228082002730"><figcaption aria-hidden="true">image-20221228082002730</figcaption></figure><p>思路，称两个链表为 a=[1, 2, 4, 5]，b=[3, 4, 5]，图中用 N 代表null</p><ol type="1"><li>遍历 a，遇到 null 时改道遍历 b</li><li>与此同时，遍历 b，遇到 null 时改道遍历 a</li><li>在此过程中，如果<strong>遇到相同</strong>的节点，即为找寻目标，返回即可，如下图中的第二次出现的4</li><li>相同节点应该比较其<strong>引用值</strong>，图中数字只是为了便于区分</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1245N345N</span><br><span class="line">345N1245N</span><br></pre></td></tr></tbody></table></figure><p>如果两个链表长度相同，则可以更早找到目标，例如 a=[1, 4, 5]，b=[3, 4,5]，第一次出现 4 时，即可返回</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">145N345N</span><br><span class="line">345N145N</span><br></pre></td></tr></tbody></table></figure><p>如果是非共尾的情况，如 a=[1, 2, 4]，b=[3,5]，可以看到，唯一相等的情况，是遍历到最后那个 N 此时退出循环</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">124N35N</span><br><span class="line">35N124N</span><br></pre></td></tr></tbody></table></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode a, ListNode b)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> a;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> b;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">if</span> (p1 == p2) {</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">null</span>) {</span><br><span class="line">            p1 = b;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (p2 == <span class="literal">null</span>) {</span><br><span class="line">            p2 = a;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        }            </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="递归">2.3 递归</h2><h3 id="概述-2">1) 概述</h3><p><strong>定义</strong></p><p>计算机科学中，递归是一种解决计算问题的方法，其中解决方案取决于同一类问题的更小子集</p><blockquote><p>In computer science, <strong>recursion</strong> is a method ofsolving a computational problem where the solution depends on solutionsto smaller instances of the same problem.</p></blockquote><p>比如单链表递归遍历的例子：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Node node)</span> {</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    println(<span class="string">"before:"</span> + node.value)</span><br><span class="line">    f(node.next);</span><br><span class="line">    println(<span class="string">"after:"</span> + node.value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>说明：</p><ol type="1"><li>自己调用自己，如果说每个函数对应着一种解决方案，自己调用自己意味着解决方案是一样的（有规律的）</li><li>每次调用，函数处理的数据会较上次缩减（子集），而且最后会缩减至无需继续递归</li><li>内层函数调用（子集处理）完成，外层函数才能算调用完成</li></ol><p><strong>原理</strong></p><p>假设链表中有 3 个节点，value 分别为1，2，3，以上代码的执行流程就类似于下面的<strong>伪码</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 1 -&gt; 2 -&gt; 3 -&gt; null  f(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Node node = <span class="number">1</span>)</span> {</span><br><span class="line">    println(<span class="string">"before:"</span> + node.value) <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Node node = <span class="number">2</span>)</span> {</span><br><span class="line">        println(<span class="string">"before:"</span> + node.value) <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Node node = <span class="number">3</span>)</span> {</span><br><span class="line">            println(<span class="string">"before:"</span> + node.value) <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Node node = <span class="literal">null</span>)</span> {</span><br><span class="line">                <span class="keyword">if</span>(node == <span class="literal">null</span>) {</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            println(<span class="string">"after:"</span> + node.value) <span class="comment">// 3</span></span><br><span class="line">        }</span><br><span class="line">        println(<span class="string">"after:"</span> + node.value) <span class="comment">// 2</span></span><br><span class="line">    }</span><br><span class="line">    println(<span class="string">"after:"</span> + node.value) <span class="comment">// 1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>思路</strong></p><ol type="1"><li>确定能否使用递归求解</li><li>推导出递推关系，即父问题与子问题的关系，以及递归的结束条件</li></ol><p>例如之前遍历链表的递推关系为 <span class="math display">\[f(n) =\begin{cases}停止&amp; n = null \\f(n.next) &amp; n \neq null\end{cases}\]</span></p><ul><li>深入到最里层叫做<strong>递</strong></li><li>从最里层出来叫做<strong>归</strong></li><li>在<strong>递</strong>的过程中，外层函数内的局部变量（以及方法参数）并未消失，<strong>归</strong>的时候还可以用到</li></ul><h3 id="单路递归-single-recursion">2) 单路递归 Single Recursion</h3><h4 id="e01.-阶乘">E01. 阶乘</h4><p>用递归方法求阶乘</p><ul><li><p>阶乘的定义 <span class="math inline">\(n!=1⋅2⋅3⋯(n-2)⋅(n-1)⋅n\)</span>，其中 <span class="math inline">\(n\)</span> 为自然数，当然 <span class="math inline">\(0! = 1\)</span></p></li><li><p>递推关系</p></li></ul><p><span class="math display">\[f(n) =\begin{cases}1 &amp; n = 1\\n * f(n-1) &amp; n &gt; 1\end{cases}\]</span></p><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> n * f(n - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>拆解<strong>伪码</strong>如下，假设 n 初始值为 3</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">f(<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">3</span>) { <span class="comment">// 解决不了,递</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> * f(<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">2</span>) { <span class="comment">// 解决不了,继续递</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * f(<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) { <span class="comment">// 可以解决, 开始归</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e02.-反向打印字符串">E02. 反向打印字符串</h4><p>用递归反向打印字符串，n 为字符在整个字符串 str 中的索引位置</p><ul><li><strong>递</strong>：n 从 0 开始，每次 n + 1，一直递到 n ==str.length() - 1</li><li><strong>归</strong>：从 n == str.length()开始归，从归打印，自然是逆序的</li></ul><p>递推关系 <span class="math display">\[f(n) =\begin{cases}停止 &amp; n = str.length() \\f(n+1) &amp; 0 \leq n \leq str.length() - 1\end{cases}\]</span> 代码为</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(String str, <span class="type">int</span> index)</span> {</span><br><span class="line">    <span class="keyword">if</span> (index == str.length()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    reversePrint(str, index + <span class="number">1</span>);</span><br><span class="line">    System.out.println(str.charAt(index));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>拆解<strong>伪码</strong>如下，假设字符串为 "abc"</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(String str, <span class="type">int</span> index = <span class="number">0</span>)</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(String str, <span class="type">int</span> index = <span class="number">1</span>)</span> {</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(String str, <span class="type">int</span> index = <span class="number">2</span>)</span> {</span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(String str, <span class="type">int</span> index = <span class="number">3</span>)</span> { </span><br><span class="line">                <span class="keyword">if</span> (index == str.length()) {</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 开始归</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            System.out.println(str.charAt(index)); <span class="comment">// 打印 c</span></span><br><span class="line">        }</span><br><span class="line">        System.out.println(str.charAt(index)); <span class="comment">// 打印 b</span></span><br><span class="line">    }</span><br><span class="line">    System.out.println(str.charAt(index)); <span class="comment">// 打印 a</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e03.-二分查找单路递归">E03. 二分查找（单路递归）</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="keyword">return</span> recursion(a, target, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">recursion</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">    <span class="keyword">if</span> (i &gt; j) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; a[m]) {</span><br><span class="line">        <span class="keyword">return</span> recursion(a, target, i, m - <span class="number">1</span>);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) {</span><br><span class="line">        <span class="keyword">return</span> recursion(a, target, m + <span class="number">1</span>, j);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e04.-冒泡排序单路递归">E04. 冒泡排序（单路递归）</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">int</span>[] a = {<span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>};</span><br><span class="line">    bubble(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    System.out.println(Arrays.toString(a));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> low, <span class="type">int</span> high)</span> {</span><br><span class="line">    <span class="keyword">if</span>(low == high) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low; i &lt; high; i++) {</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) {</span><br><span class="line">            swap(a, i, i + <span class="number">1</span>);</span><br><span class="line">            j = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    bubble(a, low, j);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = t;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>low 与 high 为未排序范围</li><li>j 表示的是未排序的边界，下一次递归时的 high<ul><li>发生交换，意味着有无序情况</li><li>最后一次交换（以后没有无序）时，左侧 i 仍是无序，右侧 i+1已然有序</li></ul></li><li>视频中讲解的是只考虑 high 边界的情况，参考以上代码，理解在 low ..high 范围内的处理方法</li></ul><h4 id="e05.-插入排序单路递归">E05. 插入排序（单路递归）</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">int</span>[] a = {<span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>};</span><br><span class="line">    insertion(a, <span class="number">1</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    System.out.println(Arrays.toString(a));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertion</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> low, <span class="type">int</span> high)</span> {</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[low];</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; a[i] &gt; i) {</span><br><span class="line">        a[i + <span class="number">1</span>] = a[i];</span><br><span class="line">        i--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(i + <span class="number">1</span> != low) {</span><br><span class="line">        a[i + <span class="number">1</span>] = t;</span><br><span class="line">    }    </span><br><span class="line">    insertion(a, low + <span class="number">1</span>, high);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>已排序区域：[0 .. i .. low-1]</li><li>未排序区域：[low .. high]</li><li>视频中讲解的是只考虑 low 边界的情况，参考以上代码，理解 low-1 ..high 范围内的处理方法</li><li>扩展：利用二分查找 leftmost 版本，改进寻找插入位置的代码</li></ul><h4 id="e06.-约瑟夫问题16单路递归">E06. 约瑟夫问题<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>（单路递归）</h4><p><span class="math inline">\(n\)</span>个人排成圆圈，从头开始报数，每次数到第 <span class="math inline">\(m\)</span> 个人（<span class="math inline">\(m\)</span> 从 <span class="math inline">\(1\)</span>开始）杀之，继续从下一个人重复以上过程，求最后活下来的人是谁？</p><p><strong>方法1</strong></p><p>根据最后的存活者 a 倒推出它在上一轮的索引号</p><table><colgroup><col style="width: 9%"><col style="width: 12%"><col style="width: 59%"><col style="width: 17%"></colgroup><thead><tr class="header"><th>f(n,m)</th><th>本轮索引</th><th>为了让 a 是这个索引，上一轮应当这样排</th><th>规律</th></tr></thead><tbody><tr class="odd"><td>f(1,3)</td><td>0</td><td>x x x a</td><td>(0 + 3) % 2</td></tr><tr class="even"><td>f(2,3)</td><td>1</td><td>x x x 0 a</td><td>(1 + 3) % 3</td></tr><tr class="odd"><td>f(3,3)</td><td>1</td><td>x x x 0 a</td><td>(1 + 3) % 4</td></tr><tr class="even"><td>f(4,3)</td><td>0</td><td>x x x a</td><td>(0 + 3) % 5</td></tr><tr class="odd"><td>f(5,3)</td><td>3</td><td>x x x 0 1 2 a</td><td>(3 + 3) % 6</td></tr><tr class="even"><td>f(6,3)</td><td>0</td><td>x x x a</td><td></td></tr></tbody></table><p><strong>方法2</strong></p><p>设 n 为总人数，m 为报数次数，解返回的是这些人的索引，从0开始</p><table><thead><tr class="header"><th>f(n, m)</th><th>解</th><th>规律</th></tr></thead><tbody><tr class="odd"><td>f(1, 3)</td><td>0</td><td></td></tr><tr class="even"><td>f(2, 3)</td><td>0 1 =&gt; 1</td><td>3%2=1</td></tr><tr class="odd"><td>f(3, 3)</td><td>0 1 2 =&gt; 0 1</td><td>3%3=0</td></tr><tr class="even"><td>f(4, 3)</td><td>0 1 2 3 =&gt; 3 0 1</td><td>3%4=3</td></tr><tr class="odd"><td>f(5, 3)</td><td>0 1 2 3 4 =&gt; 3 4 0 1</td><td>3%5=3</td></tr><tr class="even"><td>f(6, 3)</td><td>0 1 2 3 4 5 =&gt; 3 4 5 0 1</td><td>3%6=3</td></tr></tbody></table><p><strong>一. 找出等价函数</strong></p><p>规律：下次报数的起点为 <span class="math inline">\(k = m \%n\)</span></p><ul><li>首次出列人的序号是 <span class="math inline">\(k-1\)</span>，剩下的的 <span class="math inline">\(n-1\)</span> 个人重新组成约瑟夫环</li><li>下次从 <span class="math inline">\(k\)</span> 开始数，序号如下<ul><li><span class="math inline">\(k,\ k+1, \ ...\ ,\ 0,\ 1,\k-2\)</span>，如上例中 <span class="math inline">\(3\ 4\ 5\ 0\1\)</span></li></ul></li></ul><p>这个函数称之为 <span class="math inline">\(g(n-1,m)\)</span>，它的最终结果与 <span class="math inline">\(f(n,m)\)</span> 是相同的。</p><p><strong>二. 找到映射函数</strong></p><p>现在想办法找到 <span class="math inline">\(g(n-1,m)\)</span> 与 <span class="math inline">\(f(n-1, m)\)</span> 的对应关系，即 <span class="math display">\[3 \rightarrow 0 \\4 \rightarrow 1 \\5 \rightarrow 2 \\0 \rightarrow 3 \\1 \rightarrow 4 \\\]</span> 映射函数为 <span class="math display">\[mapping(x) =\begin{cases}x-k &amp; x=[k..n-1] \\x+n-k &amp; x=[0..k-2]\end{cases}\]</span> 等价于下面函数 <span class="math display">\[mapping(x) = (x + n - k)\%{n}\]</span> 代入测试一下 <span class="math display">\[3 \rightarrow (3+6-3)\%6 \rightarrow 0 \\4 \rightarrow (4+6-3)\%6 \rightarrow 1 \\5 \rightarrow (5+6-3)\%6 \rightarrow 2 \\0 \rightarrow (0+6-3)\%6 \rightarrow 3 \\1 \rightarrow (1+6-3)\%6 \rightarrow 4 \\\]</span> 综上有 <span class="math display">\[f(n-1,m) = mapping(g(n-1,m))\]</span></p><p><strong>三. 求逆映射函数</strong></p><p>映射函数是根据 x 计算 y，逆映射函数即根据 y 得到 x <span class="math display">\[mapping^{-1}(x) = (x + k)\%n\]</span> 代入测试一下 <span class="math display">\[0 \rightarrow (0+3)\%6 \rightarrow 3 \\1 \rightarrow (1+3)\%6 \rightarrow 4 \\2 \rightarrow (2+3)\%6 \rightarrow 5 \\3 \rightarrow (3+3)\%6 \rightarrow 0 \\4 \rightarrow (4+3)\%6 \rightarrow 1 \\\]</span> 因此可以求得 <span class="math display">\[g(n-1,m) = mapping^{-1}(f(n-1,m))\]</span></p><p><strong>四. 递推式</strong></p><p>代入推导 <span class="math display">\[\begin{aligned}f(n,m) = \ &amp; g(n-1,m) \\= \ &amp; mapping^{-1}(f(n-1,m)) \\= \ &amp; (f(n-1,m) + k) \% n \\= \ &amp; (f(n-1,m) + m\%n) \% n \\= \ &amp; (f(n-1,m) + m) \% n \\\end{aligned}\]</span> 最后一步化简是利用了模运算法则</p><p><span class="math inline">\((a+b)\%n = (a\%n + b\%n) \%n\)</span>例如</p><ul><li><span class="math inline">\((6+6)\%5 = 2 = (6+6\%5)\%5\)</span></li><li><span class="math inline">\((6+5)\%5 = 1 = (6+5\%5)\%5\)</span></li><li><span class="math inline">\((6+4)\%5 = 0 = (6+4\%5)\%5\)</span></li></ul><p>最终递推式 <span class="math display">\[f(n,m) =\begin{cases}(f(n-1,m) + m) \% n &amp; n&gt;1\\0 &amp; n = 1\end{cases}\]</span></p><h3 id="多路递归-multi-recursion">3) 多路递归 Multi Recursion</h3><h4 id="e01.-斐波那契数列-leetcode-70">E01. 斐波那契数列-Leetcode70</h4><ul><li>之前的例子是每个递归函数只包含一个自身的调用，这称之为 singlerecursion</li><li>如果每个递归函数例包含多个自身调用，称之为 multi recursion</li></ul><p><strong>递推关系</strong> <span class="math display">\[f(n) =\begin{cases}0 &amp; n=0 \\1 &amp; n=1 \\f(n-1) + f(n-2) &amp; n&gt;1\end{cases}\]</span></p><p>下面的表格列出了数列的前几项</p><table><colgroup><col style="width: 6%"><col style="width: 6%"><col style="width: 6%"><col style="width: 6%"><col style="width: 6%"><col style="width: 6%"><col style="width: 6%"><col style="width: 6%"><col style="width: 6%"><col style="width: 6%"><col style="width: 8%"><col style="width: 8%"><col style="width: 8%"><col style="width: 8%"></colgroup><thead><tr class="header"><th><em>F</em>0</th><th><em>F</em>1</th><th><em>F</em>2</th><th><em>F</em>3</th><th><em>F</em>4</th><th><em>F</em>5</th><th><em>F</em>6</th><th><em>F</em>7</th><th><em>F</em>8</th><th><em>F</em>9</th><th><em>F</em>10</th><th><em>F</em>11</th><th><em>F</em>12</th><th><em>F</em>13</th></tr></thead><tbody><tr class="odd"><td>0</td><td>1</td><td>1</td><td>2</td><td>3</td><td>5</td><td>8</td><td>13</td><td>21</td><td>34</td><td>55</td><td>89</td><td>144</td><td>233</td></tr></tbody></table><p><strong>实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>执行流程</strong></p><p><img src="../../../../images/StrJava/2.gif"></p><ul><li>绿色代表正在执行（对应递），灰色代表执行结束（对应归）</li><li>递不到头，不能归，对应着深度优先搜索</li></ul><p><strong>时间复杂度</strong></p><ul><li>递归的次数也符合斐波那契规律，<span class="math inline">\(2 *f(n+1)-1\)</span></li><li>时间复杂度推导过程<ul><li>斐波那契通项公式 <span class="math inline">\(f(n) =\frac{1}{\sqrt{5}}*({\frac{1+\sqrt{5}}{2}}^n -{\frac{1-\sqrt{5}}{2}}^n)\)</span></li><li>简化为：<span class="math inline">\(f(n) =\frac{1}{2.236}*({1.618}^n - {(-0.618)}^n)\)</span></li><li>带入递归次数公式 <span class="math inline">\(2*\frac{1}{2.236}*({1.618}^{n+1} -{(-0.618)}^{n+1})-1\)</span></li><li>时间复杂度为 <span class="math inline">\(\Theta(1.618^n)\)</span></li></ul></li></ul><blockquote><ol type="1"><li>更多 Fibonacci 参考<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a><a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a><a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a></li><li>以上时间复杂度分析，未考虑大数相加的因素</li></ol></blockquote><p><strong>变体1 - 兔子问题<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a></strong></p><figure><img src="../../../../images/StrJava/image-20221110155655827.png" alt="image-20221110155655827"><figcaption aria-hidden="true">image-20221110155655827</figcaption></figure><ul><li>第一个月，有一对未成熟的兔子（黑色，注意图中个头较小）</li><li>第二个月，它们成熟</li><li>第三个月，它们能产下一对新的小兔子（蓝色）</li><li>所有兔子遵循相同规律，求第 <span class="math inline">\(n\)</span>个月的兔子数</li></ul><p><strong>分析</strong></p><p>兔子问题如何与斐波那契联系起来呢？设第 n 个月兔子数为 <span class="math inline">\(f(n)\)</span></p><ul><li><span class="math inline">\(f(n)\)</span> = 上个月兔子数 +新生的小兔子数</li><li>而【新生的小兔子数】实际就是【上个月成熟的兔子数】</li><li>因为需要一个月兔子就成熟，所以【上个月成熟的兔子数】也就是【上上个月的兔子数】</li><li>上个月兔子数，即 <span class="math inline">\(f(n-1)\)</span></li><li>上上个月的兔子数，即 <span class="math inline">\(f(n-2)\)</span></li></ul><p>因此本质还是斐波那契数列，只是从其第一项开始</p><p><strong>变体2 - 青蛙爬楼梯</strong></p><ul><li>楼梯有 <span class="math inline">\(n\)</span> 阶</li><li>青蛙要爬到楼顶，可以一次跳一阶，也可以一次跳两阶</li><li>只能向上跳，问有多少种跳法</li></ul><p><strong>分析</strong></p><table><colgroup><col style="width: 3%"><col style="width: 44%"><col style="width: 52%"></colgroup><thead><tr class="header"><th>n</th><th>跳法</th><th>规律</th></tr></thead><tbody><tr class="odd"><td>1</td><td>(1)</td><td>暂时看不出</td></tr><tr class="even"><td>2</td><td>(1,1) (2)</td><td>暂时看不出</td></tr><tr class="odd"><td>3</td><td>(1,1,1) (1,2) (2,1)</td><td>暂时看不出</td></tr><tr class="even"><td>4</td><td>(1,1,1,1) (1,2,1) (2,1,1)<br>(1,1,2) (2,2)</td><td>最后一跳，跳一个台阶的，基于f(3)<br>最后一跳，跳两个台阶的，基于f(2)</td></tr><tr class="odd"><td>5</td><td>...</td><td>...</td></tr></tbody></table><ul><li><p>因此本质上还是斐波那契数列，只是从其第二项开始</p></li><li><p>对应 leetcode 题目 <a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯 -力扣（LeetCode）</a></p></li></ul><h4 id="e02.-汉诺塔13多路递归">E02. 汉诺塔<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a>（多路递归）</h4><p>Tower ofHanoi，是一个源于印度古老传说：大梵天创建世界时做了三根金刚石柱，在一根柱子从下往上按大小顺序摞着64片黄金圆盘，大梵天命令婆罗门把圆盘重新摆放在另一根柱子上，并且规定</p><ul><li>一次只能移动一个圆盘</li><li>小圆盘上不能放大圆盘</li></ul><p>下面的动图演示了4片圆盘的移动方法</p><p><img src="../../../../images/StrJava/Tower_of_Hanoi_4.gif"></p><p>使用程序代码模拟圆盘的移动过程，并估算出时间复杂度</p><p><strong>思路</strong></p><ul><li><p>假设每根柱子标号 a，b，c，每个圆盘用 1，2，3 ...表示其大小，圆盘初始在 a，要移动到的目标是 c</p></li><li><p>如果只有一个圆盘，此时是最小问题，可以直接求解</p><ul><li>移动圆盘1 <span class="math inline">\(a \mapsto c\)</span></li></ul><p><img src="../../../../images/StrJava/image-20221219090741078.png" alt="image-20221219090741078" style="zoom:50%;"></p></li><li><p>如果有两个圆盘，那么</p><ul><li>圆盘1 <span class="math inline">\(a \mapsto b\)</span></li><li>圆盘2 <span class="math inline">\(a \mapsto c\)</span></li><li>圆盘1 <span class="math inline">\(b \mapsto c\)</span></li></ul><p><img src="../../../../images/StrJava/image-20221219091316225.png" alt="image-20221219091316225" style="zoom:50%;"></p></li><li><p>如果有三个圆盘，那么</p><ul><li>圆盘12 <span class="math inline">\(a \mapsto b\)</span></li><li>圆盘3 <span class="math inline">\(a \mapsto c\)</span></li><li>圆盘12 <span class="math inline">\(b \mapsto c\)</span></li></ul><p><img src="../../../../images/StrJava/image-20221219091930614.png" alt="image-20221219091930614" style="zoom:50%;"></p></li><li><p>如果有四个圆盘，那么</p><ul><li>圆盘 123 <span class="math inline">\(a \mapsto b\)</span></li><li>圆盘4 <span class="math inline">\(a \mapsto c\)</span></li><li>圆盘 123 <span class="math inline">\(b \mapsto c\)</span></li></ul></li></ul><p><img src="../../../../images/StrJava/image-20221219092537323.png" alt="image-20221219092537323" style="zoom:50%;"></p><p><strong>题解</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E02HanoiTower</span> {</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">             源 借 目</span></span><br><span class="line"><span class="comment">        h(4, a, b, c) -&gt; h(3, a, c, b)</span></span><br><span class="line"><span class="comment">                         a -&gt; c</span></span><br><span class="line"><span class="comment">                         h(3, b, a, c)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> LinkedList&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> LinkedList&lt;Integer&gt; b = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> LinkedList&lt;Integer&gt; c = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &gt;= <span class="number">1</span>; i--) {</span><br><span class="line">            a.add(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">h</span><span class="params">(<span class="type">int</span> n, LinkedList&lt;Integer&gt; a, </span></span><br><span class="line"><span class="params">                  LinkedList&lt;Integer&gt; b, </span></span><br><span class="line"><span class="params">                  LinkedList&lt;Integer&gt; c)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        h(n - <span class="number">1</span>, a, c, b);</span><br><span class="line">        c.addLast(a.removeLast());</span><br><span class="line">        print();</span><br><span class="line">        h(n - <span class="number">1</span>, b, a, c);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        init(<span class="number">3</span>);</span><br><span class="line">        print();</span><br><span class="line">        h(<span class="number">3</span>, a, b, c);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e03.-杨辉三角6">E03. 杨辉三角<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a></h4><figure><img src="../../../../images/StrJava/image-20221219172514410.png" alt="image-20221219172514410"><figcaption aria-hidden="true">image-20221219172514410</figcaption></figure><p><strong>分析</strong></p><p>把它斜着看</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">        1</span><br><span class="line">      1   1</span><br><span class="line">    1   2   1</span><br><span class="line">  1   3   3   1</span><br><span class="line">1   4   6   4   1</span><br></pre></td></tr></tbody></table></figure><ul><li>行 <span class="math inline">\(i\)</span>，列 <span class="math inline">\(j\)</span>，那么 <span class="math inline">\([i][j]\)</span> 的取值应为 <span class="math inline">\([i-1][j-1] + [i-1][j]\)</span></li><li>当 <span class="math inline">\(j=0\)</span> 或 <span class="math inline">\(i=j\)</span> 时，<span class="math inline">\([i][j]\)</span> 取值为 <span class="math inline">\(1\)</span></li></ul><p><strong>题解</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>) {</span><br><span class="line">            System.out.printf(<span class="string">"%"</span> + <span class="number">2</span> * (n - <span class="number">1</span> - i) + <span class="string">"s"</span>, <span class="string">" "</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i + <span class="number">1</span>; j++) {</span><br><span class="line">            System.out.printf(<span class="string">"%-4d"</span>, element(i, j));</span><br><span class="line">        }</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">element</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">0</span> || i == j) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> element(i - <span class="number">1</span>, j - <span class="number">1</span>) + element(i - <span class="number">1</span>, j);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>优化1</strong></p><p>是 multiple recursion，因此很多递归调用是重复的，例如</p><ul><li>recursion(3, 1) 分解为<ul><li>recursion(2, 0) + recursion(2, 1)</li></ul></li><li>而 recursion(3, 2) 分解为<ul><li>recursion(2, 1) + recursion(2, 2)</li></ul></li></ul><p>这里 recursion(2, 1) 就重复调用了，事实上它会重复很多次，可以用static AtomicInteger counter = new AtomicInteger(0)来查看递归函数的调用总次数</p><p>事实上，可以用 <strong>memoization</strong> 来进行优化：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print1</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="type">int</span>[][] triangle = <span class="keyword">new</span> <span class="title class_">int</span>[n][];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="comment">// 打印空格</span></span><br><span class="line">        triangle[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= i; j++) {</span><br><span class="line">            System.out.printf(<span class="string">"%-4d"</span>, element1(triangle, i, j));</span><br><span class="line">        }</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">element1</span><span class="params">(<span class="type">int</span>[][] triangle, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">    <span class="keyword">if</span> (triangle[i][j] &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> triangle[i][j];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">0</span> || i == j) {</span><br><span class="line">        triangle[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> triangle[i][j];</span><br><span class="line">    }</span><br><span class="line">    triangle[i][j] = element1(triangle, i - <span class="number">1</span>, j - <span class="number">1</span>) + element1(triangle, i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">return</span> triangle[i][j];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>将数组作为递归函数内可以访问的遍历，如果 <span class="math inline">\(triangle[i][j]\)</span>已经有值，说明该元素已经被之前的递归函数计算过，就不必重复计算了</li></ul><p><strong>优化2</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print2</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="type">int</span>[] row = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="comment">// 打印空格</span></span><br><span class="line">        createRow(row, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= i; j++) {</span><br><span class="line">            System.out.printf(<span class="string">"%-4d"</span>, row[j]);</span><br><span class="line">        }</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createRow</span><span class="params">(<span class="type">int</span>[] row, <span class="type">int</span> i)</span> {</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) {</span><br><span class="line">        row[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span>; j--) {</span><br><span class="line">        row[j] = row[j - <span class="number">1</span>] + row[j];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意：还可以通过每一行的前一项计算出下一项，不必借助上一行，这与杨辉三角的另一个特性有关，暂不展开了</p></blockquote><h4 id="其它题目">其它题目</h4><p>力扣对应题目，但递归不适合在力扣刷高分，因此只列出相关题目，不做刷题讲解了</p><table><thead><tr class="header"><th>题号</th><th>名称</th></tr></thead><tbody><tr class="odd"><td>Leetcode118</td><td>杨辉三角</td></tr><tr class="even"><td>Leetcode119</td><td>杨辉三角II</td></tr><tr class="odd"><td></td><td></td></tr></tbody></table><h3 id="递归优化-记忆法">4) 递归优化-记忆法</h3><p>上述代码存在很多重复的计算，例如求 <span class="math inline">\(f(5)\)</span> 递归分解过程</p><figure><img src="../../../../images/StrJava/image-20221207092417933.png" alt="image-20221207092417933"><figcaption aria-hidden="true">image-20221207092417933</figcaption></figure><p>可以看到（颜色相同的是重复的）：</p><ul><li><span class="math inline">\(f(3)\)</span> 重复了 2 次</li><li><span class="math inline">\(f(2)\)</span> 重复了 3 次</li><li><span class="math inline">\(f(1)\)</span> 重复了 5 次</li><li><span class="math inline">\(f(0)\)</span> 重复了 3 次</li></ul><p>随着 <span class="math inline">\(n\)</span>的增大，重复次数非常可观，如何优化呢？</p><p><strong>Memoization</strong>记忆法（也称备忘录）是一种优化技术，通过存储函数调用结果（通常比较昂贵），当再次出现相同的输入（子问题）时，就能实现加速效果，改进后的代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line">    <span class="type">int</span>[] cache = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(cache, -<span class="number">1</span>);</span><br><span class="line">    cache[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    cache[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    System.out.println(f(cache, n));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] cache, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">if</span> (cache[n] != -<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[n];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cache[n] = f(cache, n - <span class="number">1</span>) + f(cache, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> cache[n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>优化后的图示，只要结果被缓存，就<strong>不会执行其子问题</strong></p><figure><img src="../../../../images/StrJava/image-20221213173225807.png" alt="image-20221213173225807"><figcaption aria-hidden="true">image-20221213173225807</figcaption></figure><ul><li>改进后的时间复杂度为 <span class="math inline">\(O(n)\)</span></li><li>请自行验证改进后的效果</li><li>请自行分析改进后的空间复杂度</li></ul><blockquote><p><strong>注意</strong></p><ol type="1"><li>记忆法是动态规划的一种情况，强调的是自顶向下的解决</li><li>记忆法的本质是空间换时间</li></ol></blockquote><h3 id="递归优化-尾递归">5) 递归优化-尾递归</h3><p><strong>爆栈</strong></p><p>用递归做 <span class="math inline">\(n + (n-1) + (n-2) ... +1\)</span></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">long</span> n)</span> {</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> n + sum(n - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在我的机器上 <span class="math inline">\(n = 12000\)</span>时，爆栈了</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Exception in thread "main" java.lang.StackOverflowError</span><br><span class="line">at Test.sum(Test.java:10)</span><br><span class="line">at Test.sum(Test.java:10)</span><br><span class="line">at Test.sum(Test.java:10)</span><br><span class="line">at Test.sum(Test.java:10)</span><br><span class="line">at Test.sum(Test.java:10)</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>为什么呢？</p><ul><li>每次方法调用是需要消耗一定的栈内存的，这些内存用来存储方法参数、方法内局部变量、返回地址等等</li><li>方法调用占用的内存需要等到<strong>方法结束时</strong>才会释放</li><li>而递归调用我们之前讲过，不到最深不会回头，最内层方法没完成之前，外层方法都结束不了<ul><li>例如，<span class="math inline">\(sum(3)\)</span>这个方法内有个需要执行 <span class="math inline">\(3 +sum(2)\)</span>，<span class="math inline">\(sum(2)\)</span>没返回前，加号前面的 <span class="math inline">\(3\)</span>不能释放</li><li>看下面伪码</li></ul></li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">long</span> n = <span class="number">3</span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> + <span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">long</span> n = <span class="number">2</span>)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> + <span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">long</span> n = <span class="number">1</span>)</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>尾调用</strong></p><p>如果函数的最后一步是调用一个函数，那么称为尾调用，例如</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">b</span>()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下面三段代码<strong>不能</strong>叫做尾调用</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">const</span> c = <span class="title function_">b</span>()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>因为最后一步并非调用函数</li></ul><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">b</span>() + <span class="number">1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>最后一步执行的是加法</li></ul><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">x</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">b</span>() + x</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>最后一步执行的是加法</li></ul><p><strong>一些语言</strong><a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a>的编译器能够对尾调用做优化，例如</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="comment">// 做前面的事</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">b</span>() </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="comment">// 做前面的事</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">c</span>()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1000</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="title function_">a</span>()</span><br></pre></td></tr></tbody></table></figure><p>没优化之前的<strong>伪码</strong></p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1000</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>优化后<strong>伪码</strong>如下</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title function_">a</span>()</span><br><span class="line"><span class="title function_">b</span>()</span><br><span class="line"><span class="title function_">c</span>()</span><br></pre></td></tr></tbody></table></figure><p>为何尾递归才能优化？</p><p>调用 a 时</p><ul><li>a 返回时发现：没什么可留给 b 的，将来返回的结果 b提供就可以了，用不着我 a 了，我的内存就可以释放</li></ul><p>调用 b 时</p><ul><li>b 返回时发现：没什么可留给 c 的，将来返回的结果 c提供就可以了，用不着我 b 了，我的内存就可以释放</li></ul><p>如果调用 a 时</p><ul><li>不是尾调用，例如 return b() + 1，那么 a就不能提前结束，因为它还得利用 b 的结果做加法</li></ul><p><strong>尾递归</strong></p><p>尾递归是尾调用的一种特例，也就是最后一步执行的是同一个函数</p><p><strong>尾递归避免爆栈</strong></p><p>安装 Scala</p><figure><img src="../../../../images/StrJava/image-20221111122709227.png" alt="image-20221111122709227"><figcaption aria-hidden="true">image-20221111122709227</figcaption></figure><p>Scala 入门</p><figure class="highlight scala"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = {</span><br><span class="line">    println(<span class="string">"Hello Scala"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Scala 是 java 的近亲，java 中的类都可以拿来重用</li><li>类型是放在变量后面的</li><li>Unit 表示无返回值，类似于 void</li><li>不需要以分号作为结尾，当然加上也对</li></ul><p>还是先写一个会爆栈的函数</p><figure class="highlight scala"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(n: <span class="type">Long</span>): <span class="type">Long</span> = {</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> n + sum(n - <span class="number">1</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Scala 最后一行代码若作为返回值，可以省略 return</li></ul><p>不出所料，在 <span class="math inline">\(n = 11000\)</span>时，还是出了异常</p><figure class="highlight scala"><table><tbody><tr><td class="code"><pre><span class="line">println(sum(<span class="number">11000</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">Exception</span> in thread <span class="string">"main"</span> java.lang.<span class="type">StackOverflowError</span></span><br><span class="line">at <span class="type">Main</span>$.sum(<span class="type">Main</span>.scala:<span class="number">25</span>)</span><br><span class="line">at <span class="type">Main</span>$.sum(<span class="type">Main</span>.scala:<span class="number">25</span>)</span><br><span class="line">at <span class="type">Main</span>$.sum(<span class="type">Main</span>.scala:<span class="number">25</span>)</span><br><span class="line">at <span class="type">Main</span>$.sum(<span class="type">Main</span>.scala:<span class="number">25</span>)</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>这是因为以上代码，还不是尾调用，要想成为尾调用，那么：</p><ol type="1"><li>最后一行代码，必须是一次函数调用</li><li>内层函数必须<strong>摆脱</strong>与外层函数的关系，内层函数<strong>执行后</strong>不依赖于外层的变量或常量</li></ol><figure class="highlight scala"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(n: <span class="type">Long</span>): <span class="type">Long</span> = {</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> n + sum(n - <span class="number">1</span>)  <span class="comment">// 依赖于外层函数的 n 变量</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如何让它执行后就摆脱对 n 的依赖呢？</p><ul><li>不能等递归回来再做加法，那样就必须保留外层的 n</li><li>把 n 当做内层函数的一个参数传进去，这时 n 就属于内层函数了</li><li>传参时就完成累加, 不必等回来时累加</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sum(n - 1, n + 累加器)</span><br></pre></td></tr></tbody></table></figure><p>改写后代码如下</p><figure class="highlight scala"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@tailrec</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(n: <span class="type">Long</span>, accumulator: <span class="type">Long</span>): <span class="type">Long</span> = {</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + accumulator</span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">return</span> sum(n - <span class="number">1</span>, n + accumulator)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>accumulator 作为累加器</li><li><span class="citation" data-cites="tailrec">@tailrec</span> 注解是scala 提供的，用来检查方法是否符合尾递归</li><li>这回 sum(10000000, 0) 也没有问题，打印 50000005000000</li></ul><p>执行流程如下，以<strong>伪码</strong>表示 <span class="math inline">\(sum(4, 0)\)</span></p><figure class="highlight scala"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 首次调用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(n = <span class="number">4</span>, accumulator = <span class="number">0</span>): <span class="type">Long</span> = {</span><br><span class="line">    <span class="keyword">return</span> sum(<span class="number">4</span> - <span class="number">1</span>, <span class="number">4</span> + accumulator)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来调用内层 sum, 传参时就完成了累加, 不必等回来时累加，当内层 sum 调用后，外层 sum 空间没必要保留</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(n = <span class="number">3</span>, accumulator = <span class="number">4</span>): <span class="type">Long</span> = {</span><br><span class="line">    <span class="keyword">return</span> sum(<span class="number">3</span> - <span class="number">1</span>, <span class="number">3</span> + accumulator)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续调用内层 sum</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(n = <span class="number">2</span>, accumulator = <span class="number">7</span>): <span class="type">Long</span> = {</span><br><span class="line">    <span class="keyword">return</span> sum(<span class="number">2</span> - <span class="number">1</span>, <span class="number">2</span> + accumulator)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续调用内层 sum, 这是最后的 sum 调用完就返回最后结果 10, 前面所有其它 sum 的空间早已释放</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(n = <span class="number">1</span>, accumulator = <span class="number">9</span>): <span class="type">Long</span> = {</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + accumulator</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>本质上，尾递归优化是将函数的<strong>递归</strong>调用，变成了函数的<strong>循环</strong>调用</p><p><strong>改循环避免爆栈</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100000000</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> n; i &gt;= <span class="number">1</span>; i--) {</span><br><span class="line">        sum += i;</span><br><span class="line">    }</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="递归时间复杂度-master-theorem14">6) 递归时间复杂度-Mastertheorem<a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a></h3><p>若有递归式 <span class="math display">\[T(n) = aT(\frac{n}{b}) + f(n)\]</span> 其中</p><ul><li><span class="math inline">\(T(n)\)</span> 是问题的运行时间，<span class="math inline">\(n\)</span> 是数据规模</li><li><span class="math inline">\(a\)</span> 是子问题个数</li><li><span class="math inline">\(T(\frac{n}{b})\)</span>是子问题运行时间，每个子问题被拆成原问题数据规模的 <span class="math inline">\(\frac{n}{b}\)</span></li><li><span class="math inline">\(f(n)\)</span> 是除递归外执行的计算</li></ul><p>令 <span class="math inline">\(x = \log_{b}{a}\)</span>，即 <span class="math inline">\(x = \log_{子问题缩小倍数}{子问题个数}\)</span></p><p>那么 <span class="math display">\[T(n) =\begin{cases}\Theta(n^x) &amp; f(n) = O(n^c) 并且 c \lt x\\\Theta(n^x\log{n}) &amp; f(n) = \Theta(n^x)\\\Theta(n^c) &amp; f(n) = \Omega(n^c) 并且 c \gt x\end{cases}\]</span></p><p><strong>例1</strong></p><p><span class="math inline">\(T(n) = 2T(\frac{n}{2}) + n^4\)</span></p><ul><li>此时 <span class="math inline">\(x = 1 &lt;4\)</span>，由后者决定整个时间复杂度 <span class="math inline">\(\Theta(n^4)\)</span></li><li>如果觉得对数不好算，可以换为求【<span class="math inline">\(b\)</span> 的几次方能等于 <span class="math inline">\(a\)</span>】</li></ul><p><strong>例2</strong></p><p><span class="math inline">\(T(n) = T(\frac{7n}{10}) + n\)</span></p><ul><li><span class="math inline">\(a=1, b=\frac{10}{7}, x=0,c=1\)</span></li><li>此时 <span class="math inline">\(x = 0 &lt;1\)</span>，由后者决定整个时间复杂度 <span class="math inline">\(\Theta(n)\)</span></li></ul><p><strong>例3</strong></p><p><span class="math inline">\(T(n) = 16T(\frac{n}{4}) +n^2\)</span></p><ul><li><span class="math inline">\(a=16, b=4, x=2, c=2\)</span></li><li>此时 <span class="math inline">\(x=2 = c\)</span>，时间复杂度 <span class="math inline">\(\Theta(n^2 \log{n})\)</span></li></ul><p><strong>例4</strong></p><p><span class="math inline">\(T(n)=7T(\frac{n}{3}) + n^2\)</span></p><ul><li><span class="math inline">\(a=7, b=3, x=1.?, c=2\)</span></li><li>此时 <span class="math inline">\(x = \log_{3}{7} &lt;2\)</span>，由后者决定整个时间复杂度 <span class="math inline">\(\Theta(n^2)\)</span></li></ul><p><strong>例5</strong></p><p><span class="math inline">\(T(n) = 7T(\frac{n}{2}) + n^2\)</span></p><ul><li><span class="math inline">\(a=7, b=2, x=2.?, c=2\)</span></li><li>此时 <span class="math inline">\(x = log_2{7} &gt;2\)</span>，由前者决定整个时间复杂度 <span class="math inline">\(\Theta(n^{\log_2{7}})\)</span></li></ul><p><strong>例6</strong></p><p><span class="math inline">\(T(n) = 2T(\frac{n}{4}) +\sqrt{n}\)</span></p><ul><li><span class="math inline">\(a=2, b=4, x = 0.5, c=0.5\)</span></li><li>此时 <span class="math inline">\(x = 0.5 = c\)</span>，时间复杂度<span class="math inline">\(\Theta(\sqrt{n}\ \log{n})\)</span></li></ul><p><strong>例7. 二分查找递归</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">    <span class="keyword">if</span> (i &gt; j) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; a[m]) {</span><br><span class="line">        <span class="keyword">return</span> f(a, target, i, m - <span class="number">1</span>);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) {</span><br><span class="line">        <span class="keyword">return</span> f(a, target, m + <span class="number">1</span>, j);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>子问题个数 <span class="math inline">\(a = 1\)</span></li><li>子问题数据规模缩小倍数 <span class="math inline">\(b =2\)</span></li><li>除递归外执行的计算是常数级 <span class="math inline">\(c=0\)</span></li></ul><p><span class="math inline">\(T(n) = T(\frac{n}{2}) + n^0\)</span></p><ul><li>此时 <span class="math inline">\(x=0 = c\)</span>，时间复杂度 <span class="math inline">\(\Theta(\log{n})\)</span></li></ul><p><strong>例8. 归并排序递归</strong></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">void split(B[], i, j, A[])</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>)                    </span><br><span class="line">        <span class="keyword">return</span>;                                </span><br><span class="line">    m = (i + j) / <span class="number">2</span>;             </span><br><span class="line">    </span><br><span class="line">    // 递归</span><br><span class="line">    split(A, i, m, B);  </span><br><span class="line">    split(A, m, j, B); </span><br><span class="line">    </span><br><span class="line">    // 合并</span><br><span class="line">    merge(B, i, m, j, A);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>子问题个数 <span class="math inline">\(a=2\)</span></li><li>子问题数据规模缩小倍数 <span class="math inline">\(b=2\)</span></li><li>除递归外，主要时间花在合并上，它可以用 <span class="math inline">\(f(n) = n\)</span> 表示</li></ul><p><span class="math inline">\(T(n) = 2T(\frac{n}{2}) + n\)</span></p><ul><li>此时 <span class="math inline">\(x=1=c\)</span>，时间复杂度 <span class="math inline">\(\Theta(n\log{n})\)</span></li></ul><p><strong>例9. 快速排序递归</strong></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">algorithm quicksort(A, lo, hi) <span class="keyword">is</span> </span><br><span class="line">  <span class="keyword">if</span> lo &gt;= hi || lo &lt; <span class="number">0</span> then </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  </span><br><span class="line">  // 分区</span><br><span class="line">  p := partition(A, lo, hi) </span><br><span class="line">  </span><br><span class="line">  // 递归</span><br><span class="line">  quicksort(A, lo, p - <span class="number">1</span>) </span><br><span class="line">  quicksort(A, p + <span class="number">1</span>, hi) </span><br></pre></td></tr></tbody></table></figure><ul><li>子问题个数 <span class="math inline">\(a=2\)</span></li><li>子问题数据规模缩小倍数<ul><li>如果分区分的好，<span class="math inline">\(b=2\)</span></li><li>如果分区没分好，例如分区1 的数据是 0，分区 2 的数据是 <span class="math inline">\(n-1\)</span></li></ul></li><li>除递归外，主要时间花在分区上，它可以用 <span class="math inline">\(f(n) = n\)</span> 表示</li></ul><p>情况1 - 分区分的好</p><p><span class="math inline">\(T(n) = 2T(\frac{n}{2}) + n\)</span></p><ul><li>此时 <span class="math inline">\(x=1=c\)</span>，时间复杂度 <span class="math inline">\(\Theta(n\log{n})\)</span></li></ul><p>情况2 - 分区没分好</p><p><span class="math inline">\(T(n) = T(n-1) + T(1) + n\)</span></p><ul><li>此时不能用主定理求解</li></ul><h3 id="递归时间复杂度-展开求解">7) 递归时间复杂度-展开求解</h3><p>像下面的递归式，都不能用主定理求解</p><p><strong>例1 - 递归求和</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">long</span> n)</span> {</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> n + sum(n - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><span class="math inline">\(T(n) = T(n-1) + c\)</span>，<span class="math inline">\(T(1) = c\)</span></p><p>下面为展开过程</p><p><span class="math inline">\(T(n) = T(n-2) + c + c\)</span></p><p><span class="math inline">\(T(n) = T(n-3) + c + c + c\)</span></p><p>...</p><p><span class="math inline">\(T(n) = T(n-(n-1)) + (n-1)c\)</span></p><ul><li>其中 <span class="math inline">\(T(n-(n-1))\)</span> 即 <span class="math inline">\(T(1)\)</span></li><li>带入求得 <span class="math inline">\(T(n) = c + (n-1)c =nc\)</span></li></ul><p>时间复杂度为 <span class="math inline">\(O(n)\)</span></p><p><strong>例2 - 递归冒泡排序</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> high)</span> {</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == high) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; high; i++) {</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) {</span><br><span class="line">            swap(a, i, i + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    bubble(a, high - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><span class="math inline">\(T(n) = T(n-1) + n\)</span>，<span class="math inline">\(T(1) = c\)</span></p><p>下面为展开过程</p><p><span class="math inline">\(T(n) = T(n-2) + (n-1) + n\)</span></p><p><span class="math inline">\(T(n) = T(n-3) + (n-2) + (n-1) +n\)</span></p><p>...</p><p><span class="math inline">\(T(n) = T(1) + 2 + ... + n = T(1) +(n-1)\frac{2+n}{2} = c + \frac{n^2}{2} + \frac{n}{2} -1\)</span></p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span></p><blockquote><p>注：</p><ul><li>等差数列求和为 <span class="math inline">\(个数*\frac{\vert首项-末项\vert}{2}\)</span></li></ul></blockquote><p><strong>例3 - 递归快排</strong></p><p>快速排序分区没分好的极端情况</p><p><span class="math inline">\(T(n) = T(n-1) + T(1) + n\)</span>，<span class="math inline">\(T(1) = c\)</span></p><p><span class="math inline">\(T(n) = T(n-1) + c + n\)</span></p><p>下面为展开过程</p><p><span class="math inline">\(T(n) = T(n-2) + c + (n-1) + c +n\)</span></p><p><span class="math inline">\(T(n) = T(n-3) + c + (n-2) + c + (n-1) + c+ n\)</span></p><p>...</p><p><span class="math inline">\(T(n) = T(n-(n-1)) + (n-1)c + 2+...+n =\frac{n^2}{2} + \frac{2cn+n}{2} -1\)</span></p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span></p><p>不会推导的同学可以进入 https://www.wolframalpha.com/</p><ul><li>例1 输入 f(n) = f(n - 1) + c, f(1) = c</li><li>例2 输入 f(n) = f(n - 1) + n, f(1) = c</li><li>例3 输入 f(n) = f(n - 1) + n + c, f(1) = c</li></ul><h2 id="队列">2.4 队列</h2><h3 id="概述-3">1) 概述</h3><p>计算机科学中，queue是以顺序的方式维护的一组数据集合，在一端添加数据，从另一端移除数据。习惯来说，添加的一端称为<strong>尾</strong>，移除的一端称为<strong>头</strong>，就如同生活中的排队买商品</p><blockquote><p>In computer science, a <strong>queue</strong> is a collection ofentities that are maintained in a sequence and can be modified by theaddition of entities at one end of the sequence and the removal ofentities from the other end of the sequence</p></blockquote><p>先定义一个简化的队列接口</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Queue</span>&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向队列尾插入值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 待插入值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 插入成功返回 true, 插入失败返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E value)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从对列头获取值, 并移除</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果队列非空返回对头值, 否则返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    E <span class="title function_">poll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从对列头获取值, 不移除</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果队列非空返回对头值, 否则返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    E <span class="title function_">peek</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查队列是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 空返回 true, 否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查队列是否已满</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 满返回 true, 否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="链表实现">2) 链表实现</h3><p>下面以<strong>单向环形带哨兵</strong>链表方式来实现队列</p><figure><img src="../../../../images/StrJava/image-20221230150105089.png" alt="image-20221230150105089"><figcaption aria-hidden="true">image-20221230150105089</figcaption></figure><figure><img src="../../../../images/StrJava/image-20221230150141318.png" alt="image-20221230150141318"><figcaption aria-hidden="true">image-20221230150141318</figcaption></figure><figure><img src="../../../../images/StrJava/image-20221230150153271.png" alt="image-20221230150153271"><figcaption aria-hidden="true">image-20221230150153271</figcaption></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListQueue</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt;, Iterable&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; {</span><br><span class="line">        E value;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E value, Node&lt;E&gt; next)</span> {</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; tail = head;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        tail.next = head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListQueue</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListQueue</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E value)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        Node&lt;E&gt; added = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(value, head);</span><br><span class="line">        tail.next = added;</span><br><span class="line">        tail = added;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        Node&lt;E&gt; first = head.next;</span><br><span class="line">        head.next = first.next;</span><br><span class="line">        <span class="keyword">if</span> (first == tail) {</span><br><span class="line">            tail = head;</span><br><span class="line">        }</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> first.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head.next.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> head == tail;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == capacity;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;E&gt;() {</span><br><span class="line">            Node&lt;E&gt; p = head.next;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> p != head;</span><br><span class="line">            }</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">                <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> p.value;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="环形数组实现">3) 环形数组实现</h3><p><strong>好处</strong></p><ol type="1"><li>对比普通数组，起点和终点更为自由，不用考虑数据移动</li><li>“环”意味着不会存在【越界】问题</li><li>数组性能更佳</li><li>环形数组比较适合实现有界队列、RingBuffer 等</li></ol><figure><img src="../../../../images/StrJava/image-20221228175413998.png" alt="image-20221228175413998"><figcaption aria-hidden="true">image-20221228175413998</figcaption></figure><p><strong>下标计算</strong></p><p>例如，数组长度是 5，当前位置是 3 ，向前走 2 步，此时下标为 <span class="math inline">\((3 + 2)\%5 = 0\)</span></p><figure><img src="../../../../images/StrJava/image-20221228180357257.png" alt="image-20221228180357257"><figcaption aria-hidden="true">image-20221228180357257</figcaption></figure><p><span class="math display">\[(cur + step) \% length\]</span></p><ul><li>cur 当前指针位置</li><li>step 前进步数</li><li>length 数组长度</li></ul><blockquote><p>注意：</p><ul><li>如果 step = 1，也就是一次走一步，可以在 &gt;= length 时重置为 0即可</li></ul></blockquote><p><strong>判断空</strong></p><figure><img src="../../../../images/StrJava/image-20221231081009018.png" alt="image-20221231081009018"><figcaption aria-hidden="true">image-20221231081009018</figcaption></figure><p><strong>判断满</strong></p><figure><img src="../../../../images/StrJava/image-20221231080909475.png" alt="image-20221231080909475"><figcaption aria-hidden="true">image-20221231080909475</figcaption></figure><p>满之后的策略可以根据业务需求决定</p><ul><li>例如我们要实现的环形队列，满之后就拒绝入队</li></ul><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueue</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt;, Iterable&lt;E&gt;{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> E[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings("all")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        length = capacity + <span class="number">1</span>;</span><br><span class="line">        array = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[length];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E value)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        array[tail] = value;</span><br><span class="line">        tail = (tail + <span class="number">1</span>) % length;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> array[head];</span><br><span class="line">        head = (head + <span class="number">1</span>) % length;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> array[head];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> tail == head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> (tail + <span class="number">1</span>) % length == head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;E&gt;() {</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> p != tail;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">                <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> array[p];</span><br><span class="line">                p = (p + <span class="number">1</span>) % array.length;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>判断空、满方法2</strong></p><p>引入 size</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueue2</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt;, Iterable&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> E[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings("all")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue2</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        array = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E value)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        array[tail] = value;</span><br><span class="line">        tail = (tail + <span class="number">1</span>) % capacity;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> array[head];</span><br><span class="line">        head = (head + <span class="number">1</span>) % capacity;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> array[head];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == capacity;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;E&gt;() {</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> p != tail;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">                <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> array[p];</span><br><span class="line">                p = (p + <span class="number">1</span>) % capacity;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>判断空、满方法3</strong></p><ul><li>head 和 tail 不断递增，用到索引时，再用它们进行计算，两个问题<ul><li><p>如何保证 head 和 tail 自增超过正整数最大值的正确性</p></li><li><p>如何让取模运算性能更高</p></li></ul></li><li>答案：让 capacity 为 2 的幂</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueue3</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt;, Iterable&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> E[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings("all")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue3</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        <span class="keyword">if</span> ((capacity &amp; capacity - <span class="number">1</span>) != <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"capacity 必须为 2 的幂"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        array = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="built_in">this</span>.capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E value)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        array[tail &amp; capacity - <span class="number">1</span>] = value;</span><br><span class="line">        tail++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> array[head &amp; capacity - <span class="number">1</span>];</span><br><span class="line">        head++;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> array[head &amp; capacity - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> tail - head == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> tail - head == capacity;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;E&gt;() {</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> p != tail;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">                <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> array[p &amp; capacity - <span class="number">1</span>];</span><br><span class="line">                p++;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="习题-3">习题</h3><h4 id="e01.-二叉树层序遍历-leetcode-102">E01. 二叉树层序遍历-Leetcode102</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        LinkedListQueue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedListQueue</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">// 本层节点个数</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 下层节点个数</span></span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c1; i++) {</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                    c2++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                    c2++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            c1 = c2;</span><br><span class="line">            result.add(level);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义队列</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LinkedListQueue</span>&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; {</span><br><span class="line">            E value;</span><br><span class="line">            Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E value, Node&lt;E&gt; next)</span> {</span><br><span class="line">                <span class="built_in">this</span>.value = value;</span><br><span class="line">                <span class="built_in">this</span>.next = next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;E&gt; head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">private</span> Node&lt;E&gt; tail = head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        {</span><br><span class="line">            tail.next = head;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LinkedListQueue</span><span class="params">()</span> {</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LinkedListQueue</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">            <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E value)</span> {</span><br><span class="line">            <span class="keyword">if</span> (isFull()) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            Node&lt;E&gt; added = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(value, head);</span><br><span class="line">            tail.next = added;</span><br><span class="line">            tail = added;</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line">            Node&lt;E&gt; first = head.next;</span><br><span class="line">            head.next = first.next;</span><br><span class="line">            <span class="keyword">if</span> (first == tail) {</span><br><span class="line">                tail = head;</span><br><span class="line">            }</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> first.value;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> head.next.value;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> head == tail;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> size == capacity;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="ex1.-设计队列-leetcode-622">Ex1. 设计队列-Leetcode 622</h4><p>由于与课堂例题差别不大，这里只给出参考解答</p><p>基于链表的实现</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ex1Leetcode622</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        Node next;</span><br><span class="line">        Node(<span class="type">int</span> value, Node next) {</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">tail</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        tail.next = head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Ex1Leetcode622</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">enQueue</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="keyword">if</span>(isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">added</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value, head);</span><br><span class="line">        tail.next = added;</span><br><span class="line">        tail = added;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deQueue</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> head.next;</span><br><span class="line">        head.next = first.next;</span><br><span class="line">        <span class="keyword">if</span> (first == tail) {</span><br><span class="line">            tail = head;</span><br><span class="line">        }</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Front</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head.next.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Rear</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> tail.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> head == tail;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == capacity;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意：</p><ul><li>Leetcode 的实现里deQueue（出队）返回值是布尔值，并不会返回队头元素</li><li>它期望用法是先用 Front 返回对头元素，再 deQueue 出队</li></ul><h2 id="栈">2.5 栈</h2><h3 id="概述-4">1) 概述</h3><p>计算机科学中，<strong>stack</strong>是一种线性的数据结构，只能在其一端添加数据和移除数据。习惯来说，这一端称之为<strong>栈顶</strong>，另一端不能操作数据的称之为<strong>栈底</strong>，就如同生活中的一摞书</p><p>先提供一个栈接口</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Stack</span>&lt;E&gt; {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向栈顶压入元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 待压入值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 压入成功返回 true, 否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">push</span><span class="params">(E value)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从栈顶弹出元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 栈非空返回栈顶元素, 栈为空返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    E <span class="title function_">pop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回栈顶元素, 不弹出</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 栈非空返回栈顶元素, 栈为空返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    E <span class="title function_">peek</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断栈是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 空返回 true, 否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断栈是否已满</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 满返回 true, 否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="链表实现-1">2) 链表实现</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListStack</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Stack</span>&lt;E&gt;, Iterable&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;E&gt; head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListStack</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">push</span><span class="params">(E value)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(value, head.next);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        Node&lt;E&gt; first = head.next;</span><br><span class="line">        head.next = first.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> first.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head.next.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> head.next == <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == capacity;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;E&gt;() {</span><br><span class="line">            Node&lt;E&gt; p = head.next;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> p != <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">                <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> p.value;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; {</span><br><span class="line">        E value;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E value, Node&lt;E&gt; next)</span> {</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="数组实现">3) 数组实现</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayStack</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Stack</span>&lt;E&gt;, Iterable&lt;E&gt;{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> E[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings("all")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        <span class="built_in">this</span>.array = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">push</span><span class="params">(E value)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        array[top++] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> array[--top];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> array[top-<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> top == array.length;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;E&gt;() {</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> top;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> p &gt; <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> array[--p];</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="应用">4) 应用</h3><p>模拟如下方法调用</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    System.out.println(<span class="string">"main1"</span>);</span><br><span class="line">    System.out.println(<span class="string">"main2"</span>);</span><br><span class="line">    method1();</span><br><span class="line">    method2();</span><br><span class="line">    System.out.println(<span class="string">"main3"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> {</span><br><span class="line">    System.out.println(<span class="string">"method1"</span>);</span><br><span class="line">    method3();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> {</span><br><span class="line">    System.out.println(<span class="string">"method2"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> {</span><br><span class="line">    System.out.println(<span class="string">"method3"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>模拟代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CPU</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Frame</span> {</span><br><span class="line">        <span class="type">int</span> exit;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Frame</span><span class="params">(<span class="type">int</span> exit)</span> {</span><br><span class="line">            <span class="built_in">this</span>.exit = exit;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">pc</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 模拟程序计数器 Program counter</span></span><br><span class="line">    <span class="keyword">static</span> ArrayStack&lt;Frame&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayStack</span>&lt;&gt;(<span class="number">100</span>); <span class="comment">// 模拟方法调用栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        stack.push(<span class="keyword">new</span> <span class="title class_">Frame</span>(-<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">            <span class="keyword">switch</span> (pc) {</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span> -&gt; {</span><br><span class="line">                    System.out.println(<span class="string">"main1"</span>);</span><br><span class="line">                    pc++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span> -&gt; {</span><br><span class="line">                    System.out.println(<span class="string">"main2"</span>);</span><br><span class="line">                    pc++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span> -&gt; {</span><br><span class="line">                    stack.push(<span class="keyword">new</span> <span class="title class_">Frame</span>(pc + <span class="number">1</span>));</span><br><span class="line">                    pc = <span class="number">100</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span> -&gt; {</span><br><span class="line">                    stack.push(<span class="keyword">new</span> <span class="title class_">Frame</span>(pc + <span class="number">1</span>));</span><br><span class="line">                    pc = <span class="number">200</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span> -&gt; {</span><br><span class="line">                    System.out.println(<span class="string">"main3"</span>);</span><br><span class="line">                    pc = stack.pop().exit;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">case</span> <span class="number">100</span> -&gt; {</span><br><span class="line">                    System.out.println(<span class="string">"method1"</span>);</span><br><span class="line">                    stack.push(<span class="keyword">new</span> <span class="title class_">Frame</span>(pc + <span class="number">1</span>));</span><br><span class="line">                    pc = <span class="number">300</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">case</span> <span class="number">101</span> -&gt; {</span><br><span class="line">                    pc = stack.pop().exit;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">case</span> <span class="number">200</span> -&gt; {</span><br><span class="line">                    System.out.println(<span class="string">"method2"</span>);</span><br><span class="line">                    pc = stack.pop().exit;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">case</span> <span class="number">300</span> -&gt; {</span><br><span class="line">                    System.out.println(<span class="string">"method3"</span>);</span><br><span class="line">                    pc = stack.pop().exit;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="习题-4">习题</h3><h4 id="e01.-有效的括号-leetcode-20">E01. 有效的括号-Leetcode 20</h4><p>一个字符串中可能出现 <code>[]</code> <code>()</code> 和<code>{}</code> 三种括号，判断该括号是否有效</p><p>有效的例子</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">()[]{}</span><br><span class="line"></span><br><span class="line">([{}])</span><br><span class="line"></span><br><span class="line">()</span><br></pre></td></tr></tbody></table></figure><p>无效的例子</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[)</span><br><span class="line"></span><br><span class="line">([)]</span><br><span class="line"></span><br><span class="line">([]</span><br></pre></td></tr></tbody></table></figure><p>思路</p><ul><li>遇到左括号, 把要配对的右括号放入栈顶</li><li>遇到右括号, 若此时栈为空, 返回 false，否则把它与栈顶元素对比<ul><li>若相等, 栈顶元素弹出, 继续对比下一组</li><li>若不等, 无效括号直接返回 false</li></ul></li><li>循环结束<ul><li>若栈为空, 表示所有括号都配上对, 返回 true</li><li>若栈不为空, 表示右没配对的括号, 应返回 false</li></ul></li></ul><p>答案（用到了课堂案例中的 ArrayStack 类）</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> {</span><br><span class="line">    ArrayStack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayStack</span>&lt;&gt;(s.length() / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) {</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'('</span>) {</span><br><span class="line">            stack.push(<span class="string">')'</span>);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'['</span>) {</span><br><span class="line">            stack.push(<span class="string">']'</span>);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'{'</span>) {</span><br><span class="line">            stack.push(<span class="string">'}'</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; stack.peek() == c) {</span><br><span class="line">                stack.pop();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e02.-后缀表达式求值-leetcode-120">E02. 后缀表达式求值-Leetcode120</h4><p>后缀表达式也称为逆波兰表达式，即运算符写在后面</p><ul><li>从左向右进行计算</li><li>不必考虑运算符优先级，即不用包含括号</li></ul><p>示例</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：tokens = ["2","1","+","3","*"]</span><br><span class="line">输出：9</span><br><span class="line">即：(2 + 1) * 3</span><br><span class="line"></span><br><span class="line">输入：tokens = ["4","13","5","/","+"]</span><br><span class="line">输出：6</span><br><span class="line">即：4 + (13 / 5)</span><br></pre></td></tr></tbody></table></figure><p>题目假设</p><ul><li>数字都视为整数</li><li>数字和运算符个数给定正确，不会有除零发生</li></ul><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> {</span><br><span class="line">    LinkedList&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String t : tokens) {</span><br><span class="line">        <span class="keyword">switch</span> (t) {</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"+"</span> -&gt; {</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> numbers.pop();</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> numbers.pop();</span><br><span class="line">                numbers.push(a + b);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"-"</span> -&gt; {</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> numbers.pop();</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> numbers.pop();</span><br><span class="line">                numbers.push(a - b);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"*"</span> -&gt; {</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> numbers.pop();</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> numbers.pop();</span><br><span class="line">                numbers.push(a * b);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"/"</span> -&gt; {</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> numbers.pop();</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> numbers.pop();</span><br><span class="line">                numbers.push(a / b);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">default</span> -&gt; numbers.push(Integer.parseInt(t));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> numbers.pop();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e03.-中缀表达式转后缀">E03. 中缀表达式转后缀</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E03InfixToSuffix</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        思路</span></span><br><span class="line"><span class="comment">        1. 遇到数字, 拼串</span></span><br><span class="line"><span class="comment">        2. 遇到 + - * /</span></span><br><span class="line"><span class="comment">            - 优先级高于栈顶运算符 入栈</span></span><br><span class="line"><span class="comment">            - 否则将栈中高级或平级运算符出栈拼串, 本运算符入栈</span></span><br><span class="line"><span class="comment">        3. 遍历完成, 栈中剩余运算符出栈拼串</span></span><br><span class="line"><span class="comment">            - 先出栈,意味着优先运算</span></span><br><span class="line"><span class="comment">        4. 带 ()</span></span><br><span class="line"><span class="comment">            - 左括号直接入栈</span></span><br><span class="line"><span class="comment">            - 右括号要将栈中直至左括号为止的运算符出栈拼串</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        |   |</span></span><br><span class="line"><span class="comment">        |   |</span></span><br><span class="line"><span class="comment">        |   |</span></span><br><span class="line"><span class="comment">        _____</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        a+b</span></span><br><span class="line"><span class="comment">        a+b-c</span></span><br><span class="line"><span class="comment">        a+b*c</span></span><br><span class="line"><span class="comment">        a*b+c</span></span><br><span class="line"><span class="comment">        (a+b)*c</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(infixToSuffix(<span class="string">"a+b"</span>));</span><br><span class="line">        System.out.println(infixToSuffix(<span class="string">"a+b-c"</span>));</span><br><span class="line">        System.out.println(infixToSuffix(<span class="string">"a+b*c"</span>));</span><br><span class="line">        System.out.println(infixToSuffix(<span class="string">"a*b-c"</span>));</span><br><span class="line">        System.out.println(infixToSuffix(<span class="string">"(a+b)*c"</span>));</span><br><span class="line">        System.out.println(infixToSuffix(<span class="string">"a+b*c+(d*e+f)*g"</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">infixToSuffix</span><span class="params">(String exp)</span> {</span><br><span class="line">        LinkedList&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(exp.length());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; exp.length(); i++) {</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> exp.charAt(i);</span><br><span class="line">            <span class="keyword">switch</span> (c) {</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>, <span class="string">'-'</span>, <span class="string">'*'</span>, <span class="string">'/'</span> -&gt; {</span><br><span class="line">                    <span class="keyword">if</span> (stack.isEmpty()) {</span><br><span class="line">                        stack.push(c);</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        <span class="keyword">if</span> (priority(c) &gt; priority(stack.peek())) {</span><br><span class="line">                            stack.push(c);</span><br><span class="line">                        } <span class="keyword">else</span> {</span><br><span class="line">                            <span class="keyword">while</span> (!stack.isEmpty() </span><br><span class="line">                                   &amp;&amp; priority(stack.peek()) &gt;= priority(c)) {</span><br><span class="line">                                sb.append(stack.pop());</span><br><span class="line">                            }</span><br><span class="line">                            stack.push(c);</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'('</span> -&gt; {</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span> -&gt; {</span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() != <span class="string">'('</span>) {</span><br><span class="line">                        sb.append(stack.pop());</span><br><span class="line">                    }</span><br><span class="line">                    stack.pop();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">default</span> -&gt; {</span><br><span class="line">                    sb.append(c);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">            sb.append(stack.pop());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">priority</span><span class="params">(<span class="type">char</span> c)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">switch</span> (c) {</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span> -&gt; <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>, <span class="string">'/'</span> -&gt; <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>, <span class="string">'-'</span> -&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"不合法字符:"</span> + c);</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e04.-双栈模拟队列-leetcode-232">E04. 双栈模拟队列-Leetcode232</h4><p>给力扣题目用的<strong>自实现</strong>栈，可以定义为静态内部类</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span>&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> E[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> top; <span class="comment">// 栈顶指针</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings("all")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        <span class="built_in">this</span>.array = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">push</span><span class="params">(E value)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        array[top++] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> array[--top];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> array[top - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> top == array.length;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>参考解答，注意：题目已说明</p><ul><li>调用 push、pop 等方法的次数最多 100</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E04Leetcode232</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        队列头      队列尾</span></span><br><span class="line"><span class="comment">        s1       s2</span></span><br><span class="line"><span class="comment">        顶   底   底   顶</span></span><br><span class="line"><span class="comment">                 abc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        push(a)</span></span><br><span class="line"><span class="comment">        push(b)</span></span><br><span class="line"><span class="comment">        push(c)</span></span><br><span class="line"><span class="comment">        pop()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ArrayStack&lt;Integer&gt; s1 = <span class="keyword">new</span> <span class="title class_">ArrayStack</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">    ArrayStack&lt;Integer&gt; s2 = <span class="keyword">new</span> <span class="title class_">ArrayStack</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        s2.push(x);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (s1.isEmpty()) {</span><br><span class="line">            <span class="keyword">while</span> (!s2.isEmpty()) {</span><br><span class="line">                s1.push(s2.pop());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s1.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (s1.isEmpty()) {</span><br><span class="line">            <span class="keyword">while</span> (!s2.isEmpty()) {</span><br><span class="line">                s1.push(s2.pop());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s1.peek();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> s1.isEmpty() &amp;&amp; s2.isEmpty();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e05.-单队列模拟栈-leetcode-225">E05. 单队列模拟栈-Leetcode225</h4><p>给力扣题目用的<strong>自实现</strong>队列，可以定义为静态内部类</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueue3</span>&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> E[] array;</span><br><span class="line">    <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings("all")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue3</span><span class="params">(<span class="type">int</span> c)</span> {</span><br><span class="line">        c -= <span class="number">1</span>;</span><br><span class="line">        c |= c &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        c |= c &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        c |= c &gt;&gt; <span class="number">4</span>;</span><br><span class="line">        c |= c &gt;&gt; <span class="number">8</span>;</span><br><span class="line">        c |= c &gt;&gt; <span class="number">16</span>;</span><br><span class="line">        c += <span class="number">1</span>;</span><br><span class="line">        array = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[c];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E value)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }        </span><br><span class="line">        array[tail &amp; (array.length - <span class="number">1</span>)] = value;</span><br><span class="line">        tail++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> array[head &amp; (array.length - <span class="number">1</span>)];</span><br><span class="line">        head++;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> array[head &amp; (array.length - <span class="number">1</span>)];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> head == tail;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> tail - head == array.length;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>参考解答，注意：题目已说明</p><ul><li>调用 push、pop 等方法的次数最多 100</li><li>每次调用 pop 和 top 都能保证栈不为空</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E05Leetcode225</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        队列头     队列尾</span></span><br><span class="line"><span class="comment">        cba</span></span><br><span class="line"><span class="comment">        顶           底</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        queue.offer(a)</span></span><br><span class="line"><span class="comment">        queue.offer(b)</span></span><br><span class="line"><span class="comment">        queue.offer(c)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ArrayQueue3&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayQueue3</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">        }</span><br><span class="line">        size++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="双端队列">2.6 双端队列</h2><h3 id="概述-5">1) 概述</h3><p>双端队列、队列、栈对比</p><table><colgroup><col style="width: 20%"><col style="width: 48%"><col style="width: 31%"></colgroup><thead><tr class="header"><th></th><th>定义</th><th>特点</th></tr></thead><tbody><tr class="odd"><td>队列</td><td>一端删除（头）另一端添加（尾）</td><td>First In First Out</td></tr><tr class="even"><td>栈</td><td>一端删除和添加（顶）</td><td>Last In First Out</td></tr><tr class="odd"><td>双端队列</td><td>两端都可以删除、添加</td><td></td></tr><tr class="even"><td>优先级队列</td><td></td><td>优先级高者先出队</td></tr><tr class="odd"><td>延时队列</td><td></td><td>根据延时时间确定优先级</td></tr><tr class="even"><td>并发非阻塞队列</td><td>队列空或满时不阻塞</td><td></td></tr><tr class="odd"><td>并发阻塞队列</td><td>队列空时删除阻塞、队列满时添加阻塞</td><td></td></tr></tbody></table><blockquote><p>注1：</p><ul><li>Java 中 LinkedList 即为典型双端队列实现，不过它同时实现了 Queue接口，也提供了栈的 push pop 等方法</li></ul><p>注2：</p><ul><li><p>不同语言，操作双端队列的方法命名有所不同，参见下表</p><table><thead><tr class="header"><th>操作</th><th>Java</th><th>JavaScript</th><th>C++</th><th>leetCode 641</th></tr></thead><tbody><tr class="odd"><td>尾部插入</td><td>offerLast</td><td>push</td><td>push_back</td><td>insertLast</td></tr><tr class="even"><td>头部插入</td><td>offerFirst</td><td>unshift</td><td>push_front</td><td>insertFront</td></tr><tr class="odd"><td>尾部移除</td><td>pollLast</td><td>pop</td><td>pop_back</td><td>deleteLast</td></tr><tr class="even"><td>头部移除</td><td>pollFirst</td><td>shift</td><td>pop_front</td><td>deleteFront</td></tr><tr class="odd"><td>尾部获取</td><td>peekLast</td><td>at(-1)</td><td>back</td><td>getRear</td></tr><tr class="even"><td>头部获取</td><td>peekFirst</td><td>at(0)</td><td>front</td><td>getFront</td></tr></tbody></table></li><li><p>吐槽一下 leetCode 命名比较 low</p></li><li><p>常见的单词还有 enqueue 入队、dequeue 出队</p></li></ul></blockquote><p><strong>接口定义</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Deque</span>&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    E <span class="title function_">pollFirst</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    E <span class="title function_">pollLast</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    E <span class="title function_">peekFirst</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    E <span class="title function_">peekLast</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="链表实现-2">2) 链表实现</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于环形链表的双端队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt; 元素类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListDeque</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Deque</span>&lt;E&gt;, Iterable&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        size++;</span><br><span class="line">        Node&lt;E&gt; a = sentinel;</span><br><span class="line">        Node&lt;E&gt; b = sentinel.next;</span><br><span class="line">        Node&lt;E&gt; offered = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(a, e, b);</span><br><span class="line">        a.next = offered;</span><br><span class="line">        b.prev = offered;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        size++;</span><br><span class="line">        Node&lt;E&gt; a = sentinel.prev;</span><br><span class="line">        Node&lt;E&gt; b = sentinel;</span><br><span class="line">        Node&lt;E&gt; offered = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(a, e, b);</span><br><span class="line">        a.next = offered;</span><br><span class="line">        b.prev = offered;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        Node&lt;E&gt; a = sentinel;</span><br><span class="line">        Node&lt;E&gt; polled = sentinel.next;</span><br><span class="line">        Node&lt;E&gt; b = polled.next;</span><br><span class="line">        a.next = b;</span><br><span class="line">        b.prev = a;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> polled.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        Node&lt;E&gt; polled = sentinel.prev;</span><br><span class="line">        Node&lt;E&gt; a = polled.prev;</span><br><span class="line">        Node&lt;E&gt; b = sentinel;</span><br><span class="line">        a.next = b;</span><br><span class="line">        b.prev = a;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> polled.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peekFirst</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sentinel.next.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peekLast</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sentinel.prev.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == capacity;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;E&gt;() {</span><br><span class="line">            Node&lt;E&gt; p = sentinel.next;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> p != sentinel;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">                <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> p.value;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; {</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        E value;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Node&lt;E&gt; prev, E value, Node&lt;E&gt; next)</span> {</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; sentinel = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListDeque</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        sentinel.next = sentinel;</span><br><span class="line">        sentinel.prev = sentinel;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="数组实现-1">3) 数组实现</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于循环数组实现, 特点</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;tail 停下来的位置不存储, 会浪费一个位置&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDeque1</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Deque</span>&lt;E&gt;, Iterable&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    h</span></span><br><span class="line"><span class="comment">            t</span></span><br><span class="line"><span class="comment">        0   1   2   3</span></span><br><span class="line"><span class="comment">        b           a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        head = dec(head, array.length);</span><br><span class="line">        array[head] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        array[tail] = e;</span><br><span class="line">        tail = inc(tail, array.length);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> array[head];</span><br><span class="line">        array[head] = <span class="literal">null</span>;</span><br><span class="line">        head = inc(head, array.length);</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        tail = dec(tail, array.length);</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> array[tail];</span><br><span class="line">        array[tail] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peekFirst</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> array[head];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peekLast</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> array[dec(tail, array.length)];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> head == tail;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (tail &gt; head) {</span><br><span class="line">            <span class="keyword">return</span> tail - head == array.length - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (tail &lt; head) {</span><br><span class="line">            <span class="keyword">return</span> head - tail == <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;E&gt;() {</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> p != tail;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">                <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> array[p];</span><br><span class="line">                p = inc(p, array.length);</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    E[] array;</span><br><span class="line">    <span class="type">int</span> head;</span><br><span class="line">    <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayDeque1</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        array = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity + <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> length)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= length) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> length)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i - <span class="number">1</span> &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> length - <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>数组实现中，如果存储的是基本类型，那么无需考虑内存释放，例如</p><figure><img src="../../../../images/StrJava/image-20230110084245095.png" alt="image-20230110084245095"><figcaption aria-hidden="true">image-20230110084245095</figcaption></figure><p>但如果存储的是引用类型，应当设置该位置的引用为null，以便内存及时释放</p><figure><img src="../../../../images/StrJava/image-20230110084632543.png" alt="image-20230110084632543"><figcaption aria-hidden="true">image-20230110084632543</figcaption></figure><h3 id="习题-5">习题</h3><h4 id="e01.-二叉树-z-字层序遍历-leetcode-103">E01. 二叉树 Z字层序遍历-Leetcode 103</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E01Leetcode103</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">leftToRight</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            LinkedList&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c1; i++) {</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">n</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (leftToRight) {</span><br><span class="line">                    deque.offerLast(n.val);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    deque.offerFirst(n.val);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (n.left != <span class="literal">null</span>) {</span><br><span class="line">                    queue.offer(n.left);</span><br><span class="line">                    c2++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (n.right != <span class="literal">null</span>) {</span><br><span class="line">                    queue.offer(n.right);</span><br><span class="line">                    c2++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            c1 = c2;</span><br><span class="line">            leftToRight = !leftToRight;</span><br><span class="line">            result.add(deque);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">TreeNode</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">4</span>),</span><br><span class="line">                        <span class="number">2</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">5</span>)</span><br><span class="line">                ),</span><br><span class="line">                <span class="number">1</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">TreeNode</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">6</span>),</span><br><span class="line">                        <span class="number">3</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">7</span>)</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> <span class="title class_">E01Leetcode103</span>().zigzagLevelOrder(root);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : lists) {</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="ex1.-设计双端队列-leetcode-641">Ex1. 设计双端队列-Leetcode641</h4><p>与课堂例题也是差别不大，略</p><h2 id="优先级队列">2.7 优先级队列</h2><h3 id="无序数组实现">1) 无序数组实现</h3><p><strong>要点</strong></p><ol type="1"><li>入队保持顺序</li><li>出队前找到优先级最高的出队，相当于一次选择排序</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueue1</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Priority</span>&gt; <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    Priority[] array;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PriorityQueue1</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        array = <span class="keyword">new</span> <span class="title class_">Priority</span>[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        array[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回优先级最高的索引值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">selectMax</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; size; i++) {</span><br><span class="line">            <span class="keyword">if</span> (array[i].priority() &gt; array[max].priority()) {</span><br><span class="line">                max = i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// O(n)</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> selectMax();</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) array[max];</span><br><span class="line">        remove(max);</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="keyword">if</span> (index &lt; size - <span class="number">1</span>) {</span><br><span class="line">            System.arraycopy(array, index + <span class="number">1</span>,</span><br><span class="line">                    array, index, size - <span class="number">1</span> - index);</span><br><span class="line">        }</span><br><span class="line">        array[--size] = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> selectMax();</span><br><span class="line">        <span class="keyword">return</span> (E) array[max];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == array.length;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>视频中忘记了 help GC，注意一下</li></ul><h3 id="有序数组实现">2) 有序数组实现</h3><p><strong>要点</strong></p><ol type="1"><li>入队后排好序，优先级最高的排列在尾部</li><li>出队只需删除尾部元素即可</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueue2</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Priority</span>&gt; <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    Priority[] array;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PriorityQueue2</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        array = <span class="keyword">new</span> <span class="title class_">Priority</span>[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(n)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        insert(e);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一轮插入排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(E e)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; array[i].priority() &gt; e.priority()) {</span><br><span class="line">            array[i + <span class="number">1</span>] = array[i];</span><br><span class="line">            i--;</span><br><span class="line">        }</span><br><span class="line">        array[i + <span class="number">1</span>] = e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(1)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) array[size - <span class="number">1</span>];</span><br><span class="line">        array[--size] = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> (E) array[size - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == array.length;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="堆实现">3) 堆实现</h3><p>计算机科学中，堆是一种基于树的数据结构，通常用<strong>完全二叉树</strong>实现。堆的特性如下</p><ul><li>在大顶堆中，任意节点 C 与它的父节点 P 符合 <span class="math inline">\(P.value \geq C.value\)</span></li><li>而小顶堆中，任意节点 C 与它的父节点 P 符合 <span class="math inline">\(P.value \leq C.value\)</span></li><li>最顶层的节点（没有父亲）称之为 root 根节点</li></ul><blockquote><p>In computer science, a <strong>heap</strong> is a specializedtree-based data structure which is essentially an almost complete treethat satisfies the <strong>heap property</strong>: in a <em>maxheap</em>, for any given node C, if P is a parent node of C, then the<em>key</em> (the <em>value</em>) of P is greater than or equal to thekey of C. In a <em>min heap</em>, the key of P is less than or equal tothe key of C. The node at the "top" of the heap (with no parents) iscalled the <strong>root</strong> node</p></blockquote><p>例1 - 满二叉树（Full Binary Tree）特点：每一层都是填满的</p><figure><img src="../../../../images/StrJava/image-20230112171444699.png" alt="image-20230112171444699"><figcaption aria-hidden="true">image-20230112171444699</figcaption></figure><p>例2 - 完全二叉树（Complete BinaryTree）特点：最后一层可能未填满，靠左对齐</p><figure><img src="../../../../images/StrJava/image-20230112171917135.png" alt="image-20230112171917135"><figcaption aria-hidden="true">image-20230112171917135</figcaption></figure><p>例3 - 大顶堆</p><figure><img src="../../../../images/StrJava/image-20230112170242265.png" alt="image-20230112170242265"><figcaption aria-hidden="true">image-20230112170242265</figcaption></figure><p>例4 - 小顶堆</p><figure><img src="../../../../images/StrJava/image-20230112171236067.png" alt="image-20230112171236067"><figcaption aria-hidden="true">image-20230112171236067</figcaption></figure><p>完全二叉树可以使用数组来表示</p><figure><img src="../../../../images/StrJava/image-20230112174351649.png" alt="image-20230112174351649"><figcaption aria-hidden="true">image-20230112174351649</figcaption></figure><p>特征</p><ul><li>如果从索引 0 开始存储节点数据<ul><li>节点 <span class="math inline">\(i\)</span> 的父节点为 <span class="math inline">\(floor((i-1)/2)\)</span>，当 <span class="math inline">\(i&gt;0\)</span> 时</li><li>节点 <span class="math inline">\(i\)</span> 的左子节点为 <span class="math inline">\(2i+1\)</span>，右子节点为 <span class="math inline">\(2i+2\)</span>，当然它们得 <span class="math inline">\(&lt; size\)</span></li></ul></li><li>如果从索引 1 开始存储节点数据<ul><li>节点 <span class="math inline">\(i\)</span> 的父节点为 <span class="math inline">\(floor(i/2)\)</span>，当 <span class="math inline">\(i &gt; 1\)</span> 时</li><li>节点 <span class="math inline">\(i\)</span> 的左子节点为 <span class="math inline">\(2i\)</span>，右子节点为 <span class="math inline">\(2i+1\)</span>，同样得 <span class="math inline">\(&lt; size\)</span></li></ul></li></ul><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueue4</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Priority</span>&gt; <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    Priority[] array;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PriorityQueue4</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        array = <span class="keyword">new</span> <span class="title class_">Priority</span>[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E offered)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> size++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (child &gt; <span class="number">0</span> &amp;&amp; offered.priority() &gt; array[parent].priority()) {</span><br><span class="line">            array[child] = array[parent];</span><br><span class="line">            child = parent;</span><br><span class="line">            parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">        array[child] = offered;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">Priority</span> <span class="variable">t</span> <span class="operator">=</span> array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = t;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        swap(<span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="type">Priority</span> <span class="variable">e</span> <span class="operator">=</span> array[size];</span><br><span class="line">        array[size] = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        shiftDown(<span class="number">0</span>);        </span><br><span class="line">        <span class="keyword">return</span> (E) e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shiftDown</span><span class="params">(<span class="type">int</span> parent)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> parent;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; size &amp;&amp; array[left].priority() &gt; array[max].priority()) {</span><br><span class="line">            max = left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; array[right].priority() &gt; array[max].priority()) {</span><br><span class="line">            max = right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (max != parent) {</span><br><span class="line">            swap(max, parent);</span><br><span class="line">            shiftDown(max);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> (E) array[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == array.length;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="习题-6">习题</h3><h4 id="e01.-合并多个有序链表-leetcode-23">E01.合并多个有序链表-Leetcode 23</h4><p>这道题目之前解答过，现在用刚学的优先级队列来实现一下</p><p>题目中要从小到大排列，因此选择用小顶堆来实现，自定义小顶堆如下</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinHeap</span> {</span><br><span class="line"></span><br><span class="line">    ListNode[] array;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinHeap</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        array = <span class="keyword">new</span> <span class="title class_">ListNode</span>[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(ListNode offered)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> size++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (child &gt; <span class="number">0</span> &amp;&amp; offered.val &lt; array[parent].val) {</span><br><span class="line">            array[child] = array[parent];</span><br><span class="line">            child = parent;</span><br><span class="line">            parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">        array[child] = offered;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        swap(<span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">e</span> <span class="operator">=</span> array[size];</span><br><span class="line">        array[size] = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line"></span><br><span class="line">        down(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span> parent)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> parent;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; size &amp;&amp; array[left].val &lt; array[min].val) {</span><br><span class="line">            min = left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; array[right].val &lt; array[min].val) {</span><br><span class="line">            min = right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (min != parent) {</span><br><span class="line">            swap(min, parent);</span><br><span class="line">            down(min);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = t;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E01Leetcode23</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> {</span><br><span class="line">        <span class="comment">// 1. 使用 jdk 的优先级队列实现</span></span><br><span class="line"><span class="comment">//        PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;(Comparator.comparingInt(a -&gt; a.val));</span></span><br><span class="line">        <span class="comment">// 2. 使用自定义小顶堆实现</span></span><br><span class="line">        <span class="type">MinHeap</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MinHeap</span>(lists.length);</span><br><span class="line">        <span class="keyword">for</span> (ListNode head : lists) {</span><br><span class="line">            <span class="keyword">if</span> (head != <span class="literal">null</span>) {</span><br><span class="line">                queue.offer(head);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> s;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            p.next = node;</span><br><span class="line">            p = node;</span><br><span class="line">            <span class="keyword">if</span> (node.next != <span class="literal">null</span>) {</span><br><span class="line">                queue.offer(node.next);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>提问：</p><ul><li>能否将每个链表的所有元素全部加入堆，再一个个从堆顶移除？</li></ul><p>回答：</p><ul><li>可以是可以，但对空间占用就高了，堆的一个优点就是用有限的空间做事情</li></ul><h2 id="阻塞队列">2.8 阻塞队列</h2><p>之前的队列在很多场景下都不能很好地工作，例如</p><ol type="1"><li>大部分场景要求分离向队列放入（生产者）、从队列拿出（消费者）两个角色、它们得由不同的线程来担当，而之前的实现根本没有考虑线程安全问题</li><li>队列为空，那么在之前的实现里会返回null，如果就是硬要拿到一个元素呢？只能不断循环尝试</li><li>队列为满，那么再之前的实现里会返回false，如果就是硬要塞入一个元素呢？只能不断循环尝试</li></ol><p>因此我们需要解决的问题有</p><ol type="1"><li>用锁保证线程安全</li><li>用条件变量让<strong>等待非空线程</strong>与<strong>等待不满线程</strong>进入<strong>等待</strong>状态，而不是不断循环尝试，让CPU 空转</li></ol><p>有同学对线程安全还没有足够的认识，下面举一个反例，两个线程都要执行入队操作（几乎在同一时刻）</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadUnsafe</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] array = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(String e)</span> {</span><br><span class="line">        array[tail] = e;</span><br><span class="line">        tail++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(array);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">TestThreadUnsafe</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestThreadUnsafe</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; queue.offer(<span class="string">"e1"</span>), <span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; queue.offer(<span class="string">"e2"</span>), <span class="string">"t2"</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>执行的时间序列如下，假设初始状态 tail = 0，在执行过程中由于 CPU在两个线程之间切换，造成了指令交错</p><table><colgroup><col style="width: 15%"><col style="width: 15%"><col style="width: 68%"></colgroup><thead><tr class="header"><th>线程1</th><th>线程2</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>array[tail]=e1</td><td></td><td>线程1 向 tail 位置加入 e1 这个元素，但还没来得及执行 tail++</td></tr><tr class="even"><td></td><td>array[tail]=e2</td><td>线程2 向 tail 位置加入 e2 这个元素，覆盖掉了 e1</td></tr><tr class="odd"><td></td><td>tail++</td><td>tail 自增为1</td></tr><tr class="even"><td>tail++</td><td></td><td>tail 自增为2</td></tr><tr class="odd"><td></td><td></td><td>最后状态 tail 为 2，数组为 [e2, null, null ...]</td></tr></tbody></table><p>糟糕的是，由于指令交错的顺序不同，得到的结果不止以上一种，宏观上造成混乱的效果</p><h3 id="单锁实现">1) 单锁实现</h3><p>Java 中要防止代码段交错执行，需要使用锁，有两种选择</p><ul><li>synchronized 代码块，属于关键字级别提供锁保护，功能少</li><li>ReentrantLock 类，功能丰富</li></ul><p>以 ReentrantLock 为例</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(String e)</span> {</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        array[tail] = e;</span><br><span class="line">        tail++;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>只要两个线程执行上段代码时，锁对象是同一个，就能保证 try块内的代码的执行不会出现指令交错现象，即执行顺序只可能是下面两种情况之一</p><table><colgroup><col style="width: 22%"><col style="width: 22%"><col style="width: 55%"></colgroup><thead><tr class="header"><th>线程1</th><th>线程2</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>lock.lockInterruptibly()</td><td></td><td>t1对锁对象上锁</td></tr><tr class="even"><td>array[tail]=e1</td><td></td><td></td></tr><tr class="odd"><td></td><td>lock.lockInterruptibly()</td><td>即使 CPU切换到线程2，但由于t1已经对该对象上锁，因此线程2卡在这儿进不去</td></tr><tr class="even"><td>tail++</td><td></td><td>切换回线程1 执行后续代码</td></tr><tr class="odd"><td>lock.unlock()</td><td></td><td>线程1 解锁</td></tr><tr class="even"><td></td><td>array[tail]=e2</td><td>线程2 此时才能获得锁，执行它的代码</td></tr><tr class="odd"><td></td><td>tail++</td><td></td></tr></tbody></table><ul><li>另一种情况是线程2 先获得锁，线程1 被挡在外面</li><li>要明白<strong>保护的本质</strong>，本例中是保护的是 tail位置读写的安全</li></ul><p>事情还没有完，上面的例子是队列还没有放满的情况，考虑下面的代码（这回锁同时保护了tail 和 size 的读写安全）</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(String e)</span> {</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span>(isFull()) {</span><br><span class="line">            <span class="comment">// 满了怎么办?</span></span><br><span class="line">        }</span><br><span class="line">        array[tail] = e;</span><br><span class="line">        tail++;</span><br><span class="line">        </span><br><span class="line">        size++;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> size == array.length;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>之前是返回 false 表示添加失败，前面分析过想达到这么一种效果：</p><ul><li>在队列满时，不是立刻返回，而是当前线程进入等待</li><li>什么时候队列不满了，再唤醒这个等待的线程，从上次的代码处继续向下运行</li></ul><p>ReentrantLock 可以配合条件变量来实现，代码进化为</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">tailWaits</span> <span class="operator">=</span> lock.newCondition(); <span class="comment">// 条件变量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(String e)</span> {</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">while</span> (isFull()) {</span><br><span class="line">            tailWaits.await();<span class="comment">// 当队列满时, 当前线程进入 tailWaits 等待</span></span><br><span class="line">        }</span><br><span class="line">        array[tail] = e;</span><br><span class="line">        tail++;</span><br><span class="line">        </span><br><span class="line">        size++;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> size == array.length;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>条件变量底层也是个队列，用来存储这些需要等待的线程，当队列满了，就会将offer 线程加入条件队列，并暂时释放锁</li><li>将来我们的队列如果不满了（由 poll 线程那边得知）可以调用tailWaits.signal() 来唤醒 tailWaits中首个等待的线程，被唤醒的线程会再次抢到锁，从上次 await处继续向下运行</li></ul><p>思考为何要用 while 而不是 if，设队列容量是 3</p><table><colgroup><col style="width: 7%"><col style="width: 27%"><col style="width: 29%"><col style="width: 27%"><col style="width: 9%"></colgroup><thead><tr class="header"><th>操作前</th><th>offer(4)</th><th>offer(5)</th><th>poll()</th><th>操作后</th></tr></thead><tbody><tr class="odd"><td>[1 2 3]</td><td>队列满，进入tailWaits 等待</td><td></td><td></td><td>[1 2 3]</td></tr><tr class="even"><td>[1 2 3]</td><td></td><td></td><td>取走 1，队列不满，唤醒线程</td><td>[2 3]</td></tr><tr class="odd"><td>[2 3]</td><td></td><td>抢先获得锁，发现不满，放入 5</td><td></td><td>[2 3 5]</td></tr><tr class="even"><td>[2 3 5]</td><td>从上次等待处直接向下执行</td><td></td><td></td><td>[2 3 5 ?]</td></tr></tbody></table><p>关键点：</p><ul><li>从 tailWaits 中唤醒的线程，会与新来的 offer的线程争抢锁，谁能抢到是不一定的，如果后者先抢到，就会导致条件又发生变化</li><li>这种情况称之为<strong>虚假唤醒</strong>，唤醒后应该重新检查条件，看是不是得重新进入等待</li></ul><p>最后的实现代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单锁实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt; 元素类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueue1</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt; {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> E[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings("all")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockingQueue1</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        array = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">tailWaits</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">headWaits</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (isFull()) {</span><br><span class="line">                tailWaits.await();</span><br><span class="line">            }</span><br><span class="line">            array[tail] = e;</span><br><span class="line">            <span class="keyword">if</span> (++tail == array.length) {</span><br><span class="line">                tail = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            size++;</span><br><span class="line">            headWaits.signal();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(E e, <span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> TimeUnit.MILLISECONDS.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (isFull()) {</span><br><span class="line">                <span class="keyword">if</span> (t &lt;= <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">                t = tailWaits.awaitNanos(t);</span><br><span class="line">            }</span><br><span class="line">            array[tail] = e;</span><br><span class="line">            <span class="keyword">if</span> (++tail == array.length) {</span><br><span class="line">                tail = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            size++;</span><br><span class="line">            headWaits.signal();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (isEmpty()) {</span><br><span class="line">                headWaits.await();</span><br><span class="line">            }</span><br><span class="line">            <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> array[head];</span><br><span class="line">            array[head] = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">            <span class="keyword">if</span> (++head == array.length) {</span><br><span class="line">                head = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            size--;</span><br><span class="line">            tailWaits.signal();</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == array.length;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>public void offer(E e, long timeout) throws InterruptedException是带超时的版本，可以只等待一段时间，而不是永久等下去，类似的 poll也可以做带超时的版本，这个留给大家了</li></ul><blockquote><p><strong>注意</strong></p><ul><li>JDK 中 BlockingQueue 接口的方法命名与我的示例有些差异<ul><li>方法 offer(E e) 是非阻塞的实现，阻塞实现方法为 put(E e)</li><li>方法 poll() 是非阻塞的实现，阻塞实现方法为 take()</li></ul></li></ul></blockquote><h3 id="双锁实现">2) 双锁实现</h3><p>单锁的缺点在于：</p><ul><li>生产和消费几乎是不冲突的，唯一冲突的是生产者和消费者它们有可能同时修改size</li><li>冲突的主要是生产者之间：多个 offer 线程修改 tail</li><li>冲突的还有消费者之间：多个 poll 线程修改 head</li></ul><p>如果希望进一步提高性能，可以用两把锁</p><ul><li>一把锁保护 tail</li><li>另一把锁保护 head</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">headLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();  <span class="comment">// 保护 head 的锁</span></span><br><span class="line"><span class="type">Condition</span> <span class="variable">headWaits</span> <span class="operator">=</span> headLock.newCondition(); <span class="comment">// 队列空时，需要等待的线程集合</span></span><br><span class="line"></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">tailLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();  <span class="comment">// 保护 tail 的锁</span></span><br><span class="line"><span class="type">Condition</span> <span class="variable">tailWaits</span> <span class="operator">=</span> tailLock.newCondition(); <span class="comment">// 队列满时，需要等待的线程集合</span></span><br></pre></td></tr></tbody></table></figure><p>先看看 offer 方法的初步实现</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    tailLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 队列满等待</span></span><br><span class="line">        <span class="keyword">while</span> (isFull()) {</span><br><span class="line">            tailWaits.await();</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不满则入队</span></span><br><span class="line">        array[tail] = e;</span><br><span class="line">        <span class="keyword">if</span> (++tail == array.length) {</span><br><span class="line">            tail = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改 size （有问题）</span></span><br><span class="line">        size++;</span><br><span class="line">        </span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        tailLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码的缺点是 size 并不受 tailLock 保护，tailLock 与 headLock是两把不同的锁，并不能实现互斥的效果。因此，size需要用下面的代码保证原子性</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">size</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);   <span class="comment">// 保护 size 的原子变量</span></span><br><span class="line"></span><br><span class="line">size.getAndIncrement(); <span class="comment">// 自增</span></span><br><span class="line">size.getAndDecrement(); <span class="comment">// 自减</span></span><br></pre></td></tr></tbody></table></figure><p>代码修改为</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    tailLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 队列满等待</span></span><br><span class="line">        <span class="keyword">while</span> (isFull()) {</span><br><span class="line">            tailWaits.await();</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不满则入队</span></span><br><span class="line">        array[tail] = e;</span><br><span class="line">        <span class="keyword">if</span> (++tail == array.length) {</span><br><span class="line">            tail = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改 size</span></span><br><span class="line">        size.getAndIncrement();</span><br><span class="line">        </span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        tailLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对称地，可以写出 poll 方法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    E e;</span><br><span class="line">    headLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 队列空等待</span></span><br><span class="line">        <span class="keyword">while</span> (isEmpty()) {</span><br><span class="line">            headWaits.await();</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不空则出队</span></span><br><span class="line">        e = array[head];</span><br><span class="line">        <span class="keyword">if</span> (++head == array.length) {</span><br><span class="line">            head = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改 size</span></span><br><span class="line">        size.getAndDecrement();</span><br><span class="line">        </span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        headLock.unlock();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下面来看一个难题，就是如何通知 headWaits 和 tailWaits中等待的线程，比如 poll 方法拿走一个元素，通知tailWaits：我拿走一个，不满了噢，你们可以放了，因此代码改为</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    E e;</span><br><span class="line">    headLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 队列空等待</span></span><br><span class="line">        <span class="keyword">while</span> (isEmpty()) {</span><br><span class="line">            headWaits.await();</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不空则出队</span></span><br><span class="line">        e = array[head];</span><br><span class="line">        <span class="keyword">if</span> (++head == array.length) {</span><br><span class="line">            head = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改 size</span></span><br><span class="line">        size.getAndDecrement();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 tailWaits 不满（有问题）</span></span><br><span class="line">        tailWaits.signal();</span><br><span class="line">        </span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        headLock.unlock();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>问题在于要使用这些条件变量的 await()， signal()等方法需要先获得与之关联的锁，上面的代码若直接运行会出现以下错误</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">java.lang.IllegalMonitorStateException</span><br></pre></td></tr></tbody></table></figure><p>那有同学说，加上锁不就行了吗，于是写出了下面的代码</p><figure><img src="../../../../images/StrJava/image-20230208160343493.png" alt="image-20230208160343493"><figcaption aria-hidden="true">image-20230208160343493</figcaption></figure><p>发现什么问题了？两把锁这么嵌套使用，非常容易出现死锁，如下所示</p><figure><img src="../../../../images/StrJava/image-20230208160143386.png" alt="image-20230208160143386"><figcaption aria-hidden="true">image-20230208160143386</figcaption></figure><p>因此得避免嵌套，两段加锁的代码变成了下面平级的样子</p><figure><img src="../../../../images/StrJava/image-20230208162857435.png" alt="image-20230208162857435"><figcaption aria-hidden="true">image-20230208162857435</figcaption></figure><p>性能还可以进一步提升</p><ol type="1"><li>代码调整后 offer 并没有同时获取 tailLock 和 headLock两把锁，因此两次加锁之间会有<strong>空隙</strong>，这个空隙内可能有其它的offer 线程添加了更多的元素，那么这些线程都要执行 signal()，通知 poll线程队列非空吗？<ul><li>每次调用 signal() 都需要这些 offer 线程先获得 headLock锁，成本较高，要想法减少 offer 线程获得 headLock 锁的次数</li><li>可以加一个条件：当 offer 增加前队列为空，即从 0 变化到不空，才由此offer 线程来通知 headWaits，其它情况不归它管</li></ul></li><li>队列从 0 变化到不空，会唤醒一个等待的 poll线程，这个线程被唤醒后，肯定能拿到 headLock 锁，因此它具备了唤醒headWaits 上其它 poll 线程的先决条件。如果检查出此时有其它 offer线程新增了元素（不空，但不是从0变化而来），那么不妨由此 poll线程来唤醒其它 poll 线程</li></ol><p>这个技巧被称之为级联通知（cascading notifies），类似的原因</p><ol start="3" type="1"><li>在 poll 时队列从满变化到不满，才由此 poll 线程来唤醒一个等待的 offer线程，目的也是为了减少 poll 线程对 tailLock 上锁次数，剩下等待的 offer线程由这个 offer 线程间接唤醒</li></ol><p>最终的代码为</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueue2</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> E[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">size</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">headLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">headWaits</span> <span class="operator">=</span> headLock.newCondition();</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">tailLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">tailWaits</span> <span class="operator">=</span> tailLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockingQueue2</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        <span class="built_in">this</span>.array = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">        tailLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (isFull()) {</span><br><span class="line">                tailWaits.await();</span><br><span class="line">            }</span><br><span class="line">            array[tail] = e;</span><br><span class="line">            <span class="keyword">if</span> (++tail == array.length) {</span><br><span class="line">                tail = <span class="number">0</span>;</span><br><span class="line">            }            </span><br><span class="line">            c = size.getAndIncrement();</span><br><span class="line">            <span class="comment">// a. 队列不满, 但不是从满-&gt;不满, 由此offer线程唤醒其它offer线程</span></span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; array.length) {</span><br><span class="line">                tailWaits.signal();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            tailLock.unlock();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// b. 从0-&gt;不空, 由此offer线程唤醒等待的poll线程</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) {</span><br><span class="line">            headLock.lock();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                headWaits.signal();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                headLock.unlock();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        E e;</span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">        headLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (isEmpty()) {</span><br><span class="line">                headWaits.await(); </span><br><span class="line">            }</span><br><span class="line">            e = array[head]; </span><br><span class="line">            <span class="keyword">if</span> (++head == array.length) {</span><br><span class="line">                head = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            c = size.getAndDecrement();</span><br><span class="line">            <span class="comment">// b. 队列不空, 但不是从0变化到不空，由此poll线程通知其它poll线程</span></span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>) {</span><br><span class="line">                headWaits.signal();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            headLock.unlock();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// a. 从满-&gt;不满, 由此poll线程唤醒等待的offer线程</span></span><br><span class="line">        <span class="keyword">if</span> (c == array.length) {</span><br><span class="line">            tailLock.lock();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                tailWaits.signal();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                tailLock.unlock();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size.get() == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size.get() == array.length;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>双锁实现的非常精巧，据说作者 Doug Lea花了一年的时间才完善了此段代码</p><h2 id="堆">2.9 堆</h2><p>以大顶堆为例，相对于之前的优先级队列，增加了堆化等方法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxHeap</span> {</span><br><span class="line">    <span class="type">int</span>[] array;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxHeap</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        <span class="built_in">this</span>.array = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取堆顶元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 堆顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除堆顶元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 堆顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        swap(<span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">        size--;</span><br><span class="line">        down(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定索引处元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 被删除元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">deleted</span> <span class="operator">=</span> array[index];</span><br><span class="line">        up(Integer.MAX_VALUE, index);</span><br><span class="line">        poll();</span><br><span class="line">        <span class="keyword">return</span> deleted;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 替换堆顶元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replaced 新元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replace</span><span class="params">(<span class="type">int</span> replaced)</span> {</span><br><span class="line">        array[<span class="number">0</span>] = replaced;</span><br><span class="line">        down(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆的尾部添加元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offered 新元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(<span class="type">int</span> offered)</span> {</span><br><span class="line">        <span class="keyword">if</span> (size == array.length) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        up(offered, size);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 offered 元素上浮: 直至 offered 小于父元素或到堆顶</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">up</span><span class="params">(<span class="type">int</span> offered, <span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> index;</span><br><span class="line">        <span class="keyword">while</span> (child &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (offered &gt; array[parent]) {</span><br><span class="line">                array[child] = array[parent];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            child = parent;</span><br><span class="line">        }</span><br><span class="line">        array[child] = offered;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxHeap</span><span class="params">(<span class="type">int</span>[] array)</span> {</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.size = array.length;</span><br><span class="line">        heapify();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建堆</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 如何找到最后这个非叶子节点  size / 2 - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            down(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 parent 索引处的元素下潜: 与两个孩子较大者交换, 直至没孩子或孩子没它大</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span> parent)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> parent;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; size &amp;&amp; array[left] &gt; array[max]) {</span><br><span class="line">            max = left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; array[right] &gt; array[max]) {</span><br><span class="line">            max = right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (max != parent) { <span class="comment">// 找到了更大的孩子</span></span><br><span class="line">            swap(max, parent);</span><br><span class="line">            down(max);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换两个索引处的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = t;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] array = {<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">        <span class="type">MaxHeap</span> <span class="variable">heap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MaxHeap</span>(array);</span><br><span class="line">        System.out.println(Arrays.toString(heap.array));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (heap.size &gt; <span class="number">1</span>) {</span><br><span class="line">            heap.swap(<span class="number">0</span>, heap.size - <span class="number">1</span>);</span><br><span class="line">            heap.size--;</span><br><span class="line">            heap.down(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(heap.array));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="建堆">建堆</h3><p>Floyd 建堆算法作者（也是之前龟兔赛跑判环作者）：</p><figure><img src="../../../../images/StrJava/image-20230213095110902.png" alt="image-20230213095110902"><figcaption aria-hidden="true">image-20230213095110902</figcaption></figure><ol type="1"><li>找到最后一个非叶子节点</li><li>从后向前，对每个节点执行下潜</li></ol><p>一些规律</p><ul><li>一棵满二叉树节点个数为 <span class="math inline">\(2^h-1\)</span>，如下例中高度 <span class="math inline">\(h=3\)</span> 节点数是 <span class="math inline">\(2^3-1=7\)</span></li><li>非叶子节点范围为 <span class="math inline">\([0,size/2-1]\)</span></li></ul><p>算法时间复杂度分析</p><figure><img src="../../../../images/StrJava/image-20230213114024607.png" alt="image-20230213114024607"><figcaption aria-hidden="true">image-20230213114024607</figcaption></figure><p>下面看交换次数的推导：设节点高度为 3</p><table><thead><tr class="header"><th></th><th>本层节点数</th><th>高度</th><th>下潜最多交换次数（高度-1）</th></tr></thead><tbody><tr class="odd"><td>4567 这层</td><td>4</td><td>1</td><td>0</td></tr><tr class="even"><td>23这层</td><td>2</td><td>2</td><td>1</td></tr><tr class="odd"><td>1这层</td><td>1</td><td>3</td><td>2</td></tr></tbody></table>每一层的交换次数为：<span class="math inline">\(节点个数*此节点交换次数\)</span>，总的交换次数为$$<span class="math display">\[\begin{aligned}&amp; 4 * 0 + 2 * 1 + 1 * 2 \\&amp; \frac{8}{2}*0 + \frac{8}{4}*1 + \frac{8}{8}*2 \\&amp; \frac{8}{2^1}*0 + \frac{8}{2^2}*1 + \frac{8}{2^3}*2\\\end{aligned}\]</span><p><span class="math display">\[即\]</span> _{i=1}^{h}(*(i-1)) $$ 在 https://www.wolframalpha.com/输入</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Sum[\(40)Divide[Power[2,x],Power[2,i]]*\(40)i-1\(41)\(41),{i,1,x}]</span><br></pre></td></tr></tbody></table></figure><p>推导出 <span class="math display">\[2^h -h -1\]</span> 其中 <span class="math inline">\(2^h \approx n\)</span>，<span class="math inline">\(h \approx \log_2{n}\)</span>，因此有时间复杂度<span class="math inline">\(O(n)\)</span></p><h3 id="习题-7">习题</h3><h4 id="e01.-堆排序">E01. 堆排序</h4><p>算法描述</p><ol type="1"><li>heapify 建立大顶堆</li><li>将堆顶与堆底交换（最大元素被交换到堆底），缩小并下潜调整堆</li><li>重复第二步直至堆里剩一个元素</li></ol><p>可以使用之前课堂例题的大顶堆来实现</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>};</span><br><span class="line"><span class="type">MaxHeap</span> <span class="variable">maxHeap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MaxHeap</span>(array);</span><br><span class="line">System.out.println(Arrays.toString(maxHeap.array));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (maxHeap.size &gt; <span class="number">1</span>) {</span><br><span class="line">    maxHeap.swap(<span class="number">0</span>, maxHeap.size - <span class="number">1</span>);</span><br><span class="line">    maxHeap.size--;</span><br><span class="line">    maxHeap.down(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line">System.out.println(Arrays.toString(maxHeap.array));</span><br></pre></td></tr></tbody></table></figure><h4 id="e02.-数组中第k大元素-leetcode-215">E02. 数组中第K大元素-Leetcode215</h4><p>小顶堆（可删去用不到代码）</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinHeap</span> {</span><br><span class="line">    <span class="type">int</span>[] array;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinHeap</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        array = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (size &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            down(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        swap(<span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">        size--;</span><br><span class="line">        down(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> array[size];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        swap(index, size - <span class="number">1</span>);</span><br><span class="line">        size--;</span><br><span class="line">        down(index);</span><br><span class="line">        <span class="keyword">return</span> array[size];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(<span class="type">int</span> offered)</span> {</span><br><span class="line">        <span class="keyword">if</span> (size == array.length) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        up(offered);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replace</span><span class="params">(<span class="type">int</span> replaced)</span> {</span><br><span class="line">        array[<span class="number">0</span>] = replaced;</span><br><span class="line">        down(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">up</span><span class="params">(<span class="type">int</span> offered)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="keyword">while</span> (child &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (child - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (offered &lt; array[parent]) {</span><br><span class="line">                array[child] = array[parent];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            child = parent;</span><br><span class="line">        }</span><br><span class="line">        array[child] = offered;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span> parent)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> (parent &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> parent;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; size &amp;&amp; array[left] &lt; array[min]) {</span><br><span class="line">            min = left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; array[right] &lt; array[min]) {</span><br><span class="line">            min = right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (min != parent) {</span><br><span class="line">            swap(min, parent);</span><br><span class="line">            down(min);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换两个索引处的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = t;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>题解</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] numbers, <span class="type">int</span> k)</span> {</span><br><span class="line">    <span class="type">MinHeap</span> <span class="variable">heap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MinHeap</span>(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) {</span><br><span class="line">        heap.offer(numbers[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; numbers.length; i++) {</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] &gt; heap.peek()){</span><br><span class="line">            heap.replace(numbers[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> heap.peek();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>求数组中的第 K 大元素，使用堆并不是最佳选择，可以采用快速选择算法</p></blockquote><h4 id="e03.-数据流中第k大元素-leetcode-703">E03.数据流中第K大元素-Leetcode 703</h4><p>上题的小顶堆加一个方法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinHeap</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == array.length;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>题解</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MinHeap heap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">KthLargest</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] nums)</span> {</span><br><span class="line">        heap = <span class="keyword">new</span> <span class="title class_">MinHeap</span>(k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            add(nums[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="keyword">if</span>(!heap.isFull()){</span><br><span class="line">            heap.offer(val);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(val &gt; heap.peek()){</span><br><span class="line">            heap.replace(val);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> heap.peek();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>求数据流中的第 K 大元素，使用堆最合适不过</p></blockquote><h4 id="e04.-数据流的中位数-leetcode-295">E04. 数据流的中位数-Leetcode295</h4><p>可以扩容的 heap, max 用于指定是大顶堆还是小顶堆</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heap</span> {</span><br><span class="line">    <span class="type">int</span>[] array;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">boolean</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> max)</span> {</span><br><span class="line">        <span class="built_in">this</span>.array = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">        <span class="built_in">this</span>.max = max;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取堆顶元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 堆顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除堆顶元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 堆顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        swap(<span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">        size--;</span><br><span class="line">        down(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定索引处元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 被删除元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">deleted</span> <span class="operator">=</span> array[index];</span><br><span class="line">        swap(index, size - <span class="number">1</span>);</span><br><span class="line">        size--;</span><br><span class="line">        down(index);</span><br><span class="line">        <span class="keyword">return</span> deleted;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 替换堆顶元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replaced 新元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replace</span><span class="params">(<span class="type">int</span> replaced)</span> {</span><br><span class="line">        array[<span class="number">0</span>] = replaced;</span><br><span class="line">        down(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆的尾部添加元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offered 新元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(<span class="type">int</span> offered)</span> {</span><br><span class="line">        <span class="keyword">if</span> (size == array.length) {</span><br><span class="line">            grow();</span><br><span class="line">        }</span><br><span class="line">        up(offered);</span><br><span class="line">        size++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> size + (size &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span>[] newArray = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>,</span><br><span class="line">                newArray, <span class="number">0</span>, size);</span><br><span class="line">        array = newArray;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 offered 元素上浮: 直至 offered 小于父元素或到堆顶</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">up</span><span class="params">(<span class="type">int</span> offered)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="keyword">while</span> (child &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">cmp</span> <span class="operator">=</span> max ? offered &gt; array[parent] : offered &lt; array[parent];</span><br><span class="line">            <span class="keyword">if</span> (cmp) {</span><br><span class="line">                array[child] = array[parent];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            child = parent;</span><br><span class="line">        }</span><br><span class="line">        array[child] = offered;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">boolean</span> max)</span> {</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.size = array.length;</span><br><span class="line">        <span class="built_in">this</span>.max = max;</span><br><span class="line">        heapify();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建堆</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 如何找到最后这个非叶子节点  size / 2 - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            down(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 parent 索引处的元素下潜: 与两个孩子较大者交换, 直至没孩子或孩子没它大</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span> parent)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> parent;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; size &amp;&amp; (max ? array[left] &gt; array[min] : array[left] &lt; array[min])) {</span><br><span class="line">            min = left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; (max ? array[right] &gt; array[min] : array[right] &lt; array[min])) {</span><br><span class="line">            min = right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (min != parent) { <span class="comment">// 找到了更大的孩子</span></span><br><span class="line">            swap(min, parent);</span><br><span class="line">            down(min);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换两个索引处的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = t;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>题解</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Heap</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Heap</span>(<span class="number">10</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="type">Heap</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Heap</span>(<span class="number">10</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 为了保证两边数据量的平衡</span></span><br><span class="line"><span class="comment"> &lt;ul&gt;</span></span><br><span class="line"><span class="comment">  &lt;li&gt;两边数据一样时,加入左边&lt;/li&gt;</span></span><br><span class="line"><span class="comment">  &lt;li&gt;两边数据不一样时,加入右边&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> 但是, 随便一个数能直接加入吗?</span></span><br><span class="line"><span class="comment"> &lt;ul&gt;</span></span><br><span class="line"><span class="comment">  &lt;li&gt;加入左边前, 应该挑右边最小的加入&lt;/li&gt;</span></span><br><span class="line"><span class="comment">  &lt;li&gt;加入右边前, 应该挑左边最大的加入&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> {</span><br><span class="line">    <span class="keyword">if</span> (left.size() == right.size()) {</span><br><span class="line">        right.offer(num);</span><br><span class="line">        left.offer(right.poll());</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        left.offer(num);</span><br><span class="line">        right.offer(left.poll());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;两边数据一致, 左右各取堆顶元素求平均&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;左边多一个, 取左边元素&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (left.size() == right.size()) {</span><br><span class="line">        <span class="keyword">return</span> (left.peek() + right.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> left.peek();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>本题还可以使用平衡二叉搜索树求解，不过代码比两个堆复杂</p></blockquote><h2 id="二叉树">2.10 二叉树</h2><p>二叉树是这么一种树状结构：每个节点最多有两个孩子，左孩子和右孩子</p><p>重要的二叉树结构</p><ul><li>完全二叉树（complete binarytree）是一种二叉树结构，除最后一层以外，每一层都必须填满，填充时要遵从先左后右</li><li>平衡二叉树（balance binarytree）是一种二叉树结构，其中每个节点的左右子树高度相差不超过 1</li></ul><h3 id="存储">1) 存储</h3><p>存储方式分为两种</p><ol type="1"><li>定义树节点与左、右孩子引用（TreeNode）</li><li>使用数组，前面讲堆时用过，若以 0作为树的根，索引可以通过如下方式计算<ul><li>父 = floor((子 - 1) / 2)</li><li>左孩子 = 父 * 2 + 1</li><li>右孩子 = 父 * 2 + 2</li></ul></li></ol><h3 id="遍历">2) 遍历</h3><p>遍历也分为两种</p><ol type="1"><li>广度优先遍历（Breadth-firstorder）：尽可能先访问距离根最近的节点，也称为层序遍历</li><li>深度优先遍历（Depth-firstorder）：对于二叉树，可以进一步分成三种（要深入到叶子节点）<ol type="1"><li>pre-order前序遍历，对于每一棵子树，先访问该节点，然后是左子树，最后是右子树</li><li>in-order中序遍历，对于每一棵子树，先访问左子树，然后是该节点，最后是右子树</li><li>post-order后序遍历，对于每一棵子树，先访问左子树，然后是右子树，最后是该节点</li></ol></li></ol><h4 id="广度优先">广度优先</h4><figure><img src="../../../../images/StrJava/image-20230216153607396.png" alt="image-20230216153607396"><figcaption aria-hidden="true">image-20230216153607396</figcaption></figure><table><thead><tr class="header"><th>本轮开始时队列</th><th>本轮访问节点</th></tr></thead><tbody><tr class="odd"><td>[1]</td><td>1</td></tr><tr class="even"><td>[2, 3]</td><td>2</td></tr><tr class="odd"><td>[3, 4]</td><td>3</td></tr><tr class="even"><td>[4, 5, 6]</td><td>4</td></tr><tr class="odd"><td>[5, 6]</td><td>5</td></tr><tr class="even"><td>[6, 7, 8]</td><td>6</td></tr><tr class="odd"><td>[7, 8]</td><td>7</td></tr><tr class="even"><td>[8]</td><td>8</td></tr><tr class="odd"><td>[]</td><td></td></tr></tbody></table><ol type="1"><li>初始化，将根节点加入队列</li><li>循环处理队列中每个节点，直至队列为空</li><li>每次循环内处理节点后，将它的孩子节点（即下一层的节点）加入队列</li></ol><blockquote><p>注意</p><ul><li><p>以上用队列来层序遍历是针对 TreeNode 这种方式表示的二叉树</p></li><li><p>对于数组表现的二叉树，则直接遍历数组即可，自然为层序遍历的顺序</p></li></ul></blockquote><h4 id="深度优先">深度优先</h4><figure><img src="../../../../images/StrJava/image-20230221110443230.png" alt="image-20230221110443230"><figcaption aria-hidden="true">image-20230221110443230</figcaption></figure><table><colgroup><col style="width: 13%"><col style="width: 62%"><col style="width: 11%"><col style="width: 11%"></colgroup><thead><tr class="header"><th>栈暂存</th><th>已处理</th><th>前序遍历</th><th>中序遍历</th></tr></thead><tbody><tr class="odd"><td>[1]</td><td>1 ✔️ 左💤 右💤</td><td>1</td><td></td></tr><tr class="even"><td>[1, 2]</td><td>2✔️ 左💤 右💤<br>1✔️ 左💤 右💤</td><td>2</td><td></td></tr><tr class="odd"><td>[1, 2, 4]</td><td>4✔️ 左✔️ 右✔️<br>2✔️ 左💤 右💤<br>1✔️ 左💤 右💤</td><td>4</td><td>4</td></tr><tr class="even"><td>[1, 2]</td><td>2✔️ 左✔️ 右✔️<br>1✔️ 左💤 右💤</td><td></td><td>2</td></tr><tr class="odd"><td>[1]</td><td>1✔️ 左✔️ 右💤</td><td></td><td>1</td></tr><tr class="even"><td>[1, 3]</td><td>3✔️ 左💤 右💤<br>1✔️ 左✔️ 右💤</td><td>3</td><td></td></tr><tr class="odd"><td>[1, 3, 5]</td><td>5✔️ 左✔️ 右✔️<br>3✔️ 左💤 右💤<br>1✔️ 左✔️ 右💤</td><td>5</td><td>5</td></tr><tr class="even"><td>[1, 3]</td><td>3✔️ 左✔️ 右💤<br>1✔️ 左✔️ 右💤</td><td></td><td>3</td></tr><tr class="odd"><td>[1, 3, 6]</td><td>6✔️ 左✔️ 右✔️<br>3✔️ 左✔️ 右💤<br>1✔️ 左✔️ 右💤</td><td>6</td><td>6</td></tr><tr class="even"><td>[1, 3]</td><td>3✔️ 左✔️ 右✔️<br>1✔️ 左✔️ 右💤</td><td></td><td></td></tr><tr class="odd"><td>[1]</td><td>1✔️ 左✔️ 右✔️</td><td></td><td></td></tr><tr class="even"><td>[]</td><td></td><td></td><td></td></tr></tbody></table><h4 id="递归实现">递归实现</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;前序遍历&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode node)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    System.out.print(node.val + <span class="string">"\t"</span>); <span class="comment">// 值</span></span><br><span class="line">    preOrder(node.left); <span class="comment">// 左</span></span><br><span class="line">    preOrder(node.right); <span class="comment">// 右</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;中序遍历&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode node)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    inOrder(node.left); <span class="comment">// 左</span></span><br><span class="line">    System.out.print(node.val + <span class="string">"\t"</span>); <span class="comment">// 值</span></span><br><span class="line">    inOrder(node.right); <span class="comment">// 右</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;后序遍历&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode node)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    postOrder(node.left); <span class="comment">// 左</span></span><br><span class="line">    postOrder(node.right); <span class="comment">// 右</span></span><br><span class="line">    System.out.print(node.val + <span class="string">"\t"</span>); <span class="comment">// 值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="非递归实现">非递归实现</h4><p><strong>前序遍历</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">LinkedListStack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedListStack</span>&lt;&gt;();</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty() || curr != <span class="literal">null</span>) {</span><br><span class="line">    <span class="keyword">if</span> (curr != <span class="literal">null</span>) {</span><br><span class="line">        stack.push(curr);</span><br><span class="line">        System.out.println(curr);</span><br><span class="line">        curr = curr.left;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        curr = pop.right;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>中序遍历</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">LinkedListStack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedListStack</span>&lt;&gt;();</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty() || curr != <span class="literal">null</span>) {</span><br><span class="line">    <span class="keyword">if</span> (curr != <span class="literal">null</span>) {</span><br><span class="line">        stack.push(curr);</span><br><span class="line">        curr = curr.left;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        System.out.println(pop);</span><br><span class="line">        curr = pop.right;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>后序遍历</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">LinkedListStack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedListStack</span>&lt;&gt;();</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty() || curr != <span class="literal">null</span>) {</span><br><span class="line">    <span class="keyword">if</span> (curr != <span class="literal">null</span>) {</span><br><span class="line">        stack.push(curr);</span><br><span class="line">        curr = curr.left;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">peek</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">        <span class="keyword">if</span> (peek.right == <span class="literal">null</span> || peek.right == pop) {</span><br><span class="line">            pop = stack.pop();</span><br><span class="line">            System.out.println(pop);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            curr = peek.right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于后序遍历，向回走时，需要处理完右子树才能 pop出栈。如何知道右子树处理完成呢？</p><ul><li><p>如果栈顶元素的 <span class="math inline">\(right \equivnull\)</span> 表示没啥可处理的，可以出栈</p></li><li><p>如果栈顶元素的 <span class="math inline">\(right \neqnull\)</span>，</p><ul><li>那么使用 lastPop 记录最近出栈的节点，即表示从这个节点向回走</li><li>如果栈顶元素的 <span class="math inline">\(right==lastPop\)</span>此时应当出栈</li></ul></li></ul><p>对于前、中两种遍历，实际以上代码从右子树向回走时，并未走完全程（stack提前出栈了）后序遍历以上代码是走完全程了</p><p><strong>统一写法</strong></p><p>下面是一种统一的写法，依据后序遍历修改</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root; <span class="comment">// 代表当前节点</span></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 最近一次弹栈的元素</span></span><br><span class="line"><span class="keyword">while</span> (curr != <span class="literal">null</span> || !stack.isEmpty()) {</span><br><span class="line">    <span class="keyword">if</span> (curr != <span class="literal">null</span>) {</span><br><span class="line">        colorPrintln(<span class="string">"前: "</span> + curr.val, <span class="number">31</span>);</span><br><span class="line">        stack.push(curr); <span class="comment">// 压入栈，为了记住回来的路</span></span><br><span class="line">        curr = curr.left;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">peek</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">        <span class="comment">// 右子树可以不处理, 对中序来说, 要在右子树处理之前打印</span></span><br><span class="line">        <span class="keyword">if</span> (peek.right == <span class="literal">null</span>) {</span><br><span class="line">            colorPrintln(<span class="string">"中: "</span> + peek.val, <span class="number">36</span>);</span><br><span class="line">            pop = stack.pop();</span><br><span class="line">            colorPrintln(<span class="string">"后: "</span> + pop.val, <span class="number">34</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 右子树处理完成, 对中序来说, 无需打印</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (peek.right == pop) {</span><br><span class="line">            pop = stack.pop();</span><br><span class="line">            colorPrintln(<span class="string">"后: "</span> + pop.val, <span class="number">34</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 右子树待处理, 对中序来说, 要在右子树处理之前打印</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            colorPrintln(<span class="string">"中: "</span> + peek.val, <span class="number">36</span>);</span><br><span class="line">            curr = peek.right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">colorPrintln</span><span class="params">(String origin, <span class="type">int</span> color)</span> {</span><br><span class="line">    System.out.printf(<span class="string">"\033[%dm%s\033[0m%n"</span>, color, origin);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>一张图演示三种遍历</p><figure><img src="../../../../images/StrJava/Sorted_binary_tree_ALL_RGB.svg.png" alt="Sorted_binary_tree_ALL_RGB.svg"><figcaption aria-hidden="true">Sorted_binary_tree_ALL_RGB.svg</figcaption></figure><ul><li>红色：前序遍历顺序</li><li>绿色：中序遍历顺序</li><li>蓝色：后续遍历顺序</li></ul><h3 id="习题-8">习题</h3><h4 id="e01.-前序遍历二叉树-leetcode-144">E01. 前序遍历二叉树-Leetcode144</h4><h4 id="e02.-中序遍历二叉树-leetcode-94">E02. 中序遍历二叉树-Leetcode94</h4><h4 id="e03.-后序遍历二叉树-leetcode-145">E03. 后序遍历二叉树-Leetcode145</h4><h4 id="e04.-对称二叉树-leetcode-101">E04. 对称二叉树-Leetcode 101</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">return</span> check(root.left, root.right);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode left, TreeNode right)</span> {</span><br><span class="line">    <span class="comment">// 若同时为 null</span></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 若有一个为 null (有上一轮筛选，另一个肯定不为 null)</span></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">null</span> || right == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (left.val != right.val) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> check(left.left, right.right) &amp;&amp; check(left.right, right.left);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>类似题目：Leetcode 100 题 - 相同的树</p><h4 id="e05.-二叉树最大深度-leetcode-104">E05. 二叉树最大深度-Leetcode104</h4><p><strong>后序遍历求解</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">    1. 得到左子树深度, 得到右子树深度, 二者最大者加一, 就是本节点深度</span></span><br><span class="line"><span class="comment">    2. 因为需要先得到左右子树深度, 很显然是后序遍历典型应用</span></span><br><span class="line"><span class="comment">    3. 关于深度的定义：从根出发, 离根最远的节点总边数,</span></span><br><span class="line"><span class="comment">        注意: 力扣里的深度定义要多一</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        深度2         深度3         深度1</span></span><br><span class="line"><span class="comment">        1            1            1</span></span><br><span class="line"><span class="comment">       / \          / \</span></span><br><span class="line"><span class="comment">      2   3        2   3</span></span><br><span class="line"><span class="comment">                        \</span></span><br><span class="line"><span class="comment">                         4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode node)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 非力扣题目改为返回 -1</span></span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">d1</span> <span class="operator">=</span> maxDepth(node.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">d2</span> <span class="operator">=</span> maxDepth(node.right);</span><br><span class="line">    <span class="keyword">return</span> Integer.max(d1, d2) + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>后序遍历求解-非递归</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">    1. 使用非递归后序遍历, 栈的最大高度即为最大深度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">null</span> || !stack.isEmpty()) {</span><br><span class="line">        <span class="keyword">if</span> (curr != <span class="literal">null</span>) {</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stack.size();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; max) {</span><br><span class="line">                max = size;</span><br><span class="line">            }</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">peek</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(peek.right == <span class="literal">null</span> || peek.right == pop) {</span><br><span class="line">                pop = stack.pop();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                curr = peek.right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>层序遍历求解</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">    1. 使用层序遍历, 层数即最大深度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">        level++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e06.-二叉树最小深度-leetcode-111">E06. 二叉树最小深度-Leetcode111</h4><p><strong>后序遍历求解</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode node)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">d1</span> <span class="operator">=</span> minDepth(node.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">d2</span> <span class="operator">=</span> minDepth(node.right);</span><br><span class="line">    <span class="keyword">if</span> (d1 == <span class="number">0</span> || d2 == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> d1 + d2 + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> Integer.min(d1, d2) + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>相较于求最大深度，应当考虑：</p><ul><li>当右子树为 null，应当返回左子树深度加一</li><li>当左子树为 null，应当返回右子树深度加一</li></ul><p>上面两种情况满足时，不应该再把为 null 子树的深度 0参与最小值比较，例如这样</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> /</span><br><span class="line">2</span><br></pre></td></tr></tbody></table></figure><ul><li>正确深度为 2，若把为 null 的右子树的深度 0 考虑进来，会得到错误结果1</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  3</span><br><span class="line">   \</span><br><span class="line">    4</span><br></pre></td></tr></tbody></table></figure><ul><li>正确深度为 3，若把为 null 的左子树的深度 0 考虑进来，会得到错误结果1</li></ul><p><strong>层序遍历求解</strong></p><p>遇到的第一个叶子节点所在层就是最小深度</p><p>例如，下面的树遇到的第一个叶子节点 3 所在的层就是最小深度，其他 4，7等叶子节点深度更深，也更晚遇到</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \     </span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5 </span><br><span class="line">   /</span><br><span class="line">  7 </span><br></pre></td></tr></tbody></table></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">        level++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> level;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>效率会高于之前后序遍历解法，因为找到第一个叶子节点后，就无需后续的层序遍历了</p><h4 id="e07.-翻转二叉树-leetcode-226">E07. 翻转二叉树-Leetcode 226</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    fn(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">(TreeNode node)</span>{</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">t</span> <span class="operator">=</span> node.left;</span><br><span class="line">    node.left = node.right;</span><br><span class="line">    node.right = t;</span><br><span class="line">    fn(node.left);</span><br><span class="line">    fn(node.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>先交换、再递归或是先递归、再交换都可以</p><h4 id="e08.-后缀表达式转二叉树">E08. 后缀表达式转二叉树</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> {</span><br><span class="line">    <span class="keyword">public</span> String val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(String val)</span> {</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(TreeNode left, String val, TreeNode right)</span> {</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.val;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    中缀表达式           (2-1)*3</span></span><br><span class="line"><span class="comment">    后缀（逆波兰）表达式   21-3*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    1.遇到数字入栈</span></span><br><span class="line"><span class="comment">    2.遇到运算符, 出栈两次, 与当前节点建立父子关系, 当前节点入栈</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    栈</span></span><br><span class="line"><span class="comment">    |   |</span></span><br><span class="line"><span class="comment">    |   |</span></span><br><span class="line"><span class="comment">    |   |</span></span><br><span class="line"><span class="comment">    _____</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    表达式树</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">       / \</span></span><br><span class="line"><span class="comment">      -   3</span></span><br><span class="line"><span class="comment">     / \</span></span><br><span class="line"><span class="comment">    2   1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    21-3*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">constructExpressionTree</span><span class="params">(String[] tokens)</span> {</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String t : tokens) {</span><br><span class="line">        <span class="keyword">switch</span> (t) {</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"+"</span>, <span class="string">"-"</span>, <span class="string">"*"</span>, <span class="string">"/"</span> -&gt; { <span class="comment">// 运算符</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(t);</span><br><span class="line">                parent.left = left;</span><br><span class="line">                parent.right = right;</span><br><span class="line">                stack.push(parent);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">default</span> -&gt; { <span class="comment">// 数字</span></span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">TreeNode</span>(t));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> stack.peek();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e09.-根据前序与中序遍历结果构造二叉树-leetcode-105">E09.根据前序与中序遍历结果构造二叉树-Leetcode 105</h4><ul><li>先通过前序遍历结果定位根节点</li><li>再结合中序遍历结果切分左右子树</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E09Leetcode105</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        preOrder = {1,2,4,3,6,7}</span></span><br><span class="line"><span class="comment">        inOrder = {4,2,1,6,3,7}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        根 1</span></span><br><span class="line"><span class="comment">            pre         in</span></span><br><span class="line"><span class="comment">        左  2,4         4,2</span></span><br><span class="line"><span class="comment">        右  3,6,7       6,3,7</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        根 2</span></span><br><span class="line"><span class="comment">        左 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        根 3</span></span><br><span class="line"><span class="comment">        左 6</span></span><br><span class="line"><span class="comment">        右 7</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preOrder, <span class="type">int</span>[] inOrder)</span> {</span><br><span class="line">        <span class="keyword">if</span> (preOrder.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 创建根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootValue</span> <span class="operator">=</span> preOrder[<span class="number">0</span>];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootValue);</span><br><span class="line">        <span class="comment">// 区分左右子树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inOrder.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (inOrder[i] == rootValue) {</span><br><span class="line">                <span class="comment">// 0 ~ i-1 左子树</span></span><br><span class="line">                <span class="comment">// i+1 ~ inOrder.length -1 右子树</span></span><br><span class="line">                <span class="type">int</span>[] inLeft = Arrays.copyOfRange(inOrder, <span class="number">0</span>, i); <span class="comment">// [4,2]</span></span><br><span class="line">                <span class="type">int</span>[] inRight = Arrays.copyOfRange(inOrder, i + <span class="number">1</span>, inOrder.length); <span class="comment">// [6,3,7]</span></span><br><span class="line"></span><br><span class="line">                <span class="type">int</span>[] preLeft = Arrays.copyOfRange(preOrder, <span class="number">1</span>, i + <span class="number">1</span>); <span class="comment">// [2,4]</span></span><br><span class="line">                <span class="type">int</span>[] preRight = Arrays.copyOfRange(preOrder, i + <span class="number">1</span>, inOrder.length); <span class="comment">// [3,6,7]</span></span><br><span class="line"></span><br><span class="line">                root.left = buildTree(preLeft, inLeft); <span class="comment">// 2</span></span><br><span class="line">                root.right = buildTree(preRight, inRight); <span class="comment">// 3</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>代码可以进一步优化，涉及新数据结构，以后实现</li></ul><h4 id="e10.-根据中序与后序遍历结果构造二叉树-leetcode-106">E10.根据中序与后序遍历结果构造二叉树-Leetcode 106</h4><ul><li>先通过后序遍历结果定位根节点</li><li>再结合中序遍历结果切分左右子树</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inOrder, <span class="type">int</span>[] postOrder)</span> {</span><br><span class="line">    <span class="keyword">if</span> (inOrder.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 根</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rootValue</span> <span class="operator">=</span> postOrder[postOrder.length - <span class="number">1</span>];</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootValue);</span><br><span class="line">    <span class="comment">// 切分左右子树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inOrder.length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (inOrder[i] == rootValue) {</span><br><span class="line">            <span class="type">int</span>[] inLeft = Arrays.copyOfRange(inOrder, <span class="number">0</span>, i);</span><br><span class="line">            <span class="type">int</span>[] inRight = Arrays.copyOfRange(inOrder, i + <span class="number">1</span>, inOrder.length);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span>[] postLeft = Arrays.copyOfRange(postOrder, <span class="number">0</span>, i);</span><br><span class="line">            <span class="type">int</span>[] postRight = Arrays.copyOfRange(postOrder, i, postOrder.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            root.left = buildTree(inLeft, postLeft);</span><br><span class="line">            root.right = buildTree(inRight, postRight);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>代码可以进一步优化，涉及新数据结构，以后实现</li></ul><h1 id="三.-基础算法">三. 基础算法</h1><h2 id="查找概述">3.1 查找概述</h2><p>查找算法是一种在数据集中寻找特定数据项的方法。通常，数据集是在计算机程序中存储的，例如数组、链表或散列表。在编写程序时，查找算法是非常重要的，它有助于快速找到所需的数据。在本文中，我们将介绍一些基本的查找算法及其特点。</p><h3 id="线性查找">线性查找</h3><p>线性查找也称为顺序查找，是一种最简单的查找算法。在这种算法中，我们从数据集的开头开始，逐个比较每个数据项，以寻找要查找的数据。如果我们找到了目标数据，查找过程就结束了。如果我们到达数据集的末尾，仍然找不到目标数据，则可以认为它不存在于数据集中。</p><p>线性查找的时间复杂度是O(n)，其中n是数据集的大小。因此，它在大型数据集中可能会很慢。然而，在小型数据集中，它仍然是一种非常有用的算法。</p><h3 id="二分查找">二分查找</h3><p>二分查找也称为折半查找，是一种更快速的查找算法。但前提是，数据集必须已经排序。在二分查找中，我们取数据集的中间值，然后将目标与中间值进行比较。如果目标小于中间值，则在左侧子集中继续查找；如果目标大于中间值，则在右侧子集中继续查找。每次比较都会缩小要搜索的数据集的大小。</p><p>二分查找的时间复杂度是O(logn)，其中n是数据集的大小。这种算法在大型数据集中非常有效，但在小型数据集中可能并不是最快的选择。</p><h3 id="哈希表查找">哈希表查找</h3><p>哈希表查找也称为散列表查找，是另一种常见的查找算法。它利用哈希函数将数据项映射到散列表中的位置。在查找过程中，我们只需通过哈希函数计算目标数据的位置，然后检查该位置是否包含目标数据。</p><p>哈希表查找的时间复杂度是O(1)。这使得它成为大型数据集中最快的查找算法之一。但是，哈希表查找的效率取决于哈希函数的质量。如果两个数据项映射到相同的位置，就会发生哈希冲突，这可能会导致性能下降。</p><h3 id="小结">小结</h3><p>在编写程序时，我们需要选择适合数据集大小和其他要求的最佳查找算法。例如，如果数据集很小，则线性查找可能是最快的选择；如果数据集已经排序，则二分查找是非常有用的。然而，在大型数据集中，哈希表查找通常是最好的选择。了解不同类型的查找算法及其特点可以帮助我们在编写程序时做出明智的选择。</p><p>不管是之前学过的数组、链表、队列、还是栈，这些线性结构中，如果想在其中查找一个元素，效率是比较慢的，只有<span class="math inline">\(O(N)\)</span>，因此如果你的需求是实现数据的快速查找，那么就需要<strong>新的数据结构</strong>支持。</p><p>还记得最先介绍的那个二分查找算法吗？它的查找效率能够达到 <span class="math inline">\(O(\log{N})\)</span>，是不是还不错？不过呢，它需要对数组事先排好序，而排序的成本是比较高的。那么有没有一个折中的办法呢？有，那就是接下来要给大家介绍的<strong>二叉搜索树</strong>，它插入元素后，自然就是排好序的，接下来的查询也自然而然可以应用二分查找算法进行高效搜索。</p><h2 id="二叉搜索树">3.2 二叉搜索树</h2><h3 id="概述-6">概述</h3><h4 id="历史">历史</h4><blockquote><p>二叉搜索树最早是由Bernoulli兄弟在18世纪中提出的，但是真正推广和应用该数据结构的是1960年代的D.L.Gries。他的著作《The Science ofProgramming》中详细介绍了二叉搜索树的实现和应用。</p><p>在计算机科学的发展中，二叉搜索树成为了一种非常基础的数据结构，被广泛应用在各种领域，包括搜索、排序、数据库索引等。随着计算机算力的提升和对数据结构的深入研究，二叉搜索树也不断被优化和扩展，例如AVL树、红黑树等。</p></blockquote><h4 id="特性">特性</h4><p>二叉搜索树（也称二叉排序树）是符合下面特征的二叉树：</p><ol type="1"><li>树节点增加 key 属性，用来比较谁大谁小，key 不可以重复</li><li>对于任意一个树节点，它的 key 比左子树的 key 都大，同时也比右子树的key 都小，例如下图所示</li></ol><figure><img src="../../../../images/StrJava/image-20230228090412983.png" alt="image-20230228090412983"><figcaption aria-hidden="true">image-20230228090412983</figcaption></figure><p>轻易看出要查找 7（从根开始）自然就可应用二分查找算法，只需三次比较</p><ul><li>与 4 比，较之大，向右找</li><li>与 6 比，较之大，继续向右找</li><li>与 7 比，找到</li></ul><p>查找的时间复杂度与<strong>树高</strong>相关，插入、删除也是如此。</p><ul><li>如果这棵树长得还不赖（左右平衡）上图，那么时间复杂度均是 <span class="math inline">\(O(\log{N})\)</span></li><li>当然，这棵树如果长得丑（左右高度相差过大）下图，那么这时是最糟的情况，时间复杂度是<span class="math inline">\(O(N)\)</span></li></ul><figure><img src="../../../../images/StrJava/image-20230228091405293.png" alt="image-20230228091405293"><figcaption aria-hidden="true">image-20230228091405293</figcaption></figure><blockquote><p>注：</p><ul><li>二叉搜索树 - 英文 binary search tree，简称 BST</li><li>二叉排序树 - 英文 binary ordered tree 或 binary sorted tree</li></ul></blockquote><h3 id="实现">实现</h3><h4 id="定义节点">定义节点</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BSTNode</span> {</span><br><span class="line">    <span class="type">int</span> key; <span class="comment">// 若希望任意类型作为 key, 则后续可以将其设计为 Comparable 接口</span></span><br><span class="line">    Object value;</span><br><span class="line">    BSTNode left;</span><br><span class="line">    BSTNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTNode</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = key;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTNode</span><span class="params">(<span class="type">int</span> key, Object value)</span> {</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTNode</span><span class="params">(<span class="type">int</span> key, Object value, BSTNode left, BSTNode right)</span> {</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="查询">查询</h4><p><strong>递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="keyword">return</span> doGet(root, key);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">doGet</span><span class="params">(BSTNode node, <span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 没找到</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.key) {</span><br><span class="line">        <span class="keyword">return</span> doGet(node.left, key); <span class="comment">// 向左找</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (node.key &lt; key) {</span><br><span class="line">        <span class="keyword">return</span> doGet(node.right, key); <span class="comment">// 向右找</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> node.value; <span class="comment">// 找到了</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>非递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (key &lt; node.key) {</span><br><span class="line">            node = node.left;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (node.key &lt; key) {</span><br><span class="line">            node = node.right;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="comparable">Comparable</h4><p>如果希望让除 int 外更多的类型能够作为 key，一种方式是 key 必须实现Comparable 接口。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BSTTree2</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BSTNode</span>&lt;T&gt; {</span><br><span class="line">        T key; <span class="comment">// 若希望任意类型作为 key, 则后续可以将其设计为 Comparable 接口</span></span><br><span class="line">        Object value;</span><br><span class="line">        BSTNode&lt;T&gt; left;</span><br><span class="line">        BSTNode&lt;T&gt; right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BSTNode</span><span class="params">(T key)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = key;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BSTNode</span><span class="params">(T key, Object value)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BSTNode</span><span class="params">(T key, Object value, BSTNode&lt;T&gt; left, BSTNode&lt;T&gt; right)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    BSTNode&lt;T&gt; root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(T key)</span> {</span><br><span class="line">        <span class="keyword">return</span> doGet(root, key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">doGet</span><span class="params">(BSTNode&lt;T&gt; node, T key)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> node.key.compareTo(key);</span><br><span class="line">        <span class="keyword">if</span> (result &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> doGet(node.left, key);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (result &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> doGet(node.right, key);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>还有一种做法不要求 key 实现 Comparable 接口，而是在构造 Tree时把比较规则作为 Comparator 传入，将来比较 key 大小时都调用此 Comparator进行比较，这种做法可以参考 Java 中的 java.util.TreeMap</p><h4 id="最小">最小</h4><p><strong>递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">min</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> doMin(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">doMin</span><span class="params">(BSTNode node)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 左边已走到头</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span>) { </span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> doMin(node.left);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>非递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">min</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="comment">// 左边未走到头</span></span><br><span class="line">    <span class="keyword">while</span> (p.left != <span class="literal">null</span>) {</span><br><span class="line">        p = p.left;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> p.value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="最大">最大</h4><p><strong>递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">max</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> doMax(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">doMax</span><span class="params">(BSTNode node)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 右边已走到头</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span>) { </span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> doMin(node.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>非递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">max</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="comment">// 右边未走到头</span></span><br><span class="line">    <span class="keyword">while</span> (p.right != <span class="literal">null</span>) {</span><br><span class="line">        p = p.right;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> p.value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="新增">新增</h4><p><strong>递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, Object value)</span> {</span><br><span class="line">    root = doPut(root, key, value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BSTNode <span class="title function_">doPut</span><span class="params">(BSTNode node, <span class="type">int</span> key, Object value)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BSTNode</span>(key, value);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.key) {</span><br><span class="line">        node.left = doPut(node.left, key, value);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (node.key &lt; key) {</span><br><span class="line">        node.right = doPut(node.right, key, value);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        node.value = value;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>若找到 key，走 else 更新找到节点的值</li><li>若没找到 key，走第一个 if，创建并返回新节点<ul><li>返回的新节点，作为上次递归时 node 的左孩子或右孩子</li><li>缺点是，会有很多不必要的赋值操作</li></ul></li></ul><p><strong>非递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, Object value)</span> {</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) {</span><br><span class="line">        parent = node;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; node.key) {</span><br><span class="line">            node = node.left;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (node.key &lt; key) {</span><br><span class="line">            node = node.right;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 1. key 存在则更新</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 2. key 不存在则新增</span></span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">null</span>) {</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">BSTNode</span>(key, value);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; parent.key) {</span><br><span class="line">        parent.left = <span class="keyword">new</span> <span class="title class_">BSTNode</span>(key, value);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        parent.right = <span class="keyword">new</span> <span class="title class_">BSTNode</span>(key, value);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="前驱后继">前驱后继</h4><figure><img src="../../../../images/StrJava/image-20230228144422128.png" alt="image-20230228144422128"><figcaption aria-hidden="true">image-20230228144422128</figcaption></figure><p>一个节点的前驱（前任）节点是指比它小的节点中，最大的那个</p><p>一个节点的后继（后任）节点是指比它大的节点中，最小的那个</p><p>例如上图中</p><ul><li>1 没有前驱，后继是 2</li><li>2 前驱是 1，后继是 3</li><li>3 前驱是 2，后继是 4</li><li>...</li></ul><p>简单的办法是中序遍历，即可获得排序结果，此时很容易找到前驱后继</p><p>要效率更高，需要研究一下规律，<strong>找前驱</strong>分成 2种情况：</p><figure><img src="../../../../images/StrJava/image-20230228144422128.png" alt="image-20230228144422128"><figcaption aria-hidden="true">image-20230228144422128</figcaption></figure><ol type="1"><li>节点有左子树，此时前驱节点就是左子树的最大值，图中属于这种情况的有<ul><li>2 的前驱是1</li><li>4 的前驱是 3</li><li>6 的前驱是 5</li><li>7 的前驱是 6</li></ul></li><li>节点没有左子树，若离它最近的祖先自从左而来，此祖先即为前驱，如<ul><li>3 的祖先 2 自左而来，前驱 2</li><li>5 的祖先 4 自左而来，前驱 4</li><li>8 的祖先 7 自左而来，前驱 7</li><li>1 没有这样的祖先，前驱 null</li></ul></li></ol><p><strong>找后继</strong>也分成 2 种情况</p><figure><img src="../../../../images/StrJava/image-20230228152715296.png" alt="image-20230228152715296"><figcaption aria-hidden="true">image-20230228152715296</figcaption></figure><ol type="1"><li>节点有右子树，此时后继节点即为右子树的最小值，如<ul><li>2 的后继 3</li><li>3 的后继 4</li><li>5 的后继 6</li><li>7 的后继 8</li></ul></li><li>节点没有右子树，若离它最近的祖先自从右而来，此祖先即为后继，如<ul><li>1 的祖先 2 自右而来，后继 2</li><li>4 的祖先 5 自右而来，后继 5</li><li>6 的祖先 7 自右而来，后继 7</li><li>8 没有这样的祖先，后继 null</li></ul></li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">predecessor</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">ancestorFromLeft</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (key &lt; p.key) {</span><br><span class="line">            p = p.left;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (p.key &lt; key) {</span><br><span class="line">            ancestorFromLeft = p;</span><br><span class="line">            p = p.right;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 情况1 - 有左孩子</span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> max(p.left);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 情况2 - 有祖先自左而来</span></span><br><span class="line">    <span class="keyword">return</span> ancestorFromLeft != <span class="literal">null</span> ? ancestorFromLeft.value : <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">successor</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">ancestorFromRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (key &lt; p.key) {</span><br><span class="line">            ancestorFromRight = p;</span><br><span class="line">            p = p.left;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (p.key &lt; key) {</span><br><span class="line">            p = p.right;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 情况1 - 有右孩子</span></span><br><span class="line">    <span class="keyword">if</span> (p.right != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> min(p.right);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 情况2 - 有祖先自右而来</span></span><br><span class="line">    <span class="keyword">return</span> ancestorFromRight != <span class="literal">null</span> ? ancestorFromRight.value : <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="删除">删除</h4><p>要删除某节点（称为 D），必须先找到被删除节点的父节点，这里称为Parent</p><ol type="1"><li>删除节点没有左孩子，将右孩子托孤给 Parent</li><li>删除节点没有右孩子，将左孩子托孤给 Parent</li><li>删除节点左右孩子都没有，已经被涵盖在情况1、情况2 当中，把 null托孤给 Parent</li><li>删除节点左右孩子都有，可以将它的后继节点（称为 S）托孤给 Parent，设S 的父亲为 SP，又分两种情况<ol type="1"><li>SP 就是被删除节点，此时 D 与 S 紧邻，只需将 S 托孤给 Parent</li><li>SP 不是被删除节点，此时 D 与 S 不相邻，此时需要将 S 的后代托孤给SP，再将 S 托孤给 Parent</li></ol></li></ol><p><strong>非递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;根据关键字删除&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 关键字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 被删除关键字对应值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">delete</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (key &lt; p.key) {</span><br><span class="line">            parent = p;</span><br><span class="line">            p = p.left;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (p.key &lt; key) {</span><br><span class="line">            parent = p;</span><br><span class="line">            p = p.right;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 删除操作</span></span><br><span class="line">    <span class="keyword">if</span> (p.left == <span class="literal">null</span>) {</span><br><span class="line">        shift(parent, p, p.right); <span class="comment">// 情况1</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (p.right == <span class="literal">null</span>) {</span><br><span class="line">        shift(parent, p, p.left); <span class="comment">// 情况2</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 情况4</span></span><br><span class="line">        <span class="comment">// 4.1 被删除节点找后继</span></span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">s</span> <span class="operator">=</span> p.right;</span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">sParent</span> <span class="operator">=</span> p; <span class="comment">// 后继父亲</span></span><br><span class="line">        <span class="keyword">while</span> (s.left != <span class="literal">null</span>) {</span><br><span class="line">            sParent = s;</span><br><span class="line">            s = s.left;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 4.2 删除和后继不相邻, 处理后继的后事</span></span><br><span class="line">        <span class="keyword">if</span> (sParent != p) {                </span><br><span class="line">            shift(sParent, s, s.right); <span class="comment">// 不可能有左孩子</span></span><br><span class="line">            s.right = p.right;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 4.3 后继取代被删除节点</span></span><br><span class="line">        shift(parent, p, s);</span><br><span class="line">        s.left = p.left;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> p.value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 托孤方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent  被删除节点的父亲</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> deleted 被删除节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> child   被顶上去的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 只考虑让 n1父亲的左或右孩子指向 n2, n1自己的左或右孩子并未在方法内改变</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">shift</span><span class="params">(BSTNode parent, BSTNode deleted, BSTNode child)</span> {</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">null</span>) {</span><br><span class="line">        root = child;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (deleted == parent.left) {</span><br><span class="line">        parent.left = child;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        parent.right = child;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">delete</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    ArrayList&lt;Object&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    root = doDelete(root, key, result);</span><br><span class="line">    <span class="keyword">return</span> result.isEmpty() ? <span class="literal">null</span> : result.get(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BSTNode <span class="title function_">doDelete</span><span class="params">(BSTNode node, <span class="type">int</span> key, ArrayList&lt;Object&gt; result)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.key) {</span><br><span class="line">        node.left = doDelete(node.left, key, result);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (node.key &lt; key) {</span><br><span class="line">        node.right = doDelete(node.right, key, result);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    result.add(node.value);</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span> &amp;&amp; node.right != <span class="literal">null</span>) {</span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">s</span> <span class="operator">=</span> node.right;</span><br><span class="line">        <span class="keyword">while</span> (s.left != <span class="literal">null</span>) {</span><br><span class="line">            s = s.left;</span><br><span class="line">        }</span><br><span class="line">        s.right = doDelete(node.right, s.key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        s.left = node.left;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> node.left != <span class="literal">null</span> ? node.left : node.right;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>说明</p><ol type="1"><li><code>ArrayList&lt;Object&gt; result</code>用来保存被删除节点的值</li><li>第二、第三个 if 对应没找到的情况，继续递归查找和删除，注意后续的doDelete 返回值代表删剩下的，因此需要更新</li><li>最后一个 return对应删除节点只有一个孩子的情况，返回那个不为空的孩子，待删节点自己因没有返回而被删除</li><li>第四个 if对应删除节点有两个孩子的情况，此时需要找到后继节点，并在待删除节点的右子树中删掉后继节点，最后用后继节点替代掉待删除节点返回，别忘了改变后继节点的左右指针</li></ol><h4 id="找小的">找小的</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">less</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    ArrayList&lt;Object&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    LinkedList&lt;BSTNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> || !stack.isEmpty()) {</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">BSTNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (pop.key &lt; key) {</span><br><span class="line">                result.add(pop.value);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            p = pop.right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="找大的">找大的</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">greater</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    ArrayList&lt;Object&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    LinkedList&lt;BSTNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> || !stack.isEmpty()) {</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">BSTNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (pop.key &gt; key) {</span><br><span class="line">                result.add(pop.value);</span><br><span class="line">            }</span><br><span class="line">            p = pop.right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但这样效率不高，可以用 RNL 遍历</p><blockquote><p>注：</p><ul><li>Pre-order, NLR</li><li>In-order, LNR</li><li>Post-order, LRN</li><li>Reverse pre-order, NRL</li><li>Reverse in-order, RNL</li><li>Reverse post-order, RLN</li></ul></blockquote><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">greater</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    ArrayList&lt;Object&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    LinkedList&lt;BSTNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> || !stack.isEmpty()) {</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.right;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">BSTNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (pop.key &gt; key) {</span><br><span class="line">                result.add(pop.value);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            p = pop.left;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="找之间">找之间</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">between</span><span class="params">(<span class="type">int</span> key1, <span class="type">int</span> key2)</span> {</span><br><span class="line">    ArrayList&lt;Object&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    LinkedList&lt;BSTNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> || !stack.isEmpty()) {</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">BSTNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (pop.key &gt;= key1 &amp;&amp; pop.key &lt;= key2) {</span><br><span class="line">                result.add(pop.value);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (pop.key &gt; key2) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            p = pop.right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="小结-1">小结</h4><p>优点：</p><ol type="1"><li>如果每个节点的左子树和右子树的大小差距不超过一，可以保证搜索操作的时间复杂度是O(log n)，效率高。</li><li>插入、删除结点等操作也比较容易实现，效率也比较高。</li><li>对于有序数据的查询和处理，二叉查找树非常适用，可以使用中序遍历得到有序序列。</li></ol><p>缺点：</p><ol type="1"><li>如果输入的数据是有序或者近似有序的，就会出现极度不平衡的情况，可能导致搜索效率下降，时间复杂度退化成O(n)。</li><li>对于频繁地插入、删除操作，需要维护平衡二叉查找树，例如红黑树、AVL树等，否则搜索效率也会下降。</li><li>对于存在大量重复数据的情况，需要做相应的处理，否则会导致树的深度增加，搜索效率下降。</li><li>对于结点过多的情况，由于树的空间开销较大，可能导致内存消耗过大，不适合对内存要求高的场景。</li></ol><h3 id="习题-9">习题</h3><h4 id="e01.-删除节点-leetcode-450">E01. 删除节点-Leetcode 450</h4><p>例题已经讲过，用非递归和递归均可实现，这里只给出递归参考代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode node, <span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.val) {</span><br><span class="line">        node.left = deleteNode(node.left, key);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (node.val &lt; key) {</span><br><span class="line">        node.right = deleteNode(node.right, key);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span>) { <span class="comment">// 情况1 - 只有右孩子</span></span><br><span class="line">        <span class="keyword">return</span> node.right;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (node.right == <span class="literal">null</span>) { <span class="comment">// 情况2 - 只有左孩子</span></span><br><span class="line">        <span class="keyword">return</span> node.left;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">s</span> <span class="operator">=</span> node.right; <span class="comment">// 情况3 - 有两个孩子</span></span><br><span class="line">    <span class="keyword">while</span> (s.left != <span class="literal">null</span>) {</span><br><span class="line">        s = s.left;</span><br><span class="line">    }</span><br><span class="line">    s.right = deleteNode(node.right, s.val);</span><br><span class="line">    s.left = node.left;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>树节点 TreeNode 相当于例题中的 BSTNode<ul><li>TreeNode 有属性：val, left, right，并未区分键值</li><li>BSTNode 有属性：key, value, left, right，区分了键值</li></ul></li><li>它的 TreeNode 没有 key，比较用的是 TreeNode.val 属性与待删除 key进行比较</li></ul><h4 id="e02.-新增节点-leetcode-701">E02. 新增节点-Leetcode 701</h4><p>例题也讲过了（put），下面给出递归实现</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode node, <span class="type">int</span> val)</span> {</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(val &lt; node.val) {</span><br><span class="line">        node.left = insertIntoBST(node.left, val);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span>(node.val &lt; val) {</span><br><span class="line">        node.right = insertIntoBST(node.right, val);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>注意事项与上题相同，不再赘述</li><li>题目提示输入的 val一定与树中节点不同，因此只需考虑<strong>新增</strong>情况，不会出现<strong>更新</strong>情况</li></ul><h4 id="e03.-查询节点-leetcode-700">E03. 查询节点-Leetcode 700</h4><p>例题讲过，下面给出递归实现</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode node, <span class="type">int</span> val)</span> {</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(val &lt; node.val) {</span><br><span class="line">        <span class="keyword">return</span> searchBST(node.left, val);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span>(node.val &lt; val) {</span><br><span class="line">        <span class="keyword">return</span> searchBST(node.right, val);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e04.-验证二叉搜索树-leetcode-98">E04. 验证二叉搜索树-Leetcode98</h4><p><strong>中序非递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">long</span> <span class="variable">prev</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> || !stack.isEmpty()) {</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (prev &gt;= pop.val) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            prev = pop.val;</span><br><span class="line">            p = pop.right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>记录 prev 需要用 long，否则若测试用例中最小的节点为Integer.MIN_VALUE 则测试会失败</li><li>注意，如果相邻两个节点相等，也不应当通过测试，例如，下面的树也是不合法的</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2</span><br><span class="line">  / </span><br><span class="line"> 2 </span><br></pre></td></tr></tbody></table></figure><p><strong>中序递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> doValid(<span class="keyword">new</span> <span class="title class_">AtomicLong</span>(Long.MIN_VALUE),root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doValid</span><span class="params">(AtomicLong prev, TreeNode node)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">a</span> <span class="operator">=</span> doValid(prev, node.left);</span><br><span class="line">    <span class="keyword">if</span> (prev.get() &gt;= node.val) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    prev.set(node.val);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> doValid(prev, node.right);</span><br><span class="line">    <span class="keyword">return</span> a &amp;&amp; b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>为何不能用 Long 或long？因为它们都是局部变量且不可变，因此每次赋值时，并不会改变其它方法调用时的prev</p></li><li><p>要么把 prev 设置为 AtomicLong，要么把 prev设置为全局变量，而不要采用方法参数这样的局部变量</p></li><li><p>上述代码并不是最有效率的，分析过程见视频讲解</p></li></ul><p><strong>上下限递归</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode node)</span> {</span><br><span class="line">    <span class="keyword">return</span> doValid(node, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">doValid</span><span class="params">(TreeNode node, <span class="type">long</span> min, <span class="type">long</span> max)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (node.val &lt;= min || node.val &gt;= max) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> doValid(node.left, min, node.val) &amp;&amp; doValid(node.right, node.val, max);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>设每个节点必须在一个范围内：<span class="math inline">\((min,max)\)</span>，不包含边界，若节点值超过这个范围，则返回 false</li><li>对于 node.left 范围肯定是 <span class="math inline">\((min,node.val)\)</span></li><li>对于 node.right 范围肯定是 <span class="math inline">\((node.val,max)\)</span></li><li>一开始不知道 min，max 则取 java 中长整数的最小、最大值</li><li>本质是前序遍历 + 剪枝</li></ul><h4 id="e05.-求范围和-leetcode-938">E05. 求范围和-Leetcode 938</h4><p><strong>中序递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(TreeNode node, <span class="type">int</span> low, <span class="type">int</span> high)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> rangeSumBST(node.left, low, high);</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.val &gt;= low &amp;&amp; node.val &lt;= high) {</span><br><span class="line">        b = node.val;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> a + b + rangeSumBST(node.right, low, high);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>中序非递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(TreeNode node, <span class="type">int</span> low, <span class="type">int</span> high)</span> {</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> node;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">null</span> || !stack.isEmpty()) {</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (pop.val &gt; high) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (pop.val &gt;= low) {</span><br><span class="line">                sum += pop.val;</span><br><span class="line">            }</span><br><span class="line">            p = pop.right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>leedcode 执行耗时 4ms</li></ul><p><strong>上下限递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(TreeNode node, <span class="type">int</span> low, <span class="type">int</span> high)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (node.val &lt; low) {</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(node.right, low, high);</span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">if</span> (node.val &gt; high) {</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(node.left, low, high);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> node.val + </span><br><span class="line">        rangeSumBST(node.left, low, high) + </span><br><span class="line">        rangeSumBST(node.right, low, high);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>leetcode 执行耗时 0 ms</li><li>node.val &lt; low 只需考虑它右子树的累加结果</li><li>node.val &gt; high 只需考虑它左子树的累加结果</li><li>node.val 在范围内，需要把当前节点的值加上其左右子树的累加结果</li></ul><h4 id="e06.-根据前序遍历结果构造二叉搜索树-leetcode-1008">E06.根据前序遍历结果构造二叉搜索树-Leetcode 1008</h4><p><strong>直接插入</strong></p><p>注意：根据前序遍历的结果，可以唯一地构造出一个二叉搜索树</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">bstFromPreorder</span><span class="params">(<span class="type">int</span>[] preorder)</span> {</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> insert(<span class="literal">null</span>, preorder[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; preorder.length; i++) {</span><br><span class="line">        insert(root, preorder[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">insert</span><span class="params">(TreeNode node, <span class="type">int</span> val)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(val &lt; node.val) {</span><br><span class="line">        node.left = insert(node.left, val);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span>(node.val &lt; val){</span><br><span class="line">        node.right = insert(node.right, val);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>上限法</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">bstFromPreorder</span><span class="params">(<span class="type">int</span>[] preorder)</span> {</span><br><span class="line">    <span class="keyword">return</span> insert(preorder, Integer.MAX_VALUE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">insert</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> max)</span> {</span><br><span class="line">    <span class="keyword">if</span> (i == preorder.length) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> preorder[i];</span><br><span class="line">    System.out.println(val + String.format(<span class="string">"[%d]"</span>, max));</span><br><span class="line">    <span class="keyword">if</span> (val &gt; max) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">    i++;</span><br><span class="line">    node.left = insert(preorder, node.val); </span><br><span class="line">    node.right = insert(preorder, max);     </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>依次处理 prevorder 中每个值, 返回创建好的节点或 null作为上个节点的孩子</p><ol type="1"><li>如果超过上限, 返回 null</li><li>如果没超过上限, 创建节点, 并将其左右孩子设置完整后返回<ul><li>i++ 需要放在设置左右孩子之前，意思是从剩下的元素中挑选左右孩子</li></ul></li></ol><p><strong>分治法</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">bstFromPreorder</span><span class="params">(<span class="type">int</span>[] preorder)</span> {</span><br><span class="line">    <span class="keyword">return</span> partition(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> start, <span class="type">int</span> end)</span> {</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[start]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> start + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt;= end) {</span><br><span class="line">        <span class="keyword">if</span> (preorder[index] &gt; preorder[start]) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        index++;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// index 就是右子树的起点</span></span><br><span class="line">    root.left = partition(preorder, start + <span class="number">1</span>, index - <span class="number">1</span>);</span><br><span class="line">    root.right = partition(preorder, index, end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>刚开始 8, 5, 1, 7, 10,12，方法每次执行，确定本次的根节点和左右子树的分界线</li><li>第一次确定根节点为 8，左子树 5, 1, 7，右子树 10, 12</li><li>对 5, 1, 7 做递归操作，确定根节点是 5， 左子树是 1， 右子树是 7</li><li>对 1 做递归操作，确定根节点是 1，左右子树为 null</li><li>对 7 做递归操作，确定根节点是 7，左右子树为 null</li><li>对 10, 12 做递归操作，确定根节点是 10，左子树为 null，右子树为12</li><li>对 12 做递归操作，确定根节点是 12，左右子树为 null</li><li>递归结束，返回本范围内的根节点</li></ul><h4 id="e07.-二叉搜索树的最近公共祖先-leetcode-235">E07.二叉搜索树的最近公共祖先-Leetcode 235</h4><p>要点：若 p，q 在 ancestor 的两侧，则 ancestor就是它们的最近公共祖先</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> {</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">ancestor</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (ancestor.val &gt; p.val &amp;&amp; ancestor.val &gt; q.val || </span><br><span class="line">           ancestor.val &lt; p.val &amp;&amp; ancestor.val &lt; q.val) {</span><br><span class="line">        <span class="keyword">if</span> (ancestor.val &gt; p.val) {</span><br><span class="line">            ancestor = ancestor.left;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            ancestor = ancestor.right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ancestor;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="其它题目-1">其它题目</h4><table><thead><tr class="header"><th>题号</th><th>名称</th></tr></thead><tbody><tr class="odd"><td>Leetcode 236</td><td>二叉树的最近公共祖先</td></tr><tr class="even"><td>Leetcode 114</td><td>二叉树展开为链表</td></tr><tr class="odd"><td>Leetcode 108</td><td>有序数组构造平衡二叉搜索树</td></tr><tr class="even"><td>Leetcode 1382</td><td>二叉搜索树变为平衡</td></tr></tbody></table><h2 id="avl-树">3.3 AVL 树</h2><h3 id="概述-7">概述</h3><h4 id="历史-1">历史</h4><blockquote><p>AVL 树是一种自平衡二叉搜索树，由托尔·哈斯特罗姆在 1960 年提出并在1962 年发表。它的名字来源于发明者的名字：Adelson-Velsky 和Landis，他们是苏联数学家，于 1962 年发表了一篇论文，详细介绍了 AVL树的概念和性质。</p><p>在二叉搜索树中，如果插入的元素按照特定的顺序排列，可能会导致树变得非常不平衡，从而降低搜索、插入和删除的效率。为了解决这个问题，AVL树通过在每个节点中维护一个平衡因子来确保树的平衡。平衡因子是左子树的高度减去右子树的高度。如果平衡因子的绝对值大于等于2，则通过旋转操作来重新平衡树。</p><p>AVL树是用于存储有序数据的一种重要数据结构，它是二叉搜索树的一种改进和扩展。它不仅能够提高搜索、插入和删除操作的效率，而且还能够确保树的深度始终保持在O(log n) 的水平。随着计算机技术的不断发展，AVL树已经成为了许多高效算法和系统中必不可少的一种基础数据结构。</p></blockquote><p>前面介绍过，如果一棵二叉搜索树长的不平衡，那么查询的效率会受到影响，如下图</p><figure><img src="../../../../images/StrJava/image-20230313090500760.png" alt="image-20230313090500760"><figcaption aria-hidden="true">image-20230313090500760</figcaption></figure><p>通过旋转可以让树重新变得平衡，并且不会改变二叉搜索树的性质（即左边仍然小，右边仍然大）</p><figure><img src="../../../../images/StrJava/image-20230313090817485.png" alt="image-20230313090817485"><figcaption aria-hidden="true">image-20230313090817485</figcaption></figure><h4 id="如何判断失衡">如何判断失衡？</h4><blockquote><p>如果一个节点的<strong>左右孩子，高度差超过1</strong>，则此节点失衡，才需要旋转</p></blockquote><h4 id="处理高度">处理高度</h4><p>如何得到节点高度？一种方式之前做过的一道题目：E05.求二叉树的最大深度（高度），但由于求高度是一个非常频繁的操作，因此将高度作为节点的一个属性，将来新增或删除时及时更新，默认为1（按力扣说法）</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AVLNode</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    Object value;</span><br><span class="line">    AVLNode left;</span><br><span class="line">    AVLNode right;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>求高度代码</strong></p><p>这里加入了 height 函数方便求节点为 null 时的高度</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(AVLNode node)</span> {</span><br><span class="line">    <span class="keyword">return</span> node == <span class="literal">null</span> ? <span class="number">0</span> : node.height;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>更新高度代码</strong></p><p>将来新增、删除、旋转时，高度都可能发生变化，需要更新。下面是更新高度的代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateHeight</span><span class="params">(AVLNode node)</span> {</span><br><span class="line">    node.height = Integer.max(height(node.left), height(node.right)) + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="何时触发失衡判断">何时触发失衡判断？</h4><p>定义平衡因子（balance factor）如下 <span class="math display">\[平衡因子 = 左子树高度 - 右子树高度\]</span> 当平衡因子</p><ul><li>bf = 0，1，-1 时，表示左右平衡</li><li>bf &gt; 1 时，表示左边太高</li><li>bf &lt; -1 时，表示右边太高</li></ul><p>对应代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bf</span><span class="params">(AVLNode node)</span> {</span><br><span class="line">    <span class="keyword">return</span> height(node.left) - height(node.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当插入新节点，或删除节点时，引起高度变化时，例如</p><figure><img src="../../../../images/StrJava/image-20230310153645397.png" alt="image-20230310153645397"><figcaption aria-hidden="true">image-20230310153645397</figcaption></figure><p>目前此树平衡，当再插入一个 4 时，节点们的高度都产生了相应的变化，8节点失衡了</p><figure><img src="../../../../images/StrJava/image-20230310153803661.png" alt="image-20230310153803661"><figcaption aria-hidden="true">image-20230310153803661</figcaption></figure><p>在比如说，下面这棵树一开始也是平衡的</p><figure><img src="../../../../images/StrJava/image-20230310154155728.png" alt="image-20230310154155728"><figcaption aria-hidden="true">image-20230310154155728</figcaption></figure><p>当删除节点 8 时，节点们的高度都产生了相应的变化，6 节点失衡了</p><figure><img src="../../../../images/StrJava/image-20230310154232729.png" alt="image-20230310154232729"><figcaption aria-hidden="true">image-20230310154232729</figcaption></figure><h4 id="失衡的四种情况">失衡的四种情况</h4><p><strong>LL</strong></p><figure><img src="../../../../images/StrJava/image-20230310154459709.png" alt="image-20230310154459709"><figcaption aria-hidden="true">image-20230310154459709</figcaption></figure><ul><li>失衡节点（图中 8 红色）的 bf &gt; 1，即左边更高</li><li>失衡节点的左孩子（图中 6）的 bf &gt;= 0即左孩子这边也是左边更高或等高</li></ul><p><strong>LR</strong></p><figure><img src="../../../../images/StrJava/image-20230310154858754.png" alt="image-20230310154858754"><figcaption aria-hidden="true">image-20230310154858754</figcaption></figure><ul><li>失衡节点（图中 8）的 bf &gt; 1，即左边更高</li><li>失衡节点的左孩子（图中 6 红色）的 bf &lt; 0即左孩子这边是右边更高</li></ul><p>对称的还有两种情况</p><p><strong>RL</strong></p><figure><img src="../../../../images/StrJava/image-20230310155048187.png" alt="image-20230310155048187"><figcaption aria-hidden="true">image-20230310155048187</figcaption></figure><ul><li>失衡节点（图中 3）的 bf &lt;-1，即右边更高</li><li>失衡节点的右孩子（图中 6 红色）的 bf &gt;0，即右孩子这边左边更高</li></ul><p><strong>RR</strong></p><figure><img src="../../../../images/StrJava/image-20230310155347349.png" alt="image-20230310155347349"><figcaption aria-hidden="true">image-20230310155347349</figcaption></figure><ul><li>失衡节点（图中 3）的 bf &lt;-1，即右边更高</li><li>失衡节点的右孩子（图中 6 红色）的 bf &lt;=0，即右孩子这边右边更高或等高</li></ul><h3 id="实现-1">实现</h3><h4 id="解决失衡">解决失衡</h4><p>失衡可以通过树的旋转解决。什么是树的旋转呢？它是在不干扰元素顺序的情况下更改结构，通常用来让树的高度变得平衡。</p><p>观察下面一棵二叉搜索树，可以看到，旋转后，并未改变树的左小右大特性，但根、父、孩子节点都发生了变化</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">    4                                   2</span><br><span class="line">   / \             4 right             / \</span><br><span class="line">  2   5      --------------------&gt;    1   4</span><br><span class="line"> / \         &lt;--------------------       / \</span><br><span class="line">1   3              2 left               3   5</span><br></pre></td></tr></tbody></table></figure><p><strong>右旋</strong></p><p>旋转前</p><figure><img src="../../../../images/StrJava/image-20230310162158692.png" alt="image-20230310162158692"><figcaption aria-hidden="true">image-20230310162158692</figcaption></figure><ul><li>红色节点，旧根（失衡节点）</li><li>黄色节点，旧根的左孩子，将来作为新根，旧根是它右孩子</li><li>绿色节点，新根的右孩子，将来要换爹作为旧根的左孩子</li></ul><p>旋转后</p><figure><img src="../../../../images/StrJava/image-20230310162442932.png" alt="image-20230310162442932"><figcaption aria-hidden="true">image-20230310162442932</figcaption></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AVLNode <span class="title function_">rightRotate</span><span class="params">(AVLNode red)</span> {</span><br><span class="line">    <span class="type">AVLNode</span> <span class="variable">yellow</span> <span class="operator">=</span> red.left;</span><br><span class="line">    <span class="type">AVLNode</span> <span class="variable">green</span> <span class="operator">=</span> yellow.right;</span><br><span class="line">    yellow.right = red;</span><br><span class="line">    red.left = green;</span><br><span class="line">    <span class="keyword">return</span> yellow;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>左旋</strong></p><p>旋转前</p><figure><img src="../../../../images/StrJava/image-20230310162945078.png" alt="image-20230310162945078"><figcaption aria-hidden="true">image-20230310162945078</figcaption></figure><ul><li>红色节点，旧根（失衡节点）</li><li>黄色节点，旧根的右孩子，将来作为新根，旧根是它左孩子</li><li>绿色节点，新根的左孩子，将来要换爹作为旧根的右孩子</li></ul><p>旋转后</p><figure><img src="../../../../images/StrJava/image-20230310163019508.png" alt="image-20230310163019508"><figcaption aria-hidden="true">image-20230310163019508</figcaption></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AVLNode <span class="title function_">leftRotate</span><span class="params">(AVLNode red)</span> {</span><br><span class="line">    <span class="type">AVLNode</span> <span class="variable">yellow</span> <span class="operator">=</span> red.right;</span><br><span class="line">    <span class="type">AVLNode</span> <span class="variable">green</span> <span class="operator">=</span> yellow.left;</span><br><span class="line">    yellow.left = red;</span><br><span class="line">    red.right = green;</span><br><span class="line">    <span class="keyword">return</span> yellow;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>左右旋</strong></p><p>指先左旋左子树，再右旋根节点（失衡），这时一次旋转并不能解决失衡</p><figure><img src="../../../../images/StrJava/image-20230310171424362.png" alt="image-20230310171424362"><figcaption aria-hidden="true">image-20230310171424362</figcaption></figure><p>左子树旋转后</p><figure><img src="../../../../images/StrJava/image-20230310171636904.png" alt="image-20230310171636904"><figcaption aria-hidden="true">image-20230310171636904</figcaption></figure><p>根右旋前</p><figure><img src="../../../../images/StrJava/image-20230310171821578.png" alt="image-20230310171821578"><figcaption aria-hidden="true">image-20230310171821578</figcaption></figure><p>根右旋后</p><figure><img src="../../../../images/StrJava/image-20230310171903417.png" alt="image-20230310171903417"><figcaption aria-hidden="true">image-20230310171903417</figcaption></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AVLNode <span class="title function_">leftRightRotate</span><span class="params">(AVLNode root)</span> {</span><br><span class="line">    root.left = leftRotate(root.left);</span><br><span class="line">    <span class="keyword">return</span> rightRotate(root);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>右左旋</strong></p><p>指先右旋右子树，再左旋根节点（失衡）</p><figure><img src="../../../../images/StrJava/image-20230310172212302.png" alt="image-20230310172212302"><figcaption aria-hidden="true">image-20230310172212302</figcaption></figure><p>右子树右旋后</p><figure><img src="../../../../images/StrJava/image-20230310172234154.png" alt="image-20230310172234154"><figcaption aria-hidden="true">image-20230310172234154</figcaption></figure><p>根左旋前</p><figure><img src="../../../../images/StrJava/image-20230310172303012.png" alt="image-20230310172303012"><figcaption aria-hidden="true">image-20230310172303012</figcaption></figure><p>根左旋后</p><figure><img src="../../../../images/StrJava/image-20230310172317379.png" alt="image-20230310172317379"><figcaption aria-hidden="true">image-20230310172317379</figcaption></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AVLNode <span class="title function_">rightLeftRotate</span><span class="params">(AVLNode root)</span> {</span><br><span class="line">    root.right = rightRotate(root.right);</span><br><span class="line">    <span class="keyword">return</span> leftRotate(root);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>判断及调整平衡代码</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AVLNode <span class="title function_">balance</span><span class="params">(AVLNode node)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">bf</span> <span class="operator">=</span> bf(node);</span><br><span class="line">    <span class="keyword">if</span> (bf &gt; <span class="number">1</span> &amp;&amp; bf(node.left) &gt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (bf &gt; <span class="number">1</span> &amp;&amp; bf(node.left) &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> rightLeftRotate(node);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (bf &lt; -<span class="number">1</span> &amp;&amp; bf(node.right) &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> leftRightRotate(node);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (bf &lt; -<span class="number">1</span> &amp;&amp; bf(node.right) &lt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以上四种旋转代码里，都需要更新高度，需要更新的节点是红色、黄色，而绿色节点高度不变</p><h4 id="新增-1">新增</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, Object value)</span> {</span><br><span class="line">    root = doPut(root, key, value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AVLNode <span class="title function_">doPut</span><span class="params">(AVLNode node, <span class="type">int</span> key, Object value)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AVLNode</span>(key, value);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (key == node.key) {</span><br><span class="line">        node.value = value;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.key) {</span><br><span class="line">        node.left = doPut(node.left, key, value);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        node.right = doPut(node.right, key, value);</span><br><span class="line">    }</span><br><span class="line">    updateHeight(node);</span><br><span class="line">    <span class="keyword">return</span> balance(node);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="删除-1">删除</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    root = doRemove(root, key);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AVLNode <span class="title function_">doRemove</span><span class="params">(AVLNode node, <span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.key) {</span><br><span class="line">        node.left = doRemove(node.left, key);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (node.key &lt; key) {</span><br><span class="line">        node.right = doRemove(node.right, key);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span>) {</span><br><span class="line">            node = node.right;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>) {</span><br><span class="line">            node = node.left;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">AVLNode</span> <span class="variable">s</span> <span class="operator">=</span> node.right;</span><br><span class="line">            <span class="keyword">while</span> (s.left != <span class="literal">null</span>) {</span><br><span class="line">                s = s.left;</span><br><span class="line">            }</span><br><span class="line">            s.right = doRemove(node.right, s.key);</span><br><span class="line">            s.left = node.left;</span><br><span class="line">            node = s;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    updateHeight(node);</span><br><span class="line">    <span class="keyword">return</span> balance(node);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完整代码备份</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AVLTree</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AVLNode</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        Object value;</span><br><span class="line">        AVLNode left;</span><br><span class="line">        AVLNode right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AVLNode</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AVLNode</span><span class="params">(<span class="type">int</span> key, Object value)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AVLNode</span><span class="params">(<span class="type">int</span> key, Object value, AVLNode left, AVLNode right)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    AVLNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AVLNode <span class="title function_">leftRotate</span><span class="params">(AVLNode p)</span> {</span><br><span class="line">        <span class="type">AVLNode</span> <span class="variable">r</span> <span class="operator">=</span> p.right;</span><br><span class="line">        <span class="type">AVLNode</span> <span class="variable">b</span> <span class="operator">=</span> r.left;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.right = b;</span><br><span class="line">        updateHeight(p);</span><br><span class="line">        updateHeight(r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateHeight</span><span class="params">(AVLNode node)</span> {</span><br><span class="line">        node.height = Integer.max(height(node.left), height(node.right)) + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AVLNode <span class="title function_">rightRotate</span><span class="params">(AVLNode r)</span> {</span><br><span class="line">        <span class="type">AVLNode</span> <span class="variable">a</span> <span class="operator">=</span> r.left;</span><br><span class="line">        <span class="type">AVLNode</span> <span class="variable">b</span> <span class="operator">=</span> a.right;</span><br><span class="line">        a.right = r;</span><br><span class="line">        r.left = b;</span><br><span class="line">        updateHeight(r);</span><br><span class="line">        updateHeight(a);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AVLNode <span class="title function_">leftRightRotate</span><span class="params">(AVLNode p)</span> {</span><br><span class="line">        <span class="type">AVLNode</span> <span class="variable">r</span> <span class="operator">=</span> p.left;</span><br><span class="line">        p.left = leftRotate(r);</span><br><span class="line">        <span class="keyword">return</span> rightRotate(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AVLNode <span class="title function_">rightLeftRotate</span><span class="params">(AVLNode p)</span> {</span><br><span class="line">        <span class="type">AVLNode</span> <span class="variable">r</span> <span class="operator">=</span> p.right;</span><br><span class="line">        p.right = rightRotate(r);</span><br><span class="line">        <span class="keyword">return</span> leftRotate(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(AVLNode node)</span> {</span><br><span class="line">        <span class="keyword">return</span> node == <span class="literal">null</span> ? <span class="number">0</span> : node.height;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        root = doRemove(root, key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AVLNode <span class="title function_">doRemove</span><span class="params">(AVLNode node, <span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (key &lt; node.key) {</span><br><span class="line">            node.left = doRemove(node.left, key);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (node.key &lt; key) {</span><br><span class="line">            node.right = doRemove(node.right, key);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span>) {</span><br><span class="line">                node = node.right;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>) {</span><br><span class="line">                node = node.left;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="type">AVLNode</span> <span class="variable">s</span> <span class="operator">=</span> node.right;</span><br><span class="line">                <span class="keyword">while</span> (s.left != <span class="literal">null</span>) {</span><br><span class="line">                    s = s.left;</span><br><span class="line">                }</span><br><span class="line">                s.right = doRemove(node.right, s.key);</span><br><span class="line">                s.left = node.left;</span><br><span class="line">                node = s;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        updateHeight(node);</span><br><span class="line">        <span class="keyword">return</span> balance(node);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, Object value)</span> {</span><br><span class="line">        root = doPut(root, key, value);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AVLNode <span class="title function_">doPut</span><span class="params">(AVLNode node, <span class="type">int</span> key, Object value)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AVLNode</span>(key, value);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (key == node.key) {</span><br><span class="line">            node.value = value;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (key &lt; node.key) {</span><br><span class="line">            node.left = doPut(node.left, key, value);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            node.right = doPut(node.right, key, value);</span><br><span class="line">        }</span><br><span class="line">        updateHeight(node);</span><br><span class="line">        <span class="keyword">return</span> balance(node);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bf</span><span class="params">(AVLNode node)</span> {</span><br><span class="line">        <span class="keyword">return</span> height(node.left) - height(node.right);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AVLNode <span class="title function_">balance</span><span class="params">(AVLNode node)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">bf</span> <span class="operator">=</span> bf(node);</span><br><span class="line">        <span class="keyword">if</span> (bf &gt; <span class="number">1</span> &amp;&amp; bf(node.left) &gt;= <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (bf &gt; <span class="number">1</span> &amp;&amp; bf(node.left) &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> rightLeftRotate(node);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (bf &lt; -<span class="number">1</span> &amp;&amp; bf(node.right) &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> leftRightRotate(node);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (bf &lt; -<span class="number">1</span> &amp;&amp; bf(node.right) &lt;= <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="小结-2">小结</h4><p>AVL树的优点：</p><ol type="1"><li>AVL树是一种自平衡树，保证了树的高度平衡，从而保证了树的查询和插入操作的时间复杂度均为O(logn)。</li><li>相比于一般二叉搜索树，AVL树对查询效率的提升更为显著，因为其左右子树高度的差值不会超过1，避免了二叉搜索树退化为链表的情况，使得整棵树的高度更低。</li><li>AVL树的删除操作比较简单，只需要像插入一样旋转即可，在旋转过程中树的平衡性可以得到维护。</li></ol><p>AVL树的缺点：</p><ol type="1"><li>AVL树每次插入或删除节点时需要进行旋转操作，这个操作比较耗时，因此在一些应用中不太适用。</li><li>在AVL树进行插入或删除操作时，为保持树的平衡需要不断进行旋转操作，在一些高并发环节和大数据量环境下，这可能会导致多余的写锁导致性能瓶颈。</li><li>AVL树的旋转操作相对较多，因此在一些应用中可能会造成较大的空间浪费。</li></ol><h2 id="红黑树">3.4 红黑树</h2><h3 id="概述-8">概述</h3><h4 id="历史-2">历史</h4><blockquote><p>红黑树是一种自平衡二叉查找树，最早由一位名叫RudolfBayer的德国计算机科学家于1972年发明。然而，最初的树形结构不是现在的红黑树，而是一种称为B树的结构，它是一种多叉树，可用于在磁盘上存储大量数据。</p><p>在1980年代早期，计算机科学家Leonard Adleman和DanielSleator推广了红黑树，并证明了它的自平衡性和高效性。从那时起，红黑树成为了最流行的自平衡二叉查找树之一，并被广泛应用于许多领域，如编译器、操作系统、数据库等。</p><p>红黑树的名字来源于红色节点和黑色节点的交替出现，它们的颜色是用来维护树的平衡性的关键。它们的颜色具有特殊的意义，黑色节点代表普通节点，而红色节点代表一个新添加的节点，它们必须满足一些特定的规则才能维持树的平衡性。</p></blockquote><p>红黑树也是一种自平衡的二叉搜索树，较之AVL，插入和删除时旋转次数更少</p><h4 id="红黑树特性">红黑树特性</h4><ol type="1"><li>所有节点都有两种颜色：红<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>、黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>所有 null 视为黑色<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>红色<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>节点不能相邻</li><li>根节点是黑色<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>从根到任意一个叶子节点，路径中的黑色<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>节点数一样</li></ol><h3 id="实现-2">实现</h3><h4 id="插入情况">插入情况</h4><p>插入节点均视为红色<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>case 1：插入节点为根节点，将根节点变黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>case2：插入节点的父亲若为黑色<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，树的红黑性质不变，无需调整</p><p>插入节点的父亲为红色<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，触发红红相邻</p><p>case 3：叔叔为红色<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><ul><li><p>父亲变为黑色<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，为了保证黑色平衡，连带的叔叔也变为黑色<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></li><li><p>祖父如果是黑色不变，会造成这颗子树黑色过多，因此祖父节点变为红色<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></li><li><p>祖父如果变成红色，可能会接着触发红红相邻，因此对将祖父进行递归调整</p></li></ul><p>case 4：叔叔为黑色<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><ol type="1"><li>父亲为左孩子，插入节点也是左孩子，此时即 LL 不平衡<ul><li>让父亲变黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，为了保证这颗子树黑色不变，将祖父变成红<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，但叔叔子树少了一个黑色</li><li>祖父右旋，补齐一个黑色给叔叔，父亲旋转上去取代祖父，由于它是黑色，不会再次触发红红相邻</li></ul></li><li>父亲为左孩子，插入节点是右孩子，此时即 LR 不平衡<ul><li>父亲左旋，变成 LL 情况，按 1. 来后续处理</li></ul></li><li>父亲为右孩子，插入节点也是右孩子，此时即 RR 不平衡<ul><li>让父亲变黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，为了保证这颗子树黑色不变，将祖父变成红<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，但叔叔子树少了一个黑色</li><li>祖父左旋，补齐一个黑色给叔叔，父亲旋转上去取代祖父，由于它是黑色，不会再次触发红红相邻</li></ul></li><li>父亲为右孩子，插入节点是左孩子，此时即 RL 不平衡<ul><li>父亲右旋，变成 RR 情况，按 3. 来后续处理</li></ul></li></ol><h4 id="删除情况">删除情况</h4><p>case0：如果删除节点有两个孩子</p><ul><li>交换删除节点和后继节点的key，value，递归删除后继节点，直到该节点没有孩子或只剩一个孩子</li></ul><p>如果删除节点没有孩子或只剩一个孩子</p><p>case 1：删的是根节点</p><ul><li>删完了，直接将 root = null</li><li>用剩余节点替换了根节点的 key，value，根节点孩子 =null，颜色保持黑色<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>不变</li></ul><p>删黑色会失衡，删红色不会失衡，但删黑色有一种简单情况</p><p>case2：删的是黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，剩下的是红<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，剩下这个红节点变黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>删除节点和剩下节点都是黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，触发双黑，双黑意思是，<strong>少了一个黑</strong></p><p>case 3：被调整节点的兄弟为红<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，此时两个侄子定为黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><ul><li>删除节点是左孩子，父亲左旋</li><li>删除节点是右孩子，父亲右旋</li><li>父亲和兄弟要变色，保证旋转后颜色平衡</li><li>旋转的目的是让黑侄子变为删除节点的黑兄弟，对删除节点再次递归，进入case 4 或 case 5</li></ul><p>case 4：被调整节点的兄弟为黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，两个侄子都为黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><ul><li>将兄弟变红<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，目的是将删除节点和兄弟那边的黑色高度同时减少1</li><li>如果父亲是红<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，则需将父亲变为黑，避免红红，此时路径黑节点数目不变</li><li>如果父亲是黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，说明这条路径还是少黑，再次让父节点触发双黑</li></ul><p>case5：被调整节点的兄弟为黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，至少一个红<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>侄子</p><ul><li>如果兄弟是左孩子，左侄子是红<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，LL 不平衡<ul><li>将来删除节点这边少个黑，所以最后旋转过来的父亲需要变成黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，平衡起见，左侄子也是黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>原来兄弟要成为父亲，需要保留父亲颜色</li></ul></li><li>如果兄弟是左孩子，右侄子是红<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，LR 不平衡<ul><li>将来删除节点这边少个黑，所以最后旋转过来的父亲需要变成黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>右侄子会取代原来父亲，因此它保留父亲颜色</li><li>兄弟已经是黑了<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，无需改变</li></ul></li><li>如果兄弟是右孩子，右侄子是红<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，RR 不平衡<ul><li>将来删除节点这边少个黑，所以最后旋转过来的父亲需要变成黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，平衡起见，右侄子也是黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>原来兄弟要成为父亲，需要保留父亲颜色</li></ul></li><li>如果兄弟是右孩子，左侄子是红<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，RL 不平衡<ul><li>将来删除节点这边少个黑，所以最后旋转过来的父亲需要变成黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>左侄子会取代原来父亲，因此它保留父亲颜色</li><li>兄弟已经是黑了<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，无需改变</li></ul></li></ul><h4 id="完整代码">完整代码</h4><p></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.datastructure.redblacktree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.itheima.datastructure.redblacktree.RedBlackTree.Color.BLACK;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.itheima.datastructure.redblacktree.RedBlackTree.Color.RED;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;红黑树&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedBlackTree</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Color</span> {</span><br><span class="line">        RED, BLACK;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        Object value;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        Node parent;        <span class="comment">// 父节点</span></span><br><span class="line">        <span class="type">Color</span> <span class="variable">color</span> <span class="operator">=</span> RED;  <span class="comment">// 颜色</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, Object value)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, Color color)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.color = color;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, Color color, Node left, Node right)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.color = color;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">null</span>) {</span><br><span class="line">                left.parent = <span class="built_in">this</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">null</span>) {</span><br><span class="line">                right.parent = <span class="built_in">this</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否是左孩子</span></span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">isLeftChild</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> parent != <span class="literal">null</span> &amp;&amp; parent.left == <span class="built_in">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 叔叔</span></span><br><span class="line">        Node <span class="title function_">uncle</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">if</span> (parent == <span class="literal">null</span> || parent.parent == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (parent.isLeftChild()) {</span><br><span class="line">                <span class="keyword">return</span> parent.parent.right;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> parent.parent.left;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 兄弟</span></span><br><span class="line">        Node <span class="title function_">sibling</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">if</span> (parent == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isLeftChild()) {</span><br><span class="line">                <span class="keyword">return</span> parent.right;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> parent.left;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断红</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRed</span><span class="params">(Node node)</span> {</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">null</span> &amp;&amp; node.color == RED;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断黑</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isBlack</span><span class="params">(Node node)</span> {</span><br><span class="line"><span class="comment">//        return !isRed(node);</span></span><br><span class="line">        <span class="keyword">return</span> node == <span class="literal">null</span> || node.color == BLACK;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右旋 1. parent 的处理 2. 旋转后新根的父子关系</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rightRotate</span><span class="params">(Node pink)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> pink.parent;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">yellow</span> <span class="operator">=</span> pink.left;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">green</span> <span class="operator">=</span> yellow.right;</span><br><span class="line">        <span class="keyword">if</span> (green != <span class="literal">null</span>) {</span><br><span class="line">            green.parent = pink;</span><br><span class="line">        }</span><br><span class="line">        yellow.right = pink;</span><br><span class="line">        yellow.parent = parent;</span><br><span class="line">        pink.left = green;</span><br><span class="line">        pink.parent = yellow;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">null</span>) {</span><br><span class="line">            root = yellow;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (parent.left == pink) {</span><br><span class="line">            parent.left = yellow;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            parent.right = yellow;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左旋</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">leftRotate</span><span class="params">(Node pink)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> pink.parent;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">yellow</span> <span class="operator">=</span> pink.right;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">green</span> <span class="operator">=</span> yellow.left;</span><br><span class="line">        <span class="keyword">if</span> (green != <span class="literal">null</span>) {</span><br><span class="line">            green.parent = pink;</span><br><span class="line">        }</span><br><span class="line">        yellow.left = pink;</span><br><span class="line">        yellow.parent = parent;</span><br><span class="line">        pink.right = green;</span><br><span class="line">        pink.parent = yellow;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">null</span>) {</span><br><span class="line">            root = yellow;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (parent.left == pink) {</span><br><span class="line">            parent.left = yellow;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            parent.right = yellow;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增或更新</span></span><br><span class="line"><span class="comment">     * &lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 正常增、遇到红红不平衡进行调整</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, Object value)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            parent = p;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; p.key) {</span><br><span class="line">                p = p.left;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (p.key &lt; key) {</span><br><span class="line">                p = p.right;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                p.value = value; <span class="comment">// 更新</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">inserted</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">null</span>) {</span><br><span class="line">            root = inserted;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; parent.key) {</span><br><span class="line">            parent.left = inserted;</span><br><span class="line">            inserted.parent = parent;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            parent.right = inserted;</span><br><span class="line">            inserted.parent = parent;</span><br><span class="line">        }</span><br><span class="line">        fixRedRed(inserted);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fixRedRed</span><span class="params">(Node x)</span> {</span><br><span class="line">        <span class="comment">// case 1 插入节点是根节点，变黑即可</span></span><br><span class="line">        <span class="keyword">if</span> (x == root) {</span><br><span class="line">            x.color = BLACK;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// case 2 插入节点父亲是黑色，无需调整</span></span><br><span class="line">        <span class="keyword">if</span> (isBlack(x.parent)) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">/* case 3 当红红相邻，叔叔为红时</span></span><br><span class="line"><span class="comment">            需要将父亲、叔叔变黑、祖父变红，然后对祖父做递归处理</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> x.parent;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">uncle</span> <span class="operator">=</span> x.uncle();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">grandparent</span> <span class="operator">=</span> parent.parent;</span><br><span class="line">        <span class="keyword">if</span> (isRed(uncle)) {</span><br><span class="line">            parent.color = BLACK;</span><br><span class="line">            uncle.color = BLACK;</span><br><span class="line">            grandparent.color = RED;</span><br><span class="line">            fixRedRed(grandparent);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// case 4 当红红相邻，叔叔为黑时</span></span><br><span class="line">        <span class="keyword">if</span> (parent.isLeftChild() &amp;&amp; x.isLeftChild()) { <span class="comment">// LL</span></span><br><span class="line">            parent.color = BLACK;</span><br><span class="line">            grandparent.color = RED;</span><br><span class="line">            rightRotate(grandparent);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (parent.isLeftChild()) { <span class="comment">// LR</span></span><br><span class="line">            leftRotate(parent);</span><br><span class="line">            x.color = BLACK;</span><br><span class="line">            grandparent.color = RED;</span><br><span class="line">            rightRotate(grandparent);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (!x.isLeftChild()) { <span class="comment">// RR</span></span><br><span class="line">            parent.color = BLACK;</span><br><span class="line">            grandparent.color = RED;</span><br><span class="line">            leftRotate(grandparent);</span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">// RL</span></span><br><span class="line">            rightRotate(parent);</span><br><span class="line">            x.color = BLACK;</span><br><span class="line">            grandparent.color = RED;</span><br><span class="line">            leftRotate(grandparent);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除</span></span><br><span class="line"><span class="comment">     * &lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 正常删、会用到李代桃僵技巧、遇到黑黑不平衡进行调整</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">deleted</span> <span class="operator">=</span> find(key);</span><br><span class="line">        <span class="keyword">if</span> (deleted == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        doRemove(deleted);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="keyword">return</span> find(key) != <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找删除节点</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">find</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (key &lt; p.key) {</span><br><span class="line">                p = p.left;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (p.key &lt; key) {</span><br><span class="line">                p = p.right;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找剩余节点</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findReplaced</span><span class="params">(Node deleted)</span> {</span><br><span class="line">        <span class="keyword">if</span> (deleted.left == <span class="literal">null</span> &amp;&amp; deleted.right == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (deleted.left == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> deleted.right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (deleted.right == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> deleted.left;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> deleted.right;</span><br><span class="line">        <span class="keyword">while</span> (s.left != <span class="literal">null</span>) {</span><br><span class="line">            s = s.left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理双黑 (case3、case4、case5)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixDoubleBlack</span><span class="params">(Node x)</span> {</span><br><span class="line">        <span class="keyword">if</span> (x == root) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> x.parent;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">sibling</span> <span class="operator">=</span> x.sibling();</span><br><span class="line">        <span class="comment">// case 3 兄弟节点是红色</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(sibling)) {</span><br><span class="line">            <span class="keyword">if</span> (x.isLeftChild()) {</span><br><span class="line">                leftRotate(parent);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                rightRotate(parent);</span><br><span class="line">            }</span><br><span class="line">            parent.color = RED;</span><br><span class="line">            sibling.color = BLACK;</span><br><span class="line">            fixDoubleBlack(x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (sibling != <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// case 4 兄弟是黑色, 两个侄子也是黑色</span></span><br><span class="line">            <span class="keyword">if</span> (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) {</span><br><span class="line">                sibling.color = RED;</span><br><span class="line">                <span class="keyword">if</span> (isRed(parent)) {</span><br><span class="line">                    parent.color = BLACK;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    fixDoubleBlack(parent);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// case 5 兄弟是黑色, 侄子有红色</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// LL</span></span><br><span class="line">                <span class="keyword">if</span> (sibling.isLeftChild() &amp;&amp; isRed(sibling.left)) {</span><br><span class="line">                    rightRotate(parent);</span><br><span class="line">                    sibling.left.color = BLACK;</span><br><span class="line">                    sibling.color = parent.color;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// LR</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sibling.isLeftChild() &amp;&amp; isRed(sibling.right)) {</span><br><span class="line">                    sibling.right.color = parent.color;</span><br><span class="line">                    leftRotate(sibling);</span><br><span class="line">                    rightRotate(parent);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// RL</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!sibling.isLeftChild() &amp;&amp; isRed(sibling.left)) {</span><br><span class="line">                    sibling.left.color = parent.color;</span><br><span class="line">                    rightRotate(sibling);</span><br><span class="line">                    leftRotate(parent);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// RR</span></span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    leftRotate(parent);</span><br><span class="line">                    sibling.right.color = BLACK;</span><br><span class="line">                    sibling.color = parent.color;</span><br><span class="line">                }</span><br><span class="line">                parent.color = BLACK;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// @TODO 实际也不会出现，触发双黑后，兄弟节点不会为 null</span></span><br><span class="line">            fixDoubleBlack(parent);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doRemove</span><span class="params">(Node deleted)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">replaced</span> <span class="operator">=</span> findReplaced(deleted);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> deleted.parent;</span><br><span class="line">        <span class="comment">// 没有孩子</span></span><br><span class="line">        <span class="keyword">if</span> (replaced == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// case 1 删除的是根节点</span></span><br><span class="line">            <span class="keyword">if</span> (deleted == root) {</span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (isBlack(deleted)) {</span><br><span class="line">                    <span class="comment">// 双黑调整</span></span><br><span class="line">                    fixDoubleBlack(deleted);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// 红色叶子, 无需任何处理</span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (deleted.isLeftChild()) {</span><br><span class="line">                    parent.left = <span class="literal">null</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    parent.right = <span class="literal">null</span>;</span><br><span class="line">                }</span><br><span class="line">                deleted.parent = <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 有一个孩子</span></span><br><span class="line">        <span class="keyword">if</span> (deleted.left == <span class="literal">null</span> || deleted.right == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// case 1 删除的是根节点</span></span><br><span class="line">            <span class="keyword">if</span> (deleted == root) {</span><br><span class="line">                root.key = replaced.key;</span><br><span class="line">                root.value = replaced.value;</span><br><span class="line">                root.left = root.right = <span class="literal">null</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (deleted.isLeftChild()) {</span><br><span class="line">                    parent.left = replaced;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    parent.right = replaced;</span><br><span class="line">                }</span><br><span class="line">                replaced.parent = parent;</span><br><span class="line">                deleted.left = deleted.right = deleted.parent = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (isBlack(deleted) &amp;&amp; isBlack(replaced)) {</span><br><span class="line">                    <span class="comment">// @TODO 实际不会有这种情况 因为只有一个孩子时 被删除节点是黑色 那么剩余节点只能是红色不会触发双黑</span></span><br><span class="line">                    fixDoubleBlack(replaced);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// case 2 删除是黑，剩下是红</span></span><br><span class="line">                    replaced.color = BLACK;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// case 0 有两个孩子 =&gt; 有一个孩子 或 没有孩子</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> deleted.key;</span><br><span class="line">        deleted.key = replaced.key;</span><br><span class="line">        replaced.key = t;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> deleted.value;</span><br><span class="line">        deleted.value = replaced.value;</span><br><span class="line">        replaced.value = v;</span><br><span class="line">        doRemove(replaced);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>以上代码中的 TODO 未作改正</li></ul><h4 id="小结-3">小结</h4><table style="width:100%;"><colgroup><col style="width: 16%"><col style="width: 28%"><col style="width: 19%"><col style="width: 35%"></colgroup><thead><tr class="header"><th>维度</th><th>普通二叉搜索树</th><th>AVL树</th><th>红黑树</th></tr></thead><tbody><tr class="odd"><td>查询</td><td>平均O(logn)，最坏O(n)</td><td>O(logn)</td><td>O(logn)</td></tr><tr class="even"><td>插入</td><td>平均O(logn)，最坏O(n)</td><td>O(logn)</td><td>O(logn)</td></tr><tr class="odd"><td>删除</td><td>平均O(logn)，最坏O(n)</td><td>O(logn)</td><td>O(logn)</td></tr><tr class="even"><td>平衡性</td><td>不平衡</td><td>严格平衡</td><td>近似平衡</td></tr><tr class="odd"><td>结构</td><td>二叉树</td><td>自平衡的二叉树</td><td>具有红黑性质的自平衡二叉树</td></tr><tr class="even"><td>查找效率</td><td>低</td><td>高</td><td>高</td></tr><tr class="odd"><td>插入删除效率</td><td>低</td><td>中等</td><td>高</td></tr></tbody></table><p>普通二叉搜索树插入、删除、查询的时间复杂度与树的高度相关，因此在最坏情况下，时间复杂度为O(n)，而且容易退化成链表，查找效率低。</p><p>AVL树是一种高度平衡的二叉搜索树，其左右子树的高度差不超过1。因此，它能够在logn的平均时间内完成插入、删除、查询操作，但是在维护平衡的过程中，需要频繁地进行旋转操作，导致插入删除效率较低。</p><p>红黑树是一种近似平衡的二叉搜索树，它在保持高度平衡的同时，又能够保持较高的插入删除效率。红黑树通过节点着色和旋转操作来维护平衡。红黑树在维护平衡的过程中，能够进行较少的节点旋转操作，因此插入删除效率较高，并且查询效率也较高。</p><p>综上所述，红黑树具有较高的综合性能，是一种广泛应用的数据结构。</p><h2 id="b-树">3.5 B 树</h2><p>ai 问题列表</p><p>请用中文回答：B-树历史</p><p>请用中文回答：100万的数据使用 avl 树来存储，树高是多少?</p><p>请用中文回答：100万的数据，如果存储到B-树(最小度数是500)，那么树高大约是多少?</p><p>请用中文回答：B-树的特性有哪些？</p><h3 id="概述-9">概述</h3><h4 id="历史-3">历史</h4><blockquote><p>B树（B-Tree）结构是一种高效存储和查询数据的方法，它的历史可以追溯到1970年代早期。B树的发明人RudolfBayer和Edward M.McCreight分别发表了一篇论文介绍了B树。这篇论文是1972年发表于《ACMTransactions on Database Systems》中的，题目为"Organization andMaintenance of Large Ordered Indexes"。</p><p>这篇论文提出了一种能够高效地维护大型有序索引的方法，这种方法的主要思想是将每个节点扩展成多个子节点，以减少查找所需的次数。B树结构非常适合应用于磁盘等大型存储器的高效操作，被广泛应用于关系数据库和文件系统中。</p><p>B树结构有很多变种和升级版，例如B+树，B*树和SB树等。这些变种和升级版本都基于B树的核心思想，通过调整B树的参数和结构，提高了B树在不同场景下的性能表现。</p><p>总的来说，B树结构是一个非常重要的数据结构，为高效存储和查询大量数据提供了可靠的方法。它的历史可以追溯到上个世纪70年代，而且在今天仍然被广泛应用于各种场景。</p></blockquote><h4 id="b-的含义">B 的含义</h4><blockquote><p>B-树的名称是由其发明者RudolfBayer提出的。Bayer和McCreight从未解释B代表什么，人们提出了许多可能的解释，比如Boeing、balanced、between、broad、bushy和Bayer等。但McCreight表示，越是思考B-trees中的B代表什么，就越能更好地理解B-trees</p></blockquote><h4 id="特性-1">特性</h4><p>一棵 B-树具有以下性质</p><p>特性1：每个节点 x 具有</p><ul><li>属性 n，表示节点 x 中 key 的个数</li><li>属性 leaf，表示节点是否是叶子节点</li><li>节点 key 可以有多个，以升序存储</li></ul><p>特性2：每个非叶子节点中的孩子数是 n + 1、叶子节点没有孩子</p><p>特性3：最小度数t（节点的孩子数称为度）和节点中键数量的关系如下：</p><table><thead><tr class="header"><th>最小度数t</th><th>键数量范围</th></tr></thead><tbody><tr class="odd"><td>2</td><td>1 ~ 3</td></tr><tr class="even"><td>3</td><td>2 ~ 5</td></tr><tr class="odd"><td>4</td><td>3 ~ 7</td></tr><tr class="even"><td>...</td><td>...</td></tr><tr class="odd"><td>n</td><td>(n-1) ~ (2n-1)</td></tr></tbody></table><p>其中，当节点中键数量达到其最大值时，即 3、5、7 ... 2n-1，需要分裂</p><p>特性4：叶子节点的深度都相同</p><blockquote><p>问：</p><p>B-树为什么有最小度数的限制？</p><p>答：</p><p>B树中有最小度数的限制是为了保证B树的平衡特性。</p><p>在B树中，每个节点都可以有多个子节点，这使得B树可以存储大量的键值，但也带来了一些问题。如果节点的子节点数量太少，那么就可能导致B树的高度过高，从而降低了B树的效率。此外，如果节点的子节点数量太多，那么就可能导致节点的搜索、插入和删除操作变得复杂和低效。</p><p>最小度数的限制通过限制节点的子节点数量，来平衡这些问题。在B树中，每个节点的子节点数量都必须在一定的范围内，即t到2t之间（其中t为最小度数）</p></blockquote><h4 id="b-树与-2-3-树2-3-4-树的关系">B-树与 2-3 树、2-3-4 树的关系</h4><p>可以这样总结它们之间的关系：</p><ol type="1"><li>2-3树是最小度数为2的B树，其中每个节点可以包含2个或3个子节点。</li><li>2-3-4树是最小度数为2的B树的一种特殊情况，其中每个节点可以包含2个、3个或4个子节点。</li><li>B树是一种更加一般化的平衡树，可以适应不同的应用场景，其节点可以包含任意数量的键值，节点的度数取决于最小度数t的设定。</li></ol><h3 id="实现-3">实现</h3><h4 id="定义节点-1">定义节点</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">leaf</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> keyNumber;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="type">int</span>[] keys;</span><br><span class="line">    Node[] children;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> t)</span> {</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">        <span class="built_in">this</span>.keys = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * t - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">2</span> * t];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(Arrays.copyOfRange(keys, <span class="number">0</span>, keyNumber));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>leaf 表示是否为叶子节点</li><li>keyNumber 为 keys 中有效 key 数目</li><li>t 为最小度数，它决定了节点中key 的最小、最大数目，分别是 t-1 和2t-1</li><li>keys 存储此节点的 key</li><li>children 存储此节点的 child</li><li>toString 只是为了方便调试和测试，非必须</li></ul><blockquote><p>实际 keys 应当改为 entries 以便同时保存 key 和value，刚开始简化实现</p></blockquote><h4 id="多路查找">多路查找</h4><p>为上面节点类添加 get 方法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Node <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; keyNumber &amp;&amp; keys[i] &lt; key) {</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (i &lt; keyNumber &amp;&amp; keys[i] == key) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (leaf) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> children[i].get(key);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="插入-key-和-child">插入 key 和 child</h4><p>为上面节点类添加 insertKey 和 insertChild 方法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">insertKey</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> index)</span> {</span><br><span class="line">    System.arraycopy(keys, index, keys, index + <span class="number">1</span>, keyNumber - index);</span><br><span class="line">    keys[index] = key;</span><br><span class="line">    keyNumber++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insertChild</span><span class="params">(Node child, <span class="type">int</span> index)</span> {</span><br><span class="line">    System.arraycopy(children, index, children, index + <span class="number">1</span>, keyNumber - index);</span><br><span class="line">    children[index] = child;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>作用是向 keys 数组或 children 数组指定 index 处插入新数据，注意</p><ul><li>由于使用了静态数组，并且不会在新增或删除时改变它的大小，因此需要额外的keyNumber 来指定数组内有效 key 的数目<ul><li>插入时 keyNumber++</li><li>删除时减少 keyNumber 的值即可</li></ul></li><li>children 不会单独维护数目，它比 keys 多一个</li><li>如果这两个方法同时调用，注意它们的先后顺序，insertChild后调用，因为它计算复制元素个数时用到了 keyNumber</li></ul><h4 id="定义树">定义树</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BTree</span> {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> t;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> MIN_KEY_NUMBER;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> MAX_KEY_NUMBER;</span><br><span class="line">    Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BTree</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BTree</span><span class="params">(<span class="type">int</span> t)</span> {</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">        MIN_KEY_NUMBER = t - <span class="number">1</span>;</span><br><span class="line">        MAX_KEY_NUMBER = <span class="number">2</span> * t - <span class="number">1</span>;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>(t);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="插入">插入</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    doPut(<span class="literal">null</span>, <span class="number">0</span>, root, key);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doPut</span><span class="params">(Node parent, <span class="type">int</span> index, Node node, <span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; node.keyNumber &amp;&amp; node.keys[i] &lt; key) {</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (i &lt; node.keyNumber &amp;&amp; node.keys[i] == key) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (node.leaf) {</span><br><span class="line">        node.insertKey(key, i);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        doPut(node, i, node.children[i], key);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (isFull(node)) {</span><br><span class="line">        split(parent, index, node);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>首先查找本节点中的插入位置 i，如果没有空位（key被找到），应该走更新的逻辑，目前什么没做</li><li>接下来分两种情况<ul><li>如果节点是叶子节点，可以直接插入了</li><li>如果节点是非叶子节点，需要继续在 children[i] 处继续递归插入</li></ul></li><li>无论哪种情况，插入完成后都可能超过节点 keys数目限制，此时应当执行节点分裂<ul><li>参数中的 parent 和 index都是给分裂方法用的，代表当前节点父节点，和分裂节点是第几个孩子</li></ul></li></ul><p>判断依据为：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">(Node node)</span> {</span><br><span class="line">    <span class="keyword">return</span> node.keyNumber == MAX_KEY_NUMBER;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="分裂">分裂</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">split</span><span class="params">(Node parent, <span class="type">int</span> index , Node left)</span> {</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">null</span>) {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newRoot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="built_in">this</span>.t);</span><br><span class="line">        newRoot.leaf = <span class="literal">false</span>;</span><br><span class="line">        newRoot.insertChild(root, <span class="number">0</span>);</span><br><span class="line">        root = newRoot;</span><br><span class="line">        parent = newRoot;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">Node</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="built_in">this</span>.t);</span><br><span class="line">    right.leaf = left.leaf;</span><br><span class="line">    right.keyNumber = t - <span class="number">1</span>;</span><br><span class="line">    System.arraycopy(left.keys, t, right.keys, <span class="number">0</span>, t - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!left.leaf) {</span><br><span class="line">        System.arraycopy(left.children, t, right.children, <span class="number">0</span>, t);</span><br><span class="line">    }</span><br><span class="line">    left.keyNumber = t - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left.keys[t - <span class="number">1</span>];</span><br><span class="line">    parent.insertKey(mid, index);</span><br><span class="line">    parent.insertChild(right, index + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>分两种情况：</p><ul><li>如果 parent == null表示要分裂的是根节点，此时需要创建新根，原来的根节点作为新根的 0孩子</li><li>否则<ul><li>创建 right 节点（分裂后大于当前 left 节点的），把 t 以后的 key 和child 都拷贝过去</li><li>t-1 处的 key 插入到 parent 的 index 处，index 指 left作为孩子时的索引</li><li>right 节点作为 parent 的孩子插入到 index + 1 处</li></ul></li></ul><h4 id="删除-2">删除</h4><p>case 1：当前节点是叶子节点，没找到</p><p>case 2：当前节点是叶子节点，找到了</p><p>case 3：当前节点是非叶子节点，没找到</p><p>case 4：当前节点是非叶子节点，找到了</p><p>case 5：删除后 key 数目 &lt; 下限（不平衡）</p><p>case 6：根节点</p><h4 id="完整代码-1">完整代码</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.algorithm.btree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;B-树&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings("all")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BTree</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">        <span class="type">int</span>[] keys; <span class="comment">// 关键字</span></span><br><span class="line">        Node[] children; <span class="comment">// 孩子</span></span><br><span class="line">        <span class="type">int</span> keyNumber; <span class="comment">// 有效关键字数目</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">leaf</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 是否是叶子节点</span></span><br><span class="line">        <span class="type">int</span> t; <span class="comment">// 最小度数 (最小孩子数)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> t)</span> { <span class="comment">// t&gt;=2</span></span><br><span class="line">            <span class="built_in">this</span>.t = t;</span><br><span class="line">            <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">2</span> * t];</span><br><span class="line">            <span class="built_in">this</span>.keys = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * t - <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span>[] keys)</span> {</span><br><span class="line">            <span class="built_in">this</span>.keys = keys;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> Arrays.toString(Arrays.copyOfRange(keys, <span class="number">0</span>, keyNumber));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多路查找</span></span><br><span class="line">        Node <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; keyNumber) {</span><br><span class="line">                <span class="keyword">if</span> (keys[i] == key) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (keys[i] &gt; key) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 执行到此时 keys[i]&gt;key 或 i==keyNumber</span></span><br><span class="line">            <span class="keyword">if</span> (leaf) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 非叶子情况</span></span><br><span class="line">            <span class="keyword">return</span> children[i].get(key);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向 keys 指定索引处插入 key</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">insertKey</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> index)</span> {</span><br><span class="line">            System.arraycopy(keys, index, keys, index + <span class="number">1</span>, keyNumber - index);</span><br><span class="line">            keys[index] = key;</span><br><span class="line">            keyNumber++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向 children 指定索引处插入 child</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">insertChild</span><span class="params">(Node child, <span class="type">int</span> index)</span> {</span><br><span class="line">            System.arraycopy(children, index, children, index + <span class="number">1</span>, keyNumber - index);</span><br><span class="line">            children[index] = child;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">removeKey</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> keys[index];</span><br><span class="line">            System.arraycopy(keys, index + <span class="number">1</span>, keys, index, --keyNumber - index);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">removeLeftmostKey</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> removeKey(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">removeRightmostKey</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> removeKey(keyNumber - <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node <span class="title function_">removeChild</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> children[index];</span><br><span class="line">            System.arraycopy(children, index + <span class="number">1</span>, children, index, keyNumber - index);</span><br><span class="line">            children[keyNumber] = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node <span class="title function_">removeLeftmostChild</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> removeChild(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node <span class="title function_">removeRightmostChild</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> removeChild(keyNumber);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">moveToLeft</span><span class="params">(Node left)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> left.keyNumber;</span><br><span class="line">            <span class="keyword">if</span> (!leaf) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= keyNumber; i++) {</span><br><span class="line">                    left.children[start + i] = children[i];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; keyNumber; i++) {</span><br><span class="line">                left.keys[left.keyNumber++] = keys[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node <span class="title function_">leftSibling</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">            <span class="keyword">return</span> index &gt; <span class="number">0</span> ? children[index - <span class="number">1</span>] : <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node <span class="title function_">rightSibling</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">            <span class="keyword">return</span> index == keyNumber ? <span class="literal">null</span> : children[index + <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node root;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t; <span class="comment">// 树中节点最小度数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> MIN_KEY_NUMBER; <span class="comment">// 最小key数目</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> MAX_KEY_NUMBER; <span class="comment">// 最大key数目</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BTree</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BTree</span><span class="params">(<span class="type">int</span> t)</span> {</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>(t);</span><br><span class="line">        MAX_KEY_NUMBER = <span class="number">2</span> * t - <span class="number">1</span>;</span><br><span class="line">        MIN_KEY_NUMBER = t - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 是否存在</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="keyword">return</span> root.get(key) != <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 新增</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        doPut(root, key, <span class="literal">null</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doPut</span><span class="params">(Node node, <span class="type">int</span> key, Node parent, <span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; node.keyNumber) {</span><br><span class="line">            <span class="keyword">if</span> (node.keys[i] == key) {</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 更新</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.keys[i] &gt; key) {</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 找到了插入位置，即为此时的 i</span></span><br><span class="line">            }</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.leaf) {</span><br><span class="line">            node.insertKey(key, i);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            doPut(node.children[i], key, node, i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.keyNumber == MAX_KEY_NUMBER) {</span><br><span class="line">            split(node, parent, index);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h3&gt;分裂方法&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left   要分裂的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent 分裂节点的父节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index  分裂节点是第几个孩子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(Node left, Node parent, <span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="comment">// 分裂的是根节点</span></span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newRoot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(t);</span><br><span class="line">            newRoot.leaf = <span class="literal">false</span>;</span><br><span class="line">            newRoot.insertChild(left, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">this</span>.root = newRoot;</span><br><span class="line">            parent = newRoot;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 1. 创建 right 节点，把 left 中 t 之后的 key 和 child 移动过去</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(t);</span><br><span class="line">        right.leaf = left.leaf;</span><br><span class="line">        System.arraycopy(left.keys, t, right.keys, <span class="number">0</span>, t - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 分裂节点是非叶子的情况</span></span><br><span class="line">        <span class="keyword">if</span> (!left.leaf) {</span><br><span class="line">            System.arraycopy(left.children, t, right.children, <span class="number">0</span>, t);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> t; i &lt;= left.keyNumber; i++) {</span><br><span class="line">                left.children[i] = <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        right.keyNumber = t - <span class="number">1</span>;</span><br><span class="line">        left.keyNumber = t - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 2. 中间的 key （t-1 处）插入到父节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left.keys[t - <span class="number">1</span>];</span><br><span class="line">        parent.insertKey(mid, index);</span><br><span class="line">        <span class="comment">// 3. right 节点作为父节点的孩子</span></span><br><span class="line">        parent.insertChild(right, index + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 删除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        doRemove(root, key, <span class="literal">null</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doRemove</span><span class="params">(Node node, <span class="type">int</span> key, Node parent, <span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; node.keyNumber) {</span><br><span class="line">            <span class="keyword">if</span> (node.keys[i] &gt;= key) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.leaf) {</span><br><span class="line">            <span class="keyword">if</span> (notFound(node, key, i)) { <span class="comment">// case 1</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            node.removeKey(i);  <span class="comment">// case 2</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (notFound(node, key, i)) { <span class="comment">// case 3</span></span><br><span class="line">                doRemove(node.children[i], key, node, i);</span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// case 4</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.children[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">while</span> (!s.leaf) {</span><br><span class="line">                    s = s.children[<span class="number">0</span>];</span><br><span class="line">                }</span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> s.keys[<span class="number">0</span>];</span><br><span class="line">                node.keys[i] = k;</span><br><span class="line">                doRemove(node.children[i + <span class="number">1</span>], k, node, i + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.keyNumber &lt; MIN_KEY_NUMBER) { <span class="comment">// case 5</span></span><br><span class="line">            balance(node, parent, index);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">notFound</span><span class="params">(Node node, <span class="type">int</span> key, <span class="type">int</span> i)</span> {</span><br><span class="line">        <span class="keyword">return</span> i &gt;= node.keyNumber || (i &lt; node.keyNumber &amp;&amp; node.keys[i] != key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">balance</span><span class="params">(Node node, Node parent, <span class="type">int</span> i)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node == root) {</span><br><span class="line">            <span class="keyword">if</span> (root.keyNumber == <span class="number">0</span> &amp;&amp; root.children[<span class="number">0</span>] != <span class="literal">null</span>) {</span><br><span class="line">                root = root.children[<span class="number">0</span>];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">leftSibling</span> <span class="operator">=</span> parent.leftSibling(i);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">rightSibling</span> <span class="operator">=</span> parent.rightSibling(i);</span><br><span class="line">        <span class="keyword">if</span> (leftSibling != <span class="literal">null</span> &amp;&amp; leftSibling.keyNumber &gt; MIN_KEY_NUMBER) {</span><br><span class="line">            rightRotate(node, leftSibling, parent, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (rightSibling != <span class="literal">null</span> &amp;&amp; rightSibling.keyNumber &gt; MIN_KEY_NUMBER) {</span><br><span class="line">            leftRotate(node, rightSibling, parent, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (leftSibling != <span class="literal">null</span>) {</span><br><span class="line">            mergeToLeft(leftSibling, parent, i - <span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            mergeToLeft(node, parent, i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeToLeft</span><span class="params">(Node left, Node parent, <span class="type">int</span> i)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">right</span> <span class="operator">=</span> parent.removeChild(i + <span class="number">1</span>);</span><br><span class="line">        left.insertKey(parent.removeKey(i), left.keyNumber);</span><br><span class="line">        right.moveToLeft(left);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rightRotate</span><span class="params">(Node node, Node leftSibling, Node parent, <span class="type">int</span> i)</span> {</span><br><span class="line">        node.insertKey(parent.keys[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!leftSibling.leaf) {</span><br><span class="line">            node.insertChild(leftSibling.removeRightmostChild(), <span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">        parent.keys[i - <span class="number">1</span>] = leftSibling.removeRightmostKey();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">leftRotate</span><span class="params">(Node node, Node rightSibling, Node parent, <span class="type">int</span> i)</span> {</span><br><span class="line">        node.insertKey(parent.keys[i], node.keyNumber);</span><br><span class="line">        <span class="keyword">if</span> (!rightSibling.leaf) {</span><br><span class="line">            node.insertChild(rightSibling.removeLeftmostChild(), node.keyNumber + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        parent.keys[i] = rightSibling.removeLeftmostKey();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="哈希表">3.6 哈希表</h2><h3 id="第一版">第一版</h3><p>未考虑 hash 码的生成，假定该 hash 码由我们提供</p><p></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashTable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> {</span><br><span class="line">        <span class="type">int</span> hash; <span class="comment">// 哈希码</span></span><br><span class="line">        Object key; <span class="comment">// 键</span></span><br><span class="line">        Object value; <span class="comment">// 值</span></span><br><span class="line">        Entry next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Entry</span><span class="params">(<span class="type">int</span> hash, Object key, Object value)</span> {</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Entry[] table = <span class="keyword">new</span> <span class="title class_">Entry</span>[<span class="number">16</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="type">float</span> <span class="variable">loadFactor</span> <span class="operator">=</span> <span class="number">0.75f</span>; <span class="comment">// 12 阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> (<span class="type">int</span>) (loadFactor * table.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 求模运算替换为位运算</span></span><br><span class="line"><span class="comment">        - 前提：数组长度是 2 的 n 次方</span></span><br><span class="line"><span class="comment">        - hash % 数组长度 等价于 hash &amp; (数组长度-1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 hash 码获取 value</span></span><br><span class="line">    Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> hash, Object key)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> hash &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (table[idx] == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">p</span> <span class="operator">=</span> table[idx];</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (p.key.equals(key)) {</span><br><span class="line">                <span class="keyword">return</span> p.value;</span><br><span class="line">            }</span><br><span class="line">            p = p.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 hash 表存入新 key value，如果 key 重复，则更新 value</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> hash, Object key, Object value)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> hash &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (table[idx] == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 1. idx 处有空位, 直接新增</span></span><br><span class="line">            table[idx] = <span class="keyword">new</span> <span class="title class_">Entry</span>(hash, key, value);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 2. idx 处无空位, 沿链表查找 有重复key更新，否则新增</span></span><br><span class="line">            <span class="type">Entry</span> <span class="variable">p</span> <span class="operator">=</span> table[idx];</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                <span class="keyword">if</span> (p.key.equals(key)) {</span><br><span class="line">                    p.value = value; <span class="comment">// 更新</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (p.next == <span class="literal">null</span>) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                p = p.next;</span><br><span class="line">            }</span><br><span class="line">            p.next = <span class="keyword">new</span> <span class="title class_">Entry</span>(hash, key, value); <span class="comment">// 新增</span></span><br><span class="line">        }</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; threshold) {</span><br><span class="line">            resize();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> {</span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[table.length &lt;&lt; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; table.length; i++) {</span><br><span class="line">            <span class="type">Entry</span> <span class="variable">p</span> <span class="operator">=</span> table[i]; <span class="comment">// 拿到每个链表头</span></span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                拆分链表，移动到新数组，拆分规律</span></span><br><span class="line"><span class="comment">                * 一个链表最多拆成两个</span></span><br><span class="line"><span class="comment">                * hash &amp; table.length == 0 的一组</span></span><br><span class="line"><span class="comment">                * hash &amp; table.length != 0 的一组</span></span><br><span class="line"><span class="comment">                                          p</span></span><br><span class="line"><span class="comment">                0-&gt;8-&gt;16-&gt;24-&gt;32-&gt;40-&gt;48-&gt;null</span></span><br><span class="line"><span class="comment">                            a</span></span><br><span class="line"><span class="comment">                0-&gt;16-&gt;32-&gt;48-&gt;null</span></span><br><span class="line"><span class="comment">                        b</span></span><br><span class="line"><span class="comment">                8-&gt;24-&gt;40-&gt;null</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">                <span class="type">Entry</span> <span class="variable">a</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">Entry</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">Entry</span> <span class="variable">aHead</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">Entry</span> <span class="variable">bHead</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">                    <span class="keyword">if</span> ((p.hash &amp; table.length) == <span class="number">0</span>) {</span><br><span class="line">                        <span class="keyword">if</span> (a != <span class="literal">null</span>) {</span><br><span class="line">                            a.next = p;</span><br><span class="line">                        } <span class="keyword">else</span> {</span><br><span class="line">                            aHead = p;</span><br><span class="line">                        }</span><br><span class="line">                        a = p; <span class="comment">// 分配到a</span></span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        <span class="keyword">if</span> (b != <span class="literal">null</span>) {</span><br><span class="line">                            b.next = p;</span><br><span class="line">                        } <span class="keyword">else</span> {</span><br><span class="line">                            bHead = p;</span><br><span class="line">                        }</span><br><span class="line">                        b = p; <span class="comment">// 分配到b</span></span><br><span class="line">                    }</span><br><span class="line">                    p = p.next;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 规律： a 链表保持索引位置不变，b 链表索引位置+table.length</span></span><br><span class="line">                <span class="keyword">if</span> (a != <span class="literal">null</span>) {</span><br><span class="line">                    a.next = <span class="literal">null</span>;</span><br><span class="line">                    newTable[i] = aHead;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (b != <span class="literal">null</span>) {</span><br><span class="line">                    b.next = <span class="literal">null</span>;</span><br><span class="line">                    newTable[i + table.length] = bHead;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (<span class="type">int</span>) (loadFactor * table.length);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 hash 码删除，返回删除的 value</span></span><br><span class="line">    Object <span class="title function_">remove</span><span class="params">(<span class="type">int</span> hash, Object key)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> hash &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (table[idx] == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">p</span> <span class="operator">=</span> table[idx];</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (p.key.equals(key)) {</span><br><span class="line">                <span class="comment">// 找到了, 删除</span></span><br><span class="line">                <span class="keyword">if</span> (prev == <span class="literal">null</span>) { <span class="comment">// 链表头</span></span><br><span class="line">                    table[idx] = p.next;</span><br><span class="line">                } <span class="keyword">else</span> { <span class="comment">// 非链表头</span></span><br><span class="line">                    prev.next = p.next;</span><br><span class="line">                }</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">return</span> p.value;</span><br><span class="line">            }</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="生成-hashcode">生成 hashCode</h3><figure><img src="../../../../images/StrJava/image-20230424083655435.png" alt="image-20230424083655435"><figcaption aria-hidden="true">image-20230424083655435</figcaption></figure><p>hash算法是将任意对象，分配一个<strong>编号</strong>的过程，其中编号是一个有限范围内的数字（如int 范围内）</p><figure><img src="../../../../images/StrJava/image-20230424090603325.png" alt="image-20230424090603325"><figcaption aria-hidden="true">image-20230424090603325</figcaption></figure><p><strong>Object.hashCode</strong></p><ul><li>Object 的 hashCode 方法默认是生成随机数作为 hash值（会缓存在对象头当中）</li><li>缺点是包含相同<strong>值</strong>的不同对象，他们的 hashCode不一样，不能够用 hash值来反映对象的<strong>值</strong>特征，因此诸多子类都会重写 hashCode方法</li></ul><p><strong>String.hashCode</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">"bac"</span>;                     </span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"abc"</span>);         </span><br><span class="line"></span><br><span class="line">    System.out.println(s1.hashCode());</span><br><span class="line">    System.out.println(s2.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原则：值相同的字符串生成相同的 hash 码, 尽量让值不同的字符串生成不同的 hash 码</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对于 abc  a * 100 + b * 10 + c</span></span><br><span class="line"><span class="comment">    对于 bac  b * 100 + a * 10 + c</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s1.length(); i++) {</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s1.charAt(i);</span><br><span class="line">        System.out.println((<span class="type">int</span>) c);</span><br><span class="line">        <span class="comment">// (a*10 + b)*10 + c  ==&gt;  a*100 + b*10 + c  2^5</span></span><br><span class="line">        hash = (hash &lt;&lt; <span class="number">5</span>) - hash + c;     </span><br><span class="line">    }</span><br><span class="line">    System.out.println(hash);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>经验表明如果每次乘的是较大质数，可以有更好地降低 hash冲突，因此改【乘 10】为【乘 31】</li><li>【乘 31】可以等价为【乘 32 - hash】，进一步可以转为更高效地【左移5位- hash】</li></ul><p><strong>检查 hash 表的分散性</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[table.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; table.length; i++) {</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">p</span> <span class="operator">=</span> table[i];</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            sum[i]++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    System.out.println(Arrays.toString(sum));</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, Long&gt; result = Arrays.stream(sum).boxed()</span><br><span class="line">        .collect(Collectors.groupingBy(s -&gt; s, Collectors.counting()));</span><br><span class="line">    System.out.println(result);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 测试 Object.hashCode</span></span><br><span class="line">    <span class="type">HashTable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashTable</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200000</span>; i++) {</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        table.put(obj, obj);</span><br><span class="line">    }</span><br><span class="line">    table.print();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试 String.hashCode</span></span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">HashTable</span>();</span><br><span class="line">    List&lt;String&gt; strings = Files.readAllLines(Path.of(<span class="string">"words"</span>));</span><br><span class="line">    <span class="keyword">for</span> (String string : strings) {</span><br><span class="line">        table.put(string, string);</span><br><span class="line">    }</span><br><span class="line">    table.print();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>MurmurHash</strong></p><figure><img src="../../../../images/StrJava/image-20230425084247888.png" alt="image-20230425084247888"><figcaption aria-hidden="true">image-20230425084247888</figcaption></figure><h3 id="思考">思考</h3><ol type="1"><li>我们的代码里使用了尾插法，如果改成头插法呢？</li><li>JDK 的 HashMap 中采用了将对象 hashCode高低位相互异或的方式减少冲突，怎么理解</li><li>我们的 HashTable 中表格容量是 2 的 n次方，很多优化都是基于这个前提，能否不用 2 的 n 次方作为表格容量？</li><li>JDK 的 HashMap 在链表长度过长会转换成红黑树，对此你怎么看</li></ol><h3 id="习题-10">习题</h3><h4 id="e01.-两数之和-leetcode-1">E01. 两数之和-Leetcode 1</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E01Leetcode1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) {</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(k)) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]{i, map.get(k)};</span><br><span class="line">            }</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 不会执行</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>注意：题目明确说明<strong>只会存在一个有效答案</strong>，因此不会执行到最后的return null</li></ul><h4 id="e02.-无重复字符的最长字串-leetcode-3">E02.无重复字符的最长字串-Leetcode 3</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> {</span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>; end &lt; s.length(); end++) {</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(end);</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(ch)) { <span class="comment">// 重复时调整 begin</span></span><br><span class="line">            begin = Math.max(begin, map.get(ch) + <span class="number">1</span>);</span><br><span class="line">            map.put(ch, end);</span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">// 不重复</span></span><br><span class="line">            map.put(ch, end);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(s.substring(begin, end + <span class="number">1</span>));</span><br><span class="line">        maxLength = Math.max(maxLength, end - begin + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>begin 调整时的解释，遇到重复的 begin 应该向右调整，例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">abca</span><br></pre></td></tr></tbody></table></figure><ul><li>遇到重复的 a，这时 begin 应该调整到上个重复字符 a 索引加 1 处，即map.get('a') + 1 = 1，</li></ul><p>但还有一种情况需要考虑，就是连续遇到两次重复，例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">abba</span><br></pre></td></tr></tbody></table></figure><ul><li>遇到重复的 b，这时 begin 应该调整到上个重复字符 b 索引加 1 处，即map.get('b') + 1 = 2</li><li>不过接下来，又遇到了重复的 a，此时若还执行 map.get('a') + 1 = 1，则begin 相当于向左退了，不对</li><li>应该是 Math.max(2, map.get('a') + 1)，即 begin应该是两个重复字符索引中更靠右者</li></ul><p>题目中说明 s由英文字母、数字、符号和空格组成，因此它的范围是有限的（在 0 ~127之内），可以用数组来替代 HashMap 优化，如下</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> {</span><br><span class="line">    <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">    Arrays.fill(map, -<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>; end &lt; s.length(); end++) {</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(end);</span><br><span class="line">        <span class="keyword">if</span> (map[ch] != -<span class="number">1</span>) { <span class="comment">// 重复时调整 begin</span></span><br><span class="line">            begin = Math.max(begin, map[ch] + <span class="number">1</span>);</span><br><span class="line">            map[ch] = end;</span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">// 不重复</span></span><br><span class="line">            map[ch] = end;</span><br><span class="line">        }</span><br><span class="line">        System.out.println(s.substring(begin, end + <span class="number">1</span>));</span><br><span class="line">        maxLength = Math.max(maxLength, end - begin + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e03.-字母异位词分组-leetcode-49">E03. 字母异位词分组-Leetcode49</h4><p>解法1</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> {</span><br><span class="line">    HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) {</span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">        List&lt;String&gt; strings = map.computeIfAbsent(key, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        strings.add(str);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解法2</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ArrayKey</span> {</span><br><span class="line">    <span class="type">int</span>[] key = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayKey</span><span class="params">(String str)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) {</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">            key[ch - <span class="string">'a'</span>]++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayKey</span> <span class="variable">arrayKey</span> <span class="operator">=</span> (ArrayKey) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(key, arrayKey.key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> Arrays.hashCode(key);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> {</span><br><span class="line">    HashMap&lt;ArrayKey, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) {</span><br><span class="line">        List&lt;String&gt; strings = map.computeIfAbsent(<span class="keyword">new</span> <span class="title class_">ArrayKey</span>(str), k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        strings.add(str);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e04.-判断有没有重复元素-leetcode-217">E04.判断有没有重复元素-Leetcode 217</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> { <span class="comment">// 5ms</span></span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> key : nums) {</span><br><span class="line">        <span class="keyword">if</span> (!set.add(key)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e05.-找出出现一次的数字-leetcode-136">E05.找出出现一次的数字-Leetcode 136</h4><p>解法1：用 HashSet</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) {</span><br><span class="line">        <span class="keyword">if</span> (!set.add(num)) {</span><br><span class="line">            set.remove(num);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> set.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">0</span>])[<span class="number">0</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解法2：用 xor</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) {</span><br><span class="line">        num = num ^ nums[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e06.-判断字母异位词-leetcode-242">E06. 判断字母异位词-Leetcode242</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> { <span class="comment">// 1ms</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.equals(getKey(s), getKey(t));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] getKey(String s) {</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : chars) {</span><br><span class="line">        array[ch - <span class="number">97</span>]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>其中用 s.toCharArray() 性能明显高于用 s.charAt() 一个个获取字符</li></ul><h4 id="e07.-第一个不重复字符-leetcode-387">E07.第一个不重复字符-Leetcode 387</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> {</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : chars) {</span><br><span class="line">        array[ch-<span class="number">97</span>]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) {</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> chars[i];</span><br><span class="line">        <span class="keyword">if</span> (array[ch - <span class="number">97</span>] == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e08.-出现次数最多的单词-leetcode-819">E08.出现次数最多的单词-Leetcode 819</h4><p>简洁解法 14 ms</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">mostCommonWord</span><span class="params">(String paragraph, String[] banned)</span> {</span><br><span class="line">    Set&lt;String&gt; banSet = Set.of(banned);</span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">String[] split = paragraph.toLowerCase().split(<span class="string">"[^A-Za-z]+"</span>);</span><br><span class="line">    <span class="keyword">for</span> (String key : split) {</span><br><span class="line">        <span class="keyword">if</span>(banSet.contains(key)) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        map.compute(key, (k, v) -&gt; v == <span class="literal">null</span> ? <span class="number">1</span> : v + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">Optional&lt;Map.Entry&lt;String, Integer&gt;&gt; optional = map.entrySet().stream().max(Map.Entry.comparingByValue());</span><br><span class="line">    <span class="keyword">return</span> optional.map(Map.Entry::getKey).orElse(<span class="literal">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>后两行避免 lambda，12 ms</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">mostCommonWord</span><span class="params">(String paragraph, String[] banned)</span> {</span><br><span class="line">    Set&lt;String&gt; banSet = Set.of(banned);</span><br><span class="line">    String[] split = paragraph.toLowerCase().split(<span class="string">"[^A-Za-z]+"</span>);</span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String key : split) {</span><br><span class="line">        <span class="keyword">if</span>(banSet.contains(key)) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        map.compute(key, (k, v) -&gt; v == <span class="literal">null</span> ? <span class="number">1</span> : v + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">maxKey</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; e : map.entrySet()) {</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">        <span class="keyword">if</span> (value &gt; max) {</span><br><span class="line">            max = value;</span><br><span class="line">            maxKey = e.getKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxKey;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>避免正则匹配 5ms</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">mostCommonWord</span><span class="params">(String paragraph, String[] banned)</span> {</span><br><span class="line">    Set&lt;String&gt; banSet = Set.of(banned);</span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[] chars = paragraph.toLowerCase().toCharArray();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : chars) {</span><br><span class="line">        <span class="keyword">if</span> (ch &gt;= <span class="string">'a'</span> &amp;&amp; ch &lt;= <span class="string">'z'</span>) {</span><br><span class="line">            sb.append(ch);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            put(banSet, map, sb);</span><br><span class="line">            sb = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    put(banSet, map, sb);</span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">maxKey</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; e : map.entrySet()) {</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">        <span class="keyword">if</span> (value &gt; max) {</span><br><span class="line">            max = value;</span><br><span class="line">            maxKey = e.getKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxKey;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Set&lt;String&gt; banSet, HashMap&lt;String, Integer&gt; map, StringBuilder sb)</span> {</span><br><span class="line">    <span class="keyword">if</span> (sb.length() &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        <span class="keyword">if</span>(!banSet.contains(key)) {</span><br><span class="line">            map.compute(key, (k, v) -&gt; v == <span class="literal">null</span> ? <span class="number">1</span> : v + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>sb 避免每次新建 4ms</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">sb.setLength(<span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure><h4 id="e09.-根据前序与中序遍历结果构造二叉树-leetcode105-improved">E09.根据前序与中序遍历结果构造二叉树-Leetcode105 Improved</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E09Leetcode105Improved</span> {</span><br><span class="line">    <span class="comment">//  用 hashmap 改善查找性能，其中 key 是 inOrder 值， value 是 inOrder 索引</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preOrder, <span class="type">int</span>[] inOrder)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inOrder.length; i++) {</span><br><span class="line">            map.put(inOrder[i], i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> helper(preOrder, <span class="number">0</span>, <span class="number">0</span>, inOrder.length - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// preBegin 决定了每次在 preOrder 中找到根元素</span></span><br><span class="line">    <span class="comment">// inBegin 和 inEnd 可以用来获取区间内元素个数，结束递归等</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">helper</span><span class="params">(<span class="type">int</span>[] preOrder, <span class="type">int</span> preBegin, <span class="type">int</span> inBegin, <span class="type">int</span> inEnd)</span> {</span><br><span class="line">        <span class="keyword">if</span> (inBegin &gt; inEnd) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootValue</span> <span class="operator">=</span> preOrder[preBegin];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootValue);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> map.get(rootValue);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> i - inBegin;</span><br><span class="line">        System.out.println(<span class="string">"元素："</span> + rootValue + <span class="string">" left["</span> + (preBegin + <span class="number">1</span>) + <span class="string">"] inOrder 索引范围["</span> + inBegin + <span class="string">"~"</span> + (i - <span class="number">1</span>) + <span class="string">"]"</span>);</span><br><span class="line">        System.out.println(<span class="string">"元素："</span> + rootValue + <span class="string">" right["</span> + (preBegin + <span class="number">1</span> + leftSize) + <span class="string">"] inOrder 索引范围["</span> + (i + <span class="number">1</span>) + <span class="string">"~"</span> + inEnd + <span class="string">"]"</span>);</span><br><span class="line">        root.left = helper(preOrder, preBegin + <span class="number">1</span>, inBegin, i - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(preOrder, preBegin + <span class="number">1</span> + leftSize, i + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] preOrder = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>};</span><br><span class="line">        <span class="type">int</span>[] inOrder = {<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>};</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        例如：</span></span><br><span class="line"><span class="comment">        根据根节点[1] 到中序遍历数组中一分为2，首次递归</span></span><br><span class="line"><span class="comment">            [1] 2  4  3  6  7  前</span></span><br><span class="line"><span class="comment">            0   1  2  3  4  5  前索引</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            4  2  [1] 6  3  7  中</span></span><br><span class="line"><span class="comment">            0  1  2   3  4  5  中索引</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            确定 preOrder 中 left 和 right 的递归起始索引，当然也要确定 inOrder 对应的两个索引位置</span></span><br><span class="line"><span class="comment">                left    right</span></span><br><span class="line"><span class="comment">            1   [2]  4  [3]  6  7  前</span></span><br><span class="line"><span class="comment">            0   1    2  3    4  5  前索引</span></span><br><span class="line"><span class="comment">            left  inOrder 索引范围： 0~1</span></span><br><span class="line"><span class="comment">            right inOrder 索引范围： 3~5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E09Leetcode105Improved</span>().buildTree(preOrder, inOrder);</span><br><span class="line">        System.out.println(root);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e10.-根据中序与后序遍历结果构造二叉树-leetcode106-improved">E10.根据中序与后序遍历结果构造二叉树-Leetcode106 Improved</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E10Leetcode106Improved</span> {</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inOrder, <span class="type">int</span>[] postOrder)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inOrder.length; i++) {</span><br><span class="line">            map.put(inOrder[i], i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> helper(postOrder, postOrder.length - <span class="number">1</span>, <span class="number">0</span>, inOrder.length - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        inOrder = {4,2,1,6,3,7}</span></span><br><span class="line"><span class="comment">        postOrder = {4,2,6,7,3,1}</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">helper</span><span class="params">(<span class="type">int</span>[] postOrder, <span class="type">int</span> postEnd, <span class="type">int</span> inBegin, <span class="type">int</span> inEnd)</span> {</span><br><span class="line">        <span class="keyword">if</span> (inBegin &gt; inEnd) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootValue</span> <span class="operator">=</span> postOrder[postEnd];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootValue);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> map.get(rootValue);</span><br><span class="line"><span class="comment">//        int leftSize = i - inBegin;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightSize</span> <span class="operator">=</span> inEnd - i;</span><br><span class="line">        System.out.println(<span class="string">"元素："</span> + rootValue + <span class="string">" left["</span> + (postEnd - <span class="number">1</span> - rightSize) + <span class="string">"] inOrder 索引范围["</span> + inBegin + <span class="string">"~"</span> + (i - <span class="number">1</span>) + <span class="string">"]"</span>);</span><br><span class="line">        System.out.println(<span class="string">"元素："</span> + rootValue + <span class="string">" right["</span> + (postEnd - <span class="number">1</span>) + <span class="string">"] inOrder 索引范围["</span> + (i + <span class="number">1</span>) + <span class="string">"~"</span> + inEnd + <span class="string">"]"</span>);</span><br><span class="line">        root.left = helper(postOrder, postEnd - <span class="number">1</span> - rightSize, inBegin, i - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(postOrder, postEnd - <span class="number">1</span>, i + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] postOrder = {<span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>};</span><br><span class="line">        <span class="type">int</span>[] inOrder = {<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>};</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E10Leetcode106Improved</span>().buildTree(inOrder, postOrder);</span><br><span class="line">        System.out.println(root);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="排序算法">3.7 排序算法</h2><h3 id="概述-10">概述</h3><h4 id="比较排序算法">比较排序算法</h4><table><colgroup><col style="width: 3%"><col style="width: 9%"><col style="width: 9%"><col style="width: 9%"><col style="width: 6%"><col style="width: 3%"><col style="width: 3%"><col style="width: 55%"></colgroup><thead><tr class="header"><th style="text-align: center;">算法</th><th style="text-align: center;">最好</th><th style="text-align: center;">最坏</th><th style="text-align: center;">平均</th><th style="text-align: center;">空间</th><th style="text-align: center;">稳定</th><th style="text-align: center;">思想</th><th style="text-align: center;">注意事项</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">冒泡</td><td style="text-align: center;">O(n)</td><td style="text-align: center;">O(<span class="math inline">\(n^2\)</span>)</td><td style="text-align: center;">O(<span class="math inline">\(n^2\)</span>)</td><td style="text-align: center;">O(1)</td><td style="text-align: center;">Y</td><td style="text-align: center;">比较</td><td style="text-align: center;">最好情况需要额外判断</td></tr><tr class="even"><td style="text-align: center;">选择</td><td style="text-align: center;">O(<span class="math inline">\(n^2\)</span>)</td><td style="text-align: center;">O(<span class="math inline">\(n^2\)</span>)</td><td style="text-align: center;">O(<span class="math inline">\(n^2\)</span>)</td><td style="text-align: center;">O(1)</td><td style="text-align: center;">N</td><td style="text-align: center;">比较</td><td style="text-align: center;">交换次数一般少于冒泡</td></tr><tr class="odd"><td style="text-align: center;">堆</td><td style="text-align: center;">O(<span class="math inline">\(nlogn\)</span>)</td><td style="text-align: center;">O(<span class="math inline">\(nlogn\)</span>)</td><td style="text-align: center;">O(<span class="math inline">\(nlogn\)</span>)</td><td style="text-align: center;">O(1)</td><td style="text-align: center;">N</td><td style="text-align: center;">选择</td><td style="text-align: center;">堆排序的辅助性较强，理解前先理解堆的数据结构</td></tr><tr class="even"><td style="text-align: center;">插入</td><td style="text-align: center;">O(n)</td><td style="text-align: center;">O(<span class="math inline">\(n^2\)</span>)</td><td style="text-align: center;">O(<span class="math inline">\(n^2\)</span>)</td><td style="text-align: center;">O(1)</td><td style="text-align: center;">Y</td><td style="text-align: center;">比较</td><td style="text-align: center;">插入排序对于近乎有序的数据处理速度比较快，复杂度有所下降，可以提前结束</td></tr><tr class="odd"><td style="text-align: center;">希尔</td><td style="text-align: center;">O(nlogn)</td><td style="text-align: center;">O(<span class="math inline">\(n^2\)</span>)</td><td style="text-align: center;">O(<span class="math inline">\(nlogn\)</span>)</td><td style="text-align: center;">O(1)</td><td style="text-align: center;">N</td><td style="text-align: center;">插入</td><td style="text-align: center;">gap序列的构造有多种方式，不同方式处理的数据复杂度可能不同</td></tr><tr class="even"><td style="text-align: center;">归并</td><td style="text-align: center;">O(<span class="math inline">\(nlogn\)</span>)</td><td style="text-align: center;">O(<span class="math inline">\(nlogn\)</span>)</td><td style="text-align: center;">O(<span class="math inline">\(nlogn\)</span>)</td><td style="text-align: center;">O(n)</td><td style="text-align: center;">Y</td><td style="text-align: center;">分治</td><td style="text-align: center;">需要额外的O(n)的存储空间</td></tr><tr class="odd"><td style="text-align: center;">快速</td><td style="text-align: center;">O(<span class="math inline">\(nlogn\)</span>)</td><td style="text-align: center;">O(<span class="math inline">\(n^2\)</span>)</td><td style="text-align: center;">O(<span class="math inline">\(nlogn\)</span>)</td><td style="text-align: center;">O(logn)</td><td style="text-align: center;">N</td><td style="text-align: center;">分治</td><td style="text-align: center;">快排可能存在最坏情况，需要把枢轴值选取得尽量随机化来缓解最坏情况下的时间复杂度</td></tr></tbody></table><h4 id="非比较排序算法">非比较排序算法</h4><table><thead><tr class="header"><th>非比较排序算法</th><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr class="odd"><td>计数排序</td><td>O(n+k)</td><td>O(n+k)</td><td>稳定</td></tr><tr class="even"><td>桶排序</td><td>O(n+k)</td><td>O(n+k)</td><td>稳定</td></tr><tr class="odd"><td>基数排序</td><td>O(d*(n+k))</td><td>O(n+k)</td><td>稳定</td></tr></tbody></table><p>其中</p><ul><li>n 是数组长度</li><li>k 是桶长度</li><li>d 是基数位数</li></ul><h4 id="稳定-vs-不稳定">稳定 vs 不稳定</h4><figure><img src="../../../../images/StrJava/stability_playing_cards.svg.png" alt="stability_playing_cards.svg"><figcaption aria-hidden="true">stability_playing_cards.svg</figcaption></figure><h4 id="java-中的排序">Java 中的排序</h4><p>Arrays.sort</p><p>JDK 7~13 中的排序实现</p><table><colgroup><col style="width: 32%"><col style="width: 46%"><col style="width: 21%"></colgroup><thead><tr class="header"><th>排序目标</th><th>条件</th><th>采用算法</th></tr></thead><tbody><tr class="odd"><td>int[] long[] float[] double[]</td><td>size &lt; 47</td><td>混合插入排序 (pair)</td></tr><tr class="even"><td></td><td>size &lt; 286</td><td>双基准点快排</td></tr><tr class="odd"><td></td><td>有序度低</td><td>双基准点快排</td></tr><tr class="even"><td></td><td>有序度高</td><td>归并排序</td></tr><tr class="odd"><td>byte[]</td><td>size &lt;= 29</td><td>插入排序</td></tr><tr class="even"><td></td><td>size &gt; 29</td><td>计数排序</td></tr><tr class="odd"><td>char[] short[]</td><td>size &lt; 47</td><td>插入排序</td></tr><tr class="even"><td></td><td>size &lt; 286</td><td>双基准点快排</td></tr><tr class="odd"><td></td><td>有序度低</td><td>双基准点快排</td></tr><tr class="even"><td></td><td>有序度高</td><td>归并排序</td></tr><tr class="odd"><td></td><td>size &gt; 3200</td><td>计数排序</td></tr><tr class="even"><td>Object[]</td><td>-Djava.util.Arrays.useLegacyMergeSort=true</td><td>传统归并排序</td></tr><tr class="odd"><td></td><td></td><td>TimSort</td></tr></tbody></table><p>JDK 14~20 中的排序实现</p><table><colgroup><col style="width: 31%"><col style="width: 48%"><col style="width: 19%"></colgroup><thead><tr class="header"><th>排序目标</th><th>条件</th><th>采用算法</th></tr></thead><tbody><tr class="odd"><td>int[] long[] float[] double[]</td><td>size &lt; 44 并位于最左侧</td><td>插入排序</td></tr><tr class="even"><td></td><td>size &lt; 65 并不是最左侧</td><td>混合插入排序 (pin)</td></tr><tr class="odd"><td></td><td>有序度低</td><td>双基准点快排</td></tr><tr class="even"><td></td><td>递归次数超过 384</td><td>堆排序</td></tr><tr class="odd"><td></td><td>对于整个数组或非最左侧 size &gt; 4096，有序度高</td><td>归并排序</td></tr><tr class="even"><td>byte[]</td><td>size &lt;= 64</td><td>插入排序</td></tr><tr class="odd"><td></td><td>size &gt; 64</td><td>计数排序</td></tr><tr class="even"><td>char[] short[]</td><td>size &lt; 44</td><td>插入排序</td></tr><tr class="odd"><td></td><td>再大</td><td>双基准点快排</td></tr><tr class="even"><td></td><td>递归次数超过 384</td><td>计数排序</td></tr><tr class="odd"><td></td><td>size &gt; 1750</td><td>计数排序</td></tr><tr class="even"><td>Object[]</td><td>-Djava.util.Arrays.useLegacyMergeSort=true</td><td>传统归并排序</td></tr><tr class="odd"><td></td><td></td><td>TimSort</td></tr></tbody></table><ul><li>其中 TimSort 是用归并+二分插入排序的混合排序算法</li><li>值得注意的是从 JDK 8 开始支持 Arrays.parallelSort 并行排序</li><li>根据最新的提交记录来看 JDK 21 可能会引入基数排序等优化</li></ul><h4 id="外部排序">外部排序</h4><h3 id="冒泡排序">1) 冒泡排序</h3><p>要点</p><ul><li>每轮冒泡不断地比较<strong>相邻</strong>的两个元素，如果它们是逆序的，则交换它们的位置</li><li>下一轮冒泡，可以调整未排序的右边界，减少不必要比较</li></ul><p>以数组 3、2、1 的冒泡排序为例，第一轮冒泡</p><figure><img src="../../../../images/StrJava/image-20230504153631958.png" alt="image-20230504153631958"><figcaption aria-hidden="true">image-20230504153631958</figcaption></figure><p>第二轮冒泡</p><figure><img src="../../../../images/StrJava/image-20230504154044402.png" alt="image-20230504154044402"><figcaption aria-hidden="true">image-20230504154044402</figcaption></figure><p>未排序区域内就剩一个元素，结束</p><figure><img src="../../../../images/StrJava/image-20230504154213239.png" alt="image-20230504154213239"><figcaption aria-hidden="true">image-20230504154213239</figcaption></figure><p>优化手段：每次循环时，若能确定<strong>更合适的</strong>右边界，则可以减少冒泡轮数</p><p>以数组 3、2、1、4、5 为例，第一轮结束后记录的 x，即为右边界</p><figure><img src="../../../../images/StrJava/image-20230504161136854.png" alt="image-20230504161136854"><figcaption aria-hidden="true">image-20230504161136854</figcaption></figure><p>非递归版代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> a.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; j; i++) {</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">                    a[i] = a[i + <span class="number">1</span>];</span><br><span class="line">                    a[i + <span class="number">1</span>] = t;</span><br><span class="line">                    x = i;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            j = x;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] a = {<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>};</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        bubble(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="选择排序">2) 选择排序</h3><p>要点</p><ul><li>每一轮选择，找出最大（最小）的元素，并把它交换到合适的位置</li></ul><p>以下面的数组选择最大值为例</p><figure><img src="../../../../images/StrJava/image-20230507112728513.png" alt="image-20230507112728513"><figcaption aria-hidden="true">image-20230507112728513</figcaption></figure><p>非递归实现</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">        <span class="comment">// 1. 选择轮数 a.length - 1</span></span><br><span class="line">        <span class="comment">// 2. 交换的索引位置(right) 初始 a.length - 1, 每次递减</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> a.length - <span class="number">1</span>; right &gt; <span class="number">0</span> ; right--) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> right;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right; i++) {</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; a[max]) {</span><br><span class="line">                    max = i;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(max != right) {</span><br><span class="line">                swap(a, max, right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] a = {<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>};</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="堆排序">3) 堆排序</h3><p>要点：</p><ul><li>建立大顶堆</li><li>每次将堆顶元素（最大值）交换到末尾，调整堆顶元素，让它重新符合大顶堆特性</li></ul><p>建堆</p><figure><img src="../../../../images/StrJava/image-20230508080820117.png" alt="image-20230508080820117"><figcaption aria-hidden="true">image-20230508080820117</figcaption></figure><p>交换，下潜调整</p><figure><img src="../../../../images/StrJava/image-20230508080912944.png" alt="image-20230508080912944"><figcaption aria-hidden="true">image-20230508080912944</figcaption></figure><figure><img src="../../../../images/StrJava/image-20230508080959301.png" alt="image-20230508080959301"><figcaption aria-hidden="true">image-20230508080959301</figcaption></figure><figure><img src="../../../../images/StrJava/image-20230508081052055.png" alt="image-20230508081052055"><figcaption aria-hidden="true">image-20230508081052055</figcaption></figure><figure><img src="../../../../images/StrJava/image-20230508081220301.png" alt="image-20230508081220301"><figcaption aria-hidden="true">image-20230508081220301</figcaption></figure><figure><img src="../../../../images/StrJava/image-20230508081315265.png" alt="image-20230508081315265"><figcaption aria-hidden="true">image-20230508081315265</figcaption></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">        heapify(a, a.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> a.length - <span class="number">1</span>; right &gt; <span class="number">0</span>; right--) {</span><br><span class="line">            swap(a, <span class="number">0</span>, right);</span><br><span class="line">            down(a, <span class="number">0</span>, right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建堆 O(n)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> size)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            down(array, i, size);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下潜</span></span><br><span class="line">    <span class="comment">// leetcode 上数组排序题目用堆排序求解，非递归实现比递归实现大约快 6ms</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> parent, <span class="type">int</span> size)</span> {</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> parent;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; size &amp;&amp; array[left] &gt; array[max]) {</span><br><span class="line">                max = left;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp; array[right] &gt; array[max]) {</span><br><span class="line">                max = right;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (max == parent) { <span class="comment">// 没找到更大的孩子</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            swap(array, max, parent);</span><br><span class="line">            parent = max;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] a = {<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="插入排序">4) 插入排序</h3><p>要点</p><ul><li><em>将数组分为两部分</em> <em>[0 .. low-1] [low .. a.length-1]</em><ul><li><em>左边</em> <em>[0 .. low-1]</em> <em>是已排序部分</em></li><li><em>右边</em> <em>[low .. a.length-1]</em><em>是未排序部分</em></li></ul></li><li><em>每次从未排序区域取出</em> <em>low</em> <em>位置的元素</em>,<em>插入到已排序区域</em></li></ul><p>例</p><figure><img src="../../../../images/StrJava/image-20230513150750673.png" alt="image-20230513150750673"><figcaption aria-hidden="true">image-20230513150750673</figcaption></figure><figure><img src="../../../../images/StrJava/image-20230513150907333.png" alt="image-20230513150907333"><figcaption aria-hidden="true">image-20230513150907333</figcaption></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertionSort</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">1</span>; low &lt; a.length; low++) {</span><br><span class="line">            <span class="comment">// 将 low 位置的元素插入至 [0..low-1] 的已排序区域</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[low];</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low - <span class="number">1</span>; <span class="comment">// 已排序区域指针</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; t &lt; a[i]) { <span class="comment">// 没有找到插入位置</span></span><br><span class="line">                a[i + <span class="number">1</span>] = a[i]; <span class="comment">// 空出插入位置</span></span><br><span class="line">                i--;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到插入位置</span></span><br><span class="line">            <span class="keyword">if</span> (i != low - <span class="number">1</span>) {</span><br><span class="line">                a[i + <span class="number">1</span>] = t;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] a = {<span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>};</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="希尔排序">5) 希尔排序</h3><p>要点</p><ul><li>简单的说，就是分组实现插入，每组元素间隙称为 gap</li><li>每轮排序后 gap 逐渐变小，直至 gap 为 1 完成排序</li><li>对插入排序的优化，让元素更快速地交换到最终位置</li></ul><p>下图演示了 gap = 4，gap = 2，gap = 1 的三轮排序前后比较</p><figure><img src="../../../../images/StrJava/image-20230508182439075.png" alt="image-20230508182439075"><figcaption aria-hidden="true">image-20230508182439075</figcaption></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> a.length&gt;&gt;<span class="number">1</span>; gap &gt;<span class="number">0</span> ; gap=gap&gt;&gt;<span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> gap; low &lt; a.length; low ++) {</span><br><span class="line">                <span class="comment">// 将 low 位置的元素插入至 [0..low-1] 的已排序区域</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[low];</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low - gap; <span class="comment">// 已排序区域指针</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; t &lt; a[i]) { <span class="comment">// 没有找到插入位置</span></span><br><span class="line">                    a[i + gap] = a[i]; <span class="comment">// 空出插入位置</span></span><br><span class="line">                    i -= gap;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 找到插入位置</span></span><br><span class="line">                <span class="keyword">if</span> (i != low - gap) {</span><br><span class="line">                    a[i + gap] = t;</span><br><span class="line">                }</span><br><span class="line">            }            </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] a = {<span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>};</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        sort(a);</span><br><span class="line">System.out.println(Arrays.toString(a));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="归并排序">6) 归并排序</h3><h4 id="递归实现-1">递归实现</h4><p>要点</p><ul><li>分 - 每次从中间切一刀，处理的数据少一半</li><li>治 - 当数据仅剩一个时可以认为有序</li><li>合 - 两个有序的结果，可以进行合并排序（参见数组练习 E01.合并有序数组）</li></ul><figure><img src="../../../../images/StrJava/image-20230513143854887.png" alt="image-20230513143854887"><figcaption aria-hidden="true">image-20230513143854887</figcaption></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSortTopDown</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        a1 原始数组</span></span><br><span class="line"><span class="comment">        i~iEnd 第一个有序范围</span></span><br><span class="line"><span class="comment">        j~jEnd 第二个有序范围</span></span><br><span class="line"><span class="comment">        a2 临时数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span> i, <span class="type">int</span> iEnd, <span class="type">int</span> j, <span class="type">int</span> jEnd, <span class="type">int</span>[] a2)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= iEnd &amp;&amp; j &lt;= jEnd) {</span><br><span class="line">            <span class="keyword">if</span> (a1[i] &lt; a1[j]) {</span><br><span class="line">                a2[k] = a1[i];</span><br><span class="line">                i++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                a2[k] = a1[j];</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">            k++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (i &gt; iEnd) {</span><br><span class="line">            System.arraycopy(a1, j, a2, k, jEnd - j + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (j &gt; jEnd) {</span><br><span class="line">            System.arraycopy(a1, i, a2, k, iEnd - i + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a1)</span> {</span><br><span class="line">        <span class="type">int</span>[] a2 = <span class="keyword">new</span> <span class="title class_">int</span>[a1.length];</span><br><span class="line">        split(a1, <span class="number">0</span>, a1.length - <span class="number">1</span>, a2);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] a2)</span> {</span><br><span class="line">        <span class="type">int</span>[] array = Arrays.copyOfRange(a1, left, right + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//        System.out.println(Arrays.toString(array));</span></span><br><span class="line">        <span class="comment">// 2. 治</span></span><br><span class="line">        <span class="keyword">if</span> (left == right) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 1. 分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        split(a1, left, m, a2);                 <span class="comment">// left = 0 m = 0  9</span></span><br><span class="line">        split(a1, m + <span class="number">1</span>, right, a2);       <span class="comment">// m+1 = 1 right = 1  3</span></span><br><span class="line">        <span class="comment">// 3. 合</span></span><br><span class="line">        merge(a1, left, m, m + <span class="number">1</span>, right, a2);</span><br><span class="line">        System.arraycopy(a2, left, a1, left, right - left + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] a = {<span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>};</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="时间复杂度">时间复杂度</h4><ul><li><p>两个长度为 m 和 n 的链表合并，时间复杂度是 m + n</p></li><li><p>归并，时间复杂度：<span class="math inline">\(f(n) = 2f(n/2) + n,f(1)=c\)</span>，等价解 <span class="math inline">\(f(n) = nlog_2{n} +cn\)</span></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">             8</span><br><span class="line">          /     \</span><br><span class="line">         4       4</span><br><span class="line">        / \     / \</span><br><span class="line">       2   2   2   2</span><br><span class="line">      ||   ||  ||  ||</span><br><span class="line">      11   11  11  11    </span><br><span class="line">      </span><br><span class="line">f(8) = 2f(4) + 8</span><br><span class="line">f(4) = 2f(2) + 4</span><br><span class="line">f(2) = 2f(1) + 2</span><br><span class="line">f(1) = 1</span><br><span class="line"></span><br><span class="line">f(8) = 8 + 24</span><br><span class="line">f(4) = 4 + 8</span><br><span class="line">f(2) = 2 + 2</span><br><span class="line">f(1) = 1</span><br></pre></td></tr></tbody></table></figure><ul><li>当 n = 16 时，结果 80</li><li>当 n = 64 时，结果 448</li></ul></li><li><p>若逐一合并，时间复杂度：<span class="math inline">\(f(n)=\sum\limits_{n=0}^{n-1}n+1\)</span>，等价解<span class="math inline">\(f(n)=\frac{1}{2}(n^2+n)\)</span></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1|0 =&gt; 1</span><br><span class="line">1|1 =&gt; 2</span><br><span class="line">1|2 =&gt; 3</span><br><span class="line">1|3 =&gt; 4</span><br><span class="line">1|4 =&gt; 5</span><br><span class="line">1|5 =&gt; 6</span><br><span class="line">1|6 =&gt; 7</span><br><span class="line">1|7 =&gt; 8</span><br><span class="line"></span><br><span class="line">36</span><br></pre></td></tr></tbody></table></figure><ul><li>当 n = 16 时，结果 136</li><li>当 n = 64 时，结果 2080</li></ul></li></ul><h4 id="非递归实现-1">非递归实现</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSortBottomUp</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        a1 原始数组</span></span><br><span class="line"><span class="comment">        i~iEnd 第一个有序范围</span></span><br><span class="line"><span class="comment">        j~jEnd 第二个有序范围</span></span><br><span class="line"><span class="comment">        a2 临时数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span> i, <span class="type">int</span> iEnd, <span class="type">int</span> j, <span class="type">int</span> jEnd, <span class="type">int</span>[] a2)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= iEnd &amp;&amp; j &lt;= jEnd) {</span><br><span class="line">            <span class="keyword">if</span> (a1[i] &lt; a1[j]) {</span><br><span class="line">                a2[k] = a1[i];</span><br><span class="line">                i++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                a2[k] = a1[j];</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">            k++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (i &gt; iEnd) {</span><br><span class="line">            System.arraycopy(a1, j, a2, k, jEnd - j + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (j &gt; jEnd) {</span><br><span class="line">            System.arraycopy(a1, i, a2, k, iEnd - i + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a1)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a1.length;</span><br><span class="line">        <span class="type">int</span>[] a2 = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">1</span>; width &lt; n; width *= <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * width) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> Integer.min(i + width - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Integer.min(i + <span class="number">2</span> * width - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">                System.out.println(i + <span class="string">" "</span> + m + <span class="string">" "</span> + j);</span><br><span class="line">                merge(a1, i, m, m + <span class="number">1</span>, j, a2);</span><br><span class="line">            }</span><br><span class="line">            System.arraycopy(a2, <span class="number">0</span>, a1, <span class="number">0</span>, n);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] a = {<span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>};</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="归并插入">7) 归并+插入</h3><ul><li>小数据量且有序度高时，插入排序效果高</li><li>大数据量用归并效果好</li><li>可以结合二者</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeInsertionSort</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertion</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> left + <span class="number">1</span>; low &lt;= right; low++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[low];</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= left &amp;&amp; t &lt; a[i]) {</span><br><span class="line">                a[i + <span class="number">1</span>] = a[i];</span><br><span class="line">                i--;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (i != low - <span class="number">1</span>) {</span><br><span class="line">                a[i + <span class="number">1</span>] = t;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        a1 原始数组</span></span><br><span class="line"><span class="comment">        i~iEnd 第一个有序范围</span></span><br><span class="line"><span class="comment">        j~jEnd 第二个有序范围</span></span><br><span class="line"><span class="comment">        a2 临时数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span> i, <span class="type">int</span> iEnd, <span class="type">int</span> j, <span class="type">int</span> jEnd, <span class="type">int</span>[] a2)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= iEnd &amp;&amp; j &lt;= jEnd) {</span><br><span class="line">            <span class="keyword">if</span> (a1[i] &lt; a1[j]) {</span><br><span class="line">                a2[k] = a1[i];</span><br><span class="line">                i++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                a2[k] = a1[j];</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">            k++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (i &gt; iEnd) {</span><br><span class="line">            System.arraycopy(a1, j, a2, k, jEnd - j + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (j &gt; jEnd) {</span><br><span class="line">            System.arraycopy(a1, i, a2, k, iEnd - i + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a1)</span> {</span><br><span class="line">        <span class="type">int</span>[] a2 = <span class="keyword">new</span> <span class="title class_">int</span>[a1.length];</span><br><span class="line">        split(a1, <span class="number">0</span>, a1.length - <span class="number">1</span>, a2);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] a2)</span> {</span><br><span class="line"><span class="comment">//        int[] array = Arrays.copyOfRange(a1, left, right + 1);</span></span><br><span class="line"><span class="comment">//        System.out.println(Arrays.toString(array));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 治</span></span><br><span class="line">        <span class="keyword">if</span> (right == left) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (right - left &lt;= <span class="number">32</span>) {</span><br><span class="line">            insertion(a1, left, right);</span><br><span class="line">            System.out.println(<span class="string">"insert..."</span> + left + <span class="string">" "</span> + right +<span class="string">" "</span>+Arrays.toString(a1));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 1. 分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        split(a1, left, m, a2);                 <span class="comment">// left = 0 m = 0  9</span></span><br><span class="line">        split(a1, m + <span class="number">1</span>, right, a2);       <span class="comment">// m+1 = 1 right = 1  3</span></span><br><span class="line">        System.out.println(left + <span class="string">" "</span> + right + <span class="string">" "</span>+Arrays.toString(a1));</span><br><span class="line">        <span class="comment">// 3. 合</span></span><br><span class="line">        merge(a1, left, m, m + <span class="number">1</span>, right, a2);</span><br><span class="line">        System.arraycopy(a2, left, a1, left, right - left + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] a = {<span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>};</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="快速排序">8) 快速排序</h3><p>单边循环（lomuto分区）要点</p><ul><li>选择最右侧元素作为基准点</li><li>j 找比基准点小的，i 找比基准点大的，一旦找到，二者进行交换<ul><li>交换时机：j 找到小的，且与 i 不相等</li><li>i 找到 &gt;= 基准点元素后，不应自增</li></ul></li><li>最后基准点与 i 交换，i 即为基准点最终索引</li></ul><p>例：</p><p>i 和 j 都从左边出发向右查找，i找到比基准点4大的5，j找到比基准点小的2，停下来交换</p><figure><img src="../../../../images/StrJava/image-20230513145045085.png" alt="image-20230513145045085"><figcaption aria-hidden="true">image-20230513145045085</figcaption></figure><p>i 找到了比基准点大的5，j 找到比基准点小的3，停下来交换</p><figure><img src="../../../../images/StrJava/image-20230513145259217.png" alt="image-20230513145259217"><figcaption aria-hidden="true">image-20230513145259217</figcaption></figure><p>j 到达right 处结束，right 与 i 交换，一轮分区结束</p><figure><img src="../../../../images/StrJava/image-20230513145454772.png" alt="image-20230513145454772"><figcaption aria-hidden="true">image-20230513145454772</figcaption></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSortLomuto</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">        quick(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a, left, right); <span class="comment">// p代表基准点元素索引</span></span><br><span class="line">        quick(a, left, p - <span class="number">1</span>);</span><br><span class="line">        quick(a, p + <span class="number">1</span>, right);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> a[right]; <span class="comment">// 基准点元素值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; right) {</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; pv) { <span class="comment">// j 找到比基准点小的了, 没找到大的</span></span><br><span class="line">                <span class="keyword">if</span> (i != j) {</span><br><span class="line">                    swap(a, i, j);</span><br><span class="line">                }</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        swap(a, i, right);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] a = {<span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>};</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>双边循环要点</p><ul><li>选择最左侧元素作为基准点</li><li>j 找比基准点小的，i 找比基准点大的，一旦找到，二者进行交换<ul><li>i 从左向右</li><li>j 从右向左</li></ul></li><li>最后基准点与 i 交换，i 即为基准点最终索引</li></ul><p>例：</p><p>i 找到比基准点大的5停下来，j找到比基准点小的1停下来（包含等于），二者交换</p><figure><img src="../../../../images/StrJava/image-20230513145918612.png" alt="image-20230513145918612"><figcaption aria-hidden="true">image-20230513145918612</figcaption></figure><p>i 找到8，j 找到3，二者交换，i 找到7，j 找到2，二者交换</p><figure><img src="../../../../images/StrJava/image-20230513150158220.png" alt="image-20230513150158220"><figcaption aria-hidden="true">image-20230513150158220</figcaption></figure><p>i == j，退出循环，基准点与 i 交换</p><figure><img src="../../../../images/StrJava/image-20230513150351115.png" alt="image-20230513150351115"><figcaption aria-hidden="true">image-20230513150351115</figcaption></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSortHoare</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">        quick(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a, left, right);</span><br><span class="line">        quick(a, left, p - <span class="number">1</span>);</span><br><span class="line">        quick(a, p + <span class="number">1</span>, right);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> a[left];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) {</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt; pv) {</span><br><span class="line">                j--;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; pv &gt;= a[i]) {</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            swap(a, i, j);</span><br><span class="line">        }</span><br><span class="line">        swap(a, left, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] a = {<span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>};</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="随机基准点">随机基准点</h4><p>使用随机数作为基准点，避免万一最大值或最小值作为基准点导致的分区不均衡</p><p>例</p><figure><img src="../../../../images/StrJava/image-20230513152038090.png" alt="image-20230513152038090"><figcaption aria-hidden="true">image-20230513152038090</figcaption></figure><p>改进代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(right - left + <span class="number">1</span>) + left;</span><br><span class="line">swap(a, idx, left);</span><br></pre></td></tr></tbody></table></figure><h4 id="处理重复值">处理重复值</h4><p>如果重复值较多，则原来算法中的分区效果也不好，如下图中左侧所示，需要想办法改为右侧的分区效果</p><figure><img src="../../../../images/StrJava/image-20230513151851103.png" alt="image-20230513151851103"><figcaption aria-hidden="true">image-20230513151851103</figcaption></figure><p>改进代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSortHandleDuplicate</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">        quick(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a, left, right);</span><br><span class="line">        quick(a, left, p - <span class="number">1</span>);</span><br><span class="line">        quick(a, p + <span class="number">1</span>, right);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        循环内</span></span><br><span class="line"><span class="comment">            i 从 left + 1 开始，从左向右找大的或相等的</span></span><br><span class="line"><span class="comment">            j 从 right 开始，从右向左找小的或相等的</span></span><br><span class="line"><span class="comment">            交换，i++ j--</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        循环外 j 和 基准点交换，j 即为分区位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(right - left + <span class="number">1</span>) + left;</span><br><span class="line">        swap(a, left, idx);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> a[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) {</span><br><span class="line">            <span class="comment">// i 从左向右找大的或者相等的</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; a[i] &lt; pv) {</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// j 从右向左找小的或者相等的</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; a[j] &gt; pv) {</span><br><span class="line">                j--;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= j) {</span><br><span class="line">                swap(a, i, j);</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        swap(a, j, left);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="comment">//        int[] a = {4, 2, 1, 3, 2, 4}; // 最外层循环 = 要加</span></span><br><span class="line"><span class="comment">//        int[] a = {2, 1, 3, 2}; // 内层循环 = 要加</span></span><br><span class="line">        <span class="type">int</span>[] a = {<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>}; <span class="comment">// 内层if要加</span></span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>核心思想是<ul><li>改进前，i 只找大于的，j会找小于等于的。一个不找等于、一个找等于，势必导致等于的值分布不平衡</li><li>改进后，二者都会找等于的交换，等于的值会平衡分布在基准点两边</li></ul></li><li>细节：<ul><li>因为一开始 i 就可能等于j，因此外层循环需要加等于条件保证至少进入一次，让 j 能减到正确位置</li><li>内层 while 循环中 i &lt;= j 的 = 也不能去掉，因为 i == j时也要做一次与基准点的判断，好让 i 及 j 正确</li><li>i == j 时，也要做一次 i++ 和 j-- 使下次循环二者不等才能退出</li><li>因为最后退出循环时 i 会大于 j，因此最终与基准点交换的是 j</li></ul></li><li>内层两个 while 循环的先后顺序不再重要</li></ul><h3 id="计数排序">9) 计数排序</h3><p>方法1（简化后的计数排序）</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : a) {</span><br><span class="line">        <span class="keyword">if</span> (i &gt; max) {</span><br><span class="line">            max = i;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; min) {</span><br><span class="line">            min = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span>[] counting = <span class="keyword">new</span> <span class="title class_">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : a) {</span><br><span class="line">        counting[i - min]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; counting.length; i++) {</span><br><span class="line">        <span class="keyword">while</span> (counting[i] &gt; <span class="number">0</span>) {</span><br><span class="line">            a[k] = i + min;</span><br><span class="line">            counting[i]--;</span><br><span class="line">            k++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>针对 byte []，因为数据范围已知，省去了求最大、最小值的过程，java 中对char[]、short[]、byte[] 的排序都可能采用 counting 排序</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">byte</span>[] a)</span> {</span><br><span class="line">    <span class="type">int</span>[] counting = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : a) {</span><br><span class="line">        counting[i &amp; <span class="number">0xFF</span>]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> a.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">128</span> + <span class="number">256</span>; k &gt;= <span class="number">0</span>; ) {            </span><br><span class="line">        <span class="keyword">while</span> (counting[--i &amp; <span class="number">0xFF</span>] ==<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> i &amp; <span class="number">0xFF</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> counting[i &amp; <span class="number">0xFF</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; c; j++) {</span><br><span class="line">            a[k] = (<span class="type">byte</span>) v;</span><br><span class="line">            k--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>稳定计数排序</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort2</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : a) {</span><br><span class="line">        <span class="keyword">if</span> (i &gt; max) {</span><br><span class="line">            max = i;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; min) {</span><br><span class="line">            min = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span>[] counting = <span class="keyword">new</span> <span class="title class_">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : a) {</span><br><span class="line">        counting[i - min]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; counting.length; i++) {</span><br><span class="line">        counting[i] = counting[i] + counting[i - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[a.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> a[i] - min;</span><br><span class="line">        counting[j]--;</span><br><span class="line">        b[counting[j]] = a[i];</span><br><span class="line">    }</span><br><span class="line">    System.arraycopy(b, <span class="number">0</span>, a, <span class="number">0</span>, a.length);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="桶排序">10) 桶排序</h3><p>初步实现</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSort</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] ages = {<span class="number">20</span>, <span class="number">18</span>, <span class="number">66</span>, <span class="number">25</span>, <span class="number">67</span>, <span class="number">30</span>}; <span class="comment">// 假设人类年龄 1~99 那么分为10个桶</span></span><br><span class="line">        System.out.println(Arrays.toString(ages));</span><br><span class="line">        sort(ages);</span><br><span class="line">        System.out.println(Arrays.toString(ages));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">        DynamicArray[] buckets = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buckets.length; i++) {</span><br><span class="line">            buckets[i] = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : a) {</span><br><span class="line">            <span class="type">DynamicArray</span> <span class="variable">bucket</span> <span class="operator">=</span> buckets[v / <span class="number">10</span>];</span><br><span class="line">            bucket.addLast(v);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (DynamicArray bucket : buckets) {</span><br><span class="line">            System.out.println(Arrays.toString(bucket.array()));</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (DynamicArray bucket : buckets) {</span><br><span class="line">            <span class="type">int</span>[] array = bucket.array();</span><br><span class="line">            InsertionSort.sort(array);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : array) {</span><br><span class="line">                a[k++] = v;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通用</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSortGeneric</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] ages = {<span class="number">20</span>, <span class="number">10</span>, <span class="number">28</span>, <span class="number">66</span>, <span class="number">25</span>, <span class="number">31</span>, <span class="number">67</span>, <span class="number">30</span>, <span class="number">70</span>}; <span class="comment">// 假设人类年龄 1~99</span></span><br><span class="line">        System.out.println(Arrays.toString(ages));</span><br><span class="line">        sort(ages, <span class="number">20</span>);</span><br><span class="line">        System.out.println(Arrays.toString(ages));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> range)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; max) {</span><br><span class="line">                max = a[i];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; min) {</span><br><span class="line">                min = a[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 1. 准备桶</span></span><br><span class="line">        DynamicArray[] buckets = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>[(max - min) / range + <span class="number">1</span>];</span><br><span class="line">        System.out.println(buckets.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buckets.length; i++) {</span><br><span class="line">            buckets[i] = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 2. 放入年龄数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> age : a) {</span><br><span class="line">            buckets[(age - min) / range].addLast(age);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (DynamicArray bucket : buckets) {</span><br><span class="line">            <span class="comment">// 3. 排序桶内元素</span></span><br><span class="line">            <span class="type">int</span>[] array = bucket.array();</span><br><span class="line">            InsertionSort.sort(array);</span><br><span class="line">            System.out.println(Arrays.toString(array));</span><br><span class="line">            <span class="comment">// 4. 把每个桶排序好的内容，依次放入原始数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : array) {</span><br><span class="line">                a[k++] = v;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="基数排序">11) 基数排序</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(String[] a, <span class="type">int</span> length)</span> {</span><br><span class="line">        ArrayList&lt;String&gt;[] buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buckets.length; i++) {</span><br><span class="line">            buckets[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) {</span><br><span class="line">            <span class="keyword">for</span> (String s : a) {</span><br><span class="line">                buckets[s.charAt(i)].add(s);</span><br><span class="line">            }</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (ArrayList&lt;String&gt; bucket : buckets) {</span><br><span class="line">                <span class="keyword">for</span> (String s : bucket) {</span><br><span class="line">                    a[k++] = s;</span><br><span class="line">                }</span><br><span class="line">                bucket.clear();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">/*String[] phoneNumbers = new String[10];</span></span><br><span class="line"><span class="comment">        phoneNumbers[0] = "13812345678";</span></span><br><span class="line"><span class="comment">        phoneNumbers[1] = "13912345678";</span></span><br><span class="line"><span class="comment">        phoneNumbers[2] = "13612345678";</span></span><br><span class="line"><span class="comment">        phoneNumbers[3] = "13712345678";</span></span><br><span class="line"><span class="comment">        phoneNumbers[4] = "13512345678";</span></span><br><span class="line"><span class="comment">        phoneNumbers[5] = "13412345678";</span></span><br><span class="line"><span class="comment">        phoneNumbers[6] = "15012345678";</span></span><br><span class="line"><span class="comment">        phoneNumbers[7] = "15112345678";</span></span><br><span class="line"><span class="comment">        phoneNumbers[8] = "15212345678";</span></span><br><span class="line"><span class="comment">        phoneNumbers[9] = "15712345678";*/</span></span><br><span class="line"></span><br><span class="line">        String[] phoneNumbers = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">        phoneNumbers[<span class="number">0</span>] = <span class="string">"138"</span>;</span><br><span class="line">        phoneNumbers[<span class="number">1</span>] = <span class="string">"139"</span>;</span><br><span class="line">        phoneNumbers[<span class="number">2</span>] = <span class="string">"136"</span>;</span><br><span class="line">        phoneNumbers[<span class="number">3</span>] = <span class="string">"137"</span>;</span><br><span class="line">        phoneNumbers[<span class="number">4</span>] = <span class="string">"135"</span>;</span><br><span class="line">        phoneNumbers[<span class="number">5</span>] = <span class="string">"134"</span>;</span><br><span class="line">        phoneNumbers[<span class="number">6</span>] = <span class="string">"150"</span>;</span><br><span class="line">        phoneNumbers[<span class="number">7</span>] = <span class="string">"151"</span>;</span><br><span class="line">        phoneNumbers[<span class="number">8</span>] = <span class="string">"152"</span>;</span><br><span class="line">        phoneNumbers[<span class="number">9</span>] = <span class="string">"157"</span>;</span><br><span class="line">        RadixSort.radixSort(phoneNumbers, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (String phoneNumber : phoneNumbers) {</span><br><span class="line">            System.out.println(phoneNumber);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>基数排序是稳定排序，因此先排个位、再排十位，十位的排序不会打乱个位取值相等的元素顺序</p><h3 id="习题-11">习题</h3><h4 id="e01.-根据另一个数组次序排序-leetcode-1122">E01.根据另一个数组次序排序-Leetcode 1122</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    前提</span></span><br><span class="line"><span class="comment">    1. 元素值均 &gt;= 0</span></span><br><span class="line"><span class="comment">    2. arr2 内元素唯一，且长度 &lt;= 1000</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E01Leetcode1122</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] relativeSortArray(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2) {</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1001</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr1) {</span><br><span class="line">            count[i]++;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr2) {</span><br><span class="line">            <span class="keyword">while</span> (count[i] &gt; <span class="number">0</span>) {</span><br><span class="line">                result[k++] = i;</span><br><span class="line">                count[i]--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count.length; i++) {</span><br><span class="line">            <span class="keyword">while</span> (count[i] &gt; <span class="number">0</span>) {</span><br><span class="line">                result[k++] = i;</span><br><span class="line">                count[i]--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e02.-按出现频率排序-leetcode-1636">E02. 按出现频率排序-Leetcode1636</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E02Leetcode1636</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] frequencySort(<span class="type">int</span>[] nums) {</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">201</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) {</span><br><span class="line">            count[i + <span class="number">100</span>]++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(nums).boxed().sorted((a, b) -&gt; {</span><br><span class="line">            <span class="type">int</span> <span class="variable">fa</span> <span class="operator">=</span> count[a + <span class="number">100</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">fb</span> <span class="operator">=</span> count[b + <span class="number">100</span>];</span><br><span class="line">            <span class="keyword">if</span> (fa == fb) {</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(b, a);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> fa - fb;</span><br><span class="line">            }</span><br><span class="line">        }).mapToInt(Integer::intValue).toArray();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e03.-最大间距-leetcode-164">E03. 最大间距-Leetcode 164</h4><p>解法1：桶排序 - 超过<strong>内存</strong>限制</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E03Leetcode164_1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumGap</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        sort(nums, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            ret = Math.max(ret, nums[i] - nums[i - <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> range)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; max) {</span><br><span class="line">                max = a[i];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; min) {</span><br><span class="line">                min = a[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 1. 准备桶</span></span><br><span class="line">        DynamicArray[] buckets = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>[(max - min) / range + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buckets.length; i++) {</span><br><span class="line">            buckets[i] = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 2. 放入数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> age : a) {</span><br><span class="line">            buckets[(age - min) / range].addLast(age);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (DynamicArray bucket : buckets) {</span><br><span class="line">            <span class="comment">// 3. 排序桶内元素</span></span><br><span class="line">            <span class="type">int</span>[] array = bucket.array();</span><br><span class="line">            InsertionSort.sort(array);</span><br><span class="line">            <span class="comment">// 4. 把每个桶排序好的内容，依次放入原始数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : array) {</span><br><span class="line">                a[k++] = v;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] nums = {<span class="number">13</span>, <span class="number">26</span>, <span class="number">16</span>, <span class="number">11</span>};</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E03Leetcode164_1</span>().maximumGap(nums);</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解法2：基数排序</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E03Leetcode164</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumGap</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">                </span><br><span class="line">        <span class="comment">// 计算最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) {</span><br><span class="line">            max = Math.max(a[i], max);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备10个桶</span></span><br><span class="line">        ArrayList&lt;Integer&gt;[] buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buckets.length; i++) {</span><br><span class="line">            buckets[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没超过最大值</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (max &gt;= exp) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : a) {</span><br><span class="line">                buckets[(j / (<span class="type">int</span>) exp) % <span class="number">10</span>].add(j);</span><br><span class="line">            }</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (ArrayList&lt;Integer&gt; bucket : buckets) {</span><br><span class="line">                <span class="keyword">for</span> (Integer i : bucket) {</span><br><span class="line">                    a[k++] = i;</span><br><span class="line">                }</span><br><span class="line">                bucket.clear();</span><br><span class="line">            }</span><br><span class="line">            exp *= <span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求最大间距</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) {</span><br><span class="line">            r = Math.max(r, a[i] - a[i - <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] nums = {<span class="number">3</span>, <span class="number">6</span>, <span class="number">16</span>, <span class="number">1</span>};</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E03Leetcode164</span>().maximumGap(nums);</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解法3：桶排序 - 合理化桶个数</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E03Leetcode164_3</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumGap</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="comment">// 1. 处理特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 2. 桶排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">1</span>; i1 &lt; nums.length; i1++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i1] &gt; max) {</span><br><span class="line">                max = nums[i1];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (nums[i1] &lt; min) {</span><br><span class="line">                min = nums[i1];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 2.1 准备桶</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            计算桶个数                   期望桶个数</span></span><br><span class="line"><span class="comment">            (max - min) / range + 1 = nums.length</span></span><br><span class="line"><span class="comment">            (max - min) / (nums.length - 1) = range</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">range</span> <span class="operator">=</span> Math.max((max - min) / (nums.length - <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">        DynamicArray[] buckets = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>[(max - min) / range + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">0</span>; i1 &lt; buckets.length; i1++) {</span><br><span class="line">            buckets[i1] = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 2.2 放入数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> age : nums) {</span><br><span class="line">            buckets[(age - min) / range].addLast(age);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (DynamicArray bucket : buckets) {</span><br><span class="line">            <span class="comment">// 2.3 排序桶内元素</span></span><br><span class="line">            <span class="type">int</span>[] array = bucket.array();</span><br><span class="line">            InsertionSort.sort(array);</span><br><span class="line">            System.out.println(Arrays.toString(array));</span><br><span class="line">            <span class="comment">// 2.4 把每个桶排序好的内容，依次放入原始数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : array) {</span><br><span class="line">                nums[k++] = v;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 3. 寻找最大差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) {</span><br><span class="line">            r = Math.max(r, nums[i] - nums[i - <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="comment">//        int[] nums = {1, 10000000};</span></span><br><span class="line"><span class="comment">//        int[] nums = {9, 1, 3, 5};</span></span><br><span class="line"><span class="comment">//        int[] nums = {1, 1, 1, 1};</span></span><br><span class="line"><span class="comment">//        int[] nums = {1, 1, 1, 1, 1, 5, 5, 5, 5, 5};</span></span><br><span class="line">        <span class="type">int</span>[] nums = {<span class="number">15252</span>, <span class="number">16764</span>, <span class="number">27963</span>, <span class="number">7817</span>, <span class="number">26155</span>, <span class="number">20757</span>, <span class="number">3478</span>, <span class="number">22602</span>, <span class="number">20404</span>, <span class="number">6739</span>, <span class="number">16790</span>, <span class="number">10588</span>, <span class="number">16521</span>, <span class="number">6644</span>, <span class="number">20880</span>, <span class="number">15632</span>, <span class="number">27078</span>, <span class="number">25463</span>, <span class="number">20124</span>, <span class="number">15728</span>, <span class="number">30042</span>, <span class="number">16604</span>, <span class="number">17223</span>, <span class="number">4388</span>, <span class="number">23646</span>, <span class="number">32683</span>, <span class="number">23688</span>, <span class="number">12439</span>, <span class="number">30630</span>, <span class="number">3895</span>, <span class="number">7926</span>, <span class="number">22101</span>, <span class="number">32406</span>, <span class="number">21540</span>, <span class="number">31799</span>, <span class="number">3768</span>, <span class="number">26679</span>, <span class="number">21799</span>, <span class="number">23740</span>};</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E03Leetcode164_3</span>().maximumGap(nums);</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解法4：在解法3的基础上，只保留桶内最大最小值</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E03Leetcode164_4</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumGap</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="comment">// 1. 处理特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 2. 桶排序</span></span><br><span class="line">        <span class="comment">// 桶个数 (max - min) / range + 1  期望桶个数 nums.length + 1</span></span><br><span class="line">        <span class="comment">// range = (max - min) / nums.length</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; max) {</span><br><span class="line">                max = nums[i];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; min) {</span><br><span class="line">                min = nums[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (max == min) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">range</span> <span class="operator">=</span> Math.max(<span class="number">1</span>, (max - min) / nums.length);</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> (max - min) / range + <span class="number">1</span>;</span><br><span class="line">        Pair[] buckets = <span class="keyword">new</span> <span class="title class_">Pair</span>[size];</span><br><span class="line">        <span class="comment">// 2. 放入数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> (i - min) / range;</span><br><span class="line">            <span class="keyword">if</span> (buckets[idx] == <span class="literal">null</span>) {</span><br><span class="line">                buckets[idx] = <span class="keyword">new</span> <span class="title class_">Pair</span>();</span><br><span class="line">            }</span><br><span class="line">            buckets[idx].add(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(buckets));</span><br><span class="line">        <span class="comment">// 3. 寻找最大差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastMax</span> <span class="operator">=</span> buckets[<span class="number">0</span>].max;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; buckets.length; i++) {</span><br><span class="line">            <span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> buckets[i];</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">null</span>) {</span><br><span class="line">                r = Math.max(r, pair.min - lastMax);</span><br><span class="line">                lastMax = pair.max;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Pair</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">1000_000_000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> v)</span> {</span><br><span class="line">            max = Math.max(max, v);</span><br><span class="line">            min = Math.min(min, v);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"["</span> + min + <span class="string">","</span> + max + <span class="string">"]"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] nums = {<span class="number">9</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>};</span><br><span class="line"><span class="comment">//        int[] nums = {1, 10000000};</span></span><br><span class="line"><span class="comment">//        int[] nums = {1, 1, 1, 1};</span></span><br><span class="line"><span class="comment">//        int[] nums = {1, 1, 1, 1, 1, 5, 5, 5, 5, 5};</span></span><br><span class="line"><span class="comment">//        int[] nums = {15252, 16764, 27963, 7817, 26155, 20757, 3478, 22602, 20404, 6739, 16790, 10588, 16521, 6644, 20880, 15632, 27078, 25463, 20124, 15728, 30042, 16604, 17223, 4388, 23646, 32683, 23688, 12439, 30630, 3895, 7926, 22101, 32406, 21540, 31799, 3768, 26679, 21799, 23740};</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E03Leetcode164_4</span>().maximumGap(nums);</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="排序数组-leetcode-912">排序数组-Leetcode 912</h4><h4 id="排序链表-leetcode-148">排序链表-Leetcode 148</h4><h4 id="其它题目-2">其它题目</h4><table><thead><tr class="header"><th>题目编号</th><th>题目标题</th><th>排序算法类型</th></tr></thead><tbody><tr class="odd"><td>1122</td><td>数组的相对排序</td><td>计数排序</td></tr><tr class="even"><td>1636</td><td>按照频率将数组升序排序</td><td>计数排序</td></tr><tr class="odd"><td>164</td><td>最大间距</td><td>基数排序、桶排序</td></tr><tr class="even"><td>315</td><td>计算右侧小于当前元素的个数</td><td>基数排序</td></tr><tr class="odd"><td>347</td><td>前 K 个高频元素</td><td>桶排序</td></tr></tbody></table><table><thead><tr class="header"><th>题目编号</th><th>题目标题</th><th>排序算法类型</th></tr></thead><tbody><tr class="odd"><td>75</td><td>颜色分类</td><td>三向切分快速排序</td></tr><tr class="even"><td>215</td><td>数组中的第K个最大元素</td><td>堆排序</td></tr><tr class="odd"><td>493</td><td>翻转对</td><td>归并排序</td></tr><tr class="even"><td>493</td><td>翻转对</td><td>树状数组</td></tr><tr class="odd"><td>524</td><td>通过删除字母匹配到字典里最长单词</td><td>循环排序</td></tr><tr class="even"><td>977</td><td>有序数组的平方</td><td>双指针法</td></tr></tbody></table><h1 id="四.-高级数据结构与算法设计">四. 高级数据结构与算法设计</h1><h2 id="图">4.1 图</h2><h3 id="概念">1) 概念</h3><p>图是由顶点（vertex）和边（edge）组成的数据结构，例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A---&gt;B</span><br><span class="line">    A---&gt;C</span><br><span class="line">    B---&gt;D</span><br><span class="line">    C---&gt;D</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>该图有四个顶点：A、B、C、D 以及四条有向边，有向图中，边是单向的</p><h4 id="有向-vs-无向">有向 vs 无向</h4><p>如果是无向图，那么边是双向的，下面是一个无向图的例子</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A---B</span><br><span class="line">    A---C</span><br><span class="line">    B---D</span><br><span class="line">    C---D</span><br></pre></td></tr></tbody></table></figure><h4 id="度">度</h4><p><strong>度</strong>是指与该顶点相邻的边的数量</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A((A))---B((B))</span><br><span class="line">    A---C((C))</span><br><span class="line">    B---D((D))</span><br><span class="line">    C---D</span><br><span class="line">    D---E((E))</span><br><span class="line">    D---F((F))</span><br><span class="line">    E---F</span><br><span class="line">    A &amp; B &amp; C &amp; D &amp; E &amp; F</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>例如上图中</p><ul><li>A、B、C、E、F 这几个顶点度数为 2</li><li>D 顶点度数为 4</li></ul><p>有向图中，细分为<strong>入度</strong>和<strong>出度</strong>，参见下图</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A((A))--&gt;B((B))</span><br><span class="line">    A--&gt;C((C))</span><br><span class="line">    B--&gt;D((D))</span><br><span class="line">    C--&gt;D</span><br><span class="line">    D--&gt;E((E))</span><br><span class="line">    D--&gt;F((F))</span><br><span class="line">    E--&gt;F</span><br><span class="line">    A &amp; B &amp; C &amp; D &amp; E &amp; F</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>A (2 out / 0 in)</li><li>B、C、E (1 out / 1 in)</li><li>D (2 out / 2 in)</li><li>F (0 out / 2 in)</li></ul><h4 id="权">权</h4><p>边可以有权重，代表从源顶点到目标顶点的距离、费用、时间或其他度量。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    BJ((北京))</span><br><span class="line">    WH((武汉))</span><br><span class="line">    GZ((广州))</span><br><span class="line">    SH((上海))</span><br><span class="line">    BJ---800km--&gt;WH</span><br><span class="line">    BJ---1900km--&gt;GZ</span><br><span class="line">    BJ---1200km--&gt;SH</span><br><span class="line">    WH---1050km--&gt;GZ</span><br><span class="line">    WH---700km--&gt;SH</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="路径">路径</h4><p>路径被定义为从一个顶点到另一个顶点的一系列连续边，例如上图中【北京】到【上海】有多条路径</p><ul><li>北京 - 上海</li><li>北京 - 武汉 - 上海</li></ul><p>路径长度</p><ul><li>不考虑权重，长度就是边的数量</li><li>考虑权重，一般就是权重累加</li></ul><h4 id="环">环</h4><p>在有向图中，从一个顶点开始，可以通过若干条有向边返回到该顶点，那么就形成了一个环</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">  A((A))</span><br><span class="line">  B((B))</span><br><span class="line">  C((C))</span><br><span class="line">  D((D))</span><br><span class="line">  E((E))</span><br><span class="line"></span><br><span class="line">  A---&gt;B</span><br><span class="line">  B---&gt;C</span><br><span class="line">  C---&gt;D</span><br><span class="line">  D---&gt;E</span><br><span class="line">  E---&gt;A</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="图的连通性">图的连通性</h4><p>如果两个顶点之间存在路径，则这两个顶点是连通的，所有顶点都连通，则该图被称之为连通图，若子图连通，则称为连通分量</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A --- B</span><br><span class="line">    A --- C</span><br><span class="line">    C --- D</span><br><span class="line">    D --- E</span><br><span class="line">    B --- E</span><br><span class="line">    F --- G</span><br><span class="line">    G --- H</span><br><span class="line">    H --- F</span><br><span class="line">    I --- J</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="图的表示">2) 图的表示</h3><p>比如说，下面的图</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A---B</span><br><span class="line">    A---C</span><br><span class="line">    B---D</span><br><span class="line">    C---D</span><br></pre></td></tr></tbody></table></figure><p>用<strong>邻接矩阵</strong>可以表示为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">  A B C D</span><br><span class="line">A 0 1 1 0</span><br><span class="line">B 1 0 0 1 </span><br><span class="line">C 1 0 0 1</span><br><span class="line">D 0 1 1 0</span><br></pre></td></tr></tbody></table></figure><p>用<strong>邻接表</strong>可以表示为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">A -&gt; B -&gt; C</span><br><span class="line">B -&gt; A -&gt; D</span><br><span class="line">C -&gt; A -&gt; D</span><br><span class="line">D -&gt; B -&gt; C</span><br></pre></td></tr></tbody></table></figure><p>有向图的例子</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A---&gt;B</span><br><span class="line">    A---&gt;C</span><br><span class="line">    B---&gt;D</span><br><span class="line">    C---&gt;D</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">  A B C D</span><br><span class="line">A 0 1 1 0</span><br><span class="line">B 0 0 0 1</span><br><span class="line">C 0 0 0 1</span><br><span class="line">D 0 0 0 0</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">A - B - C</span><br><span class="line">B - D</span><br><span class="line">C - D</span><br><span class="line">D - empty</span><br></pre></td></tr></tbody></table></figure><h3 id="java-表示">3) Java 表示</h3><p>顶点</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vertex</span> {</span><br><span class="line">    String name;</span><br><span class="line">    List&lt;Edge&gt; edges;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拓扑排序相关</span></span><br><span class="line">    <span class="type">int</span> inDegree;</span><br><span class="line">    <span class="type">int</span> status; <span class="comment">// 状态 0-未访问 1-访问中 2-访问过，用在拓扑排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dfs, bfs 相关</span></span><br><span class="line">    <span class="type">boolean</span> visited;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求解最短距离相关</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dist</span> <span class="operator">=</span> INF;</span><br><span class="line">    <span class="type">Vertex</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>边</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Edge</span> {</span><br><span class="line"></span><br><span class="line">    Vertex linked;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(Vertex linked)</span> {</span><br><span class="line">        <span class="built_in">this</span>(linked, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(Vertex linked, <span class="type">int</span> weight)</span> {</span><br><span class="line">        <span class="built_in">this</span>.linked = linked;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="dfs">4) DFS</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dfs</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v1"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v2"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v3"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v4"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v5"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v6"</span>);</span><br><span class="line"></span><br><span class="line">        v1.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v3), <span class="keyword">new</span> <span class="title class_">Edge</span>(v2), <span class="keyword">new</span> <span class="title class_">Edge</span>(v6));</span><br><span class="line">        v2.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4));</span><br><span class="line">        v3.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4), <span class="keyword">new</span> <span class="title class_">Edge</span>(v6));</span><br><span class="line">        v4.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v5));</span><br><span class="line">        v5.edges = List.of();</span><br><span class="line">        v6.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v5));</span><br><span class="line"></span><br><span class="line">        dfs1(v1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs2</span><span class="params">(Vertex v)</span> {</span><br><span class="line">        LinkedList&lt;Vertex&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(v);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">            <span class="type">Vertex</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            pop.visited = <span class="literal">true</span>;</span><br><span class="line">            System.out.println(pop.name);</span><br><span class="line">            <span class="keyword">for</span> (Edge edge : pop.edges) {</span><br><span class="line">                <span class="keyword">if</span> (!edge.linked.visited) {</span><br><span class="line">                    stack.push(edge.linked);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs1</span><span class="params">(Vertex v)</span> {</span><br><span class="line">        v.visited = <span class="literal">true</span>;</span><br><span class="line">        System.out.println(v.name);</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : v.edges) {</span><br><span class="line">            <span class="keyword">if</span> (!edge.linked.visited) {</span><br><span class="line">                dfs(edge.linked);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="bfs">5) BFS</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bfs</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v1"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v2"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v3"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v4"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v5"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v6"</span>);</span><br><span class="line"></span><br><span class="line">        v1.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v3), <span class="keyword">new</span> <span class="title class_">Edge</span>(v2), <span class="keyword">new</span> <span class="title class_">Edge</span>(v6));</span><br><span class="line">        v2.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4));</span><br><span class="line">        v3.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4), <span class="keyword">new</span> <span class="title class_">Edge</span>(v6));</span><br><span class="line">        v4.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v5));</span><br><span class="line">        v5.edges = List.of();</span><br><span class="line">        v6.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v5));</span><br><span class="line"></span><br><span class="line">        bfs(v1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(Vertex v)</span> {</span><br><span class="line">        LinkedList&lt;Vertex&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        v.visited = <span class="literal">true</span>;</span><br><span class="line">        queue.offer(v);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            <span class="type">Vertex</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.println(poll.name);</span><br><span class="line">            <span class="keyword">for</span> (Edge edge : poll.edges) {</span><br><span class="line">                <span class="keyword">if</span> (!edge.linked.visited) {</span><br><span class="line">                    edge.linked.visited = <span class="literal">true</span>;</span><br><span class="line">                    queue.offer(edge.linked);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="拓扑排序">6) 拓扑排序</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">HTML[网页基础] --&gt; WEB</span><br><span class="line">    SE[Java 基础] --&gt; WEB[Java Web] </span><br><span class="line">    DB[数据库] --&gt; Spring</span><br><span class="line">    WEB --&gt; Spring[Spring框架]</span><br><span class="line">    Spring --&gt; Micro[微服务框架]</span><br><span class="line">    Micro --&gt; Project[实战项目]</span><br></pre></td></tr></tbody></table></figure><h4 id="kahn">Kahn</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopologicalSort</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"网页基础"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"Java基础"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"JavaWeb"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"Spring框架"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"微服务框架"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"数据库"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"实战项目"</span>);</span><br><span class="line"></span><br><span class="line">        v1.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v3)); <span class="comment">// +1</span></span><br><span class="line">        v2.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v3)); <span class="comment">// +1</span></span><br><span class="line">        v3.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4));</span><br><span class="line">        v6.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4));</span><br><span class="line">        v4.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v5));</span><br><span class="line">        v5.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v7));</span><br><span class="line">        v7.edges = List.of();</span><br><span class="line"></span><br><span class="line">        List&lt;Vertex&gt; graph = List.of(v1, v2, v3, v4, v5, v6, v7);</span><br><span class="line">        <span class="comment">// 1. 统计每个顶点的入度</span></span><br><span class="line">        <span class="keyword">for</span> (Vertex v : graph) {</span><br><span class="line">            <span class="keyword">for</span> (Edge edge : v.edges) {</span><br><span class="line">                edge.linked.inDegree++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">/*for (Vertex vertex : graph) {</span></span><br><span class="line"><span class="comment">            System.out.println(vertex.name + " " + vertex.inDegree);</span></span><br><span class="line"><span class="comment">        }*/</span></span><br><span class="line">        <span class="comment">// 2. 将入度为0的顶点加入队列</span></span><br><span class="line">        LinkedList&lt;Vertex&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Vertex v : graph) {</span><br><span class="line">            <span class="keyword">if</span> (v.inDegree == <span class="number">0</span>) {</span><br><span class="line">                queue.offer(v);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 3. 队列中不断移除顶点，每移除一个顶点，把它相邻顶点入度减1，若减到0则入队</span></span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            <span class="type">Vertex</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"><span class="comment">//            System.out.println(poll.name);</span></span><br><span class="line">            result.add(poll.name);</span><br><span class="line">            <span class="keyword">for</span> (Edge edge : poll.edges) {</span><br><span class="line">                edge.linked.inDegree--;</span><br><span class="line">                <span class="keyword">if</span> (edge.linked.inDegree == <span class="number">0</span>) {</span><br><span class="line">                    queue.offer(edge.linked);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (result.size() != graph.size()) {</span><br><span class="line">            System.out.println(<span class="string">"出现环"</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">for</span> (String key : result) {</span><br><span class="line">                System.out.println(key);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="dfs-1">DFS</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopologicalSortDFS</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"网页基础"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"Java基础"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"JavaWeb"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"Spring框架"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"微服务框架"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"数据库"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"实战项目"</span>);</span><br><span class="line"></span><br><span class="line">        v1.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v3));</span><br><span class="line">        v2.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v3));</span><br><span class="line">        v3.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4));</span><br><span class="line">        v6.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4));</span><br><span class="line">        v4.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v5));</span><br><span class="line">        v5.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v7));</span><br><span class="line">        v7.edges = List.of();</span><br><span class="line"></span><br><span class="line">        List&lt;Vertex&gt; graph = List.of(v1, v2, v3, v4, v5, v6, v7);</span><br><span class="line">        LinkedList&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Vertex v : graph) {</span><br><span class="line">            <span class="keyword">if</span>(v.status==<span class="number">0</span>) {</span><br><span class="line">                dfs(v, result);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Vertex v, LinkedList&lt;String&gt; result)</span> {</span><br><span class="line">        <span class="keyword">if</span> (v.status == <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (v.status == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"发现环"</span>);</span><br><span class="line">        }</span><br><span class="line">        v.status = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : v.edges) {</span><br><span class="line">            dfs(edge.linked, result);</span><br><span class="line">        }</span><br><span class="line">        v.status = <span class="number">2</span>;</span><br><span class="line">        result.push(v.name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="最短路径">7) 最短路径</h3><h4 id="dijkstra">Dijkstra</h4><figure><img src="../../../../images/StrJava/330px-Edsger_Wybe_Dijkstra.jpg" alt="330px-Edsger_Wybe_Dijkstra"><figcaption aria-hidden="true">330px-Edsger_Wybe_Dijkstra</figcaption></figure><p><strong>Edsger Wybe Dijkstra</strong></p><blockquote><p>艾兹格·维布·迪克斯特拉（Edsger Wybe Dijkstra，/ˈdaɪkstrə/DYKE-strə；荷兰语：[ˈɛtsxər ˈʋibə ˈdɛikstra]1930年5月11日-2002年8月6日）是一位荷兰计算机科学家、程序员、软件工程师、系统科学家和科学散文家。他因对开发结构化编程语言做出的基础贡献而获得了1972年的图灵奖，并担任德克萨斯大学奥斯汀分校的斯伦贝谢百年计算机科学主席，任职时间从1984年到2000年。在他于2002年去世前不久，他因其在程序计算的自稳定性方面的工作而获得了ACMPODC分布式计算有影响力论文奖。为了纪念他，该年度奖项在接下来的一年更名为迪克斯特拉奖。</p><p>迪克斯特拉在计算机科学领域的贡献</p><ol type="1"><li>最短路径算法，也称为迪克斯特拉算法，现代计算机科学本科课程中广泛教授</li><li>Shunting yard算法</li><li>THE OS 操作系统</li><li>银行家算法</li><li>用于协调多个处理器和程序的信号量构造</li><li>在分布式计算领域提出概念：自稳定性</li></ol></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    1--7--&gt;2</span><br><span class="line">    1--9---&gt;3</span><br><span class="line">    1--14---&gt;6</span><br><span class="line">    6--9---&gt;5</span><br><span class="line">    3--2---&gt;6</span><br><span class="line">    2--15---&gt;4</span><br><span class="line">    3--11---&gt;4</span><br><span class="line">    4--6---&gt;5</span><br></pre></td></tr></tbody></table></figure><p>算法描述：</p><ol type="1"><li>将所有顶点标记为未访问。创建一个未访问顶点的集合。</li><li>为每个顶点分配一个临时距离值<ul><li>对于我们的初始顶点，将其设置为零</li><li>对于所有其他顶点，将其设置为无穷大。</li></ul></li><li>每次选择最小临时距离的未访问顶点，作为新的当前顶点</li><li>对于当前顶点，遍历其所有未访问的邻居，并更新它们的临时距离为更小<ul><li>例如，1-&gt;6 的距离是 14，而1-&gt;3-&gt;6的距离是11。这时将距离更新为 11</li><li>否则，将保留上次距离值</li></ul></li><li>当前顶点的邻居处理完成后，把它从未访问集合中删除</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dijkstra</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v1"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v2"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v3"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v4"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v5"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v6"</span>);</span><br><span class="line"></span><br><span class="line">        v1.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v3, <span class="number">9</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v2, <span class="number">7</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v6, <span class="number">14</span>));</span><br><span class="line">        v2.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4, <span class="number">15</span>));</span><br><span class="line">        v3.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4, <span class="number">11</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v6, <span class="number">2</span>));</span><br><span class="line">        v4.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v5, <span class="number">6</span>));</span><br><span class="line">        v5.edges = List.of();</span><br><span class="line">        v6.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v5, <span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">        List&lt;Vertex&gt; graph = List.of(v1, v2, v3, v4, v5, v6);</span><br><span class="line"></span><br><span class="line">        dijkstra(graph, v1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dijkstra</span><span class="params">(List&lt;Vertex&gt; graph, Vertex source)</span> {</span><br><span class="line">        ArrayList&lt;Vertex&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(graph);</span><br><span class="line">        source.dist = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!list.isEmpty()) {</span><br><span class="line">            <span class="comment">// 3. 选取当前顶点</span></span><br><span class="line">            <span class="type">Vertex</span> <span class="variable">curr</span> <span class="operator">=</span> chooseMinDistVertex(list);</span><br><span class="line">            <span class="comment">// 4. 更新当前顶点邻居距离</span></span><br><span class="line">            updateNeighboursDist(curr, list);</span><br><span class="line">            <span class="comment">// 5. 移除当前顶点</span></span><br><span class="line">            list.remove(curr);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Vertex v : graph) {</span><br><span class="line">            System.out.println(v.name + <span class="string">" "</span> + v.dist);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateNeighboursDist</span><span class="params">(Vertex curr, ArrayList&lt;Vertex&gt; list)</span> {</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : curr.edges) {</span><br><span class="line">            <span class="type">Vertex</span> <span class="variable">n</span> <span class="operator">=</span> edge.linked;</span><br><span class="line">            <span class="keyword">if</span> (list.contains(n)) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">dist</span> <span class="operator">=</span> curr.dist + edge.weight;</span><br><span class="line">                <span class="keyword">if</span> (dist &lt; n.dist) {</span><br><span class="line">                    n.dist = dist;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vertex <span class="title function_">chooseMinDistVertex</span><span class="params">(ArrayList&lt;Vertex&gt; list)</span> {</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">min</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; list.size(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (list.get(i).dist &lt; min.dist) {</span><br><span class="line">                min = list.get(i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>改进 - 优先级队列</p><ol type="1"><li>创建一个优先级队列，放入所有顶点（队列大小会达到边的数量）</li><li>为每个顶点分配一个临时距离值<ul><li>对于我们的初始顶点，将其设置为零</li><li>对于所有其他顶点，将其设置为无穷大。</li></ul></li><li>每次选择最小临时距离的未访问顶点，作为新的当前顶点</li><li>对于当前顶点，遍历其所有未访问的邻居，并更新它们的临时距离为更小，若距离更新需加入队列<ul><li>例如，1-&gt;6 的距离是 14，而1-&gt;3-&gt;6的距离是11。这时将距离更新为 11</li><li>否则，将保留上次距离值</li></ul></li><li>当前顶点的邻居处理完成后，把它从队列中删除</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DijkstraPriorityQueue</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v1"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v2"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v3"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v4"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v5"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v6"</span>);</span><br><span class="line"></span><br><span class="line">        v1.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v3, <span class="number">9</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v2, <span class="number">7</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v6, <span class="number">14</span>));</span><br><span class="line">        v2.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4, <span class="number">15</span>));</span><br><span class="line">        v3.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4, <span class="number">11</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v6, <span class="number">2</span>));</span><br><span class="line">        v4.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v5, <span class="number">6</span>));</span><br><span class="line">        v5.edges = List.of();</span><br><span class="line">        v6.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v5, <span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">        List&lt;Vertex&gt; graph = List.of(v1, v2, v3, v4, v5, v6);</span><br><span class="line"></span><br><span class="line">        dijkstra(graph, v1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dijkstra</span><span class="params">(List&lt;Vertex&gt; graph, Vertex source)</span> {</span><br><span class="line">        PriorityQueue&lt;Vertex&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(v -&gt; v.dist));</span><br><span class="line">        source.dist = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Vertex v : graph) {</span><br><span class="line">            queue.offer(v);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            System.out.println(queue);</span><br><span class="line">            <span class="comment">// 3. 选取当前顶点</span></span><br><span class="line">            <span class="type">Vertex</span> <span class="variable">curr</span> <span class="operator">=</span> queue.peek();</span><br><span class="line">            <span class="comment">// 4. 更新当前顶点邻居距离</span></span><br><span class="line">            <span class="keyword">if</span>(!curr.visited) {</span><br><span class="line">                updateNeighboursDist(curr, queue);</span><br><span class="line">                curr.visited = <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 5. 移除当前顶点</span></span><br><span class="line">            queue.poll();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Vertex v : graph) {</span><br><span class="line">            System.out.println(v.name + <span class="string">" "</span> + v.dist + <span class="string">" "</span> + (v.prev != <span class="literal">null</span> ? v.prev.name : <span class="string">"null"</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateNeighboursDist</span><span class="params">(Vertex curr, PriorityQueue&lt;Vertex&gt; queue)</span> {</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : curr.edges) {</span><br><span class="line">            <span class="type">Vertex</span> <span class="variable">n</span> <span class="operator">=</span> edge.linked;</span><br><span class="line">            <span class="keyword">if</span> (!n.visited) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">dist</span> <span class="operator">=</span> curr.dist + edge.weight;</span><br><span class="line">                <span class="keyword">if</span> (dist &lt; n.dist) {</span><br><span class="line">                    n.dist = dist;</span><br><span class="line">                    n.prev = curr;</span><br><span class="line">                    queue.offer(n);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>问题</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">v1 --2--&gt; v2</span><br><span class="line">v1 --1--&gt; v3</span><br><span class="line">v2 --"-2"--&gt; v3</span><br><span class="line">v3 --1--&gt; v4</span><br></pre></td></tr></tbody></table></figure><p>按照 Dijkstra 算法，得出</p><ul><li>v1 -&gt; v2 最短距离2</li><li>v1 -&gt; v3 最短距离1</li><li>v1 -&gt; v4 最短距离2</li></ul><p>事实应当是</p><ul><li>v1 -&gt; v2 最短距离2</li><li>v1 -&gt; v3 最短距离0</li><li>v1 -&gt; v4 最短距离1</li></ul><h4 id="bellman-ford">Bellman-Ford</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BellmanFord</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 正常情况</span></span><br><span class="line">        <span class="comment">/*Vertex v1 = new Vertex("v1");</span></span><br><span class="line"><span class="comment">        Vertex v2 = new Vertex("v2");</span></span><br><span class="line"><span class="comment">        Vertex v3 = new Vertex("v3");</span></span><br><span class="line"><span class="comment">        Vertex v4 = new Vertex("v4");</span></span><br><span class="line"><span class="comment">        Vertex v5 = new Vertex("v5");</span></span><br><span class="line"><span class="comment">        Vertex v6 = new Vertex("v6");</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        v1.edges = List.of(new Edge(v3, 9), new Edge(v2, 7), new Edge(v6, 14));</span></span><br><span class="line"><span class="comment">        v2.edges = List.of(new Edge(v4, 15));</span></span><br><span class="line"><span class="comment">        v3.edges = List.of(new Edge(v4, 11), new Edge(v6, 2));</span></span><br><span class="line"><span class="comment">        v4.edges = List.of(new Edge(v5, 6));</span></span><br><span class="line"><span class="comment">        v5.edges = List.of();</span></span><br><span class="line"><span class="comment">        v6.edges = List.of(new Edge(v5, 9));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        List&lt;Vertex&gt; graph = List.of(v4, v5, v6, v1, v2, v3);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 负边情况</span></span><br><span class="line">        <span class="comment">/*Vertex v1 = new Vertex("v1");</span></span><br><span class="line"><span class="comment">        Vertex v2 = new Vertex("v2");</span></span><br><span class="line"><span class="comment">        Vertex v3 = new Vertex("v3");</span></span><br><span class="line"><span class="comment">        Vertex v4 = new Vertex("v4");</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        v1.edges = List.of(new Edge(v2, 2), new Edge(v3, 1));</span></span><br><span class="line"><span class="comment">        v2.edges = List.of(new Edge(v3, -2));</span></span><br><span class="line"><span class="comment">        v3.edges = List.of(new Edge(v4, 1));</span></span><br><span class="line"><span class="comment">        v4.edges = List.of();</span></span><br><span class="line"><span class="comment">        List&lt;Vertex&gt; graph = List.of(v1, v2, v3, v4);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 负环情况</span></span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v1"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v2"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v3"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v4"</span>);</span><br><span class="line"></span><br><span class="line">        v1.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v2, <span class="number">2</span>));</span><br><span class="line">        v2.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v3, -<span class="number">4</span>));</span><br><span class="line">        v3.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4, <span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v1, <span class="number">1</span>));</span><br><span class="line">        v4.edges = List.of();</span><br><span class="line">        List&lt;Vertex&gt; graph = List.of(v1, v2, v3, v4);</span><br><span class="line"></span><br><span class="line">        bellmanFord(graph, v1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bellmanFord</span><span class="params">(List&lt;Vertex&gt; graph, Vertex source)</span> {</span><br><span class="line">        source.dist = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> graph.size();</span><br><span class="line">        <span class="comment">// 1. 进行 顶点个数 - 1 轮处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="comment">// 2. 遍历所有的边</span></span><br><span class="line">            <span class="keyword">for</span> (Vertex s : graph) {</span><br><span class="line">                <span class="keyword">for</span> (Edge edge : s.edges) {</span><br><span class="line">                    <span class="comment">// 3. 处理每一条边</span></span><br><span class="line">                    <span class="type">Vertex</span> <span class="variable">e</span> <span class="operator">=</span> edge.linked;</span><br><span class="line">                    <span class="keyword">if</span> (s.dist != Integer.MAX_VALUE &amp;&amp; s.dist + edge.weight &lt; e.dist) {</span><br><span class="line">                        e.dist = s.dist + edge.weight;</span><br><span class="line">                        e.prev = s;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (Vertex v : graph) {</span><br><span class="line">            System.out.println(v + <span class="string">" "</span> + (v.prev != <span class="literal">null</span> ? v.prev.name : <span class="string">"null"</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>负环</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">v1 --2--&gt; v2</span><br><span class="line">v2 --"-4"--&gt; v3</span><br><span class="line">v3 --1--&gt; v4</span><br><span class="line">v3 --1--&gt; v1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>如果在【顶点-1】轮处理完成后，还能继续找到更短距离，表示发现了负环</p><h4 id="floyd-warshall">Floyd-Warshall</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">v1 --"-2"--&gt; v3</span><br><span class="line">v2 --"4"--&gt; v1</span><br><span class="line">v2 --"3"--&gt; v3</span><br><span class="line">v3 --2--&gt; v4</span><br><span class="line">v4 --"-1"--&gt; v2</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FloydWarshall</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v1"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v2"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v3"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v4"</span>);</span><br><span class="line"></span><br><span class="line">        v1.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v3, -<span class="number">2</span>));</span><br><span class="line">        v2.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v1, <span class="number">4</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v3, <span class="number">3</span>));</span><br><span class="line">        v3.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4, <span class="number">2</span>));</span><br><span class="line">        v4.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v2, -<span class="number">1</span>));</span><br><span class="line">        List&lt;Vertex&gt; graph = List.of(v1, v2, v3, v4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                直接连通</span></span><br><span class="line"><span class="comment">                v1  v2  v3  v4</span></span><br><span class="line"><span class="comment">            v1  0   ∞   -2  ∞</span></span><br><span class="line"><span class="comment">            v2  4   0   3   ∞</span></span><br><span class="line"><span class="comment">            v3  ∞   ∞   0   2</span></span><br><span class="line"><span class="comment">            v4  ∞   -1  ∞   0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                k=0 借助v1到达其它顶点</span></span><br><span class="line"><span class="comment">                v1  v2  v3  v4</span></span><br><span class="line"><span class="comment">            v1  0   ∞   -2  ∞</span></span><br><span class="line"><span class="comment">            v2  4   0   2   ∞</span></span><br><span class="line"><span class="comment">            v3  ∞   ∞   0   2</span></span><br><span class="line"><span class="comment">            v4  ∞   -1  ∞   0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                k=1 借助v2到达其它顶点</span></span><br><span class="line"><span class="comment">                v1  v2  v3  v4</span></span><br><span class="line"><span class="comment">            v1  0   ∞   -2  ∞</span></span><br><span class="line"><span class="comment">            v2  4   0   2   ∞</span></span><br><span class="line"><span class="comment">            v3  ∞   ∞   0   2</span></span><br><span class="line"><span class="comment">            v4  3   -1  1   0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                k=2 借助v3到达其它顶点</span></span><br><span class="line"><span class="comment">                v1  v2  v3  v4</span></span><br><span class="line"><span class="comment">            v1  0   ∞   -2  0</span></span><br><span class="line"><span class="comment">            v2  4   0   2   4</span></span><br><span class="line"><span class="comment">            v3  ∞   ∞   0   2</span></span><br><span class="line"><span class="comment">            v4  3   -1  1   0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                k=3 借助v4到达其它顶点</span></span><br><span class="line"><span class="comment">                v1  v2  v3  v4</span></span><br><span class="line"><span class="comment">            v1  0   -1   -2  0</span></span><br><span class="line"><span class="comment">            v2  4   0   2   4</span></span><br><span class="line"><span class="comment">            v3  5   1   0   2</span></span><br><span class="line"><span class="comment">            v4  3   -1  1   0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        floydWarshall(graph);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">floydWarshall</span><span class="params">(List&lt;Vertex&gt; graph)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> graph.size();</span><br><span class="line">        <span class="type">int</span>[][] dist = <span class="keyword">new</span> <span class="title class_">int</span>[size][size];</span><br><span class="line">        Vertex[][] prev = <span class="keyword">new</span> <span class="title class_">Vertex</span>[size][size];</span><br><span class="line">        <span class="comment">// 1）初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            <span class="type">Vertex</span> <span class="variable">v</span> <span class="operator">=</span> graph.get(i); <span class="comment">// v1 (v3)</span></span><br><span class="line">            Map&lt;Vertex, Integer&gt; map = v.edges.stream().collect(Collectors.toMap(e -&gt; e.linked, e -&gt; e.weight));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; size; j++) {</span><br><span class="line">                <span class="type">Vertex</span> <span class="variable">u</span> <span class="operator">=</span> graph.get(j); <span class="comment">// v3</span></span><br><span class="line">                <span class="keyword">if</span> (v == u) {</span><br><span class="line">                    dist[i][j] = <span class="number">0</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dist[i][j] = map.getOrDefault(u, Integer.MAX_VALUE);</span><br><span class="line">                    prev[i][j] = map.get(u) != <span class="literal">null</span> ? v : <span class="literal">null</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        print(prev);</span><br><span class="line">        <span class="comment">// 2）看能否借路到达其它顶点</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            v2-&gt;v1          v1-&gt;v?</span></span><br><span class="line"><span class="comment">            dist[1][0]   +   dist[0][0]</span></span><br><span class="line"><span class="comment">            dist[1][0]   +   dist[0][1]</span></span><br><span class="line"><span class="comment">            dist[1][0]   +   dist[0][2]</span></span><br><span class="line"><span class="comment">            dist[1][0]   +   dist[0][3]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; size; k++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; size; j++) {</span><br><span class="line"><span class="comment">//                    dist[i][k]   +   dist[k][j] // i行的顶点，借助k顶点，到达j列顶点</span></span><br><span class="line"><span class="comment">//                    dist[i][j]                  // i行顶点，直接到达j列顶点</span></span><br><span class="line">                    <span class="keyword">if</span> (dist[i][k] != Integer.MAX_VALUE &amp;&amp;</span><br><span class="line">                            dist[k][j] != Integer.MAX_VALUE &amp;&amp;</span><br><span class="line">                            dist[i][k] + dist[k][j] &lt; dist[i][j]) {</span><br><span class="line">                        dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">                        prev[i][j] = prev[k][j];</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"><span class="comment">//            print(dist);</span></span><br><span class="line">        }</span><br><span class="line">        print(prev);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">path</span><span class="params">(Vertex[][] prev, List&lt;Vertex&gt; graph, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        LinkedList&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        System.out.print(<span class="string">"["</span> + graph.get(i).name + <span class="string">","</span> + graph.get(j).name + <span class="string">"] "</span>);</span><br><span class="line">        stack.push(graph.get(j).name);</span><br><span class="line">        <span class="keyword">while</span> (i != j) {</span><br><span class="line">            <span class="type">Vertex</span> <span class="variable">p</span> <span class="operator">=</span> prev[i][j];</span><br><span class="line">            stack.push(p.name);</span><br><span class="line">            j = graph.indexOf(p);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(stack);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[][] dist)</span> {</span><br><span class="line">        System.out.println(<span class="string">"-------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : dist) {</span><br><span class="line">            System.out.println(Arrays.stream(row).boxed()</span><br><span class="line">                    .map(x -&gt; x == Integer.MAX_VALUE ? <span class="string">"∞"</span> : String.valueOf(x))</span><br><span class="line">                    .map(s -&gt; String.format(<span class="string">"%2s"</span>, s))</span><br><span class="line">                    .collect(Collectors.joining(<span class="string">","</span>, <span class="string">"["</span>, <span class="string">"]"</span>)));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Vertex[][] prev)</span> {</span><br><span class="line">        System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Vertex[] row : prev) {</span><br><span class="line">            System.out.println(Arrays.stream(row).map(v -&gt; v == <span class="literal">null</span> ? <span class="string">"null"</span> : v.name)</span><br><span class="line">                    .map(s -&gt; String.format(<span class="string">"%5s"</span>, s))</span><br><span class="line">                    .collect(Collectors.joining(<span class="string">","</span>, <span class="string">"["</span>, <span class="string">"]"</span>)));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>负环</strong></p><p>如果在 3 层循环结束后，在 dist 数组的对角线处（i==j处）发现了负数，表示出现了负环</p><h3 id="最小生成树">8) 最小生成树</h3><h4 id="prim">Prim</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Prim</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v1"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v2"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v3"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v4"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v5"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v6"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v7"</span>);</span><br><span class="line"></span><br><span class="line">        v1.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v2, <span class="number">2</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v3, <span class="number">4</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v4, <span class="number">1</span>));</span><br><span class="line">        v2.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v1, <span class="number">2</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v4, <span class="number">3</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v5, <span class="number">10</span>));</span><br><span class="line">        v3.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v1, <span class="number">4</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v4, <span class="number">2</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v6, <span class="number">5</span>));</span><br><span class="line">        v4.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v1, <span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v2, <span class="number">3</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v3, <span class="number">2</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(v5, <span class="number">7</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v6, <span class="number">8</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v7, <span class="number">4</span>));</span><br><span class="line">        v5.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v2, <span class="number">10</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v4, <span class="number">7</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v7, <span class="number">6</span>));</span><br><span class="line">        v6.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v3, <span class="number">5</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v4, <span class="number">8</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v7, <span class="number">1</span>));</span><br><span class="line">        v7.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4, <span class="number">4</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v5, <span class="number">6</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v6, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        List&lt;Vertex&gt; graph = List.of(v1, v2, v3, v4, v5, v6, v7);</span><br><span class="line"></span><br><span class="line">        prim(graph, v1);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prim</span><span class="params">(List&lt;Vertex&gt; graph, Vertex source)</span> {</span><br><span class="line">        ArrayList&lt;Vertex&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(graph);</span><br><span class="line">        source.dist = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!list.isEmpty()) {</span><br><span class="line">            <span class="type">Vertex</span> <span class="variable">min</span> <span class="operator">=</span> chooseMinDistVertex(list);</span><br><span class="line">            updateNeighboursDist(min);</span><br><span class="line">            list.remove(min);</span><br><span class="line">            min.visited = <span class="literal">true</span>;</span><br><span class="line">            System.out.println(<span class="string">"---------------"</span>);</span><br><span class="line">            <span class="keyword">for</span> (Vertex v : graph) {</span><br><span class="line">                System.out.println(v);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateNeighboursDist</span><span class="params">(Vertex curr)</span> {</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : curr.edges) {</span><br><span class="line">            <span class="type">Vertex</span> <span class="variable">n</span> <span class="operator">=</span> edge.linked;</span><br><span class="line">            <span class="keyword">if</span> (!n.visited) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">dist</span> <span class="operator">=</span> edge.weight;</span><br><span class="line">                <span class="keyword">if</span> (dist &lt; n.dist) {</span><br><span class="line">                    n.dist = dist;</span><br><span class="line">                    n.prev = curr;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vertex <span class="title function_">chooseMinDistVertex</span><span class="params">(ArrayList&lt;Vertex&gt; list)</span> {</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">min</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; list.size(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (list.get(i).dist &lt; min.dist) {</span><br><span class="line">                min = list.get(i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="kruskal">Kruskal</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kruskal</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Edge</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Edge&gt; {</span><br><span class="line">        List&lt;Vertex&gt; vertices;</span><br><span class="line">        <span class="type">int</span> start;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(List&lt;Vertex&gt; vertices, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> weight)</span> {</span><br><span class="line">            <span class="built_in">this</span>.vertices = vertices;</span><br><span class="line">            <span class="built_in">this</span>.start = start;</span><br><span class="line">            <span class="built_in">this</span>.end = end;</span><br><span class="line">            <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> weight)</span> {</span><br><span class="line">            <span class="built_in">this</span>.start = start;</span><br><span class="line">            <span class="built_in">this</span>.end = end;</span><br><span class="line">            <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Edge o)</span> {</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.weight, o.weight);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> vertices.get(start).name + <span class="string">"&lt;-&gt;"</span> + vertices.get(end).name + <span class="string">"("</span> + weight + <span class="string">")"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v1"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v2"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v3"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v4"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v5"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v6"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v7"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Vertex&gt; vertices = List.of(v1, v2, v3, v4, v5, v6, v7);</span><br><span class="line">        PriorityQueue&lt;Edge&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(List.of(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(vertices,<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(vertices,<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(vertices,<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(vertices,<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(vertices,<span class="number">1</span>, <span class="number">4</span>, <span class="number">10</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(vertices,<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(vertices,<span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(vertices,<span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(vertices,<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(vertices,<span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(vertices,<span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(vertices,<span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>)</span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">        kruskal(vertices.size(), queue);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">kruskal</span><span class="params">(<span class="type">int</span> size, PriorityQueue&lt;Edge&gt; queue)</span> {</span><br><span class="line">        List&lt;Edge&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">DisjointSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DisjointSet</span>(size);</span><br><span class="line">        <span class="keyword">while</span> (result.size() &lt; size - <span class="number">1</span>) {</span><br><span class="line">            <span class="type">Edge</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> set.find(poll.start);</span><br><span class="line">            <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> set.find(poll.end);</span><br><span class="line">            <span class="keyword">if</span> (s != e) {</span><br><span class="line">                result.add(poll);</span><br><span class="line">                set.union(s, e);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Edge edge : result) {</span><br><span class="line">            System.out.println(edge);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="不相交集合并查集合">9) 不相交集合（并查集合）</h3><h4 id="基础">基础</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DisjointSet</span> {</span><br><span class="line">    <span class="type">int</span>[] s;</span><br><span class="line">    <span class="comment">// 索引对应顶点</span></span><br><span class="line">    <span class="comment">// 元素是用来表示与之有关系的顶点</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        索引  0  1  2  3  4  5  6</span></span><br><span class="line"><span class="comment">        元素 [0, 1, 2, 3, 4, 5, 6] 表示一开始顶点直接没有联系（只与自己有联系）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DisjointSet</span><span class="params">(<span class="type">int</span> size)</span> {</span><br><span class="line">        s = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            s[i] = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find 是找到老大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        <span class="keyword">if</span> (x == s[x]) {</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> find(s[x]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// union 是让两个集合“相交”，即选出新老大，x、y 是原老大索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> {</span><br><span class="line">        s[y] = x;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(s);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="路径压缩">路径压缩</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> { <span class="comment">// x = 2</span></span><br><span class="line">    <span class="keyword">if</span> (x == s[x]) {</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s[x] = find(s[x]); <span class="comment">// 0    s[2]=0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="union-by-size">Union By Size</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DisjointSetUnionBySize</span> {</span><br><span class="line">    <span class="type">int</span>[] s;</span><br><span class="line">    <span class="type">int</span>[] size;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DisjointSetUnionBySize</span><span class="params">(<span class="type">int</span> size)</span> {</span><br><span class="line">        s = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            s[i] = i;</span><br><span class="line">            <span class="built_in">this</span>.size[i] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find 是找到老大 - 优化：路径压缩</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> { <span class="comment">// x = 2</span></span><br><span class="line">        <span class="keyword">if</span> (x == s[x]) {</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s[x] = find(s[x]); <span class="comment">// 0    s[2]=0</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// union 是让两个集合“相交”，即选出新老大，x、y 是原老大索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> {</span><br><span class="line"><span class="comment">//        s[y] = x;</span></span><br><span class="line">        <span class="keyword">if</span> (size[x] &lt; size[y]) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> x;</span><br><span class="line">            x = y;</span><br><span class="line">            y = t;</span><br><span class="line">        }</span><br><span class="line">        s[y] = x;</span><br><span class="line">        size[x] = size[x] + size[y];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"内容："</span>+Arrays.toString(s) + <span class="string">"\n大小："</span> + Arrays.toString(size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">DisjointSetUnionBySize</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DisjointSetUnionBySize</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        set.union(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        set.union(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        set.union(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="图-相关题目">图-相关题目</h3><table><thead><tr class="header"><th>题目编号</th><th>题目标题</th><th>算法思想</th></tr></thead><tbody><tr class="odd"><td>547</td><td>省份数量</td><td>DFS、BFS、并查集</td></tr><tr class="even"><td>797</td><td>所有可能路径</td><td>DFS、BFS</td></tr><tr class="odd"><td>1584</td><td>连接所有点的最小费用</td><td>最小生成树</td></tr><tr class="even"><td>743</td><td>网络延迟时间</td><td>单源最短路径</td></tr><tr class="odd"><td>787</td><td>K 站中转内最便宜的航班</td><td>单源最短路径</td></tr><tr class="even"><td>207</td><td>课程表</td><td>拓扑排序</td></tr><tr class="odd"><td>210</td><td>课程表 II</td><td>拓扑排序</td></tr></tbody></table><h2 id="greedy-algorithm">4.2 Greedy Algorithm</h2><h3 id="贪心例子">1) 贪心例子</h3><p>称之为贪心算法或贪婪算法，核心思想是</p><ol type="1"><li>将寻找最优解的问题分为若干个步骤</li><li>每一步骤都采用贪心原则，选取当前最优解</li><li>因为没有考虑所有可能，局部最优的堆叠<strong>不一定</strong>让最终解最优</li></ol><p>贪心算法是一种在每一步选择中都采取在当前状态下最好或最优(即最有利)的选择，从而希望导致结果是最好或最优的算法。这种算法通常用于求解优化问题，如最小生成树、背包问题等。</p><p>贪心算法的应用：</p><ol type="1"><li>背包问题：给定一组物品和一个背包，每个物品有一定的重量和价值，要求在不超过背包容量的情况下，尽可能多地装入物品。</li><li>活动选择问题：在一个活动集合中，每次只能参加一个活动，问如何安排时间以最大化所有活动的收益。</li><li>编辑距离问题：给定两个字符串，求它们之间的最小编辑距离(即将一个字符串转换为另一个字符串所需的最少操作次数)。</li><li>网络流问题：给定一张有向图和一些起点和终点，求最大流量。</li><li>找零问题：给定一定数量的硬币和需要找零的金额，求使用最少的硬币数。</li></ol><p>常见问题及解答：</p><ol type="1"><li>贪心算法一定会找到最优解吗？答：不一定。贪心算法只保证在每一步选择中都是最优的，但并不能保证整个问题的最优解。例如，背包问题中的贪心算法可能会导致最后一个物品没有被装入背包。</li><li>如何判断一个问题是否适合用贪心算法解决？答：一个问题如果可以用递归的方式分解成若干个子问题，且每个子问题都有明确的最优解(即局部最优),那么这个问题就可以用贪心算法解决。</li><li>贪心算法的时间复杂度是多少？答：贪心算法的时间复杂度取决于问题的规模和具体实现。一般来说，对于规模较小的问题，贪心算法的时间复杂度可以达到O(nlogn)或O(n<sup>2);对于规模较大的问题，可能需要O(n</sup>3)或更高。</li></ol><p>几个贪心的例子</p><h4 id="dijkstra-1">Dijkstra</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">while</span> (!list.isEmpty()) {</span><br><span class="line">    <span class="comment">// 选取当前【距离最小】的顶点</span></span><br><span class="line">    <span class="type">Vertex</span> <span class="variable">curr</span> <span class="operator">=</span> chooseMinDistVertex(list);</span><br><span class="line">    <span class="comment">// 更新当前顶点邻居距离</span></span><br><span class="line">    updateNeighboursDist(curr);</span><br><span class="line">    <span class="comment">// 移除当前顶点</span></span><br><span class="line">    list.remove(curr);</span><br><span class="line">    <span class="comment">// 标记当前顶点已经处理过</span></span><br><span class="line">    curr.visited = <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>没找到最短路径的例子：负边存在时，可能得不到正确解</li><li>问题出在贪心的原则会认为本次已经找到了该顶点的最短路径，下次不会再处理它（curr.visited= true）</li><li>与之对比，Bellman-Ford并没有考虑局部距离最小的顶点，而是每次都处理所有边，所以不会出错，当然效率不如Dijkstra</li></ul><h4 id="prim-1">Prim</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">while</span> (!list.isEmpty()) {</span><br><span class="line">    <span class="comment">// 选取当前【距离最小】的顶点</span></span><br><span class="line">    <span class="type">Vertex</span> <span class="variable">curr</span> <span class="operator">=</span> chooseMinDistVertex(list);</span><br><span class="line">    <span class="comment">// 更新当前顶点邻居距离</span></span><br><span class="line">    updateNeighboursDist(curr);</span><br><span class="line">    <span class="comment">// 移除当前顶点</span></span><br><span class="line">    list.remove(curr);</span><br><span class="line">    <span class="comment">// 标记当前顶点已经处理过</span></span><br><span class="line">    curr.visited = <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="kruskal-1">Kruskal</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">while</span> (list.size() &lt; size - <span class="number">1</span>) {</span><br><span class="line">    <span class="comment">// 选取当前【距离最短】的边</span></span><br><span class="line">    <span class="type">Edge</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">    <span class="comment">// 判断两个集合是否相交</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> set.find(poll.start);</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> set.find(poll.end);</span><br><span class="line">    <span class="keyword">if</span> (i != j) { <span class="comment">// 未相交</span></span><br><span class="line">        list.add(poll);</span><br><span class="line">        set.union(i, j); <span class="comment">// 相交</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其它贪心的例子</p><ul><li>选择排序、堆排序</li><li>拓扑排序</li><li>并查集合中的 union by size 和 union by height</li><li>哈夫曼编码</li><li>钱币找零，英文搜索关键字<ul><li>change-making problem</li><li>find Minimum number of Coins</li></ul></li><li>任务编排</li><li>求复杂问题的近似解</li></ul><h3 id="零钱兑换问题">2) 零钱兑换问题</h3><h4 id="有几个解零钱兑换-iileetcode-518">有几个解（零钱兑换 II）Leetcode518</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leetcode518</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> {</span><br><span class="line">        <span class="keyword">return</span> rec(<span class="number">0</span>, coins, amount, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), <span class="literal">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求凑成剩余金额的解的个数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index     当前硬币索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coins     硬币面值数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> remainder 剩余金额</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stack     -</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> first     -</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rec</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span>[] coins, <span class="type">int</span> remainder, LinkedList&lt;Integer&gt; stack, <span class="type">boolean</span> first)</span> {</span><br><span class="line">        <span class="keyword">if</span>(!first) {</span><br><span class="line">            stack.push(coins[index]);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 情况1：剩余金额 &lt; 0 - 无解</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (remainder &lt; <span class="number">0</span>) {</span><br><span class="line">            print(<span class="string">"无解："</span>, stack);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 情况2：剩余金额 == 0 - 有解</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (remainder == <span class="number">0</span>) {</span><br><span class="line">            print(<span class="string">"有解："</span>, stack);</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 情况3：剩余金额 &gt; 0 - 继续递归</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; coins.length; i++) {</span><br><span class="line">                count += rec(i, coins, remainder - coins[i], stack, <span class="literal">false</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty()) {</span><br><span class="line">            stack.pop();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String prompt, LinkedList&lt;Integer&gt; stack)</span> {</span><br><span class="line">        ArrayList&lt;Integer&gt; print = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ListIterator&lt;Integer&gt; iterator = stack.listIterator(stack.size());</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasPrevious()) {</span><br><span class="line">            print.add(iterator.previous());</span><br><span class="line">        }</span><br><span class="line">        System.out.println(prompt + print);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Leetcode518</span> <span class="variable">leetcode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leetcode518</span>();</span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{1, 5, 10, 25}, 41);</span></span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{25, 10, 5, 1}, 41);</span></span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{5, 2, 1}, 5);</span></span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{1, 2, 5}, 5);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> leetcode.change(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">15</span>, <span class="number">10</span>, <span class="number">1</span>}, <span class="number">21</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="最优解零钱兑换--穷举法-leetcode-322">最优解（零钱兑换）- 穷举法Leetcode 322</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leetcode322</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 需要的最少硬币数  2 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> {</span><br><span class="line">        rec(<span class="number">0</span>, coins, amount, <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(-<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// count 代表某一组合 钱币的总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rec</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span>[] coins, <span class="type">int</span> remainder, AtomicInteger count, LinkedList&lt;Integer&gt; stack, <span class="type">boolean</span> first)</span> {</span><br><span class="line">        <span class="keyword">if</span> (!first) {</span><br><span class="line">            stack.push(coins[index]);</span><br><span class="line">        }</span><br><span class="line">        count.incrementAndGet(); <span class="comment">// count++</span></span><br><span class="line">        <span class="keyword">if</span> (remainder == <span class="number">0</span>) {</span><br><span class="line">            System.out.println(stack);</span><br><span class="line">            <span class="keyword">if</span> (min == -<span class="number">1</span>) {</span><br><span class="line">                min = count.get();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                min = Integer.min(min, count.get());</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (remainder &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; coins.length; i++) {</span><br><span class="line">                rec(i, coins, remainder - coins[i], count, stack, <span class="literal">false</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        count.decrementAndGet(); <span class="comment">// count--</span></span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty()) {</span><br><span class="line">            stack.pop();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Leetcode322</span> <span class="variable">leetcode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leetcode322</span>();</span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{5, 2, 1}, 5);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> leetcode.coinChange(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">25</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>}, <span class="number">41</span>);</span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{2}, 3);</span></span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{15, 10, 1}, 21);</span></span><br><span class="line">        System.out.println(count);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="最优解零钱兑换--贪心法-leetcode-322">最优解（零钱兑换）- 贪心法Leetcode 322</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leetcode322</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> amount;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> coin : coins) {</span><br><span class="line">            <span class="keyword">while</span> (remainder - coin &gt; <span class="number">0</span>) {</span><br><span class="line">                remainder -= coin;</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (remainder - coin == <span class="number">0</span>) {</span><br><span class="line">                remainder = <span class="number">0</span>;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (remainder &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Leetcode322</span> <span class="variable">leetcode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leetcode322</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> leetcode.coinChange(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>}, <span class="number">5</span>);</span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{25, 10, 5, 1}, 41);</span></span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{2}, 3);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 问题1 没有回头，导致找到更差的解</span></span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{15, 10, 1}, 21);  </span></span><br><span class="line">        <span class="comment">// 问题2 没有回头，导致无解</span></span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{15, 10}, 20);  </span></span><br><span class="line">        System.out.println(count);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="huffman-编码问题">3) Huffman 编码问题</h3><h4 id="问题引入">问题引入</h4><p>什么是编码？</p><p>简单说就是建立【字符】到【数字】的对应关系，如下面大家熟知的 ASC II编码表，例如，可以查表得知字符【a】对应的数字是十六进制数【0x61】</p><table><colgroup><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"></colgroup><thead><tr class="header"><th>\</th><th>00</th><th>01</th><th>02</th><th>03</th><th>04</th><th>05</th><th>06</th><th>07</th><th>08</th><th>09</th><th>0a</th><th>0b</th><th>0c</th><th>0d</th><th>0e</th><th>0f</th></tr></thead><tbody><tr class="odd"><td>0000</td><td>00</td><td>01</td><td>02</td><td>03</td><td>04</td><td>05</td><td>06</td><td>07</td><td>08</td><td>09</td><td>0a</td><td>0b</td><td>0c</td><td>0d</td><td>0e</td><td>0f</td></tr><tr class="even"><td>0010</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td><td>17</td><td>18</td><td>19</td><td>1a</td><td>1b</td><td>1c</td><td>1d</td><td>1e</td><td>1f</td></tr><tr class="odd"><td>0020</td><td>20</td><td>!</td><td>"</td><td>#</td><td>$</td><td>%</td><td>&amp;</td><td>'</td><td>(</td><td>)</td><td>*</td><td>+</td><td>,</td><td>-</td><td>.</td><td>/</td></tr><tr class="even"><td>0030</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>:</td><td>;</td><td>&lt;</td><td>=</td><td>&gt;</td><td>?</td></tr><tr class="odd"><td>0040</td><td>@</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td><td>G</td><td>H</td><td>I</td><td>J</td><td>K</td><td>L</td><td>M</td><td>N</td><td>O</td></tr><tr class="even"><td>0050</td><td>P</td><td>Q</td><td>R</td><td>S</td><td>T</td><td>U</td><td>V</td><td>W</td><td>X</td><td>Y</td><td>Z</td><td>[</td><td>\</td><td>]</td><td>^</td><td>_</td></tr><tr class="odd"><td>0060</td><td>`</td><td>a</td><td>b</td><td>c</td><td>d</td><td>e</td><td>f</td><td>g</td><td>h</td><td>i</td><td>j</td><td>k</td><td>l</td><td>m</td><td>n</td><td>o</td></tr><tr class="even"><td>0070</td><td>p</td><td>q</td><td>r</td><td>s</td><td>t</td><td>u</td><td>v</td><td>w</td><td>x</td><td>y</td><td>z</td><td>{</td><td>|</td><td>}</td><td>~</td><td>7f</td></tr></tbody></table><blockquote><p>注：一些直接以十六进制数字标识的是那些不可打印字符</p></blockquote><p>传输时的编码</p><ul><li>java 中每个 char 对应的数字会占用固定长度 2 个字节</li><li>如果在传输中仍采用上述规则，传递 abbccccccc 这 10 个字符<ul><li>实际的字节为0061006200620063006300630063006300630063（16进制表示）</li><li>总共 20 个字节，不经济</li></ul></li></ul><p>现在希望找到一种最节省字节的传输方式，怎么办？</p><p>假设传输的字符中只包含 a，b，c 这 3个字符，有同学重新设计一张二进制编码表，见下图</p><ul><li>0 表示 a</li><li>1 表示 b</li><li>10 表示 c</li></ul><p>现在还是传递 abbccccccc 这 10 个字符</p><ul><li>实际的字节为 01110101010101010 （二进制表示）</li><li>总共需要 17 bits，也就是 2 个字节多一点，行不行？</li></ul><p>不行，因为解码会出现问题，因为 10 会被错误的解码成 ba，而不是 c</p><ul><li>解码后结果为 abbbababababababa，是错误的</li></ul><p>怎么解决？必须保证编码后的二进制数字，要能区分它们的前缀（prefix-free）</p><p>用满二叉树结构编码，可以确保前缀不重复</p><figure><img src="../../../../images/StrJava/image-20230616094945068.png" alt="image-20230616094945068"><figcaption aria-hidden="true">image-20230616094945068</figcaption></figure><ul><li>向左走 0，向右走 1</li><li>走到叶子字符，累计起来的 0 和 1 就是该字符的二进制编码</li></ul><p>再来试一遍</p><ul><li>a 的编码 0</li><li>b 的编码 10</li><li>c 的编码 11</li></ul><p>现在还是传递 abbccccccc 这 10 个字符</p><ul><li>实际的字节为 0101011111111111111（二进制表示）</li><li>总共需要 19 bits，也是 2个字节多一点，并且解码没有问题了，行不行？</li></ul><p>这回解码没问题了，但并非最少字节，因为 c 的出现频率高（7 次）a的出现频率低（1 次），因此出现频率高的字符编码成短数字更经济</p><p>考察下面的树</p><figure><img src="../../../../images/StrJava/image-20230616095129461.png" alt="image-20230616095129461"><figcaption aria-hidden="true">image-20230616095129461</figcaption></figure><ul><li>00 表示 a</li><li>01 表示 b</li><li>1 表示 c</li></ul><p>现在还是传递 abbccccccc 这 10 个字符</p><ul><li>实际的字节为 000101 1111111 （二进制表示）</li><li>总共需要 13 bits，这棵树就称之为 Huffman 树</li><li>根据 Huffman 树对字符和数字进行编解码，就是 Huffman 编解码</li></ul><h4 id="huffman-树">Huffman 树</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanTree</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Huffman 树的构建过程</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1. 将统计了出现频率的字符，放入优先级队列</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2. 每次出队两个频次最低的元素，给它俩找个爹</span></span><br><span class="line"><span class="comment">        3. 把爹重新放入队列，重复 2~3</span></span><br><span class="line"><span class="comment">        4. 当队列只剩一个元素时，Huffman 树构建完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">        Character ch; <span class="comment">// 字符</span></span><br><span class="line">        <span class="type">int</span> freq;     <span class="comment">// 频次</span></span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        String code;  <span class="comment">// 编码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Character ch)</span> {</span><br><span class="line">            <span class="built_in">this</span>.ch = ch;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> freq, Node left, Node right)</span> {</span><br><span class="line">            <span class="built_in">this</span>.freq = freq;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">freq</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> freq;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">isLeaf</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> left == <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Node{"</span> +</span><br><span class="line">                    <span class="string">"ch="</span> + ch +</span><br><span class="line">                    <span class="string">", freq="</span> + freq +</span><br><span class="line">                    <span class="string">'}'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    String str;</span><br><span class="line">    Map&lt;Character, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HuffmanTree</span><span class="params">(String str)</span> {</span><br><span class="line">        <span class="built_in">this</span>.str = str;</span><br><span class="line">        <span class="comment">// 功能1：统计频率</span></span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : chars) {</span><br><span class="line">            <span class="comment">/*if (!map.containsKey(c)) {</span></span><br><span class="line"><span class="comment">                map.put(c, new Node(c));</span></span><br><span class="line"><span class="comment">            }</span></span><br><span class="line"><span class="comment">            Node node = map.get(c);</span></span><br><span class="line"><span class="comment">            node.freq++;*/</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.computeIfAbsent(c, Node::<span class="keyword">new</span>);</span><br><span class="line">            node.freq++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 功能2: 构造树</span></span><br><span class="line">        PriorityQueue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(Node::freq));</span><br><span class="line">        queue.addAll(map.values());</span><br><span class="line">        <span class="keyword">while</span> (queue.size() &gt;= <span class="number">2</span>) {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">y</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">freq</span> <span class="operator">=</span> x.freq + y.freq;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="title class_">Node</span>(freq, x, y));</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="comment">// 功能3：计算每个字符的编码, 功能4：字符串编码后占用 bits</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> dfs(root, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>());</span><br><span class="line">        <span class="keyword">for</span> (Node node : map.values()) {</span><br><span class="line">            System.out.println(node + <span class="string">" "</span> + node.code);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"总共会占用 bits:"</span> + sum);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(Node node, StringBuilder code)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.isLeaf()) {</span><br><span class="line">            node.code = code.toString();</span><br><span class="line">            sum = node.freq * code.length();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            sum += dfs(node.left, code.append(<span class="string">"0"</span>));</span><br><span class="line">            sum += dfs(node.right, code.append(<span class="string">"1"</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (code.length() &gt; <span class="number">0</span>) {</span><br><span class="line">            code.deleteCharAt(code.length() - <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HuffmanTree</span>(<span class="string">"abbccccccc"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong><em>注意</em></strong></p><ul><li>Node::new 是一个 Function，根据 key（即字符）生成 Node 对象</li><li>对应的是 public Node(Character ch) 有参构造</li></ul></blockquote><h4 id="huffman-编解码">Huffman 编解码</h4><p>补充两个方法，注意为了简单期间用了编解码都用字符串演示，实际应该按bits 编解码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanTree</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : chars) {</span><br><span class="line">            sb.append(map.get(c).code);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decode</span><span class="params">(String str)</span> {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            从根节点，寻找数字对应的字符</span></span><br><span class="line"><span class="comment">                数字是 0 向左走</span></span><br><span class="line"><span class="comment">                数字是 1 向右走</span></span><br><span class="line"><span class="comment">                如果没走到头，每走一步数字的索引 i++</span></span><br><span class="line"><span class="comment">            走到头就可以找到解码字符，再将 node 重置为根节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; chars.length) {</span><br><span class="line">            <span class="keyword">if</span> (!node.isLeaf()) { <span class="comment">// 非叶子</span></span><br><span class="line">                <span class="keyword">if</span>(chars[i] == <span class="string">'0'</span>) { <span class="comment">// 向左走</span></span><br><span class="line">                    node = node.left;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span>(chars[i] == <span class="string">'1'</span>) { <span class="comment">// 向右走</span></span><br><span class="line">                    node = node.right;</span><br><span class="line">                }</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.isLeaf()) {</span><br><span class="line">                sb.append(node.ch);</span><br><span class="line">                node = root;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings("all")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">HuffmanTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HuffmanTree</span>(<span class="string">"abbccccccc"</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">encoded</span> <span class="operator">=</span> tree.encode();</span><br><span class="line">        System.out.println(encoded);</span><br><span class="line">        System.out.println(tree.decode(encoded));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong><em>注意</em></strong></p><ul><li>循环中非叶子节点 i 要自增，但叶子节点 i 暂不自增</li><li>第一个非叶子的 if 判断结束后，仍需要第二个叶子的 if判断，因为在第一个 if 内 node 发生了变化</li></ul></blockquote><h4 id="相关题目">相关题目</h4><table><thead><tr class="header"><th>题目编号</th><th>题目标题</th><th>算法思路</th></tr></thead><tbody><tr class="odd"><td>1167（Plus 题目）</td><td>连接棒材的最低费用</td><td>Huffman 树、贪心</td></tr></tbody></table><p>参考解答</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;连接棒材的最低费用&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;为了装修新房，你需要加工一些长度为正整数的棒材。如果要将长度分别为 X 和 Y 的两根棒材连接在一起，你需要支付 X + Y 的费用。 返回讲所有棒材连成一根所需要的最低费用。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leetcode1167</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        举例 棒材为 [1,8,3,5]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        如果以如下顺序连接(非最优)</span></span><br><span class="line"><span class="comment">        - 1+8=9</span></span><br><span class="line"><span class="comment">        - 9+3=12</span></span><br><span class="line"><span class="comment">        - 12+5=17</span></span><br><span class="line"><span class="comment">        总费用为 9+12+17=38</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        如果以如下顺序连接(最优)</span></span><br><span class="line"><span class="comment">        - 1+3=4</span></span><br><span class="line"><span class="comment">        - 4+5=9</span></span><br><span class="line"><span class="comment">        - 8+9=17</span></span><br><span class="line"><span class="comment">        总费用为 4+9+17=30</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">connectSticks</span><span class="params">(<span class="type">int</span>[] sticks)</span> {</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> stick : sticks) {</span><br><span class="line">            queue.offer(stick);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() &gt;= <span class="number">2</span>) {</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> x + y;</span><br><span class="line">            sum += c;</span><br><span class="line">            queue.offer(c);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Leetcode1167</span> <span class="variable">leetcode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leetcode1167</span>();</span><br><span class="line">        System.out.println(leetcode.connectSticks(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>})); <span class="comment">// 30</span></span><br><span class="line">        System.out.println(leetcode.connectSticks(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>})); <span class="comment">// 14</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="活动选择问题">4) 活动选择问题</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActivitySelectionProblem</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        要在一个会议室举办 n 个活动</span></span><br><span class="line"><span class="comment">        - 每个活动有它们各自的起始和结束时间</span></span><br><span class="line"><span class="comment">        - 找出在时间上互不冲突的活动组合，能够最充分利用会议室（举办的活动次数最多）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        例1</span></span><br><span class="line"><span class="comment">            0   1   2   3   4   5   6   7   8   9</span></span><br><span class="line"><span class="comment">                |-------)</span></span><br><span class="line"><span class="comment">                    |-------)</span></span><br><span class="line"><span class="comment">                        |-------)</span></span><br><span class="line"><span class="comment">        例2</span></span><br><span class="line"><span class="comment">            0   1   2   3   4   5   6   7   8   9</span></span><br><span class="line"><span class="comment">                |---)</span></span><br><span class="line"><span class="comment">                        |---)</span></span><br><span class="line"><span class="comment">            |-----------------------)</span></span><br><span class="line"><span class="comment">                                |-------)</span></span><br><span class="line"><span class="comment">                                            |---)</span></span><br><span class="line"><span class="comment">                                |---------------)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        几种贪心策略</span></span><br><span class="line"><span class="comment">        1. 优先选择持续时间最短的活动</span></span><br><span class="line"><span class="comment">            0   1   2   3   4   5   6   7   8   9</span></span><br><span class="line"><span class="comment">                |---------------)</span></span><br><span class="line"><span class="comment">                            |-------)</span></span><br><span class="line"><span class="comment">                                |---------------)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2. 优先选择冲突最少的活动</span></span><br><span class="line"><span class="comment">            0   1   2   3   4   5   6   7   8   9</span></span><br><span class="line"><span class="comment">            |-------)                                       3</span></span><br><span class="line"><span class="comment">                |-------)                                   4</span></span><br><span class="line"><span class="comment">                |-------)                                   4</span></span><br><span class="line"><span class="comment">                |-------)                                   4</span></span><br><span class="line"><span class="comment">                    |-------)                               4</span></span><br><span class="line"><span class="comment">                        |-------)                           2</span></span><br><span class="line"><span class="comment">                            |-----------)                   4</span></span><br><span class="line"><span class="comment">                                    |-------)               4</span></span><br><span class="line"><span class="comment">                                    |-------)               4</span></span><br><span class="line"><span class="comment">                                    |-------)               4</span></span><br><span class="line"><span class="comment">                                        |-------)           3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3. 优先选择最先开始的活动</span></span><br><span class="line"><span class="comment">            0   1   2   3   4   5   6   7   8   9</span></span><br><span class="line"><span class="comment">            |-----------------------------------)</span></span><br><span class="line"><span class="comment">                |---)</span></span><br><span class="line"><span class="comment">                    |---)</span></span><br><span class="line"><span class="comment">                        |---)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        4. 优先选择最后结束的活动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Activity</span> {</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="type">int</span> start;</span><br><span class="line">        <span class="type">int</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Activity</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> start, <span class="type">int</span> finish)</span> {</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">            <span class="built_in">this</span>.start = start;</span><br><span class="line">            <span class="built_in">this</span>.finish = finish;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Activity("</span> + index + <span class="string">")"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Activity[] activities = <span class="keyword">new</span> <span class="title class_">Activity</span>[]{</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Activity</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Activity</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Activity</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">        };</span><br><span class="line"><span class="comment">//        Activity[] activities = new Activity[]{</span></span><br><span class="line"><span class="comment">//                new Activity(0, 1, 2),</span></span><br><span class="line"><span class="comment">//                new Activity(1, 3, 4),</span></span><br><span class="line"><span class="comment">//                new Activity(2, 0, 6),</span></span><br><span class="line"><span class="comment">//                new Activity(3, 5, 7),</span></span><br><span class="line"><span class="comment">//                new Activity(4, 8, 9),</span></span><br><span class="line"><span class="comment">//                new Activity(5, 5, 9)</span></span><br><span class="line"><span class="comment">//        };</span></span><br><span class="line">        select(activities, activities.length);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">(Activity[] activities, <span class="type">int</span> n)</span> {</span><br><span class="line">        List&lt;Activity&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        result.add(activities[i]);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; n; j++) {</span><br><span class="line">            <span class="keyword">if</span> (activities[j].start &gt;= activities[i].finish) {</span><br><span class="line">                result.add(activities[j]);</span><br><span class="line">                i = j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="无重叠区间-leetcode-435">无重叠区间-Leetcode 435</h4><table><thead><tr class="header"><th>题目编号</th><th>题目标题</th><th>算法思路</th></tr></thead><tbody><tr class="odd"><td>435</td><td>无重叠区间</td><td>贪心</td></tr></tbody></table><p>参考解答</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 下面代码为 Leetcode 435 题解</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> {</span><br><span class="line">    Arrays.sort(intervals, Comparator.comparingInt(a -&gt; a[<span class="number">1</span>]));</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; intervals.length; j++) {</span><br><span class="line">        <span class="keyword">if</span> (intervals[j][<span class="number">0</span>] &gt;= intervals[i][<span class="number">1</span>]) {</span><br><span class="line">            i = j;</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> intervals.length - count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>找到不重叠的最多的活动数（count），即活动选择问题原始需求</li><li>在此基础上，活动总数 - count，就是题目要的排除数量</li></ul><h3 id="分数背包问题">5) 分数背包问题</h3><h4 id="贪心法">贪心法</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FractionalKnapsackProblem</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. n个物品都是液体，有重量和价值</span></span><br><span class="line"><span class="comment">    2. 现在你要取走 10升 的液体</span></span><br><span class="line"><span class="comment">    3. 每次可以不拿，全拿，或拿一部分，问最高价值是多少</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        编号 重量(升) 价值</span></span><br><span class="line"><span class="comment">        0   4       24      水</span></span><br><span class="line"><span class="comment">        1   8       160     牛奶       选中 7/8</span></span><br><span class="line"><span class="comment">        2   2       4000    五粮液     选中</span></span><br><span class="line"><span class="comment">        3   6       108     可乐</span></span><br><span class="line"><span class="comment">        4   1       4000    茅台       选中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        8140</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        简化起见，给出的数据都是【价值/重量】能够整除，避免计算结果中出现小数，增加心算难度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Item</span> {</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Item</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> weight, <span class="type">int</span> value)</span> {</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">            <span class="built_in">this</span>.weight = weight;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">unitPrice</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> value / weight;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Item("</span> + index + <span class="string">")"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Item[] items = <span class="keyword">new</span> <span class="title class_">Item</span>[]{</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">0</span>, <span class="number">4</span>, <span class="number">24</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">1</span>, <span class="number">8</span>, <span class="number">160</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="number">4000</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">3</span>, <span class="number">6</span>, <span class="number">108</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">4000</span>),</span><br><span class="line">        };</span><br><span class="line">        select(items, <span class="number">10</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">(Item[] items, <span class="type">int</span> total)</span> {</span><br><span class="line">        Arrays.sort(items, Comparator.comparingInt(Item::unitPrice).reversed());</span><br><span class="line">        <span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> total;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Item item : items) {</span><br><span class="line">            <span class="keyword">if</span> (remainder - item.weight &gt; <span class="number">0</span>) {</span><br><span class="line">                max += item.value;</span><br><span class="line">                remainder -= item.weight;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                max += remainder * item.unitPrice();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"最高价值为："</span> + max);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="背包问题">6) 0-1 背包问题</h3><h4 id="贪心法-1">贪心法</h4><p>可能得不到最优解</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KnapsackProblem</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. n个物品都是固体，有重量和价值</span></span><br><span class="line"><span class="comment">    2. 现在你要取走不超过 10克 的物品</span></span><br><span class="line"><span class="comment">    3. 每次可以不拿或全拿，问最高价值是多少</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        编号 重量(g)  价值(元)</span></span><br><span class="line"><span class="comment">        0   1       1_000_000      钻戒一枚</span></span><br><span class="line"><span class="comment">        1   4       1600           黄金一块</span></span><br><span class="line"><span class="comment">        2   8       2400           红宝石戒指一枚</span></span><br><span class="line"><span class="comment">        3   5       30             白银一块</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Item</span> {</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Item</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> weight, <span class="type">int</span> value)</span> {</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">            <span class="built_in">this</span>.weight = weight;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">unitValue</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> value / weight;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Item("</span> + index + <span class="string">")"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Item[] items = <span class="keyword">new</span> <span class="title class_">Item</span>[]{</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1_000_000</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1600</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">2</span>, <span class="number">8</span>, <span class="number">2400</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">30</span>)</span><br><span class="line">        };</span><br><span class="line">        select(items, <span class="number">10</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">(Item[] items, <span class="type">int</span> total)</span> {</span><br><span class="line">        Arrays.sort(items, Comparator.comparingInt(Item::unitValue).reversed());</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 最大价值</span></span><br><span class="line">        <span class="keyword">for</span> (Item item : items) {</span><br><span class="line">            System.out.println(item);</span><br><span class="line">            <span class="keyword">if</span> (total &gt;= item.weight) { <span class="comment">// 可以拿完</span></span><br><span class="line">                total -= item.weight;</span><br><span class="line">                max += item.value;</span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 拿不完</span></span><br><span class="line"><span class="comment">//                max += total * item.unitValue();</span></span><br><span class="line"><span class="comment">//                break;</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"最大价值是:"</span> + max);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="贪心算法的局限">贪心算法的局限</h3><table><thead><tr class="header"><th>问题名称</th><th>是否能用贪心得到最优解</th><th>替换解法</th></tr></thead><tbody><tr class="odd"><td>Dijkstra(不存在负边)</td><td>✔️</td><td></td></tr><tr class="even"><td>Dijkstra(存在负边)</td><td>❌</td><td>Bellman-Ford</td></tr><tr class="odd"><td>Prim</td><td>✔️</td><td></td></tr><tr class="even"><td>Kruskal</td><td>✔️</td><td></td></tr><tr class="odd"><td>零钱兑换</td><td>❌</td><td>动态规划</td></tr><tr class="even"><td>Huffman 树</td><td>✔️</td><td></td></tr><tr class="odd"><td>活动选择问题</td><td>✔️</td><td></td></tr><tr class="even"><td>分数背包问题</td><td>✔️</td><td></td></tr><tr class="odd"><td>0-1 背包问题</td><td>❌</td><td>动态规划</td></tr></tbody></table><h3 id="set-cover-problem">7) Set cover problem</h3><p>集合覆盖问题</p><h2 id="dynamic-programming">4.3 Dynamic-Programming</h2><h3 id="fibonacci">1) Fibonacci</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fibonacci</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(fibonacci(<span class="number">13</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> dp[n];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) {</span><br><span class="line">            dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="降维">降维</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fibonacci</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(fibonacci(<span class="number">13</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> {        </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> b + a;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="最短路径---bellman-ford">2) 最短路径 - Bellman-Ford</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BellmanFord</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Edge</span> {</span><br><span class="line">        <span class="type">int</span> from;</span><br><span class="line">        <span class="type">int</span> to;</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> weight)</span> {</span><br><span class="line">            <span class="built_in">this</span>.from = from;</span><br><span class="line">            <span class="built_in">this</span>.to = to;</span><br><span class="line">            <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">            f(v) 用来表示从起点出发，到达 v 这个顶点的最短距离</span></span><br><span class="line"><span class="comment">            初始时</span></span><br><span class="line"><span class="comment">            f(v) = 0   当 v==起点 时</span></span><br><span class="line"><span class="comment">            f(v) = ∞   当 v!=起点 时</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            之后</span></span><br><span class="line"><span class="comment">            新           旧     所有from</span></span><br><span class="line"><span class="comment">            f(to) = min(f(to), f(from) + from.weight)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            from 从哪来</span></span><br><span class="line"><span class="comment">            to   到哪去</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            f(v4) = min( ∞, f(v3) + 11 ) = 20</span></span><br><span class="line"><span class="comment">            f(v4) = min( 20, f(v2) + 15 ) = 20</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            v1  v2  v3  v4  v5  v6</span></span><br><span class="line"><span class="comment">            0   ∞   ∞   ∞   ∞   ∞</span></span><br><span class="line"><span class="comment">            0   7   9   ∞   ∞   14  第一轮</span></span><br><span class="line"><span class="comment">            0   7   9   20  23  11  第二轮</span></span><br><span class="line"><span class="comment">            0   7   9   20  20  11  第三轮</span></span><br><span class="line"><span class="comment">            0   7   9   20  20  11  第四轮</span></span><br><span class="line"><span class="comment">            0   7   9   20  20  11  第五轮</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        List&lt;Edge&gt; edges = List.of(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">6</span>, <span class="number">5</span>, <span class="number">9</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">1</span>, <span class="number">6</span>, <span class="number">14</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">11</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">15</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">7</span>]; <span class="comment">// 一维数组用来缓存结果</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; dp.length; i++) {</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">        }</span><br><span class="line">        print(dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="keyword">for</span> (Edge e : edges) {</span><br><span class="line">                <span class="keyword">if</span>(dp[e.from] != Integer.MAX_VALUE) {</span><br><span class="line">                    dp[e.to] = Integer.min(dp[e.to], dp[e.from] + e.weight);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        print(dp);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[] dp)</span> {</span><br><span class="line">        System.out.println(Arrays.stream(dp)</span><br><span class="line">                .mapToObj(i -&gt; i == Integer.MAX_VALUE ? <span class="string">"∞"</span> : String.valueOf(i))</span><br><span class="line">                .collect(Collectors.joining(<span class="string">","</span>, <span class="string">"["</span>, <span class="string">"]"</span>)));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="不同路径-leetcode-62">3) 不同路径-Leetcode 62</h3><p>机器人要从左上角走到右下角，每次只能<strong>向右</strong>或<strong>向下</strong>，问一共有多少条不同路径？</p><p><img src="../../../../images/StrJava/robot_maze2.png"></p><p>分析，先考虑较为简单的情况</p><p><img src="../../../../images/StrJava/robot_maze.png"></p><p>可能路径有三种情况：</p><ul><li>👉 👇 👇</li><li>👇 👇👉</li><li>👇👉👇</li></ul><p>分析：设坐标为，共有 m 行 n 列</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">(0,0)(0,1)</span><br><span class="line">(1,0)(1,1)</span><br><span class="line">(2,0)(2,1)</span><br></pre></td></tr></tbody></table></figure><p>如果终点是 (0,1) 那么只有一种走法</p><p>如果终点是 (1,0) 那么也只有一种走法</p><p>如果终点是 (1,1)呢，它的走法是从它的上方走下来，或者从它的左边走过来，因此走法 = (0,1) +(1,0) = 2种</p><p>如果终点是 (2,0) 那么也只有一种走法</p><p>如果终点是 (2,1)呢，它的走法是从它的上方走下来，或者从它的左边走过来，因此走法 = (1,1) +(2,0) = 3种</p><p>总结规律发现：</p><ol type="1"><li>终点是 (0,1) (0,2) (0,3) ... (0,n) 走法只有1种</li><li>终点是 (1,0) (2,0) (3,0) ... (m,0) 走法也只有1种</li><li>除了上面两种情况以外，(i,j) 处的走法等于(i-1,j) + (i,j-1)的走法之和，即为递推公式</li></ol><p>画表格</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">0111111</span><br><span class="line">1234567</span><br><span class="line">13610152128</span><br></pre></td></tr></tbody></table></figure><p>题解</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UniquePaths</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UniquePaths</span>().uniquePaths(<span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) {</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="降维-1">降维</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UniquePaths</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UniquePaths</span>().uniquePaths(<span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) {</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) {</span><br><span class="line">                dp[j] = dp[j] + dp[j - <span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>类似于不规则的杨辉三角</p><h3 id="背包问题-1">4) 0-1 背包问题</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KnapsackProblem</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. n个物品都是固体，有重量和价值</span></span><br><span class="line"><span class="comment">        2. 现在你要取走不超过 10克 的物品</span></span><br><span class="line"><span class="comment">        3. 每次可以不拿或全拿，问最高价值是多少</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            编号 重量(g)  价值(元)                        简称</span></span><br><span class="line"><span class="comment">            1   4       1600           黄金一块   400    A</span></span><br><span class="line"><span class="comment">            2   8       2400           红宝石一粒 300    R</span></span><br><span class="line"><span class="comment">            3   5       30             白银一块         S</span></span><br><span class="line"><span class="comment">            0   1       1_000_000      钻石一粒          D</span></span><br><span class="line"><span class="comment">        1_001_630</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1_002_400</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1   2   3   4   5   6   7   8   9   10</span></span><br><span class="line"><span class="comment">                    a</span></span><br><span class="line"><span class="comment">                    a               r</span></span><br><span class="line"><span class="comment">                    a               r</span></span><br><span class="line"><span class="comment">        d               da          da  dr  dr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Item</span> {</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Item</span><span class="params">(<span class="type">int</span> index, String name, <span class="type">int</span> weight, <span class="type">int</span> value)</span> {</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.weight = weight;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Item("</span> + name + <span class="string">")"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Item[] items = <span class="keyword">new</span> <span class="title class_">Item</span>[]{</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">1</span>, <span class="string">"黄金"</span>, <span class="number">4</span>, <span class="number">1600</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">2</span>, <span class="string">"宝石"</span>, <span class="number">8</span>, <span class="number">2400</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">3</span>, <span class="string">"白银"</span>, <span class="number">5</span>, <span class="number">30</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">4</span>, <span class="string">"钻石"</span>, <span class="number">1</span>, <span class="number">10_000</span>),</span><br><span class="line">        };</span><br><span class="line">        System.out.println(select(items, <span class="number">10</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">(Item[] items, <span class="type">int</span> total)</span> {</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[items.length][total + <span class="number">1</span>];</span><br><span class="line">        print(dp);</span><br><span class="line">        <span class="type">Item</span> <span class="variable">item0</span> <span class="operator">=</span> items[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; total + <span class="number">1</span>; j++) {</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= item0.weight) {</span><br><span class="line">                dp[<span class="number">0</span>][j] = item0.value;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        print(dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length; i++) {</span><br><span class="line">            <span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> items[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; total + <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="comment">// x: 上一次同容量背包的最大价值</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= item.weight) {</span><br><span class="line">                    <span class="comment">// j-item.weight: 当前背包容量-这次物品重量=剩余背包空间</span></span><br><span class="line">                    <span class="comment">// y: 剩余背包空间能装下的最大价值 + 这次物品价值</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j - item.weight] + item.value;</span><br><span class="line">                    dp[i][j] = Integer.max(x, y);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = x;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            print(dp);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>][total];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[][] dp)</span> {</span><br><span class="line">        System.out.println(<span class="string">"   "</span> + <span class="string">"-"</span>.repeat(<span class="number">63</span>));</span><br><span class="line">        Object[] array = IntStream.range(<span class="number">0</span>, dp[<span class="number">0</span>].length + <span class="number">1</span>).boxed().toArray();</span><br><span class="line">        System.out.printf((<span class="string">"%5d "</span>.repeat(dp[<span class="number">0</span>].length)) + <span class="string">"%n"</span>, array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] d : dp) {</span><br><span class="line">            array = Arrays.stream(d).boxed().toArray();</span><br><span class="line">            System.out.printf((<span class="string">"%5d "</span>.repeat(d.length)) + <span class="string">"%n"</span>, array);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="降维-2">降维</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">(Item[] items, <span class="type">int</span> total)</span> {</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[total + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (Item item : items) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> total; j &gt; <span class="number">0</span>; j--) {</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= item.weight) { <span class="comment">// 装得下</span></span><br><span class="line">                dp[j] = Integer.max(dp[j], item.value + dp[j - item.weight]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(Arrays.toString(dp));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[total];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意：内层循环需要倒序，否则 dp[j - item.weight]的结果会被提前覆盖</p><h3 id="完全背包问题">5) 完全背包问题</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KnapsackProblemComplete</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Item</span> {</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Item</span><span class="params">(<span class="type">int</span> index, String name, <span class="type">int</span> weight, <span class="type">int</span> value)</span> {</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.weight = weight;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Item("</span> + name + <span class="string">")"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Item[] items = <span class="keyword">new</span> <span class="title class_">Item</span>[]{</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">1</span>, <span class="string">"青铜"</span>, <span class="number">2</span>, <span class="number">3</span>),    <span class="comment">// c</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">2</span>, <span class="string">"白银"</span>, <span class="number">3</span>, <span class="number">4</span>),    <span class="comment">// s</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">3</span>, <span class="string">"黄金"</span>, <span class="number">4</span>, <span class="number">7</span>),    <span class="comment">// a</span></span><br><span class="line">        };</span><br><span class="line">        System.out.println(select(items, <span class="number">6</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">            0   1   2   3   4   5   6</span></span><br><span class="line"><span class="comment">        1   0   0   c   c   cc  cc  ccc</span></span><br><span class="line"><span class="comment">        2   0   0   c   s   cc  cs  ccc</span></span><br><span class="line"><span class="comment">        3   0   0   c   s   a   a   ac</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">(Item[] items, <span class="type">int</span> total)</span> {</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[items.length][total + <span class="number">1</span>];</span><br><span class="line">        <span class="type">Item</span> <span class="variable">item0</span> <span class="operator">=</span> items[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; total + <span class="number">1</span>; j++) {</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= item0.weight) {</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - item0.weight] + item0.value;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        print(dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; items.length; i++) {</span><br><span class="line">            <span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> items[i];            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; total + <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="comment">// x: 上一次同容量背包的最大价值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= item.weight) {</span><br><span class="line">                    <span class="comment">// j-item.weight: 当前背包容量-这次物品重量=剩余背包空间</span></span><br><span class="line">                    <span class="comment">// y: 剩余背包空间能装下的最大价值 + 这次物品价值</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> dp[i][j - item.weight] + item.value;</span><br><span class="line">                    dp[i][j] = Integer.max(x, y);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = x;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            print(dp);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>][total];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[][] dp)</span> {</span><br><span class="line">        System.out.println(<span class="string">"   "</span> + <span class="string">"-"</span>.repeat(<span class="number">63</span>));</span><br><span class="line">        Object[] array = IntStream.range(<span class="number">0</span>, dp[<span class="number">0</span>].length + <span class="number">1</span>).boxed().toArray();</span><br><span class="line">        System.out.printf((<span class="string">"%5d "</span>.repeat(dp[<span class="number">0</span>].length)) + <span class="string">"%n"</span>, array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] d : dp) {</span><br><span class="line">            array = Arrays.stream(d).boxed().toArray();</span><br><span class="line">            System.out.printf((<span class="string">"%5d "</span>.repeat(d.length)) + <span class="string">"%n"</span>, array);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="降维-3">降维</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">(Item[] items, <span class="type">int</span> total)</span> {</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[total + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (Item item : items) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; total + <span class="number">1</span>; j++) {</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= item.weight) {</span><br><span class="line">                dp[j] = Integer.max(dp[j], dp[j - item.weight] + item.value);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(Arrays.toString(dp));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[total];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="零钱兑换问题-leetcode322">6) 零钱兑换问题-Leetcode322</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChangeMakingProblemLeetcode322</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> amount + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[coins.length][amount + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; amount + <span class="number">1</span>; j++) {</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= coins[<span class="number">0</span>]) {</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span> + dp[<span class="number">0</span>][j - coins[<span class="number">0</span>]];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                dp[<span class="number">0</span>][j] = max;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; coins.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; amount + <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= coins[i]) {</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], <span class="number">1</span> + dp[i][j - coins[i]]);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            print(dp);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> dp[coins.length - <span class="number">1</span>][amount];</span><br><span class="line">        <span class="keyword">return</span> r &gt; amount ? -<span class="number">1</span> : r;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ChangeMakingProblemLeetcode322</span> <span class="variable">leetcode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChangeMakingProblemLeetcode322</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> leetcode.coinChange(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>}, <span class="number">5</span>);</span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{25, 10, 5, 1}, 41);</span></span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{2}, 3);</span></span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{15, 10, 1}, 21);</span></span><br><span class="line">        System.out.println(count);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[][] dp)</span> {</span><br><span class="line">        System.out.println(<span class="string">"-"</span>.repeat(<span class="number">18</span>));</span><br><span class="line">        Object[] array = IntStream.range(<span class="number">0</span>, dp[<span class="number">0</span>].length + <span class="number">1</span>).boxed().toArray();</span><br><span class="line">        System.out.printf((<span class="string">"%2d "</span>.repeat(dp[<span class="number">0</span>].length)) + <span class="string">"%n"</span>, array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] d : dp) {</span><br><span class="line">            array = Arrays.stream(d).boxed().toArray();</span><br><span class="line">            System.out.printf((<span class="string">"%2d "</span>.repeat(d.length)) + <span class="string">"%n"</span>, array);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="降维-4">降维</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> {</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> coin : coins) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coin; j &lt; amount + <span class="number">1</span>; j++) {</span><br><span class="line">            dp[j] = Math.min(dp[j], <span class="number">1</span> + dp[j - coin]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> dp[amount];</span><br><span class="line">    <span class="keyword">return</span> r &gt; amount ? -<span class="number">1</span> : r;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="零钱兑换-ii-leetcode-518">零钱兑换 II-Leetcode 518</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChangeMakingProblemLeetcode518</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     面值    0        1        2        3        4        5</span></span><br><span class="line"><span class="comment">       1    1        1        1        1        1        1</span></span><br><span class="line"><span class="comment">       2    1        1        2        2        3        3</span></span><br><span class="line"><span class="comment">       5    1        1        2        2        3        4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     面值    0        1        2        3</span></span><br><span class="line"><span class="comment">            1        0        0        0</span></span><br><span class="line"><span class="comment">       2    1        0        1        0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> {</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> coin : coins) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coin; j &lt; amount + <span class="number">1</span>; j++) {</span><br><span class="line">                dp[j] = dp[j] + dp[j - coin];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ChangeMakingProblemLeetcode518</span> <span class="variable">leetcode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChangeMakingProblemLeetcode518</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> leetcode.change(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>}, <span class="number">5</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="钢条切割问题">7) 钢条切割问题</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CutRodProblem</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1 5 8 9</span></span><br><span class="line"><span class="comment">            0   1   2   3   4</span></span><br><span class="line"><span class="comment">        1       1   11  111 1111</span></span><br><span class="line"><span class="comment">                (1) (2) (3) (4)</span></span><br><span class="line"><span class="comment">        2           11  111 1111</span></span><br><span class="line"><span class="comment">                    2   21  211</span></span><br><span class="line"><span class="comment">                            22</span></span><br><span class="line"><span class="comment">                (1) (5) (6) (10)</span></span><br><span class="line"><span class="comment">        3       1   11  111 1111</span></span><br><span class="line"><span class="comment">                    2   21  211</span></span><br><span class="line"><span class="comment">                        3   22</span></span><br><span class="line"><span class="comment">                            31</span></span><br><span class="line"><span class="comment">                (1) (5) (8) (10)</span></span><br><span class="line"><span class="comment">        4       1   11  111 1111</span></span><br><span class="line"><span class="comment">                    2   21  211</span></span><br><span class="line"><span class="comment">                        3   22</span></span><br><span class="line"><span class="comment">                            31</span></span><br><span class="line"><span class="comment">                            4</span></span><br><span class="line"><span class="comment">                (1) (5) (8) (10)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">cut</span><span class="params">(<span class="type">int</span>[] values, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[values.length][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; values.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> values[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= i) {</span><br><span class="line">                    dp[i][j] = Integer.max(dp[i - <span class="number">1</span>][j], v + dp[i][j - i]);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            print(dp);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[values.length - <span class="number">1</span>][n];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(cut(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>}, <span class="number">4</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="降维-5">降维</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">cut</span><span class="params">(<span class="type">int</span>[] values, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; values.length; i++) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> values[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n + <span class="number">1</span>; j++) {</span><br><span class="line">            dp[j] = Integer.max(dp[j], v + dp[j - i]);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(Arrays.toString(dp));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>本质上是完全背包问题，把钢条总长度看作背包容量，切分后的钢条看作物品。只是</p><ul><li><p>此时的背包容量=物品数量，例如，钢条总长度为4，可以看作有四种物品：</p><ul><li><p>长度1的钢条</p></li><li><p>长度2的钢条</p></li><li><p>长度3的钢条</p></li><li><p>长度4的钢条</p></li></ul></li><li><p>另外，这个场景下，总能装满背包</p></li></ul><h4 id="类似题目-leetcode-343-整数拆分">类似题目 Leetcode-343整数拆分</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leetcode343</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         0   1   2   3   4</span></span><br><span class="line"><span class="comment">     1   1   1   11  111 1111</span></span><br><span class="line"><span class="comment">     2   1   1   11  111 1111</span></span><br><span class="line"><span class="comment">                 2   21  211</span></span><br><span class="line"><span class="comment">                         22</span></span><br><span class="line"><span class="comment">             (1) (2) (2) (4)</span></span><br><span class="line"><span class="comment">     3   1   1   11  111 1111</span></span><br><span class="line"><span class="comment">                 2   21  211</span></span><br><span class="line"><span class="comment">                     3   22</span></span><br><span class="line"><span class="comment">                         31</span></span><br><span class="line"><span class="comment">             (1) (2) (3) (4)</span></span><br><span class="line"><span class="comment">     4   1   1   11  111 1111</span></span><br><span class="line"><span class="comment">                 2   21  211</span></span><br><span class="line"><span class="comment">                     3   22</span></span><br><span class="line"><span class="comment">                         31</span></span><br><span class="line"><span class="comment">                         4</span></span><br><span class="line"><span class="comment">             (1) (2) (3) (4)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= i) {</span><br><span class="line">                    dp[j] = Integer.max(dp[j], i * dp[j - i]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Arrays.toString(dp));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak2</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= i) {</span><br><span class="line">                    dp[i][j] = Integer.max(dp[i - <span class="number">1</span>][j], i * dp[i][j - i]);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            print(dp);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][n];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Leetcode343</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leetcode343</span>();</span><br><span class="line">        System.out.println(code.integerBreak(<span class="number">4</span>));</span><br><span class="line">        System.out.println(code.integerBreak(<span class="number">10</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="最长公共子串">8) 最长公共子串</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LCSubstring</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lcs</span><span class="params">(String a, String b)</span> {</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[b.length()][a.length()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length(); j++) {</span><br><span class="line">                <span class="keyword">if</span> (a.charAt(j) == b.charAt(i)) {</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) {</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    }</span><br><span class="line">                    max = Integer.max(dp[i][j], max);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        print(dp, a, b);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[][] dp, String a, String b)</span> {</span><br><span class="line">        System.out.println(<span class="string">"-"</span>.repeat(<span class="number">23</span>));</span><br><span class="line">        Object[] array = a.chars().mapToObj(i -&gt; String.valueOf((<span class="type">char</span>) i)).toArray();</span><br><span class="line">        System.out.printf(<span class="string">"  "</span>+<span class="string">"%2s "</span>.repeat(a.length()) + <span class="string">"%n"</span>, array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length(); i++) {</span><br><span class="line">            <span class="type">int</span>[] d = dp[i];</span><br><span class="line">            array = Arrays.stream(d).boxed().toArray();</span><br><span class="line">            System.out.printf(b.charAt(i) + <span class="string">" "</span> + <span class="string">"%2d "</span>.repeat(d.length) + <span class="string">"%n"</span>, array);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">            i   t   h   e   i   m   a</span></span><br><span class="line"><span class="comment">         t  0   1   0   0   0   0   0</span></span><br><span class="line"><span class="comment">         h  0   0   2   0   0   0   0</span></span><br><span class="line"><span class="comment">         e  0   0   0   3   0   0   0</span></span><br><span class="line"><span class="comment">         n  0   0   0   0   0   0   0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(lcs(<span class="string">"itheima"</span>, <span class="string">"then"</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="类似题目-leetcode-718-最长重复子数组">类似题目 Leetcode-718最长重复子数组</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leetcode718</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) {</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) {</span><br><span class="line">                    dp[j] = dp[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    max = Integer.max(max, dp[j]);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength1</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) {</span><br><span class="line">                <span class="keyword">if</span> (nums1[i] == nums2[j]) {</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) {</span><br><span class="line">                        dp[j] = <span class="number">1</span>;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        dp[j] = dp[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    }</span><br><span class="line">                    max = Integer.max(max, dp[j]);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength2</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> {</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length][nums2.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums2.length; j++) {</span><br><span class="line">                <span class="keyword">if</span> (nums1[i] == nums2[j]) {</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) {</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    }</span><br><span class="line">                    max = Integer.max(max, dp[i][j]);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Leetcode718</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leetcode718</span>();</span><br><span class="line">        System.out.println(code.findLength(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>}, <span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>}));</span><br><span class="line">        System.out.println(code.findLength(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>}, <span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>}));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="最长公共子序列">9) 最长公共子序列</h3><h4 id="最长公共子序列-leetcode-1143">最长公共子序列-Leetcode 1143</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LCSubsequence</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> text1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> text2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> text1.charAt(i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="type">char</span> <span class="variable">b</span> <span class="operator">=</span> text2.charAt(j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (a == b) {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = Integer.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        print(dp, text2, text1);</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[][] dp, String a, String b)</span> {</span><br><span class="line">        System.out.println(<span class="string">"-"</span>.repeat(<span class="number">23</span>));</span><br><span class="line">        Object[] array = a.chars().mapToObj(i -&gt; String.valueOf((<span class="type">char</span>) i)).toArray();</span><br><span class="line">        System.out.printf(<span class="string">"     "</span> + <span class="string">"%2s "</span>.repeat(a.length()) + <span class="string">"%n"</span>, array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length(); i++) {</span><br><span class="line">            <span class="type">int</span>[] d = dp[i + <span class="number">1</span>];</span><br><span class="line">            array = Arrays.stream(d).boxed().toArray();</span><br><span class="line">            System.out.printf(b.charAt(i) + <span class="string">" "</span> + <span class="string">"%2d "</span>.repeat(d.length) + <span class="string">"%n"</span>, array);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">LCSubsequence</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LCSubsequence</span>();</span><br><span class="line">        System.out.println(code.longestCommonSubsequence(<span class="string">"abcde"</span>, <span class="string">"ace"</span>));</span><br><span class="line">        System.out.println(code.longestCommonSubsequence(<span class="string">"ba"</span>, <span class="string">"yby"</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="两个字符串的删除操作-leetcode-583">两个字符串的删除操作-Leetcode583</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leetcode538</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Leetcode538</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leetcode538</span>();</span><br><span class="line">        System.out.println(code.minDistance(<span class="string">"leetcode"</span>, <span class="string">"etco"</span>));  <span class="comment">// 4</span></span><br><span class="line">        System.out.println(code.minDistance(<span class="string">"eat"</span>, <span class="string">"sea"</span>));   <span class="comment">// 2</span></span><br><span class="line">        System.out.println(code.minDistance(<span class="string">"park"</span>, <span class="string">"spake"</span>));   <span class="comment">// 3</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> word1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word2.length();</span><br><span class="line">        <span class="type">char</span>[] chars1 = word1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] chars2 = word2.toCharArray();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> chars1[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> chars2[j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x == y) {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = Integer.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> m + n - dp[m][n] - dp[m][n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="最长上升子序列-leetcode-300">10) 最长上升子序列-Leetcode300</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leetcode300</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    1       2       3       4</span></span><br><span class="line"><span class="comment">            1       3       6       4       9</span></span><br><span class="line"><span class="comment">            1       13      16      14      19</span></span><br><span class="line"><span class="comment">                            136     134     139</span></span><br><span class="line"><span class="comment">                                            169</span></span><br><span class="line"><span class="comment">                                            1369</span></span><br><span class="line"><span class="comment">                                            149</span></span><br><span class="line"><span class="comment">                                            1349</span></span><br><span class="line"><span class="comment">           (1)    (2)      (3)     (3)      (4)</span></span><br><span class="line"><span class="comment">                                            4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) {</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) { <span class="comment">// 满足了升序条件</span></span><br><span class="line">                    <span class="comment">// 用之前递增子序列的最大长度 + 1 更新当前长度</span></span><br><span class="line">                    dp[i] = Integer.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Arrays.toString(dp));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(dp).max().getAsInt();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Leetcode300</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leetcode300</span>();</span><br><span class="line">        System.out.println(code.lengthOfLIS(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>}));</span><br><span class="line"><span class="comment">//        System.out.println(code.lengthOfLIS(new int[]{10, 9, 2, 5, 3, 7, 101, 18}));</span></span><br><span class="line"><span class="comment">//        System.out.println(code.lengthOfLIS(new int[]{1, 3, 6, 7, 9, 4, 10, 5, 6}));</span></span><br><span class="line">        <span class="comment">//                                            1 3 6 7 9 10  = 6</span></span><br><span class="line">        <span class="comment">//                                            1 3 4 5 6     = 5</span></span><br><span class="line"><span class="comment">//        System.out.println(code.lengthOfLIS(new int[]{0, 1, 0, 3, 2, 3}));</span></span><br><span class="line"><span class="comment">//        System.out.println(code.lengthOfLIS(new int[]{7, 7, 7, 7, 7, 7, 7}));</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="catalan-数">11) Catalan 数</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Catalan</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(catalan(<span class="number">6</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">catalan</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) {</span><br><span class="line">                System.out.print(<span class="string">"("</span> + j + <span class="string">" "</span> + (i - <span class="number">1</span> - j) + <span class="string">")\t"</span>);</span><br><span class="line">                dp[i] += dp[j] * dp[i - <span class="number">1</span> - j];</span><br><span class="line">            }</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(Arrays.toString(dp));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="leetcode-96-不同的二叉搜索树">Leetcode-96 不同的二叉搜索树</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt; n + <span class="number">1</span>; j++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; j; i++) { </span><br><span class="line">                dp[j] += dp[i] * dp[j - <span class="number">1</span> - i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="leetcode-22-括号生成">Leetcode-22 括号生成</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leetcode22</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        ArrayList&lt;String&gt;[] dp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(List.of(<span class="string">""</span>));</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(List.of(<span class="string">"()"</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt; n + <span class="number">1</span>; j++) {</span><br><span class="line">            dp[j] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; j; i++) { <span class="comment">// 第j个卡特兰数的拆分</span></span><br><span class="line">                System.out.printf(<span class="string">"(%d,%d)\t"</span>, i, j - <span class="number">1</span> - i);</span><br><span class="line"><span class="comment">//                dp[j] += dp[i] * dp[j - 1 - i];</span></span><br><span class="line"><span class="comment">//                dp[j].add("(" + dp[i] + ")" + dp[j - 1 - i]);</span></span><br><span class="line">                <span class="keyword">for</span> (String k1 : dp[i]) {</span><br><span class="line">                    <span class="keyword">for</span> (String k2 : dp[j - <span class="number">1</span> - i]) {</span><br><span class="line">                        dp[j].add(<span class="string">"("</span> + k1 + <span class="string">")"</span> + k2);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            System.out.println(dp[j]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Leetcode22</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leetcode22</span>();</span><br><span class="line">        System.out.println(code.generateParenthesis(<span class="number">4</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="买票找零问题">买票找零问题</h4><p>售票处售卖球票，每张票 50 元。有2n人前来买票</p><ul><li>其中一半人手持 50 元钞票</li><li>另一半人手持 100 元钞票</li></ul><p>若售票处开始没有任何零钱，问：有多少种排队方式，能够让售票顺畅进行。</p><p>思路：</p><ul><li>把手持 50 元钞票的人视为左括号</li><li>把手持 100 元钞票的人视为右括号</li><li>左右括号合法配对，即先出现左括号，再出现右括号，就可以让售票顺畅执行</li></ul><p>可以看到，问题又变成了求解 n 的卡特兰数</p><h4 id="其它问题">其它问题</h4><table><thead><tr class="header"><th>题号</th><th>标题</th></tr></thead><tbody><tr class="odd"><td>Leetcode 331</td><td>验证二叉树的前序序列化</td></tr><tr class="even"><td>Leetcode 894</td><td>所有可能的满二叉树</td></tr><tr class="odd"><td></td><td></td></tr></tbody></table><h3 id="打家劫舍-leetcode-198">12) 打家劫舍-Leetcode 198</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseRobberLeetcode198</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        房子价值</span></span><br><span class="line"><span class="comment">              0   1   2   3   4</span></span><br><span class="line"><span class="comment">              2   7   9   3   1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              0   1   2   3   4</span></span><br><span class="line"><span class="comment">              0   0   0   0   0</span></span><br><span class="line"><span class="comment">              2   7   11  10  12</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              0   1   2   3</span></span><br><span class="line"><span class="comment">              2   1   1   2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              0   1   2   3</span></span><br><span class="line"><span class="comment">              2   2   3   4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Integer.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; len; i++) {</span><br><span class="line">            dp[i] = Integer.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">HouseRobberLeetcode198</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseRobberLeetcode198</span>();</span><br><span class="line">        System.out.println(code.rob(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>}));</span><br><span class="line">        System.out.println(code.rob(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>}));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="travelling-salesman-problem">13) Travelling salesmanproblem</h3><p>旅行商问题</p><figure><img src="../../../../images/StrJava/image-20230731213127478.png" alt="image-20230731213127478"><figcaption aria-hidden="true">image-20230731213127478</figcaption></figure><p>java 代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TravellingSalesmanProblem</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">            0   1   2   3</span></span><br><span class="line"><span class="comment">        0   0   1   2   3</span></span><br><span class="line"><span class="comment">        1   1   0   6   4</span></span><br><span class="line"><span class="comment">        2   2   6   0   5</span></span><br><span class="line"><span class="comment">        3   3   4   5   0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        d(0,{1,2,3}) =&gt; c01+d(1,{2,3}) =&gt; c12+d(2,{3}) =&gt; c23+d(3,{})</span></span><br><span class="line"><span class="comment">                                          c13+d(3,{2}) =&gt; c32+d(2,{})</span></span><br><span class="line"><span class="comment">                        c02+d(2,{1,3}) =&gt; c21+d(1,{3}) =&gt; c13+d(3,{})</span></span><br><span class="line"><span class="comment">                                          c23+d(3,{1}) =&gt; c31+d(1,{})</span></span><br><span class="line"><span class="comment">                        c03+d(3,{1,2}) =&gt; c31+d(1,{2}) =&gt; c12+d(2,{})</span></span><br><span class="line"><span class="comment">                                          c32+d(2,{1}) =&gt; c21+d(1,{})</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        d(0,{1}) =&gt; c01+d(1,{}) 0-&gt;1-&gt;0</span></span><br><span class="line"><span class="comment">        d(1,{1})</span></span><br><span class="line"><span class="comment">        d(2,{1}) =&gt; c21+d(1,{}) 2-&gt;1-&gt;0</span></span><br><span class="line"><span class="comment">        d(3,{1}) =&gt; c31+d(1,{}) 3-&gt;1-&gt;0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        d(0,{2}) =&gt; c02+d(2,{}) 0-&gt;2-&gt;0</span></span><br><span class="line"><span class="comment">        d(1,{2}) =&gt; c12+d(2,{}) 1-&gt;2-&gt;0</span></span><br><span class="line"><span class="comment">        d(2,{2})</span></span><br><span class="line"><span class="comment">        d(3,{2}) =&gt; c32+d(2,{}) 3-&gt;2-&gt;0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        d(0,{1,2}) =&gt; c01+d(1,{2}) =&gt; 0-&gt;1-&gt;2-&gt;0</span></span><br><span class="line"><span class="comment">                      c02+d(2,{1}) =&gt; 0-&gt;2-&gt;1-&gt;0</span></span><br><span class="line"><span class="comment">        d(3,{1,2}) =&gt; c31+d(1,{2}) =&gt; 3-&gt;1-&gt;2-&gt;0</span></span><br><span class="line"><span class="comment">                      c32+d(2,{1}) =&gt; 3-&gt;2-&gt;1-&gt;0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        d(0,{3}) =&gt; c03+d(3,{}) 0-&gt;3-&gt;0</span></span><br><span class="line"><span class="comment">        d(1,{3}) =&gt; c13+d(3,{}) 1-&gt;3-&gt;0</span></span><br><span class="line"><span class="comment">        d(2,{3}) =&gt; c23+d(3,{}) 2-&gt;3-&gt;0</span></span><br><span class="line"><span class="comment">        d(3,{3})</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        d(0,{1,3}) =&gt; c01+d(1,{3}) =&gt; 0-&gt;1-&gt;3-&gt;0</span></span><br><span class="line"><span class="comment">                      c03+d(3,{1}) =&gt; 0-&gt;3-&gt;1-&gt;0</span></span><br><span class="line"><span class="comment">        d(2,{1,3}) =&gt; c21+d(1,{3}) =&gt; 2-&gt;1-&gt;3-&gt;0</span></span><br><span class="line"><span class="comment">                      c23+d(3,{1}) =&gt; 2-&gt;3-&gt;1-&gt;0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        d(0,{2,3}) =&gt; c02+d(2,{3}) =&gt; 0-&gt;2-&gt;3-&gt;0</span></span><br><span class="line"><span class="comment">                      c03+d(3,{2}) =&gt; 0-&gt;3-&gt;2-&gt;0</span></span><br><span class="line"><span class="comment">        d(1,{2,3}) =&gt; c12+d(2,{3}) =&gt; 1-&gt;2-&gt;3-&gt;0</span></span><br><span class="line"><span class="comment">                      c13+d(3,{2}) =&gt; 1-&gt;3-&gt;2-&gt;0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        d(0,{1,2,3}) =&gt; c01+d(1,{2,3})  11+1</span></span><br><span class="line"><span class="comment">                        c02+d(2,{1,3})  10+2</span></span><br><span class="line"><span class="comment">                        c03+d(3,{1,2})  12+3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            0       1       2       12      3       13      23      123</span></span><br><span class="line"><span class="comment">            0       1       2       3       4       5       6       7</span></span><br><span class="line"><span class="comment">       0    0       2       4       9       6       8       10      12</span></span><br><span class="line"><span class="comment">       1    1       _       8       _       7       _       11      _</span></span><br><span class="line"><span class="comment">       2    2       7       _       _       8       10      _       _</span></span><br><span class="line"><span class="comment">       3    3       5       7       12      _       _       _       _</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[][] graph = {</span><br><span class="line">                {<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>},</span><br><span class="line">                {<span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">4</span>},</span><br><span class="line">                {<span class="number">2</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">5</span>},</span><br><span class="line">                {<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>},</span><br><span class="line">        };</span><br><span class="line"><span class="comment">//        System.out.println(tsp(graph));</span></span><br><span class="line">        System.out.println(<span class="number">6</span> &gt;&gt; (<span class="number">0</span>-<span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">tsp1</span><span class="params">(<span class="type">int</span>[][] graph)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> graph.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span> &lt;&lt; n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : dp) {</span><br><span class="line">            Arrays.fill(row, Integer.MAX_VALUE / <span class="number">2</span>);</span><br><span class="line">        }</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">1</span>; mask &lt; <span class="number">1</span> &lt;&lt; n; mask++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">                <span class="keyword">if</span> ((mask &amp; <span class="number">1</span> &lt;&lt; i) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; <span class="number">1</span> &lt;&lt; j) != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    dp[mask | <span class="number">1</span> &lt;&lt; j][j] = Math.min(dp[mask | <span class="number">1</span> &lt;&lt; j][j], dp[mask][i] + graph[i][j]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            print(dp);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            res = Math.min(res, dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][i] + graph[i][<span class="number">0</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        110 是否包含 0 = 0 &amp; 1 = 0</span></span><br><span class="line"><span class="comment">        110 是否包含 1 = 110 &amp; 1 = 0</span></span><br><span class="line"><span class="comment">        110 是否包含 2 = 11 &amp; 1 = 1</span></span><br><span class="line"><span class="comment">        110 是否包含 3 = 1 &amp; 1 = 1</span></span><br><span class="line"><span class="comment">        110 是否包含 4 = 0 &amp; 1 = 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(<span class="type">int</span> set, <span class="type">int</span> city)</span> {</span><br><span class="line">        <span class="keyword">return</span> (set &gt;&gt; (city - <span class="number">1</span>) &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        110     110</span></span><br><span class="line"><span class="comment">       ^100    ^010</span></span><br><span class="line"><span class="comment">       ----    ----</span></span><br><span class="line"><span class="comment">         10     100</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">exclude</span><span class="params">(<span class="type">int</span> set, <span class="type">int</span> city)</span> {</span><br><span class="line">        <span class="keyword">return</span> set ^ (<span class="number">1</span> &lt;&lt; (city - <span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">tsp</span><span class="params">(<span class="type">int</span>[][] g)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> g.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = g[i][<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; j++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">                dp[i][j] = Integer.MAX_VALUE / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (contains(j, i)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt; n; k++) {</span><br><span class="line">                    <span class="keyword">if</span> (contains(j, k)) {</span><br><span class="line"><span class="comment">//                    System.out.println("(" + k + "," + (j ^ (1 &lt;&lt; (k - 1))) + ")");</span></span><br><span class="line">                        dp[i][j] = Math.min(dp[i][j], g[i][k] + dp[k][exclude(j, k)]);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            print(dp);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][m - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[][] dist)</span> {</span><br><span class="line">        System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : dist) {</span><br><span class="line">            System.out.println(Arrays.stream(row).boxed()</span><br><span class="line">                    .map(x -&gt; x &gt;= Integer.MAX_VALUE / <span class="number">2</span> ? <span class="string">"∞"</span> : String.valueOf(x))</span><br><span class="line">                    .map(s -&gt; String.format(<span class="string">"%2s"</span>, s))</span><br><span class="line">                    .collect(Collectors.joining(<span class="string">","</span>, <span class="string">"["</span>, <span class="string">"]"</span>)));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="其它题目-3">其它题目</h3><table><thead><tr class="header"><th>题号</th><th>标题</th></tr></thead><tbody><tr class="odd"><td>无</td><td>集合覆盖问题</td></tr><tr class="even"><td>无</td><td>扔鸡蛋问题</td></tr><tr class="odd"><td>Leetcode 72</td><td>编辑距离</td></tr><tr class="even"><td>Leetcode 121</td><td>买股票的最佳时机</td></tr></tbody></table><h4 id="组合总和-iv-leetcode-377">组合总和 IV-Leetcode 377</h4><p>不要被题目名字误导了，本题类似于零钱兑换518题，区别在于零钱兑换求的是组合数，本题求的是排列数</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CombinationLeetcode377</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="keyword">return</span> change(nums, target);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">            0       1       2       3       4 总金额</span></span><br><span class="line"><span class="comment">        1           1       11      111     1111</span></span><br><span class="line"><span class="comment">        2           1       11      111     1111</span></span><br><span class="line"><span class="comment">                            2       12      112</span></span><br><span class="line"><span class="comment">                                    21      121</span></span><br><span class="line"><span class="comment">                                            22</span></span><br><span class="line"><span class="comment">                                            211</span></span><br><span class="line"><span class="comment">        3           1       11      111     1111</span></span><br><span class="line"><span class="comment">                            2       12      112</span></span><br><span class="line"><span class="comment">                                    21      121</span></span><br><span class="line"><span class="comment">                                    3       13</span></span><br><span class="line"><span class="comment">                                            211</span></span><br><span class="line"><span class="comment">                                            22</span></span><br><span class="line"><span class="comment">                                            31</span></span><br><span class="line"><span class="comment">        面值</span></span><br><span class="line"><span class="comment">        dp[j] = dp[j-1] + dp[j-2] + dp[j-3]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> {</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; amount + <span class="number">1</span>; j++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> coin : coins) {</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= coin) {</span><br><span class="line">                    dp[j] += dp[j - coin];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Arrays.toString(dp));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(combinationSum4(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}, <span class="number">4</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="divide-and-conquer">4.4 Divide and Conquer</h2><h3 id="概述-11">1) 概述</h3><p>分治思想</p><ul><li>将大问题划分为两个到多个子问题</li><li>子问题可以继续拆分成更小的子问题，直到能够简单求解</li><li>如有必要，将子问题的解进行合并，得到原始问题的解</li></ul><p>之前学过的一些经典分而治之的例子</p><ul><li>二分查找</li><li>快速排序</li><li>归并排序</li><li>合并K个排序链表 - LeetCode 23</li></ul><h4 id="二分查找-1">二分查找</h4><figure><img src="../../../../images/StrJava/image-20230802100240290.png" alt="image-20230802100240290"><figcaption aria-hidden="true">image-20230802100240290</figcaption></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="keyword">return</span> recursion(a, target, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">recursion</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">    <span class="keyword">if</span> (i &gt; j) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; a[m]) {</span><br><span class="line">        <span class="keyword">return</span> recursion(a, target, i, m - <span class="number">1</span>);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) {</span><br><span class="line">        <span class="keyword">return</span> recursion(a, target, m + <span class="number">1</span>, j);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>减而治之，每次搜索范围内元素减少一半</p><h4 id="快速排序-1">快速排序</h4><figure><img src="../../../../images/StrJava/image-20230802100332341.png" alt="image-20230802100332341"><figcaption aria-hidden="true">image-20230802100332341</figcaption></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">    quick(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a, left, right);</span><br><span class="line">    quick(a, left, p - <span class="number">1</span>);</span><br><span class="line">    quick(a, p + <span class="number">1</span>, right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>分而治之，这次分区基准点，在划分后两个区域分别进行下次分区</p><h4 id="归并排序-1">归并排序</h4><figure><img src="../../../../images/StrJava/image-20230513143854887.png" alt="image-20230513143854887"><figcaption aria-hidden="true">image-20230513143854887</figcaption></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a1)</span> {</span><br><span class="line">    <span class="type">int</span>[] a2 = <span class="keyword">new</span> <span class="title class_">int</span>[a1.length];</span><br><span class="line">    split(a1, <span class="number">0</span>, a1.length - <span class="number">1</span>, a2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] a2)</span> {</span><br><span class="line">    <span class="type">int</span>[] array = Arrays.copyOfRange(a1, left, right + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 2. 治</span></span><br><span class="line">    <span class="keyword">if</span> (left == right) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 1. 分</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    split(a1, left, m, a2);                 </span><br><span class="line">    split(a1, m + <span class="number">1</span>, right, a2);       </span><br><span class="line">    <span class="comment">// 3. 合</span></span><br><span class="line">    merge(a1, left, m, m + <span class="number">1</span>, right, a2);</span><br><span class="line">    System.arraycopy(a2, left, a1, left, right - left + <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>分而治之，分到区间内只有一个元素，合并区间</p><h4 id="合并k个排序链表---leetcode-23">合并K个排序链表 - LeetCode23</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> {</span><br><span class="line">    <span class="keyword">if</span> (lists.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> split(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">split</span><span class="params">(ListNode[] lists, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">    System.out.println(i + <span class="string">" "</span> + j);</span><br><span class="line">    <span class="keyword">if</span> (j == i) {</span><br><span class="line">        <span class="keyword">return</span> lists[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(</span><br><span class="line">        split(lists, i, m),</span><br><span class="line">        split(lists, m + <span class="number">1</span>, j)</span><br><span class="line">    );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>分而治之，分到区间内只有一个链表，合并区间</p><h4 id="对比动态规划">对比动态规划</h4><ul><li>都需要拆分子问题</li><li>动态规划的子问题有重叠、因此需要记录之前子问题解，避免重复运算</li><li>分而治之的子问题无重叠</li></ul><h3 id="快速选择算法">2) 快速选择算法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Utils</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a, left, right);</span><br><span class="line">        <span class="keyword">if</span> (p == index) {</span><br><span class="line">            <span class="keyword">return</span> a[p];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (p &lt; index) {</span><br><span class="line">            <span class="keyword">return</span> quick(a, p + <span class="number">1</span>, right, index);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> quick(a, left, p - <span class="number">1</span>, index);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(right - left + <span class="number">1</span>) + left;</span><br><span class="line">        swap(a, left, idx);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> a[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) {</span><br><span class="line">            <span class="comment">// i 从左向右找大的或者相等的</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; a[i] &lt; pv) {</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// j 从右向左找小的或者相等的</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; a[j] &gt; pv) {</span><br><span class="line">                j--;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= j) {</span><br><span class="line">                swap(a, i, j);</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        swap(a, j, left);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="数组中第k个最大元素-leetcode-215">数组中第k个最大元素-Leetcode215</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindKthLargestLeetcode215</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        目标 index = 4</span></span><br><span class="line"><span class="comment">            3   2   1   5   6   4</span></span><br><span class="line"><span class="comment">        =&gt;  3   2   1   4   5   6   (3)</span></span><br><span class="line"><span class="comment">        =&gt;  3   2   1   4   5   6   (5)</span></span><br><span class="line"><span class="comment">        =&gt;  3   2   1   4   5   6   (4)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> k)</span> {</span><br><span class="line">        <span class="keyword">return</span> Utils.quick(a, <span class="number">0</span>, a.length - <span class="number">1</span>, a.length - k);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 应为5</span></span><br><span class="line">        <span class="type">FindKthLargestLeetcode215</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FindKthLargestLeetcode215</span>();</span><br><span class="line">        System.out.println(code.findKthLargest(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>}, <span class="number">2</span>));</span><br><span class="line">        <span class="comment">// 应为4</span></span><br><span class="line">        System.out.println(code.findKthLargest(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>}, <span class="number">4</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="数组中位数">数组中位数</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindMedian</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        偶数个</span></span><br><span class="line"><span class="comment">            3   1   5   4</span></span><br><span class="line"><span class="comment">        奇数个</span></span><br><span class="line"><span class="comment">            4   5   1</span></span><br><span class="line"><span class="comment">            4   5   1   6   3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="keyword">if</span> (nums.length % <span class="number">2</span> != <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> findIndex(nums, nums.length / <span class="number">2</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            System.out.println((nums.length / <span class="number">2</span> - <span class="number">1</span>) + <span class="string">","</span> + (nums.length / <span class="number">2</span>));</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> findIndex(nums, nums.length / <span class="number">2</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> findIndex(nums, nums.length / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> (a + b) / <span class="number">2.0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(findMedian(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>}));</span><br><span class="line">        System.out.println(findMedian(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>}));</span><br><span class="line">        System.out.println(findMedian(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>}));</span><br><span class="line">        System.out.println(findMedian(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>}));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findIndex</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="keyword">return</span> Utils.quick(a, <span class="number">0</span>, a.length - <span class="number">1</span>, index);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="快速幂-leetcode-50">3) 快速幂-Leetcode 50</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickPowLeetcode50</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                  2^10</span></span><br><span class="line"><span class="comment">              /         \</span></span><br><span class="line"><span class="comment">            2^5         2^5</span></span><br><span class="line"><span class="comment">           /  \        /  \</span></span><br><span class="line"><span class="comment">        2 2^2 2^2    2 2^2 2^2</span></span><br><span class="line"><span class="comment">         / \  / \     / \  / \</span></span><br><span class="line"><span class="comment">        2  2  2  2   2  2  2  2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                  256          n=1 x=65536 mul=1024</span></span><br><span class="line"><span class="comment">              /         \</span></span><br><span class="line"><span class="comment">            16          16          n=2 x=256 mul=4</span></span><br><span class="line"><span class="comment">           /  \        /  \</span></span><br><span class="line"><span class="comment">        2 4    4    2  4    4       n=5  x=16 mul=4</span></span><br><span class="line"><span class="comment">         / \  / \     / \  / \</span></span><br><span class="line"><span class="comment">        2  2  2  2   2  2  2  2     n=10  x=4  mul=1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">double</span> <span class="variable">mul</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">N</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) {</span><br><span class="line">            N = -N;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> ((N &amp; <span class="number">1</span>) == <span class="number">1</span>) {</span><br><span class="line">                mul *= x;</span><br><span class="line">            }</span><br><span class="line">            x =  x * x;</span><br><span class="line">            N = N &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> ? mul : <span class="number">1</span> / mul;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">myPow1</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">long</span> <span class="variable">N</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">if</span> (N &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span> / rec(x, -N);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> rec(x, n);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">rec</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> n)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> rec(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> x * y * y;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> y * y;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(myPow(<span class="number">2</span>, <span class="number">10</span>));  <span class="comment">// 1024.0</span></span><br><span class="line">        System.out.println(myPow(<span class="number">2.1</span>, <span class="number">3</span>)); <span class="comment">// 9.261</span></span><br><span class="line">        System.out.println(myPow(<span class="number">2</span>, -<span class="number">2</span>)); <span class="comment">// 0.25</span></span><br><span class="line">        System.out.println(myPow(<span class="number">2</span>, <span class="number">0</span>)); <span class="comment">// 1.0</span></span><br><span class="line">        System.out.println(myPow(<span class="number">2</span>, -<span class="number">2147483648</span>)); <span class="comment">// 1.0</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="平方根整数部分-leetcode-69">4) 平方根整数部分-Leetcode 69</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqrtLeetcode69</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (x / m &gt;= m) {</span><br><span class="line">                r = m;</span><br><span class="line">                i = m+<span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                j = m-<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(mySqrt(<span class="number">1</span>));</span><br><span class="line">        System.out.println(mySqrt(<span class="number">2</span>));</span><br><span class="line">        System.out.println(mySqrt(<span class="number">4</span>));</span><br><span class="line">        System.out.println(mySqrt(<span class="number">8</span>));</span><br><span class="line">        System.out.println(mySqrt(<span class="number">9</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>while(i &lt;= j)含义是在此区间内，只要有数字还未尝试，就不算结束</li><li>r 的作用是保留最近一次当 <span class="math inline">\(m^2 &lt;=x\)</span> 的 m 的值</li><li>使用除法而非乘法，避免大数相乘越界</li></ul><h3 id="至少k个重复字符的最长子串-leetcode-395">5)至少k个重复字符的最长子串-Leetcode 395</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongestSubstringLeetcode395</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestSubstring</span><span class="params">(String s, <span class="type">int</span> k)</span> {</span><br><span class="line">        <span class="comment">// 子串落选情况</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; k) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>]; <span class="comment">// 索引对应字符 值用来存储该字符出现了几次</span></span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : chars) { <span class="comment">// 'a' -&gt; 0  'b' -&gt; 1 ....</span></span><br><span class="line">            counts[c - <span class="string">'a'</span>]++;</span><br><span class="line">        }</span><br><span class="line">        System.out.println(Arrays.toString(counts));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) {</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> chars[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> counts[c - <span class="string">'a'</span>]; <span class="comment">// i字符出现次数</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; count &lt; k) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(j &lt; s.length() &amp;&amp; counts[chars[j] - <span class="string">'a'</span>] &lt; k) {</span><br><span class="line">                    j++;</span><br><span class="line">                }</span><br><span class="line">                System.out.println(s.substring(<span class="number">0</span>, i) + <span class="string">"\t"</span> + s.substring(j));</span><br><span class="line">                <span class="keyword">return</span> Integer.max(</span><br><span class="line">                        longestSubstring(s.substring(<span class="number">0</span>, i), k),</span><br><span class="line">                        longestSubstring(s.substring(j), k)</span><br><span class="line">                );</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 子串入选情况</span></span><br><span class="line">        <span class="keyword">return</span> s.length();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//                                         i j</span></span><br><span class="line">        System.out.println(longestSubstring(<span class="string">"aaaccbbb"</span>, <span class="number">3</span>)); <span class="comment">// ababb</span></span><br><span class="line">        System.out.println(longestSubstring(<span class="string">"dddxaabaaabaacciiiiefbff"</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">//        System.out.println(longestSubstring("ababbc", 3)); // ababb</span></span><br><span class="line"><span class="comment">//        System.out.println(longestSubstring("ababbc", 2)); // ababb</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            ddd aabaaabaa iiii fbff</span></span><br><span class="line"><span class="comment">                aa aaa aa      f ff</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            统计字符串中每个字符的出现次数，移除哪些出现次数 &lt; k 的字符</span></span><br><span class="line"><span class="comment">            剩余的子串，递归做此处理，直至</span></span><br><span class="line"><span class="comment">                 - 整个子串长度 &lt; k (排除)</span></span><br><span class="line"><span class="comment">                 - 子串中没有出现次数 &lt; k 的字符</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="backtracking-algorithm">4.5 Backtracking Algorithm</h2><h3 id="入门例子">1) 入门例子</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Backtracking</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        rec(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rec</span><span class="params">(<span class="type">int</span> n, LinkedList&lt;String&gt; list)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"before:"</span> + list);</span><br><span class="line">        list.push(<span class="string">"a"</span>);</span><br><span class="line">        rec(n + <span class="number">1</span>, list);</span><br><span class="line">        list.pop();</span><br><span class="line">        System.out.println(<span class="string">"after:"</span> + list);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="全排列-leetcode-46">2) 全排列-Leetcode 46</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PermuteLeetcode46</span> {</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; r = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        rec(nums, visited, stack, r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rec</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] visited, LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; r)</span> {</span><br><span class="line">        <span class="keyword">if</span> (stack.size() == nums.length) {</span><br><span class="line">            r.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span>(visited[i]){</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            stack.push(nums[i]);</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            rec(nums, visited, stack, r);</span><br><span class="line">            stack.pop();</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; permute = permute(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>});</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; s : permute) {</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="全排列ii-leetcode-47">3) 全排列II-Leetcode 47</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PermuteLeetcode47</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(nums, <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length], <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] visited, LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result)</span> {</span><br><span class="line">        <span class="keyword">if</span> (stack.size() == nums.length) {</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !visited[i-<span class="number">1</span>]) { <span class="comment">// 找出重复数字</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) {</span><br><span class="line">                stack.push(nums[i]);</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">                dfs(nums, visited, stack, result);</span><br><span class="line">                visited[i] = <span class="literal">false</span>;</span><br><span class="line">                stack.pop();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] nums = {<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>};        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; permute = permuteUnique(nums);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : permute) {</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>排好序，这样重复的数字会相邻</li><li>定好规则：必须 1 固定之后才能固定 1'，即 1 的 visited = true才能继续处理 1'</li><li>在遍历时，遇到了 <code>nums[i] == nums[i - 1]</code>（即 1 和 1‘这种情况），进一步检查 i-1 位置的数字有没有visited，没有，则不处理（剪枝）</li></ul><h3 id="组合-leetcode-77">4) 组合-Leetcode 77</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CombinationLeetcode77</span> {</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(n, k, <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> start, LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result)</span> {</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) {</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">            System.out.println(stack);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"><span class="comment">//      if (k &gt; n - start + 1) { return; }</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n; i++) {</span><br><span class="line"><span class="comment">//            System.out.printf("k-1=%d n=%d i=%d %n", k - 1, n, i);</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; n - i + <span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            stack.push(i);</span><br><span class="line">            dfs(n, k - <span class="number">1</span>, i + <span class="number">1</span>, stack, result);</span><br><span class="line">            stack.pop();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = combinationSum(<span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//        for (List&lt;Integer&gt; list : lists) {</span></span><br><span class="line"><span class="comment">//            System.out.println(list);</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line">        System.out.println(count);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>k 代表剩余要组合的个数</li><li><code>n - i + 1</code> 代表剩余可用数字</li><li>剪枝条件是：剩余可用数字要大于剩余组合数</li><li>为啥放在外面不行？即这行代码：<code>if (k &gt; n - start + 1) { return; }</code><ul><li>因为它只考虑了 start 一种情况，而实际在循环内要处理的是start，start+1 ... n 这多种情况</li></ul></li></ul><p>似乎 ArrayList 作为 stack 性能高一些，见下面代码，但是这道题在leetcode 上执行时间不稳定，相同代码都会有较大时间差异（15ms vs 9ms）</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> {        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || n &lt; k) <span class="keyword">return</span> result;</span><br><span class="line">        dfs(n, k, <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> start, ArrayList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result)</span> {</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) {</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (k-<span class="number">1</span> &gt; n - i) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            stack.add(i);</span><br><span class="line">            dfs(n, k - <span class="number">1</span>, i + <span class="number">1</span>, stack, result);</span><br><span class="line">            stack.remove(stack.size()-<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="组合总和-leetcode-39">5) 组合总和-Leetcode 39</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CombinationLeetcode39</span> {</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(target, <span class="number">0</span>,candidates, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> start, <span class="type">int</span>[] candidates, LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result)</span> {</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) {</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> candidates[i];</span><br><span class="line">            <span class="keyword">if</span> (target &lt; candidate) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            stack.push(candidate);</span><br><span class="line">            dfs(target - candidate, i, candidates, stack, result);</span><br><span class="line">            stack.pop();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = combinationSum(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>}, <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : lists) {</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>与之前的零钱兑换问题其实是一样的，只是</p><ul><li>本题求的是：所有组合的具体信息</li><li>零钱兑换问题求的是：所有组合中数字最少的、所有组合个数...</li></ul><h3 id="组合总和-ii-leetcode-40">6) 组合总和 II-Leetcode 40</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CombinationLeetcode40</span> {</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> {</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(target, <span class="number">0</span>, candidates, <span class="keyword">new</span> <span class="title class_">boolean</span>[candidates.length], <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> start, <span class="type">int</span>[] candidates, <span class="type">boolean</span>[] visited, LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result)</span> {</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) {</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> candidates[i];</span><br><span class="line">            <span class="keyword">if</span> (target &lt; candidate) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidate == candidates[i - <span class="number">1</span>] &amp;&amp; !visited[i - <span class="number">1</span>]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            stack.push(candidate);</span><br><span class="line">            dfs(target - candidate, i + <span class="number">1</span>, candidates, visited, stack, result);</span><br><span class="line">            stack.pop();</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] candidates = {<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>};        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = combinationSum2(candidates, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : lists) {</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="组合总和-iii-leetcode-216">7) 组合总和 III-Leetcode 216</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CombinationLeetcode216</span> {</span><br><span class="line">    <span class="comment">// 此 target 代表数字组合后的和</span></span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> target)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">1</span>, target, k, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> target, <span class="type">int</span> k,</span></span><br><span class="line"><span class="params">                    LinkedList&lt;Integer&gt; stack,</span></span><br><span class="line"><span class="params">                    List&lt;List&lt;Integer&gt;&gt; result)</span> {</span><br><span class="line"><span class="comment">//        System.out.println(stack);</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> &amp;&amp; stack.size() == k) {</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= <span class="number">9</span>; i++) {</span><br><span class="line">            <span class="comment">//  还差几个数字          剩余可用数字</span></span><br><span class="line">            <span class="comment">/*if (k - stack.size() &gt; 9 - i + 1) {</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            }*/</span></span><br><span class="line">            <span class="keyword">if</span>(target &lt; i){</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(stack.size() == k) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            stack.push(i);</span><br><span class="line">            dfs(i + <span class="number">1</span>, target - i, k, stack, result);</span><br><span class="line">            stack.pop();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="comment">//        List&lt;List&lt;Integer&gt;&gt; lists = combinationSum3(3, 7);</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = combinationSum3(<span class="number">2</span>, <span class="number">18</span>); <span class="comment">// 9 8</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : lists) {</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这道题更类似于 77 题，区别在于</p><ol type="1"><li>77 题的数字范围 n 更大 [1,20]，而本题数字范围限制为 [1,9]</li><li>本题不仅仅找到组合，还要让组合之和等于 target（类似于 39 题）</li></ol><p>剪枝优化</p><ol type="1"><li>如果剩余的和 target 还没 i 大，这时减完 i是负数，肯定无法满足要求，因此有剪枝条件：<ul><li><code>target &lt; i</code></li></ul></li><li>如果组合的数字个数已经到达了上限 k，还没有凑够target，也没必要继续递归，因此有：<ul><li><code>stack.size() == k</code></li></ul></li></ol><h3 id="n-皇后-leetcode-51">8) N 皇后 Leetcode 51</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NQueenLeetcode51</span> {</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[][] table = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            Arrays.fill(table[i], <span class="string">'.'</span>);</span><br><span class="line">        }</span><br><span class="line">        dfs(<span class="number">0</span>, n, table, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n, <span class="type">char</span>[][] table, List&lt;List&lt;String&gt;&gt; result)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i == n) {</span><br><span class="line">            ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span>[] chars : table) {</span><br><span class="line">                list.add(String.valueOf(chars));</span><br><span class="line">            }</span><br><span class="line">            result.add(list);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">            <span class="keyword">if</span> (notValid(table, i, j)) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            table[i][j] = <span class="string">'Q'</span>;</span><br><span class="line">            dfs(i + <span class="number">1</span>, n, table, result);</span><br><span class="line">            table[i][j] = <span class="string">'.'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        .   .   .   .</span></span><br><span class="line"><span class="comment">        .   .   .   .</span></span><br><span class="line"><span class="comment">        .   ?   .   .</span></span><br><span class="line"><span class="comment">        .   .   .   .</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">notValid</span><span class="params">(<span class="type">char</span>[][] table, <span class="type">int</span> row, <span class="type">int</span> col)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> table.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (table[i][col] == <span class="string">'Q'</span>) { <span class="comment">// 上</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) {</span><br><span class="line">            <span class="keyword">if</span> (table[i][j] == <span class="string">'Q'</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) {</span><br><span class="line">            <span class="keyword">if</span> (table[i][j] == <span class="string">'Q'</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; table : solveNQueens(<span class="number">8</span>)) {</span><br><span class="line">            <span class="keyword">for</span> (String row : table) {</span><br><span class="line">                System.out.println(row);</span><br><span class="line">            }</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(<span class="string">"--------------------- "</span> + count);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NQueenLeetcode51</span> {</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[][] table = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="type">boolean</span>[] va = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="type">boolean</span>[] vb = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2</span> * n - <span class="number">1</span>];</span><br><span class="line">        <span class="type">boolean</span>[] vc = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2</span> * n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            Arrays.fill(table[i], <span class="string">'.'</span>);</span><br><span class="line">        }</span><br><span class="line">        dfs(<span class="number">0</span>, n, table, result, va, vb, vc);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n, <span class="type">char</span>[][] table, List&lt;List&lt;String&gt;&gt; result, <span class="type">boolean</span>[] va, <span class="type">boolean</span>[] vb, <span class="type">boolean</span>[] vc)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i == n) {</span><br><span class="line">            ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span>[] chars : table) {</span><br><span class="line">                list.add(String.valueOf(chars));</span><br><span class="line">            }</span><br><span class="line">            result.add(list);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">            <span class="keyword">if</span> (va[j] || vb[i + j] || vc[i - j + n - <span class="number">1</span>]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            va[j] = <span class="literal">true</span>;</span><br><span class="line">            vb[i + j] = <span class="literal">true</span>;</span><br><span class="line">            vc[i - j + n - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            table[i][j] = <span class="string">'Q'</span>;</span><br><span class="line">            dfs(i + <span class="number">1</span>, n, table, result, va, vb, vc);</span><br><span class="line">            table[i][j] = <span class="string">'.'</span>;</span><br><span class="line">            va[j] = <span class="literal">false</span>;</span><br><span class="line">            vb[i + j] = <span class="literal">false</span>;</span><br><span class="line">            vc[i - j + n - <span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; table : solveNQueens(<span class="number">4</span>)) {</span><br><span class="line">            <span class="keyword">for</span> (String row : table) {</span><br><span class="line">                System.out.println(row);</span><br><span class="line">            }</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(<span class="string">"--------------------- "</span> + count);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="解数独-leetcode37">9) 解数独-Leetcode37</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SudokuLeetcode37</span> {</span><br><span class="line">    <span class="keyword">record</span> <span class="title class_">Pair</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] table)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">        <span class="type">boolean</span>[][] va = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="type">boolean</span>[][] vb = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="type">boolean</span>[][][] vc = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">3</span>][<span class="number">3</span>][n];</span><br><span class="line">        List&lt;Pair&gt; blanks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (table[i][j] != <span class="string">'.'</span>) {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> table[i][j] - <span class="string">'0'</span> - <span class="number">1</span>;</span><br><span class="line">                    va[i][x] = <span class="literal">true</span>;</span><br><span class="line">                    vb[j][x] = <span class="literal">true</span>;</span><br><span class="line">                    vc[i / <span class="number">3</span>][j / <span class="number">3</span>][x] = <span class="literal">true</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    blanks.add(<span class="keyword">new</span> <span class="title class_">Pair</span>(i, j));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        dfs(<span class="number">0</span>, blanks, table, va, vb, vc);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> p, List&lt;Pair&gt; blanks, <span class="type">char</span>[][] table, <span class="type">boolean</span>[][] va, <span class="type">boolean</span>[][] vb, <span class="type">boolean</span>[][][] vc)</span> {</span><br><span class="line">        <span class="keyword">if</span> (p == blanks.size()) {</span><br><span class="line">            print(table);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> table.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0</span>; d &lt; n; d++) {</span><br><span class="line">            <span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> blanks.get(p);</span><br><span class="line">            <span class="keyword">if</span> (va[pair.i][d] || vb[pair.j][d] || vc[pair.i / <span class="number">3</span>][pair.j / <span class="number">3</span>][d]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> (<span class="type">char</span>) (d + <span class="string">'0'</span> + <span class="number">1</span>);</span><br><span class="line">            table[pair.i][pair.j] = ch;</span><br><span class="line">            va[pair.i][d] = <span class="literal">true</span>;</span><br><span class="line">            vb[pair.j][d] = <span class="literal">true</span>;</span><br><span class="line">            vc[pair.i / <span class="number">3</span>][pair.j / <span class="number">3</span>][d] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">dfs</span> <span class="operator">=</span> dfs(p + <span class="number">1</span>, blanks, table, va, vb, vc);</span><br><span class="line">            <span class="keyword">if</span> (dfs) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            table[pair.i][pair.j] = <span class="string">'.'</span>;</span><br><span class="line">            va[pair.i][d] = <span class="literal">false</span>;</span><br><span class="line">            vb[pair.j][d] = <span class="literal">false</span>;</span><br><span class="line">            vc[pair.i / <span class="number">3</span>][pair.j / <span class="number">3</span>][d] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">char</span>[][] table = {</span><br><span class="line">                {<span class="string">'5'</span>, <span class="string">'3'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'7'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>},</span><br><span class="line">                {<span class="string">'6'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'1'</span>, <span class="string">'9'</span>, <span class="string">'5'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>},</span><br><span class="line">                {<span class="string">'.'</span>, <span class="string">'9'</span>, <span class="string">'8'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'6'</span>, <span class="string">'.'</span>},</span><br><span class="line">                {<span class="string">'8'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'6'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'3'</span>},</span><br><span class="line">                {<span class="string">'4'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'8'</span>, <span class="string">'.'</span>, <span class="string">'3'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'1'</span>},</span><br><span class="line">                {<span class="string">'7'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'2'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'6'</span>},</span><br><span class="line">                {<span class="string">'.'</span>, <span class="string">'6'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'2'</span>, <span class="string">'8'</span>, <span class="string">'.'</span>},</span><br><span class="line">                {<span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'4'</span>, <span class="string">'1'</span>, <span class="string">'9'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'5'</span>},</span><br><span class="line">                {<span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'8'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'7'</span>, <span class="string">'9'</span>}</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        solveSudoku(table);</span><br><span class="line"></span><br><span class="line">        print(table);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">char</span>[][] solved = {</span><br><span class="line">            {<span class="string">'5'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>},</span><br><span class="line">            {<span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'2'</span>, <span class="string">'1'</span>, <span class="string">'9'</span>, <span class="string">'5'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'8'</span>},</span><br><span class="line">            {<span class="string">'1'</span>, <span class="string">'9'</span>, <span class="string">'8'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'2'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>},</span><br><span class="line">            {<span class="string">'8'</span>, <span class="string">'5'</span>, <span class="string">'9'</span>, <span class="string">'7'</span>, <span class="string">'6'</span>, <span class="string">'1'</span>, <span class="string">'4'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>},</span><br><span class="line">            {<span class="string">'4'</span>, <span class="string">'2'</span>, <span class="string">'6'</span>, <span class="string">'8'</span>, <span class="string">'5'</span>, <span class="string">'3'</span>, <span class="string">'7'</span>, <span class="string">'9'</span>, <span class="string">'1'</span>},</span><br><span class="line">            {<span class="string">'7'</span>, <span class="string">'1'</span>, <span class="string">'3'</span>, <span class="string">'9'</span>, <span class="string">'2'</span>, <span class="string">'4'</span>, <span class="string">'8'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>},</span><br><span class="line">            {<span class="string">'9'</span>, <span class="string">'6'</span>, <span class="string">'1'</span>, <span class="string">'5'</span>, <span class="string">'3'</span>, <span class="string">'7'</span>, <span class="string">'2'</span>, <span class="string">'8'</span>, <span class="string">'4'</span>},</span><br><span class="line">            {<span class="string">'2'</span>, <span class="string">'8'</span>, <span class="string">'7'</span>, <span class="string">'4'</span>, <span class="string">'1'</span>, <span class="string">'9'</span>, <span class="string">'6'</span>, <span class="string">'3'</span>, <span class="string">'5'</span>},</span><br><span class="line">            {<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'2'</span>, <span class="string">'8'</span>, <span class="string">'6'</span>, <span class="string">'1'</span>, <span class="string">'7'</span>, <span class="string">'9'</span>}</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span>[][] table)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] chars : table) {</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(chars));</span><br><span class="line">        }</span><br><span class="line">        System.out.println(Arrays.deepEquals(table, solved));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SudokuLeetcode37</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] table)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">        <span class="type">boolean</span>[][] va = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="type">boolean</span>[][] vb = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="type">boolean</span>[][][] vc = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">3</span>][<span class="number">3</span>][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (table[i][j] != <span class="string">'.'</span>) {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> table[i][j] - <span class="string">'0'</span> - <span class="number">1</span>;</span><br><span class="line">                    va[i][x] = <span class="literal">true</span>;</span><br><span class="line">                    vb[j][x] = <span class="literal">true</span>;</span><br><span class="line">                    vc[i / <span class="number">3</span>][j / <span class="number">3</span>][x] = <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        dfs(table, va, vb, vc, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] table, <span class="type">boolean</span>[][] va, <span class="type">boolean</span>[][] vb, <span class="type">boolean</span>[][][] vc, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="keyword">while</span> (table[i][j] != <span class="string">'.'</span>) {</span><br><span class="line">            <span class="keyword">if</span> (++j &gt;= <span class="number">9</span>) {</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">9</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> table.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0</span>; d &lt; n; d++) {</span><br><span class="line">            <span class="keyword">if</span> (va[i][d] || vb[j][d] || vc[i / <span class="number">3</span>][j / <span class="number">3</span>][d]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> (<span class="type">char</span>) (d + <span class="string">'0'</span> + <span class="number">1</span>);</span><br><span class="line">            table[i][j] = ch;</span><br><span class="line">            va[i][d] = <span class="literal">true</span>;</span><br><span class="line">            vb[j][d] = <span class="literal">true</span>;</span><br><span class="line">            vc[i / <span class="number">3</span>][j / <span class="number">3</span>][d] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">dfs</span> <span class="operator">=</span> dfs(table, va, vb, vc, i, j);</span><br><span class="line">            <span class="keyword">if</span> (dfs) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            table[i][j] = <span class="string">'.'</span>;</span><br><span class="line">            va[i][d] = <span class="literal">false</span>;</span><br><span class="line">            vb[j][d] = <span class="literal">false</span>;</span><br><span class="line">            vc[i / <span class="number">3</span>][j / <span class="number">3</span>][d] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">char</span>[][] table = {</span><br><span class="line">                {<span class="string">'5'</span>, <span class="string">'3'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'7'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>},</span><br><span class="line">                {<span class="string">'6'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'1'</span>, <span class="string">'9'</span>, <span class="string">'5'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>},</span><br><span class="line">                {<span class="string">'.'</span>, <span class="string">'9'</span>, <span class="string">'8'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'6'</span>, <span class="string">'.'</span>},</span><br><span class="line">                {<span class="string">'8'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'6'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'3'</span>},</span><br><span class="line">                {<span class="string">'4'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'8'</span>, <span class="string">'.'</span>, <span class="string">'3'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'1'</span>},</span><br><span class="line">                {<span class="string">'7'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'2'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'6'</span>},</span><br><span class="line">                {<span class="string">'.'</span>, <span class="string">'6'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'2'</span>, <span class="string">'8'</span>, <span class="string">'.'</span>},</span><br><span class="line">                {<span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'4'</span>, <span class="string">'1'</span>, <span class="string">'9'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'5'</span>},</span><br><span class="line">                {<span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'8'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'7'</span>, <span class="string">'9'</span>}</span><br><span class="line">        };</span><br><span class="line">        solveSudoku(table);</span><br><span class="line"></span><br><span class="line">        print(table);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">char</span>[][] solved = {</span><br><span class="line">            {<span class="string">'5'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>},</span><br><span class="line">            {<span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'2'</span>, <span class="string">'1'</span>, <span class="string">'9'</span>, <span class="string">'5'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'8'</span>},</span><br><span class="line">            {<span class="string">'1'</span>, <span class="string">'9'</span>, <span class="string">'8'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'2'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>},</span><br><span class="line">            {<span class="string">'8'</span>, <span class="string">'5'</span>, <span class="string">'9'</span>, <span class="string">'7'</span>, <span class="string">'6'</span>, <span class="string">'1'</span>, <span class="string">'4'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>},</span><br><span class="line">            {<span class="string">'4'</span>, <span class="string">'2'</span>, <span class="string">'6'</span>, <span class="string">'8'</span>, <span class="string">'5'</span>, <span class="string">'3'</span>, <span class="string">'7'</span>, <span class="string">'9'</span>, <span class="string">'1'</span>},</span><br><span class="line">            {<span class="string">'7'</span>, <span class="string">'1'</span>, <span class="string">'3'</span>, <span class="string">'9'</span>, <span class="string">'2'</span>, <span class="string">'4'</span>, <span class="string">'8'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>},</span><br><span class="line">            {<span class="string">'9'</span>, <span class="string">'6'</span>, <span class="string">'1'</span>, <span class="string">'5'</span>, <span class="string">'3'</span>, <span class="string">'7'</span>, <span class="string">'2'</span>, <span class="string">'8'</span>, <span class="string">'4'</span>},</span><br><span class="line">            {<span class="string">'2'</span>, <span class="string">'8'</span>, <span class="string">'7'</span>, <span class="string">'4'</span>, <span class="string">'1'</span>, <span class="string">'9'</span>, <span class="string">'6'</span>, <span class="string">'3'</span>, <span class="string">'5'</span>},</span><br><span class="line">            {<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'2'</span>, <span class="string">'8'</span>, <span class="string">'6'</span>, <span class="string">'1'</span>, <span class="string">'7'</span>, <span class="string">'9'</span>}</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span>[][] table)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] chars : table) {</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(chars));</span><br><span class="line">        }</span><br><span class="line">        System.out.println(Arrays.deepEquals(table, solved));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="其它题目-4">其它题目</h3><table><colgroup><col style="width: 11%"><col style="width: 33%"><col style="width: 54%"></colgroup><thead><tr class="header"><th>题号</th><th>标题</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>Leetcode 1219</td><td>黄金矿工</td><td></td></tr><tr class="even"><td>无</td><td>马踏棋盘（The Knight’s tour problem）</td><td></td></tr><tr class="odd"><td>无</td><td>Rat in a Maze</td><td>与 Leetcode 62不同路径区别在于，该题问的是有多少种走法，而本题只是找到其中一种走法实现</td></tr></tbody></table><h2 id="leetcode-双指针">4.6 Leetcode 双指针</h2><p>下面是的题目都会涉及双指针，除此外，还有</p><ul><li>Leetcode3 最长不重复子串，在 hash 表部分讲过了</li><li>快排中</li><li>二分中</li><li>...</li></ul><h3 id="移动零-leetcode-283">移动零-Leetcode 283</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoveZeroesLeetcode283</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; nums.length) {</span><br><span class="line">            <span class="keyword">if</span> (nums[j] != <span class="number">0</span>) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = t;</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] nums = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">12</span>};</span><br><span class="line">        moveZeroes(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="两数之和-ii-leetcode-167">两数之和 II-Leetcode 167</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SumLeetcode167</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(Arrays.toString(twoSum(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>}, <span class="number">9</span>)));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) {</span><br><span class="line">        <span class="keyword">return</span> twoSum(numbers, <span class="number">0</span>, numbers.length - <span class="number">1</span>, target);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] &lt; target) {</span><br><span class="line">                i++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] &gt; target) {</span><br><span class="line">                j--;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]{i + <span class="number">1</span>, j + <span class="number">1</span>};</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>与 Leetcode 1 的两数之和区别在于，本题的数组是升序排好的</p><h3 id="三数之和-leetcode-15">三数之和-Leetcode 15</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SumLeetcode15</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">3</span>, <span class="number">0</span>, nums.length - <span class="number">1</span>, <span class="number">0</span>, nums,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> target, <span class="type">int</span>[] nums,</span></span><br><span class="line"><span class="params">                    LinkedList&lt;Integer&gt; stack,</span></span><br><span class="line"><span class="params">                    List&lt;List&lt;Integer&gt;&gt; result)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) {</span><br><span class="line">            <span class="comment">// 套用两数之和求解</span></span><br><span class="line">            twoSum(i, j, nums, target, stack, result);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i; k &lt; j - (n - <span class="number">2</span>); k++) {</span><br><span class="line">            <span class="comment">// 检查重复</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; i &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 固定一个数字，再尝试 n-1 数字之和</span></span><br><span class="line">            stack.push(nums[k]);</span><br><span class="line">            dfs(n - <span class="number">1</span>, k + <span class="number">1</span>, j, target - nums[k], nums, stack, result);</span><br><span class="line">            stack.pop();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] numbers, <span class="type">int</span> target,</span></span><br><span class="line"><span class="params">                              LinkedList&lt;Integer&gt; stack,</span></span><br><span class="line"><span class="params">                              List&lt;List&lt;Integer&gt;&gt; result)</span> {</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers[i] + numbers[j];</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target) {</span><br><span class="line">                i++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) {</span><br><span class="line">                j--;</span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 找到解</span></span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack);</span><br><span class="line">                list.add(numbers[i]);</span><br><span class="line">                list.add(numbers[j]);</span><br><span class="line">                result.add(list);</span><br><span class="line">                <span class="comment">// 继续查找其它的解</span></span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; numbers[i] == numbers[i - <span class="number">1</span>]) {</span><br><span class="line">                    i++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; numbers[j] == numbers[j + <span class="number">1</span>]) {</span><br><span class="line">                    j--;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">int</span>[] candidates = {-<span class="number">4</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>};</span><br><span class="line">        System.out.println(<span class="string">"数据量:"</span> + candidates.length);</span><br><span class="line">        System.out.println(threeSum(candidates));</span><br><span class="line">        System.out.println(<span class="string">"耗费时间:"</span> + (System.currentTimeMillis() - start));</span><br><span class="line">        System.out.println(<span class="string">"递归次数:"</span> + count);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>本题与之前的两数之和（Leetcode 1 和 Leetcode 167）相比，区别在于<ul><li>两数之和里明确说了，只有一个答案，而本题要找出所有答案</li><li>本题要考虑去重</li></ul></li><li>本题类似于 组合总和 II（Leetcode 40） 区别在于<ul><li>40 题要求列出任意数之和等于 target的所有组合，而本题要求三数之和等于 target 的所有组合</li><li>40 题使用回溯的办法时间复杂度是 <span class="math inline">\(O(2^n *n)\)</span>，而本题的三数限制了递归次数仅有一次，并且每次递归终点是求两数之和时间复杂度为<span class="math inline">\(O(n)\)</span>，因此总时间复杂度为 <span class="math inline">\(O(n^2)\)</span></li></ul></li><li>小优化：固定数字时，应该预留三个数字做三数之和，预览两个数字做两数之和，因此有k &lt; j - (n - 2)</li></ul><h3 id="四数之和-leetcode-18">四数之和-Leetcode 18</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SumLeetcode18</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">4</span>, <span class="number">0</span>, nums.length - <span class="number">1</span>, target, nums,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> target, <span class="type">int</span>[] nums,</span></span><br><span class="line"><span class="params">                    LinkedList&lt;Integer&gt; stack,</span></span><br><span class="line"><span class="params">                    List&lt;List&lt;Integer&gt;&gt; result)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) {</span><br><span class="line">            <span class="comment">// 套用两数之和求解</span></span><br><span class="line">            twoSum(i, j, nums, target, stack, result);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i; k &lt; j - (n - <span class="number">2</span>); k++) { <span class="comment">// 四数之和 i &lt;j-2  三数之和 i &lt;j-1</span></span><br><span class="line">            <span class="comment">// 检查重复</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; i &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 固定一个数字，再尝试 n-1 数字之和</span></span><br><span class="line">            stack.push(nums[k]);</span><br><span class="line">            dfs(n - <span class="number">1</span>, k + <span class="number">1</span>, j, target - nums[k], nums, stack, result);</span><br><span class="line">            stack.pop();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] numbers, <span class="type">int</span> target,</span></span><br><span class="line"><span class="params">                              LinkedList&lt;Integer&gt; stack,</span></span><br><span class="line"><span class="params">                              List&lt;List&lt;Integer&gt;&gt; result)</span> {</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers[i] + numbers[j];</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target) {</span><br><span class="line">                i++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) {</span><br><span class="line">                j--;</span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 找到解</span></span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack);</span><br><span class="line">                list.add(numbers[i]);</span><br><span class="line">                list.add(numbers[j]);</span><br><span class="line">                result.add(list);</span><br><span class="line">                <span class="comment">// 继续查找其它的解</span></span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; numbers[i] == numbers[i - <span class="number">1</span>]) {</span><br><span class="line">                    i++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; numbers[j] == numbers[j + <span class="number">1</span>]) {</span><br><span class="line">                    j--;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(fourSum(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">2</span>, <span class="number">2</span>}, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//        System.out.println(fourSum(new int[]{2, 2, 2, 2, 2}, 8));</span></span><br><span class="line"><span class="comment">//        System.out.println(fourSum(new int[]{1000000000,1000000000,1000000000,1000000000}, -294967296));</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="盛最多水的容器-leetcode-11">盛最多水的容器-Leetcode 11</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MostWaterLeetcode11</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.min(height[i], height[j]);</span><br><span class="line">            max = Integer.max(max, (j - i) * min);</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; height[i] &lt;= min) {</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; height[j] &lt;= min) {</span><br><span class="line">                j--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(maxArea(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>})); <span class="comment">// 49</span></span><br><span class="line">        System.out.println(maxArea(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">2</span>,<span class="number">1</span>})); <span class="comment">// 1</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="反转字符数组-leetcode-344">反转字符数组-Leetcode 344</h3><p>双指针</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReverseStringLeetcode344</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">char</span>[] array = <span class="string">"abcde"</span>.toCharArray();</span><br><span class="line">        reverseString(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> {</span><br><span class="line">        recursion(s, <span class="number">0</span>, s.length - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recursion</span><span class="params">(<span class="type">char</span>[] array, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        swap(array, i, j);</span><br><span class="line">        recursion(array, ++i, --j);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] array, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = c;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>第一次交换的是 array[0] 和 array[4]</li><li>第二次交换的是 array[1] 和 array[3]</li><li>第三次 i = j = 2，开始返回</li><li>如果 array.length 是偶数，则会在 i &gt; j 时返回</li></ul><h2 id="leetcode-单调队列和栈">4.7 Leetcode 单调队列和栈</h2><h3 id="单调递减队列">单调递减队列</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonotonicStack</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;T&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T t)</span> {</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().compareTo(t) &lt; <span class="number">0</span>) {</span><br><span class="line">            stack.pop();</span><br><span class="line">        }</span><br><span class="line">        stack.push(t);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        stack.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> stack.toString();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        MonotonicStack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">MonotonicStack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : <span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>}) {</span><br><span class="line">            stack.push(i);</span><br><span class="line">            System.out.println(stack);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="最大滑动窗口-leetcode-239">最大滑动窗口-Leetcode 239</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlidingWindowMaximumLeetcode239</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) {</span><br><span class="line">        MonotonicQueue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">MonotonicQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] output = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - (k - <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k &amp;&amp; nums[i - k] == q.peek()) {</span><br><span class="line">                q.poll();</span><br><span class="line">            }</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            q.offer(num);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) {</span><br><span class="line">                output[i - (k - <span class="number">1</span>)] = q.peek();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(Arrays.toString(maxSlidingWindow(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>}, <span class="number">3</span>))); <span class="comment">//[3, 3, 5, 5, 6, 7]</span></span><br><span class="line">        System.out.println(Arrays.toString(maxSlidingWindow(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>}, <span class="number">2</span>))); <span class="comment">// [7, 4]</span></span><br><span class="line">        System.out.println(Arrays.toString(maxSlidingWindow(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">5</span>}, <span class="number">3</span>))); <span class="comment">// [3, 3, 2, 5]</span></span><br><span class="line">        System.out.println(Arrays.toString(maxSlidingWindow(<span class="keyword">new</span> <span class="title class_">int</span>[]{-<span class="number">7</span>, -<span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">0</span>}, <span class="number">4</span>))); <span class="comment">// [7, 7, 7, 7, 7]</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果每移动一次窗口，就在 k 个数里找最大值，时间复杂度约为 <span class="math inline">\(O(n*k)\)</span></li><li>利用了单调队列后，每个元素都最多<strong>入队</strong>、<strong>出队</strong>一次，找最大值就在队头找，时间复杂度为<span class="math inline">\(O(n)\)</span></li></ul><h3 id="单调递减栈">单调递减栈</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonotonicStack</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ValueAndIndex</span> {</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ValueAndIndex</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> i)</span> {</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.i = i;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line"><span class="comment">//            return "[%d]%d".formatted(index, value);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"%d"</span>.formatted(value);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;ValueAndIndex&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> i, TriConsumer onPop)</span> {</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().value &lt; value) {</span><br><span class="line">            <span class="type">ValueAndIndex</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="type">ValueAndIndex</span> <span class="variable">peek</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (peek != <span class="literal">null</span>) {</span><br><span class="line">                onPop.accept(pop.value, peek.value, peek.i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        stack.push(<span class="keyword">new</span> <span class="title class_">ValueAndIndex</span>(value, i));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> stack.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="接雨水-leetcode-42">接雨水-Leetcode 42</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrappingRainWaterLeetcode42</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(trap(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>})); <span class="comment">// 6</span></span><br><span class="line">        System.out.println(trap(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>})); <span class="comment">// 9</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">record</span> <span class="title class_">Data</span><span class="params">(<span class="type">int</span> height, <span class="type">int</span> i)</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] heights)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;Data&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; heights.length; i++) {</span><br><span class="line">            <span class="type">Data</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>(heights[i], i);</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().height &lt; heights[i]) {</span><br><span class="line">                <span class="type">Data</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">Data</span> <span class="variable">left</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">                <span class="keyword">if</span> (left != <span class="literal">null</span>) {</span><br><span class="line">                    sum += (Integer.min(left.height, right.height) - pop.height) * (right.i - left.i - <span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            stack.push(right);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>维护一个单调栈</li><li>当加入新柱子（right）时，如果发现要弹出之前的柱子，表示遇到了凹陷的地方<ul><li>此时栈里没有更左边的柱子，表示拦不住雨水</li><li>栈里有左边柱子（left）就可以计算雨水容量：<span class="math inline">\((right.i -left.i-1)*Min(right.height,left.height)-pop.height\)</span></li></ul></li></ul><h2 id="leetcode-字符串">4.8 Leetcode 字符串</h2><h3 id="indexof-leetcode-28">indexOf-Leetcode 28</h3><p>native string matching</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrStrLeetcode28</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> {</span><br><span class="line">        <span class="type">char</span>[] text = haystack.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] pattern = needle.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> text.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> pattern.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - m; i++) {</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; j++) {</span><br><span class="line">                <span class="keyword">if</span> (pattern[j] != text[i + j]) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (j == m) {</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(strStr(<span class="string">"aaacaaab"</span>, <span class="string">"aaab"</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>kmp string matching</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrStrLeetcode28KMP</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> {</span><br><span class="line">        <span class="type">char</span>[] text = haystack.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] pattern = needle.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> text.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> pattern.length;</span><br><span class="line">        <span class="type">int</span>[] lps = lps(pattern);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((n - i) &gt;= (m - j)) {</span><br><span class="line">            <span class="keyword">if</span> (text[i] == pattern[j]) { <span class="comment">// 匹配成功</span></span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (j != <span class="number">0</span>) { <span class="comment">// 匹配失败</span></span><br><span class="line">                j = lsp[j - <span class="number">1</span>];</span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 匹配失败 j == 0</span></span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (j == m) { <span class="comment">// 找到解</span></span><br><span class="line">                <span class="keyword">return</span> i - j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] lps(<span class="type">char</span>[] pattern) {</span><br><span class="line">        <span class="type">int</span>[] lps = <span class="keyword">new</span> <span class="title class_">int</span>[pattern.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 后缀</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 前缀 同时也是数量</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; pattern.length) {</span><br><span class="line">            <span class="keyword">if</span> (pattern[i] == pattern[j]) {</span><br><span class="line">                j++;</span><br><span class="line">                lps[i] = j;</span><br><span class="line">                i++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (j != <span class="number">0</span>) {</span><br><span class="line">                j = lps[j - <span class="number">1</span>];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> lps;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(strStr(<span class="string">"aaaaaaab"</span>, <span class="string">"aaab"</span>));</span><br><span class="line"><span class="comment">//        System.out.println(Arrays.toString(prefix("aaab".toCharArray())));</span></span><br><span class="line">        System.out.println(Arrays.toString(lsp(<span class="string">"ababaca"</span>.toCharArray())));</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>很多文章里<a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a>，把 lps 数组的向后平移一位，lps 用-1 填充，这个平移后的数组称为 next<ul><li>这样可以用 -1 代替 j == 0 的判断</li><li>并可以在 j &gt; 0 向前移动时，做少量优化（不用 next数组也能做同样优化）</li></ul></li><li>其它字符串匹配算法有：BM 算法、sunday 算法、Horspool 算法等</li></ul><h3 id="最长公共前缀-leetcode-14">最长公共前缀-Leetcode 14</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LCPLeetcode14</span> {</span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strings)</span> {</span><br><span class="line">        <span class="type">char</span>[] first = strings[<span class="number">0</span>].toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; first.length; i++) {</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> first[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; strings.length; j++) {</span><br><span class="line">                <span class="keyword">if</span> (i == strings[j].length() || ch != strings[j].charAt(i)) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(first, <span class="number">0</span>, i);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> strings[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(longestCommonPrefix(<span class="keyword">new</span> <span class="title class_">String</span>[]{<span class="string">"flower"</span>, <span class="string">"flow"</span>, <span class="string">"flight"</span>})); <span class="comment">// fl</span></span><br><span class="line">        System.out.println(longestCommonPrefix(<span class="keyword">new</span> <span class="title class_">String</span>[]{<span class="string">"dog"</span>,<span class="string">"racecar"</span>,<span class="string">"car"</span>})); <span class="comment">//</span></span><br><span class="line">        System.out.println(longestCommonPrefix(<span class="keyword">new</span> <span class="title class_">String</span>[]{<span class="string">"ab"</span>,<span class="string">"a"</span>})); <span class="comment">// a</span></span><br><span class="line">        System.out.println(longestCommonPrefix(<span class="keyword">new</span> <span class="title class_">String</span>[]{<span class="string">"dog"</span>,<span class="string">"dogaa"</span>,<span class="string">"dogbb"</span>})); <span class="comment">// dog</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="最长回文子串-leetcode-5">最长回文子串-Leetcode 5</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongestPalindromeLeetcode5</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(longestPalindrome(<span class="string">"babad"</span>));  <span class="comment">// bab</span></span><br><span class="line">        System.out.println(longestPalindrome(<span class="string">"cbbd"</span>)); <span class="comment">// bb</span></span><br><span class="line">        System.out.println(longestPalindrome(<span class="string">"a"</span>)); <span class="comment">// a</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">record</span> <span class="title class_">Result</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> length)</span> {</span><br><span class="line">        <span class="keyword">static</span> Result <span class="title function_">max</span><span class="params">(Result r1, Result r2, Result r3)</span> {</span><br><span class="line">            <span class="type">Result</span> <span class="variable">m</span> <span class="operator">=</span> r1;</span><br><span class="line">            <span class="keyword">if</span> (r2.length &gt; m.length) {</span><br><span class="line">                m = r2;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (r3.length &gt; m.length) {</span><br><span class="line">                m = r3;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="type">Result</span> <span class="variable">max</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="type">Result</span> <span class="variable">r1</span> <span class="operator">=</span> extend(chars, i, i);</span><br><span class="line">            <span class="type">Result</span> <span class="variable">r2</span> <span class="operator">=</span> extend(chars, i, i + <span class="number">1</span>);</span><br><span class="line">            max = Result.max(max, r1, r2);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars, max.i, max.length);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Result <span class="title function_">extend</span><span class="params">(<span class="type">char</span>[] chars, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> chars.length;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; len &amp;&amp; chars[i] == chars[j]) {</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(i, j - i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>还有时间复杂度更低的算法：Manacher</li></ul><h3 id="最小覆盖子串-leetcode-76">最小覆盖子串-Leetcode 76</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinWindowLeetcode76_2</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(minWindow(<span class="string">"ADOBECODEBANC"</span>, <span class="string">"ABC"</span>)); <span class="comment">// BANC</span></span><br><span class="line">        System.out.println(minWindow(<span class="string">"aaabbbbbcdd"</span>, <span class="string">"abcdd"</span>)); <span class="comment">// abbbbbcdd</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">record</span> <span class="title class_">Answer</span><span class="params">(<span class="type">int</span> count, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> {</span><br><span class="line">        <span class="type">char</span>[] source = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] target = t.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] targetCountMap = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="type">int</span>[] windowCountMap = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : target) {</span><br><span class="line">            targetCountMap[ch]++;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">Answer</span> <span class="variable">answer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Answer</span>(Integer.MAX_VALUE, i, j);</span><br><span class="line">        <span class="type">int</span> <span class="variable">passCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> count : targetCountMap) {</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">                passCount++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">pass</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; source.length) {</span><br><span class="line">            <span class="type">char</span> <span class="variable">right</span> <span class="operator">=</span> source[j];</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ++windowCountMap[right];</span><br><span class="line">            <span class="keyword">if</span> (c == targetCountMap[right]) {</span><br><span class="line">                pass++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span> (pass == passCount &amp;&amp; i &lt;= j) {</span><br><span class="line">                <span class="keyword">if</span> (j - i &lt; answer.count) {</span><br><span class="line">                    answer = <span class="keyword">new</span> <span class="title class_">Answer</span>(j - i, i, j);</span><br><span class="line">                }</span><br><span class="line">                <span class="type">char</span> <span class="variable">left</span> <span class="operator">=</span> source[i];</span><br><span class="line">                windowCountMap[left]--;</span><br><span class="line">                <span class="keyword">if</span> (windowCountMap[left] &lt; targetCountMap[left]) {</span><br><span class="line">                    pass--;</span><br><span class="line">                }</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer.count != Integer.MAX_VALUE ? s.substring(answer.i, answer.j + <span class="number">1</span>) : <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="leetcode-设计">4.9 Leetcode 设计</h2><h3 id="lru-缓存-leetcode-146">LRU 缓存-Leetcode 146</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCacheLeetcode146</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> {</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">            Node prev;</span><br><span class="line">            Node next;</span><br><span class="line">            <span class="type">int</span> key;</span><br><span class="line">            <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> {</span><br><span class="line">                <span class="built_in">this</span>.key = key;</span><br><span class="line">                <span class="built_in">this</span>.value = value;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DoublyLinkedList</span> {</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Node head;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Node tail;</span><br><span class="line"></span><br><span class="line">            DoublyLinkedList() {</span><br><span class="line">                head = tail = <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">                head.next = tail;</span><br><span class="line">                tail.prev = head;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(Node newFirst)</span> {</span><br><span class="line">                <span class="type">Node</span> <span class="variable">oldFirst</span> <span class="operator">=</span> head.next;</span><br><span class="line">                newFirst.prev = head;</span><br><span class="line">                newFirst.next = oldFirst;</span><br><span class="line">                head.next = newFirst;</span><br><span class="line">                oldFirst.prev = newFirst;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Node node)</span> {</span><br><span class="line">                <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> node.prev;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">                prev.next = next;</span><br><span class="line">                next.prev = prev;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Node <span class="title function_">removeLast</span><span class="params">()</span> {</span><br><span class="line">                <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">                remove(last);</span><br><span class="line">                <span class="keyword">return</span> last;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Integer, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">DoublyLinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoublyLinkedList</span>();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">            <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            linkedList.remove(node);</span><br><span class="line">            linkedList.addFirst(node);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> {</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(key)) {</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">                node.value = value;</span><br><span class="line">                linkedList.remove(node);</span><br><span class="line">                linkedList.addFirst(node);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">                map.put(key, node);</span><br><span class="line">                linkedList.addFirst(node);</span><br><span class="line">                <span class="keyword">if</span> (map.size() &gt; capacity) {</span><br><span class="line">                    <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> linkedList.removeLast();</span><br><span class="line">                    map.remove(last.key);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">LRUCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LRUCache</span>(<span class="number">2</span>);</span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(cache.get(<span class="number">1</span>)); <span class="comment">// 1</span></span><br><span class="line">        cache.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(cache.get(<span class="number">2</span>)); <span class="comment">// -1</span></span><br><span class="line">        cache.put(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(cache.get(<span class="number">1</span>)); <span class="comment">// -1</span></span><br><span class="line">        System.out.println(cache.get(<span class="number">3</span>)); <span class="comment">// 3</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意：</p><ul><li>这里很重要的一点是，map 中存储 node，可以省去在双向链表中查找 node的时间，这样让使用最近访问的节点移动到链表头时达到 <span class="math inline">\(O(1)\)</span> 的需求</li><li>同时我们应当意识到，node的引用不能修改了（不方便修改，真要改得同时改链表）<ul><li>例如，不能在更新时用新的 node 对象替换，而应该在原有的 node 上修改value</li></ul></li></ul><h3 id="lfu-缓存-leetcode-460">LFU 缓存-Leetcode 460</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LFUCacheLeetcode460</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LFUCache</span> {</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">            Node prev;</span><br><span class="line">            Node next;</span><br><span class="line">            <span class="type">int</span> key;</span><br><span class="line">            <span class="type">int</span> value;</span><br><span class="line">            <span class="type">int</span> freq;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> {</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value, <span class="type">int</span> freq)</span> {</span><br><span class="line">                <span class="built_in">this</span>.key = key;</span><br><span class="line">                <span class="built_in">this</span>.value = value;</span><br><span class="line">                <span class="built_in">this</span>.freq = freq;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DoublyLinkedList</span> {</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Node head;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Node tail;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">DoublyLinkedList</span><span class="params">()</span> {</span><br><span class="line">                head = tail = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">                head.next = tail;</span><br><span class="line">                tail.prev = head;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Node node)</span> {</span><br><span class="line">                <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> node.prev;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">                prev.next = next;</span><br><span class="line">                next.prev = prev;</span><br><span class="line">                node.prev = node.next = <span class="literal">null</span>;</span><br><span class="line">                size--;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(Node newFirst)</span> {</span><br><span class="line">                <span class="type">Node</span> <span class="variable">oldFirst</span> <span class="operator">=</span> head.next;</span><br><span class="line">                newFirst.prev = head;</span><br><span class="line">                newFirst.next = oldFirst;</span><br><span class="line">                head.next = newFirst;</span><br><span class="line">                oldFirst.prev = newFirst;</span><br><span class="line">                size++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Node <span class="title function_">removeLast</span><span class="params">()</span> {</span><br><span class="line">                <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">                remove(last);</span><br><span class="line">                <span class="keyword">return</span> last;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Integer, DoublyLinkedList&gt; freqMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Integer, Node&gt; kvMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> minFreq;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LFUCache</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">            <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> kvMap.get(key);</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="type">DoublyLinkedList</span> <span class="variable">list</span> <span class="operator">=</span> freqMap.get(node.freq);</span><br><span class="line">            list.remove(node);</span><br><span class="line">            <span class="keyword">if</span> (node.freq == minFreq &amp;&amp; list.isEmpty()) {</span><br><span class="line">                minFreq++;</span><br><span class="line">            }</span><br><span class="line">            node.freq++;</span><br><span class="line">            freqMap.computeIfAbsent(node.freq, k -&gt; <span class="keyword">new</span> <span class="title class_">DoublyLinkedList</span>()).addFirst(node);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> {</span><br><span class="line">            <span class="keyword">if</span> (kvMap.containsKey(key)) {</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> kvMap.get(key);</span><br><span class="line">                <span class="type">DoublyLinkedList</span> <span class="variable">list</span> <span class="operator">=</span> freqMap.get(node.freq);</span><br><span class="line">                list.remove(node);</span><br><span class="line">                <span class="keyword">if</span> (node.freq == minFreq &amp;&amp; list.isEmpty()) {</span><br><span class="line">                    minFreq++;</span><br><span class="line">                }</span><br><span class="line">                node.freq++;</span><br><span class="line">                node.value = value;</span><br><span class="line">                freqMap.computeIfAbsent(node.freq, k -&gt; <span class="keyword">new</span> <span class="title class_">DoublyLinkedList</span>()).addFirst(node);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (kvMap.size() == capacity) {</span><br><span class="line">                    <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> freqMap.get(minFreq).removeLast();</span><br><span class="line">                    kvMap.remove(last.key);</span><br><span class="line">                }</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value, <span class="number">1</span>);</span><br><span class="line">                kvMap.put(key, node);</span><br><span class="line">                minFreq = <span class="number">1</span>;</span><br><span class="line">                freqMap.computeIfAbsent(node.freq, k -&gt; <span class="keyword">new</span> <span class="title class_">DoublyLinkedList</span>()).addFirst(node);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">LFUCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LFUCache</span>(<span class="number">2</span>);</span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(cache.get(<span class="number">1</span>)); <span class="comment">// 1 freq=2</span></span><br><span class="line">        cache.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(cache.get(<span class="number">2</span>)); <span class="comment">// -1</span></span><br><span class="line">        System.out.println(cache.get(<span class="number">3</span>)); <span class="comment">// 3 freq=2</span></span><br><span class="line">        cache.put(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(cache.get(<span class="number">1</span>)); <span class="comment">// -1</span></span><br><span class="line">        System.out.println(cache.get(<span class="number">3</span>)); <span class="comment">// 3  freq=3</span></span><br><span class="line">        System.out.println(cache.get(<span class="number">4</span>)); <span class="comment">// 4  freq=2</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="随机数">随机数</h3><h4 id="线性同余发生器">线性同余发生器</h4><p>公式 <span class="math inline">\(nextSeed = (seed * a + c) \modm\)</span></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRandom</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> m;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> seed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRandom</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> c, <span class="type">int</span> m, <span class="type">int</span> seed)</span> {</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">        <span class="built_in">this</span>.m = m;</span><br><span class="line">        <span class="built_in">this</span>.seed = seed;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">return</span> <span class="variable">seed</span> <span class="operator">=</span> (a * seed + c) % m;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">MyRandom</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRandom</span>(<span class="number">7</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(IntStream.generate(r1::nextInt).limit(<span class="number">30</span>).toArray()));</span><br><span class="line">        <span class="type">MyRandom</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRandom</span>(<span class="number">7</span>, <span class="number">0</span>, Integer.MAX_VALUE, <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(IntStream.generate(r2::nextInt).limit(<span class="number">30</span>).toArray()));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>32 位随机数生成器</li><li>乘法会超过 int 范围导致随机性被破坏</li></ul><h4 id="java-版-1">java 版</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRandom2</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0x5DEECE66DL</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0xBL</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1L</span> &lt;&lt; <span class="number">48</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> seed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRandom2</span><span class="params">(<span class="type">long</span> seed)</span> {</span><br><span class="line">        <span class="built_in">this</span>.seed = (seed ^ a) &amp; (m - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> {</span><br><span class="line">        seed = (a * seed + c) &amp; (m - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ((<span class="type">int</span>) (seed &gt;&gt;&gt; <span class="number">16</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">MyRandom2</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRandom2</span>(<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(IntStream.generate(r1::nextInt).limit(<span class="number">10</span>).toArray()));</span><br><span class="line">        System.out.println(Arrays.toString(IntStream.generate(r2::nextInt).limit(<span class="number">10</span>).toArray()));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>0x5DEECE66DL * 0x5DEECE66DL 不会超过 long 的范围</li><li>m 决定只取 48 位随机数</li><li>对于 nextInt，只取 48 位随机数的高 32 位</li></ul><h3 id="跳表-leetcode-1206">跳表-Leetcode 1206</h3><h4 id="randomlevel">randomLevel</h4><p>设计一个方法调用若干次，每次返回 <em>1~max</em> 的数字，从 1开始，返回数字的比例减半，例如 <em>max = 4</em>，让大概</p><ul><li>50% 的几率返回 1</li><li>25% 的几率返回 2</li><li>12.5% 的几率返回 3</li><li>12.5% 的几率返回 4</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    第一轮有 500 个(level 1) &gt;= 0.5 退出循环，剩下 500 个(level 2)</span></span><br><span class="line"><span class="comment">    第二轮有 250 个(level 2) &gt;= 0.5 退出循环，剩下 125 个(level 3)</span></span><br><span class="line"><span class="comment">    第三轮有 63 个(level 3) &gt;= 0.5 退出循环，剩下 62 个(level 4) 由于第二个条件退出循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">randomLevel</span><span class="params">(<span class="type">int</span> max)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (Math.random() &lt; <span class="number">0.5</span> &amp;&amp; level &lt; max) {</span><br><span class="line">        level++;</span><br><span class="line">    }    </span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="跳表">跳表</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SkipListLeetcode1206</span> {</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> Skiplist.randomLevel();</span><br><span class="line">            map.compute(level, (k, v) -&gt; v == <span class="literal">null</span> ? <span class="number">1</span> : v + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(map.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, e -&gt; String.format(<span class="string">"%d%%"</span>, e.getValue() * <span class="number">100</span> / <span class="number">1000</span>))));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Skiplist</span> {</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">randomLevel</span><span class="params">()</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (Math.random() &lt; <span class="number">0.5</span> &amp;&amp; level &lt; MAX) {</span><br><span class="line">                level++;</span><br><span class="line">            }</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一轮有 500 个(level 1) &gt;= 0.5 退出循环，剩下 500 个(level 2)</span></span><br><span class="line"><span class="comment">            第二轮有 250 个(level 2) &gt;= 0.5 退出循环，剩下 125 个(level 3)</span></span><br><span class="line"><span class="comment">            第三轮有 63 个(level 3) &gt;= 0.5 退出循环，剩下 62 个(level 4) 由于第二个条件退出循环</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            <span class="keyword">return</span> level;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">            <span class="type">int</span> val;</span><br><span class="line">            Node[] next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">                <span class="built_in">this</span>.val = val;</span><br><span class="line">                <span class="built_in">this</span>.next = <span class="keyword">new</span> <span class="title class_">Node</span>[MAX];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Node[] find(<span class="type">int</span> val) {</span><br><span class="line">            Node[] path = <span class="keyword">new</span> <span class="title class_">Node</span>[MAX];</span><br><span class="line">            <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">lvl</span> <span class="operator">=</span> MAX - <span class="number">1</span>; lvl &gt;= <span class="number">0</span>; lvl--) {</span><br><span class="line">                <span class="keyword">while</span> (curr.next[lvl] != <span class="literal">null</span> &amp;&amp; curr.next[lvl].val &lt; val) {</span><br><span class="line">                    curr = curr.next[lvl];</span><br><span class="line">                }</span><br><span class="line">                path[lvl] = curr;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> path;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">            Node[] path = find(val);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> path[<span class="number">0</span>].next[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> node != <span class="literal">null</span> &amp;&amp; node.val == val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">            Node[] path = find(val);</span><br><span class="line">            <span class="type">int</span> <span class="variable">lv</span> <span class="operator">=</span> randomLevel();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lv; i++) {</span><br><span class="line">                node.next[i] = path[i].next[i];</span><br><span class="line">                path[i].next[i] = node;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">erase</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">            Node[] path = find(val);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> path[<span class="number">0</span>].next[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">null</span> || node.val != val) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX; i++) {</span><br><span class="line">                <span class="keyword">if</span> (path[i].next[i] != node) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                path[i].next[i] = node.next[i];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下楼梯规则</p><ul><li>若 next 指针为 null，或者 next 指向的节点值 &gt;= 目标，向下找</li><li>若 next 指针不为 null，且 next 指向的节点值 &lt; 目标，向右找</li></ul><p>节点的【高度】</p><ul><li>高度并不需要额外属性来记录，而是由之前节点 next ==本节点的个数来决定，或是本节点 next 数组长度</li><li>本实现选择了第一种方式来决定高度，本节点的 next 数组长度统一为MAX</li></ul><h3 id="最小栈-leetcode-155">最小栈-Leetcode 155</h3><p>解法1</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MinStack</span> {</span><br><span class="line">    LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; min = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> {</span><br><span class="line">        min.push(Integer.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">        stack.push(val);</span><br><span class="line">        min.push(Math.min(val, min.peek()));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        stack.pop();</span><br><span class="line">        min.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> min.peek();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解法2</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MinStack2</span> {</span><br><span class="line">    <span class="keyword">record</span> <span class="title class_">Data</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> min)</span> {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">final</span> LinkedList&lt;Data&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) {</span><br><span class="line">            stack.push(<span class="keyword">new</span> <span class="title class_">Data</span>(val, val));</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">Data</span> <span class="variable">peek</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            stack.push(<span class="keyword">new</span> <span class="title class_">Data</span>(val, Math.min(val, peek.min)));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        stack.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> stack.peek().val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> stack.peek().min;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="tinyurl-的加密与解密-leetcode-535">TinyURL 的加密与解密-Leetcode535</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TinyURLLeetcode535</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">/*CodecSequence codec = new CodecSequence();</span></span><br><span class="line"><span class="comment">        String encoded = codec.encode("https://leetcode.cn/problems/1");</span></span><br><span class="line"><span class="comment">        System.out.println(encoded);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        encoded = codec.encode("https://leetcode.cn/problems/2");</span></span><br><span class="line"><span class="comment">        System.out.println(encoded);*/</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt;= 62; i++) {</span></span><br><span class="line"><span class="comment">//            System.out.println(i + "\t" + CodecSequence.toBase62(i));</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line"></span><br><span class="line">        System.out.println(CodecSequence.toBase62(<span class="number">237849728</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        要让【长】【短】网址一一对应</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            1. 用【随机数】作为短网址标识</span></span><br><span class="line"><span class="comment">            2. 用【hash码】作为短网址标识</span></span><br><span class="line"><span class="comment">            3. 用【递增数】作为短网址标识</span></span><br><span class="line"><span class="comment">                1) 多线程下可以使用吗？</span></span><br><span class="line"><span class="comment">                2) 分布式下可以使用吗？</span></span><br><span class="line"><span class="comment">                3) 4e9iAk 是怎么生成的？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                a-z 0-9 A-Z  62进制的数字</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        十进制 =&gt; 十六进制</span></span><br><span class="line"><span class="comment">        31       1f</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        31 % 16 = 15</span></span><br><span class="line"><span class="comment">        31 / 16 = 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 % 16 = 1</span></span><br><span class="line"><span class="comment">        1 / 16 = 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        长网址： https://leetcode.cn/problems/encode-and-decode-tinyurl/description/</span></span><br><span class="line"><span class="comment">        对应的短网址： http://tinyurl.com/4e9iAk</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CodecSequence</span> {</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span>[] toBase62 = {</span><br><span class="line">                <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>, <span class="string">'H'</span>, <span class="string">'I'</span>, <span class="string">'J'</span>, <span class="string">'K'</span>, <span class="string">'L'</span>, <span class="string">'M'</span>,</span><br><span class="line">                <span class="string">'N'</span>, <span class="string">'O'</span>, <span class="string">'P'</span>, <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'S'</span>, <span class="string">'T'</span>, <span class="string">'U'</span>, <span class="string">'V'</span>, <span class="string">'W'</span>, <span class="string">'X'</span>, <span class="string">'Y'</span>, <span class="string">'Z'</span>,</span><br><span class="line">                <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>, <span class="string">'m'</span>,</span><br><span class="line">                <span class="string">'n'</span>, <span class="string">'o'</span>, <span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>, <span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>, <span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>,</span><br><span class="line">                <span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span></span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toBase62</span><span class="params">(<span class="type">int</span> number)</span> {</span><br><span class="line">            <span class="keyword">if</span> (number == <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">return</span> String.valueOf(toBase62[<span class="number">0</span>]);</span><br><span class="line">            }</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">while</span> (number &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> number % <span class="number">62</span>;</span><br><span class="line">                sb.append(toBase62[r]);</span><br><span class="line">                number = number / <span class="number">62</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; longToShort = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; shortToLong = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SHORT_PREFIX</span> <span class="operator">=</span> <span class="string">"http://tinyurl.com/"</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String longUrl)</span> {</span><br><span class="line">            <span class="type">String</span> <span class="variable">shortUrl</span> <span class="operator">=</span> longToShort.get(longUrl);</span><br><span class="line">            <span class="keyword">if</span> (shortUrl != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> shortUrl;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 生成短网址</span></span><br><span class="line">            shortUrl = SHORT_PREFIX + id;</span><br><span class="line">            longToShort.put(longUrl, shortUrl);</span><br><span class="line">            shortToLong.put(shortUrl, longUrl);</span><br><span class="line">            id++;</span><br><span class="line">            <span class="keyword">return</span> shortUrl;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">decode</span><span class="params">(String shortUrl)</span> {</span><br><span class="line">            <span class="keyword">return</span> shortToLong.get(shortUrl);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CodecHashCode</span> {</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; longToShort = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; shortToLong = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SHORT_PREFIX</span> <span class="operator">=</span> <span class="string">"http://tinyurl.com/"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String longUrl)</span> {</span><br><span class="line">            <span class="type">String</span> <span class="variable">shortUrl</span> <span class="operator">=</span> longToShort.get(longUrl);</span><br><span class="line">            <span class="keyword">if</span> (shortUrl != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> shortUrl;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 生成短网址</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> longUrl.hashCode(); <span class="comment">// int</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                shortUrl = SHORT_PREFIX + id;</span><br><span class="line">                <span class="keyword">if</span> (!shortToLong.containsKey(shortUrl)) {</span><br><span class="line">                    longToShort.put(longUrl, shortUrl);</span><br><span class="line">                    shortToLong.put(shortUrl, longUrl);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                id++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> shortUrl;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">decode</span><span class="params">(String shortUrl)</span> {</span><br><span class="line">            <span class="keyword">return</span> shortToLong.get(shortUrl);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CodecRandom</span> {</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; longToShort = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; shortToLong = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SHORT_PREFIX</span> <span class="operator">=</span> <span class="string">"http://tinyurl.com/"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String longUrl)</span> {</span><br><span class="line">            <span class="type">String</span> <span class="variable">shortUrl</span> <span class="operator">=</span> longToShort.get(longUrl);</span><br><span class="line">            <span class="keyword">if</span> (shortUrl != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> shortUrl;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 生成短网址</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt();<span class="comment">// 1</span></span><br><span class="line">                shortUrl = SHORT_PREFIX + id;</span><br><span class="line">                <span class="keyword">if</span> (!shortToLong.containsKey(shortUrl)) {</span><br><span class="line">                    longToShort.put(longUrl, shortUrl);</span><br><span class="line">                    shortToLong.put(shortUrl, longUrl);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> shortUrl;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">decode</span><span class="params">(String shortUrl)</span> {</span><br><span class="line">            <span class="keyword">return</span> shortToLong.get(shortUrl);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="设计-twitter-leetcode-355">设计 Twitter-Leetcode 355</h3><p>线性合并</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Twitter2</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Tweet</span> {</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        <span class="type">int</span> time;</span><br><span class="line">        Tweet next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Tweet</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> time, Tweet next)</span> {</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.time = time;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">time</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> time;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line">        Integer id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(Integer id)</span> {</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; followees = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Tweet</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tweet</span>(-<span class="number">1</span>, -<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, User&gt; userMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, User&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postTweet</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> tweetId)</span> {</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMap.computeIfAbsent(userId, User::<span class="keyword">new</span>);</span><br><span class="line">        user.head.next = <span class="keyword">new</span> <span class="title class_">Tweet</span>(tweetId, time++, user.head.next);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getNewsFeed</span><span class="params">(<span class="type">int</span> userId)</span> {</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMap.get(userId);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> List.of();</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Tweet</span> <span class="variable">p1</span> <span class="operator">=</span> user.head.next;</span><br><span class="line">        <span class="keyword">for</span> (Integer id : user.followees) {</span><br><span class="line">            p1 = merge(p1, userMap.get(id).head.next);</span><br><span class="line">        }</span><br><span class="line">        LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; count &lt; <span class="number">10</span>) {</span><br><span class="line">            result.addLast(p1.id);</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Tweet <span class="title function_">merge</span><span class="params">(Tweet p1, Tweet p2)</span> {</span><br><span class="line">        <span class="type">Tweet</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tweet</span>(-<span class="number">1</span>, -<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">Tweet</span> <span class="variable">p0</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span> &amp;&amp; count &lt; <span class="number">10</span>) {</span><br><span class="line">            <span class="keyword">if</span> (p1.time &gt; p2.time) {</span><br><span class="line">                p0.next = <span class="keyword">new</span> <span class="title class_">Tweet</span>(p1.id, p1.time, <span class="literal">null</span>);</span><br><span class="line">                p0 = p0.next;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                p0.next = <span class="keyword">new</span> <span class="title class_">Tweet</span>(p2.id, p2.time, <span class="literal">null</span>);</span><br><span class="line">                p0 = p0.next;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            }</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; count &lt; <span class="number">10</span>) {</span><br><span class="line">            p0.next = <span class="keyword">new</span> <span class="title class_">Tweet</span>(p1.id, p1.time, <span class="literal">null</span>);</span><br><span class="line">            p0 = p0.next;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="literal">null</span> &amp;&amp; count &lt; <span class="number">10</span>) {</span><br><span class="line">            p0.next = <span class="keyword">new</span> <span class="title class_">Tweet</span>(p2.id, p2.time, <span class="literal">null</span>);</span><br><span class="line">            p0 = p0.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">follow</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> followeeId)</span> {</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMap.computeIfAbsent(userId, User::<span class="keyword">new</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">followee</span> <span class="operator">=</span> userMap.computeIfAbsent(followeeId, User::<span class="keyword">new</span>);</span><br><span class="line">        user.followees.add(followeeId);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unfollow</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> followeeId)</span> {</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMap.get(userId);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) {</span><br><span class="line">            user.followees.remove(followeeId);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>优先级队列合并</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwitterLeetcode355</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Twitter</span> {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Tweet</span> {</span><br><span class="line">            <span class="type">int</span> id;</span><br><span class="line">            <span class="type">int</span> time;</span><br><span class="line">            Tweet next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Tweet</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> time, Tweet next)</span> {</span><br><span class="line">                <span class="built_in">this</span>.id = id;</span><br><span class="line">                <span class="built_in">this</span>.time = time;</span><br><span class="line">                <span class="built_in">this</span>.next = next;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> id;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTime</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> time;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line">            <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id)</span> {</span><br><span class="line">                <span class="built_in">this</span>.id = id;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Set&lt;Integer&gt; followees = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            <span class="type">Tweet</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tweet</span>(-<span class="number">1</span>, -<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, User&gt; userMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> time;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布文章</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postTweet</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> tweetId)</span> {</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMap.computeIfAbsent(userId, User::<span class="keyword">new</span>);</span><br><span class="line">            user.head.next = <span class="keyword">new</span> <span class="title class_">Tweet</span>(tweetId, time++, user.head.next);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新增关注</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">follow</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> followeeId)</span> {</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMap.computeIfAbsent(userId, User::<span class="keyword">new</span>);</span><br><span class="line">            <span class="type">User</span> <span class="variable">followee</span> <span class="operator">=</span> userMap.computeIfAbsent(followeeId, User::<span class="keyword">new</span>);</span><br><span class="line">            user.followees.add(followee.id);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消关注</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unfollow</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> followeeId)</span> {</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMap.get(userId);</span><br><span class="line">            <span class="keyword">if</span> (user != <span class="literal">null</span>) {</span><br><span class="line">                user.followees.remove(followeeId);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取最新10篇文章（包括自己和关注用户）</span></span><br><span class="line">        <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getNewsFeed</span><span class="params">(<span class="type">int</span> userId)</span> {</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMap.get(userId);</span><br><span class="line">            <span class="keyword">if</span> (user == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> List.of();</span><br><span class="line">            }</span><br><span class="line">            PriorityQueue&lt;Tweet&gt; queue</span><br><span class="line">                    = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(Tweet::getTime).reversed());</span><br><span class="line">            <span class="keyword">if</span>(user.head.next != <span class="literal">null</span>) {</span><br><span class="line">                queue.offer(user.head.next);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (Integer id : user.followees) {</span><br><span class="line">                <span class="type">User</span> <span class="variable">followee</span> <span class="operator">=</span> userMap.get(id);</span><br><span class="line">                <span class="keyword">if</span>(followee.head.next != <span class="literal">null</span>) {</span><br><span class="line">                    queue.offer(followee.head.next);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; count &lt; <span class="number">10</span>) {</span><br><span class="line">                <span class="type">Tweet</span> <span class="variable">max</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                res.add(max.id);</span><br><span class="line">                <span class="keyword">if</span> (max.next != <span class="literal">null</span>) {</span><br><span class="line">                    queue.offer(max.next);</span><br><span class="line">                }</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="股票问题">4.10 股票问题</h2><h3 id="leetcode-121">Leetcode 121</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharesI</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; prices.length) {</span><br><span class="line">            <span class="keyword">if</span> (prices[j] - prices[i] &gt; <span class="number">0</span>) {</span><br><span class="line">                max = Math.max(max, prices[j] - prices[i]);</span><br><span class="line">                j++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                i = j;</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(maxProfit(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">9</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">11</span>}));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="leetcode-122">Leetcode 122</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharesIILeetcode122</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; prices.length) {</span><br><span class="line">            <span class="keyword">if</span> (prices[j] - prices[i] &gt; <span class="number">0</span>) { <span class="comment">// 有利润</span></span><br><span class="line">                max += prices[j] - prices[i];</span><br><span class="line">            }</span><br><span class="line">            i = j;</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(maxProfit(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">9</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>})); <span class="comment">// 11</span></span><br><span class="line">        System.out.println(maxProfit(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>})); <span class="comment">// 7</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="leetcode-714">Leetcode 714</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharesLeetcode714</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        0       1           2           3           4       5</span></span><br><span class="line"><span class="comment">        1       3           2           8           4       9</span></span><br><span class="line"><span class="comment"> 买     -1     等-1 √       等-1 √       等-1 √      -1       等1 √</span></span><br><span class="line"><span class="comment">               买-3         买-2        买-8        买1 √     买-4</span></span><br><span class="line"><span class="comment"> 卖     0      等0  √        等0  √      等0          等5 √    等5</span></span><br><span class="line"><span class="comment">               卖0          卖-1         卖5 √        卖1     卖8 √</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">b1</span> <span class="operator">=</span> -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">s0</span> <span class="operator">=</span> Math.max(s1, b1 + prices[i] - fee);</span><br><span class="line">            <span class="type">int</span> <span class="variable">b0</span> <span class="operator">=</span> Math.max(b1, s1 - prices[i]);</span><br><span class="line">            s1 = s0;</span><br><span class="line">            b1 = b0;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(maxProfit(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>}, <span class="number">2</span>)); <span class="comment">// 8</span></span><br><span class="line">        System.out.println(maxProfit(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">18</span>, <span class="number">3</span>}, <span class="number">3</span>)); <span class="comment">// 16</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">        System.out.println(maxProfit(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">3</span>}, <span class="number">3</span>)); <span class="comment">// 6</span></span><br><span class="line">        System.out.println(maxProfit(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">3</span>}, <span class="number">3</span>)); <span class="comment">// 7</span></span><br><span class="line">        System.out.println(maxProfit(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>}, <span class="number">1</span>)); <span class="comment">// 4</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>降维</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> {</span><br><span class="line">    <span class="comment">// _buy _sell 代表上一次 buy sell 代表这一次</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">_buy</span> <span class="operator">=</span> -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">_sell</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">buy</span> <span class="operator">=</span> Math.max(_buy, _sell - prices[i]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sell</span> <span class="operator">=</span> Math.max(_sell, _buy + prices[i] - fee);</span><br><span class="line">        _buy = buy;</span><br><span class="line">        _sell = sell;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> _sell;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>结构优化（非性能）</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">buy</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sell</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> price : prices) {</span><br><span class="line">        buy = Math.max(buy, sell - price);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            若 max 是 上次 buy，那么显然用这次 buy 是一样的</span></span><br><span class="line"><span class="comment">            若 max 是 上次 sell - prices[i], 则</span></span><br><span class="line"><span class="comment">                Math.max(sell, sell - prices[i] + prices[i] - fee);</span></span><br><span class="line"><span class="comment">                ==&gt;</span></span><br><span class="line"><span class="comment">                Math.max(sell, sell - fee);</span></span><br><span class="line"><span class="comment">                显然后面的式子不可能比上次 sell 更大，此时新的 sell 只由上次 sell 决定，与 上次 buy 无关</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        sell = Math.max(sell, buy + price - fee);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sell;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol type="1"><li>在计算这次的 sell 时，用这次的 buy 代替上次buy（证明见上方注释）</li><li>设置 buy 的初始值为最小，可以让循环统一从 0 开始</li></ol><h3 id="leetcode-309">Leetcode 309</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharesLeetcode309</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        0       1           2           3           4</span></span><br><span class="line"><span class="comment">        1       2           3           0           2</span></span><br><span class="line"><span class="comment"> 买     -1      -2          -3          1√          0</span></span><br><span class="line"><span class="comment"> 等             -1√         -1√         -1          1√</span></span><br><span class="line"><span class="comment"> 卖     0       1√          2√          -1          3√</span></span><br><span class="line"><span class="comment"> 等             0           1           2√          2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> {</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[] buy = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length];</span><br><span class="line">        <span class="type">int</span>[] sell = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length];</span><br><span class="line">        buy[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        sell[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        buy[<span class="number">1</span>] = Math.max(-prices[<span class="number">0</span>], -prices[<span class="number">1</span>]);</span><br><span class="line">        sell[<span class="number">1</span>] = Math.max(sell[<span class="number">0</span>], buy[<span class="number">0</span>] + prices[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; prices.length; i++) {</span><br><span class="line">            buy[i] = Math.max(buy[i - <span class="number">1</span>], sell[i - <span class="number">2</span>] - prices[i]);</span><br><span class="line">            sell[i] = Math.max(sell[i - <span class="number">1</span>], buy[i - <span class="number">1</span>] + prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sell[prices.length - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(maxProfit(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>})); <span class="comment">// 3</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>降维</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> {</span><br><span class="line">    <span class="keyword">if</span> (prices.length == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">__sell</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">_sell</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">_buy</span> <span class="operator">=</span> -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">buy</span> <span class="operator">=</span> Math.max(_buy, __sell - prices[i]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sell</span> <span class="operator">=</span> Math.max(_sell, prices[i] + _buy);</span><br><span class="line">        _buy = buy;</span><br><span class="line">        __sell = _sell;</span><br><span class="line">        _sell = sell;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> _sell;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="leetcode-123">Leetcode 123</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharesIIILeetcode123</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">buy1</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sell1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">buy2</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sell2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price : prices) {</span><br><span class="line">            buy1 = Math.max(buy1, -price);</span><br><span class="line">            sell1 = Math.max(sell1, buy1 + price);</span><br><span class="line">            buy2 = Math.max(buy2, sell1 - price);</span><br><span class="line">            sell2 = Math.max(sell2, buy2 + price);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sell2;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(maxProfit(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>})); <span class="comment">// 6</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="leetcode-188">Leetcode 188</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharesLeetcode188</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; prices.length) {</span><br><span class="line">            <span class="keyword">if</span> (prices[j] - prices[i] &gt; <span class="number">0</span>) { <span class="comment">// 有利润</span></span><br><span class="line">                sum += prices[j] - prices[i];</span><br><span class="line">            }</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> {</span><br><span class="line">        <span class="keyword">if</span> (k &gt; prices.length / <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> maxProfit(prices);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[] buy = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span>[] sell = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        Arrays.fill(buy, Integer.MIN_VALUE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price : prices) {</span><br><span class="line">            buy[<span class="number">0</span>] = Math.max(buy[<span class="number">0</span>], -price);</span><br><span class="line">            sell[<span class="number">0</span>] = Math.max(sell[<span class="number">0</span>], buy[<span class="number">0</span>] + price);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; k; j++) {</span><br><span class="line">                buy[j] = Math.max(buy[j], sell[j - <span class="number">1</span>] - price);</span><br><span class="line">                sell[j] = Math.max(sell[j], buy[j] + price);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sell[k - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="comment">//        System.out.println(maxProfit(2, new int[]{3, 2, 6, 5, 0, 3})); // 7</span></span><br><span class="line">        System.out.println(maxProfit(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>})); <span class="comment">// 6</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>对于天数 n = 6，最多进行 3 次交易，如果此时 k &gt;3，意味着不限次交易</p></li><li><p>对于天数 n = 7，最多进行 3 次交易，如果此时 k &gt;3，意味着不限次交易</p></li></ul><h1 id="附录">附录</h1><h2 id="参考文章">参考文章</h2><p>注：以上内容来自网络资源，仅出于分享目的，若侵权请联系删除。</p><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="https://www.merriam-webster.com/dictionary/algorithm">"Definitionof ALGORITHM"</a>. <em>Merriam-Webster Online Dictionary</em>. <a href="https://web.archive.org/web/20200214074446/https://www.merriam-webster.com/dictionary/algorithm">Archived</a>from the original on February 14, 2020. Retrieved November 14, 2019.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p>Introduction to Algorithm 中文译作《算法导论》<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p>Introduction to Algorithm 中文译作《算法导论》<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p>主要参考文档https://en.wikipedia.org/wiki/Binary_search_algorithm<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn5"><p>图片及概念均摘自 Introduction to Algorithm4th，3.1节，3.2 节<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn6"><p>jdk 版本有关，64 位 jdk，按 8 字节对齐<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn7"><p>图片引用自 wikipedia linkedlist条目，https://en.wikipedia.org/wiki/Linked_list<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn8"><p>龟兔赛跑动画来自于 <a href="https://onestepcode.com/floyd-hare-tortoise-algorithm-demo/">Floyd'sHare and Tortoise Algorithm Demo - One Step! Code(onestepcode.com)</a><a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn9"><p>Josephus problem 主要参考https://en.wikipedia.org/wiki/Josephus_problem<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn10"><p>Fibonacci介绍：https://en.wikipedia.org/wiki/Fibonacci_number<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn11"><p><a href="https://zhuanlan.zhihu.com/p/165877869">几种计算Fibonacci数列算法的时间复杂度比较- 知乎 (zhihu.com)</a><a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn12"><p>几种斐波那契数列算法比较 <a href="https://www.nayuki.io/page/fast-fibonacci-algorithms">FastFibonacci algorithms (nayuki.io)</a><a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn13"><p>Fibonacci介绍：https://en.wikipedia.org/wiki/Fibonacci_number<a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn14"><p>汉诺塔图片资料均来自https://en.wikipedia.org/wiki/Tower_of_Hanoi<a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn15"><p>也称为 Pascal's trianglehttps://en.wikipedia.org/wiki/Pascal%27s_triangle<a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn16"><p>我知道的有 C++，Scala<a href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn17"><p>与主定理类似的还有 Akra–Bazzimethod，https://en.wikipedia.org/wiki/Akra%E2%80%93Bazzi_method<a href="#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn18"><p>KMP 算法中 next 数组的说明 <a href="https://www.cnblogs.com/tangzhengyue/p/4315393.html">KMP算法的Next数组详解- 唐小喵 - 博客园 (cnblogs.com)</a><a href="#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三节 三重积分</title>
      <link href="/2024/03/25/duo-yuan-wei-ji-fen-10-3-san-chong-ji-fen/"/>
      <url>/2024/03/25/duo-yuan-wei-ji-fen-10-3-san-chong-ji-fen/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/i3ucW1sjrjhc">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分10-3三重积分/123.jpg" alt="123.jpg"><figcaption aria-hidden="true">123.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分10-3三重积分/124.jpg" alt="124.jpg"><figcaption aria-hidden="true">124.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分10-3三重积分/125.jpg" alt="125.jpg"><figcaption aria-hidden="true">125.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分10-3三重积分/126.jpg" alt="126.jpg"><figcaption aria-hidden="true">126.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分10-3三重积分/127.jpg" alt="127.jpg"><figcaption aria-hidden="true">127.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分10-3三重积分/128.jpg" alt="128.jpg"><figcaption aria-hidden="true">128.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分10-3三重积分/129.jpg" alt="129.jpg"><figcaption aria-hidden="true">129.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分10-3三重积分/130.jpg" alt="130.jpg"><figcaption aria-hidden="true">130.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十章 重积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三重积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四节 重积分的应用</title>
      <link href="/2024/03/25/duo-yuan-wei-ji-fen-10-4-chong-ji-fen-de-ying-yong/"/>
      <url>/2024/03/25/duo-yuan-wei-ji-fen-10-4-chong-ji-fen-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iWMgk1sjtepc">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分10-4重积分的应用/131.jpg" alt="131.jpg"><figcaption aria-hidden="true">131.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分10-4重积分的应用/132.jpg" alt="132.jpg"><figcaption aria-hidden="true">132.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分10-4重积分的应用/133.jpg" alt="133.jpg"><figcaption aria-hidden="true">133.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分10-4重积分的应用/134.jpg" alt="134.jpg"><figcaption aria-hidden="true">134.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分10-4重积分的应用/135.jpg" alt="135.jpg"><figcaption aria-hidden="true">135.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分10-4重积分的应用/136.jpg" alt="136.jpg"><figcaption aria-hidden="true">136.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十章 重积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多重积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT Deep Learning Bootcamp_ Phillip Isola</title>
      <link href="/2024/03/24/mit-deep-learning-bootcamp-phillip-isola/"/>
      <url>/2024/03/24/mit-deep-learning-bootcamp-phillip-isola/</url>
      
        <content type="html"><![CDATA[<h1 id="deep-learning-bootcamp_-phillip-isola">Deep Learning Bootcamp_Phillip Isola</h1><p>MIT Deep Learning Bootcamp，上半场为PhillipIsola主讲，下半场为KaimingHe主讲。目前只大概校准了前30分钟的翻译，后面的翻译还在制作当中。</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=1952115963&amp;bvid=BV1LC41187hj&amp;cid=1481029257&amp;p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
          <category> 深度学习简介 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 什么是深度学习 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六节 空间曲线及其方程</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-8-6-kong-jian-qu-xian-ji-qi-fang-cheng/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-8-6-kong-jian-qu-xian-ji-qi-fang-cheng/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/i8VrV1sim23a">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分8-6空间曲线及其方程/30.jpg" alt="30.jpg"><figcaption aria-hidden="true">30.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-6空间曲线及其方程/31.jpg" alt="31.jpg"><figcaption aria-hidden="true">31.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-6空间曲线及其方程/32.jpg" alt="32.jpg"><figcaption aria-hidden="true">32.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-6空间曲线及其方程/33.jpg" alt="33.jpg"><figcaption aria-hidden="true">33.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-6空间曲线及其方程/34.jpg" alt="34.jpg"><figcaption aria-hidden="true">34.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第八章 向量代数与空间解析几何 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 空间曲线方程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四节 空间直线及其方程</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-8-4-kong-jian-zhi-xian-ji-qi-fang-cheng/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-8-4-kong-jian-zhi-xian-ji-qi-fang-cheng/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/ii9JG1sikwxi">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分8-4空间直线及其方程/17.jpg" alt="17.jpg"><figcaption aria-hidden="true">17.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-4空间直线及其方程/18.jpg" alt="18.jpg"><figcaption aria-hidden="true">18.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-4空间直线及其方程/19.jpg" alt="19.jpg"><figcaption aria-hidden="true">19.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-4空间直线及其方程/20.jpg" alt="20.jpg"><figcaption aria-hidden="true">20.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-4空间直线及其方程/21.jpg" alt="21.jpg"><figcaption aria-hidden="true">21.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-4空间直线及其方程/22.jpg" alt="22.jpg"><figcaption aria-hidden="true">22.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第八章 向量代数与空间解析几何 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 空间直线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五节 曲面及其方程</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-8-5-qu-mian-ji-qi-fang-cheng/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-8-5-qu-mian-ji-qi-fang-cheng/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iHag01silrne">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分8-5曲面及其方程/23.jpg" alt="23.jpg"><figcaption aria-hidden="true">23.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-5曲面及其方程/24.jpg" alt="24.jpg"><figcaption aria-hidden="true">24.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-5曲面及其方程/25.jpg" alt="25.jpg"><figcaption aria-hidden="true">25.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-5曲面及其方程/26.jpg" alt="26.jpg"><figcaption aria-hidden="true">26.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-5曲面及其方程/27.jpg" alt="27.jpg"><figcaption aria-hidden="true">27.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-5曲面及其方程/28.jpg" alt="28.jpg"><figcaption aria-hidden="true">28.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-5曲面及其方程/29.jpg" alt="29.jpg"><figcaption aria-hidden="true">29.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第八章 向量代数与空间解析几何 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 曲面方程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二节 数量积 向量积 混合积</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-8-2-shu-liang-ji-xiang-liang-ji-hun-he-ji/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-8-2-shu-liang-ji-xiang-liang-ji-hun-he-ji/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iMNku1sifsmd">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分8-2数量积-向量积-混合积/8.jpg" alt="8.jpg"><figcaption aria-hidden="true">8.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-2数量积-向量积-混合积/9.jpg" alt="9.jpg"><figcaption aria-hidden="true">9.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-2数量积-向量积-混合积/10.jpg" alt="10.jpg"><figcaption aria-hidden="true">10.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-2数量积-向量积-混合积/11.jpg" alt="11.jpg"><figcaption aria-hidden="true">11.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-2数量积-向量积-混合积/12.jpg" alt="12.jpg"><figcaption aria-hidden="true">12.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第八章 向量代数与空间解析几何 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数量积 </tag>
            
            <tag> 向量积 </tag>
            
            <tag> 混合积 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三节 平面及其方程</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-8-3-ping-mian-ji-qi-fang-cheng/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-8-3-ping-mian-ji-qi-fang-cheng/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iTTwt1siju6d">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分8-3平面及其方程/13.jpg" alt="13.jpg"><figcaption aria-hidden="true">13.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-3平面及其方程/14.jpg" alt="14.jpg"><figcaption aria-hidden="true">14.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-3平面及其方程/15.jpg" alt="15.jpg"><figcaption aria-hidden="true">15.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-3平面及其方程/16.jpg" alt="16.jpg"><figcaption aria-hidden="true">16.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第八章 向量代数与空间解析几何 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 平面方程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三节 全微分</title>
      <link href="/2024/03/24/duo-yuan-han-shu-quan-wei-fen/"/>
      <url>/2024/03/24/duo-yuan-han-shu-quan-wei-fen/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/i3HEa1si7b1c">下载PDF点这里</a></p><figure><img src="../../../../images/多元函数全微分/52.jpg" alt="52.jpg"><figcaption aria-hidden="true">52.jpg</figcaption></figure><figure><img src="../../../../images/多元函数全微分/53.jpg" alt="53.jpg"><figcaption aria-hidden="true">53.jpg</figcaption></figure><figure><img src="../../../../images/多元函数全微分/54.jpg" alt="54.jpg"><figcaption aria-hidden="true">54.jpg</figcaption></figure><figure><img src="../../../../images/多元函数全微分/55.jpg" alt="55.jpg"><figcaption aria-hidden="true">55.jpg</figcaption></figure><figure><img src="../../../../images/多元函数全微分/56.jpg" alt="56.jpg"><figcaption aria-hidden="true">56.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第九章 多元函数微分法及其应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 全微分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一节 向量及其线性运算</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-8-1-xiang-liang-ji-qi-xian-xing-yun-suan/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-8-1-xiang-liang-ji-qi-xian-xing-yun-suan/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/ifa1T1siexkf">下载PDF点这里</a></p><figure><img src="../../../../images/8-1向量及其线性运算/4.jpg" alt="4.jpg"><figcaption aria-hidden="true">4.jpg</figcaption></figure><figure><img src="../../../../images/8-1向量及其线性运算/5.jpg" alt="5.jpg"><figcaption aria-hidden="true">5.jpg</figcaption></figure><figure><img src="../../../../images/8-1向量及其线性运算/6.jpg" alt="6.jpg"><figcaption aria-hidden="true">6.jpg</figcaption></figure><figure><img src="../../../../images/8-1向量及其线性运算/7.jpg" alt="7.jpg"><figcaption aria-hidden="true">7.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第八章 向量代数与空间解析几何 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 向量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六节 多元函数微分学的几何应用</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-duo-yuan-han-shu-wei-fen-xue-de-ji-he-ying-yong/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-duo-yuan-han-shu-wei-fen-xue-de-ji-he-ying-yong/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/ixMOv1si9tgh">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分多元函数微分学的几何应用/71.jpg" alt="71.jpg"><figcaption aria-hidden="true">71.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数微分学的几何应用/72.jpg" alt="72.jpg"><figcaption aria-hidden="true">72.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数微分学的几何应用/73.jpg" alt="73.jpg"><figcaption aria-hidden="true">73.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数微分学的几何应用/74.jpg" alt="74.jpg"><figcaption aria-hidden="true">74.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数微分学的几何应用/75.jpg" alt="75.jpg"><figcaption aria-hidden="true">75.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数微分学的几何应用/76.jpg" alt="76.jpg"><figcaption aria-hidden="true">76.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数微分学的几何应用/77.jpg" alt="77.jpg"><figcaption aria-hidden="true">77.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数微分学的几何应用/78.jpg" alt="78.jpg"><figcaption aria-hidden="true">78.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数微分学的几何应用/79.jpg" alt="79.jpg"><figcaption aria-hidden="true">79.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数微分学的几何应用/80.jpg" alt="80.jpg"><figcaption aria-hidden="true">80.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第九章 多元函数微分法及其应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多元函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八节 多元函数的极值及其求法</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-duo-yuan-han-shu-de-ji-zhi-ji-qi-qiu-fa/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-duo-yuan-han-shu-de-ji-zhi-ji-qi-qiu-fa/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/ieDhy1sibm9a">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分多元函数的极值及其求法/88.jpg" alt="88.jpg"><figcaption aria-hidden="true">88.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数的极值及其求法/89.jpg" alt="89.jpg"><figcaption aria-hidden="true">89.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数的极值及其求法/90.jpg" alt="90.jpg"><figcaption aria-hidden="true">90.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数的极值及其求法/91.jpg" alt="91.jpg"><figcaption aria-hidden="true">91.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数的极值及其求法/92.jpg" alt="92.jpg"><figcaption aria-hidden="true">92.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数的极值及其求法/93.jpg" alt="93.jpg"><figcaption aria-hidden="true">93.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数的极值及其求法/94.jpg" alt="94.jpg"><figcaption aria-hidden="true">94.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第九章 多元函数微分法及其应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多元函数的极值 </tag>
            
            <tag> 拉格朗日乘数法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七节 方向导数与梯度</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-fang-xiang-dao-shu-yu-ti-du/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-fang-xiang-dao-shu-yu-ti-du/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iAKOX1siaqaj">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分方向导数与梯度/81.jpg" alt="81.jpg"><figcaption aria-hidden="true">81.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分方向导数与梯度/82.jpg" alt="82.jpg"><figcaption aria-hidden="true">82.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分方向导数与梯度/83.jpg" alt="83.jpg"><figcaption aria-hidden="true">83.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分方向导数与梯度/84.jpg" alt="84.jpg"><figcaption aria-hidden="true">84.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分方向导数与梯度/85.jpg" alt="85.jpg"><figcaption aria-hidden="true">85.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分方向导数与梯度/86.jpg" alt="86.jpg"><figcaption aria-hidden="true">86.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分方向导数与梯度/87.jpg" alt="87.jpg"><figcaption aria-hidden="true">87.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第九章 多元函数微分法及其应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方向导数 </tag>
            
            <tag> 梯度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四节 多元复合函数的求导法则</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-duo-yuan-fu-he-han-shu-de-qiu-dao-fa-ze/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-duo-yuan-fu-he-han-shu-de-qiu-dao-fa-ze/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/i5lYU1si86if">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分多元复合函数的求导法则/57.jpg" alt="57.jpg"><figcaption aria-hidden="true">57.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元复合函数的求导法则/58.jpg" alt="58.jpg"><figcaption aria-hidden="true">58.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元复合函数的求导法则/59.jpg" alt="59.jpg"><figcaption aria-hidden="true">59.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元复合函数的求导法则/60.jpg" alt="60.jpg"><figcaption aria-hidden="true">60.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元复合函数的求导法则/61.jpg" alt="61.jpg"><figcaption aria-hidden="true">61.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元复合函数的求导法则/62.jpg" alt="62.jpg"><figcaption aria-hidden="true">62.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元复合函数的求导法则/63.jpg" alt="63.jpg"><figcaption aria-hidden="true">63.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第九章 多元函数微分法及其应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复合函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五节 隐函数的求导公式</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-yin-han-shu-de-qiu-dao-gong-shi/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-yin-han-shu-de-qiu-dao-gong-shi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/imvmj1si8o8d">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分隐函数的求导公式/64.jpg" alt="64.jpg"><figcaption aria-hidden="true">64.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分隐函数的求导公式/65.jpg" alt="65.jpg"><figcaption aria-hidden="true">65.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分隐函数的求导公式/66.jpg" alt="66.jpg"><figcaption aria-hidden="true">66.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分隐函数的求导公式/67.jpg" alt="67.jpg"><figcaption aria-hidden="true">67.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分隐函数的求导公式/68.jpg" alt="68.jpg"><figcaption aria-hidden="true">68.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分隐函数的求导公式/69.jpg" alt="69.jpg"><figcaption aria-hidden="true">69.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分隐函数的求导公式/70.jpg" alt="70.jpg"><figcaption aria-hidden="true">70.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第九章 多元函数微分法及其应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一节 二重积分的概念与性质</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-er-chong-ji-fen-de-gai-nian-yu-xing-zhi/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-er-chong-ji-fen-de-gai-nian-yu-xing-zhi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iAUeM1sgbz3a">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分二重积分的概念与性质/p105.jpg" alt="p105.jpg"><figcaption aria-hidden="true">p105.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的概念与性质/p106.jpg" alt="p106.jpg"><figcaption aria-hidden="true">p106.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的概念与性质/p107.jpg" alt="p107.jpg"><figcaption aria-hidden="true">p107.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的概念与性质/p108.jpg" alt="p108.jpg"><figcaption aria-hidden="true">p108.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十章 重积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二重积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二节 二重积分的计算方法</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-er-chong-ji-fen-de-ji-suan-fang-fa/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-er-chong-ji-fen-de-ji-suan-fang-fa/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/inVBC1sgdp3c">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分二重积分的计算方法/109.jpg" alt="109.jpg"><figcaption aria-hidden="true">109.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/110.jpg" alt="110.jpg"><figcaption aria-hidden="true">110.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/111.jpg" alt="111.jpg"><figcaption aria-hidden="true">111.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/112.jpg" alt="112.jpg"><figcaption aria-hidden="true">112.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/113.jpg" alt="113.jpg"><figcaption aria-hidden="true">113.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/114.jpg" alt="114.jpg"><figcaption aria-hidden="true">114.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/115.jpg" alt="115.jpg"><figcaption aria-hidden="true">115.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/116.jpg" alt="116.jpg"><figcaption aria-hidden="true">116.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/117.jpg" alt="117.jpg"><figcaption aria-hidden="true">117.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/118.jpg" alt="118.jpg"><figcaption aria-hidden="true">118.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/119.jpg" alt="119.jpg"><figcaption aria-hidden="true">119.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/120.jpg" alt="120.jpg"><figcaption aria-hidden="true">120.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/121.jpg" alt="121.jpg"><figcaption aria-hidden="true">121.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/122.jpg" alt="122.jpg"><figcaption aria-hidden="true">122.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十章 重积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二重积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>凸集和凸函数基础知识</title>
      <link href="/2024/03/20/tu-you-hua-tu-ji-he-tu-han-shu/"/>
      <url>/2024/03/20/tu-you-hua-tu-ji-he-tu-han-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="凸集和凸函数">凸集和凸函数</h1><p><strong>今天是春分，春分快乐~</strong></p><p>​ <span class="math inline">\(——\)</span>谁把春光，平分一半，最惜今朝。</p><h2 id="凸集">1. 凸集</h2><h3 id="凸集的定义">1.1 凸集的定义</h3><p>设集合 <span class="math inline">\(\boldsymbol{D} \subset\mathbb{R}^n\)</span> ，如果对于任意的 <span class="math inline">\(\boldsymbol{x}, \boldsymbol{y} \in\boldsymbol{D}\)</span> 与任意的 <span class="math inline">\(\alpha\in[0,1]\)</span>,有 <span class="math inline">\(\alpha\boldsymbol{x}+(1-\alpha) \boldsymbol{y} \in \boldsymbol{D}\)</span>，则称 <span class="math inline">\(\boldsymbol{D}\)</span> 是凸集（<span class="math inline">\(convex \quad set\)</span>）。</p><p>凸集的几何意义是：如果两个点属于此集合，则这两点连线上的任意一点均属于此集合。</p><hr><p>定义推广：<span class="math inline">\(\boldsymbol{D}\)</span>是凸集的充分必要条件是：</p><p>对任意<span class="math inline">\(\forall m \geqslant 2, \forall\boldsymbol{x}_1, \boldsymbol{x}_2, \cdots, \boldsymbol{x}_m \in\boldsymbol{D}, \forall \alpha_1, \alpha_2, \cdots, \alpha_m\)</span>，其中 <span class="math inline">\(\alpha_i \geqslant 0\)</span> <span class="math inline">\((i=1,2,\cdots,m)\)</span> 且 <span class="math inline">\(\sum_{i=1}^m \alpha_i = 1\)</span> ，均有： <span class="math display">\[\alpha_1 \boldsymbol{x}_1+\alpha_2 \boldsymbol{x}_2+\cdots+\alpha_m\boldsymbol{x}_m \in \boldsymbol{D}\]</span></p><h3 id="凸集的性质">1.2 凸集的性质</h3><p>设 <span class="math inline">\(\boldsymbol{D}_1, \boldsymbol{D}_2\subset \mathbb{R}^n\)</span> 是凸集， <span class="math inline">\(\alpha \in \mathbb{R}\)</span> ，则有：</p><ul><li><span class="math inline">\(\boldsymbol{D}_1 \cap\boldsymbol{D}_2=\left\{\boldsymbol{x} \mid \boldsymbol{x} \in\boldsymbol{D}_1, \boldsymbol{x} \in \boldsymbol{D}_2\right\}\)</span>是凸集。</li><li><span class="math inline">\(\alpha \boldsymbol{D}_1=\left\{\alpha\boldsymbol{x} \mid \boldsymbol{x} \in \boldsymbol{D}_1\right\}\)</span>是凸集。</li><li><span class="math inline">\(\boldsymbol{D}_1+\boldsymbol{D}_2=\left\{\boldsymbol{x}+\boldsymbol{y}\mid \boldsymbol{x} \in \boldsymbol{D}_1, \boldsymbol{y} \in\boldsymbol{D}_2\right\}\)</span> 是凸集。</li><li><span class="math inline">\(\boldsymbol{D}_1-\boldsymbol{D}_2=\left\{\boldsymbol{x}-\boldsymbol{y}\mid \boldsymbol{x} \in \boldsymbol{D}_1, \boldsymbol{y} \in\boldsymbol{D}_2\right\}\)</span> 是凸集。</li></ul><p>注意：这里要明确一点凸集的加减法和集合中的加减法完全是两件事情，比如说即使<span class="math inline">\(\boldsymbol{D}_1=\boldsymbol{D}_2\)</span>，那么 <span class="math inline">\(\boldsymbol{D}_1-\boldsymbol{D}_2\neq \varnothing\)</span> ，甚至结果的测度要比原来的 <span class="math inline">\(\boldsymbol{D}_1\)</span>更大。给出其中一个性质的证明有利于更好地理解凸集加减法的运算：</p><blockquote><p>证明：设 <span class="math inline">\(\boldsymbol{D}_1,\boldsymbol{D}_2 \subset \mathbb{R}^n\)</span> 是凸集，则 <span class="math inline">\(\boldsymbol{D}_1 +\boldsymbol{D}_2=\left\{\boldsymbol{x}+\boldsymbol{y} \mid\boldsymbol{x} \in \boldsymbol{D}_1, \boldsymbol{y} \in\boldsymbol{D}_2\right\}\)</span> 也是凸集。</p><p>不妨设：$_1 + _2 = $ ，任取 <span class="math inline">\(\boldsymbol{z}\in \boldsymbol{Z},\boldsymbol{z}'\in \boldsymbol{Z}\)</span> ，则有： <span class="math display">\[\boldsymbol{x} + \boldsymbol{y} = \boldsymbol{z},\boldsymbol{x}' +\boldsymbol{y}' = \boldsymbol{z}'\]</span> 其中 <span class="math inline">\(\boldsymbol{x},\boldsymbol{x}'\in \boldsymbol{D_1};\boldsymbol{y},\boldsymbol{y}' \in \boldsymbol{D_2}\)</span></p><p>所以对于任意 <span class="math inline">\(\alpha \in [0,1]\)</span>有：<span class="math inline">\(\alpha\boldsymbol{z} +(1-\alpha)\boldsymbol{z'} =\alpha(\boldsymbol{x}+\boldsymbol{y})+(1-\alpha)(\boldsymbol{x'}+\boldsymbol{y'})=\alpha\boldsymbol{x}+(1-\alpha)\boldsymbol{x'}+\alpha\boldsymbol{y}+(1-\alpha)\boldsymbol{y'}\)</span></p><p>而 <span class="math inline">\(\alpha\boldsymbol{x}+(1-\alpha)\boldsymbol{x'}\in\boldsymbol{D_1}\)</span> ， <span class="math inline">\(\alpha\boldsymbol{y}+(1-\alpha)\boldsymbol{y'}\in\boldsymbol{D_2}\)</span>。</p><p>所以：<span class="math inline">\(\alpha\boldsymbol{z}+(1-\alpha)\boldsymbol{z'}\in\boldsymbol{D_1} + \boldsymbol{D_2} = \boldsymbol{Z}\)</span> 。</p></blockquote><h3 id="内点边界闭包">1.3 内点、边界、闭包</h3><p>内点：给定 <span class="math inline">\(\boldsymbol{D} \subset\mathbb{R}^n, \boldsymbol{x} \in \mathbb{R}^n\)</span> 。若存在 <span class="math inline">\(\boldsymbol{x}\)</span> 的 <span class="math inline">\(\delta\)</span> 邻域 <span class="math inline">\(N_\delta(\boldsymbol{x})=\{\boldsymbol{y}\mid\|\boldsymbol{y}-\boldsymbol{x}\|&lt;\delta\} \subset\)</span> <span class="math inline">\(D\)</span> ，则称 <span class="math inline">\(x\)</span> 为 <span class="math inline">\(D\)</span> 的内点; 所有内点组合成的集合记为 <span class="math inline">\(i n t D\)</span> 。</p><p>边界：若 <span class="math inline">\(\boldsymbol{x}\)</span> 的任意<span class="math inline">\(\delta\)</span> 邻域 <span class="math inline">\(N_\delta(\boldsymbol{x}\)</span> )既包含 <span class="math inline">\(\boldsymbol{D}\)</span> 中的点, 又包含不属于 <span class="math inline">\(\boldsymbol{D}\)</span> 的点, 则称 <span class="math inline">\(x\)</span> 为 <span class="math inline">\(D\)</span> 的边界点; 所有边界点组成的集合记为<span class="math inline">\(\partial \boldsymbol{D}\)</span> 。</p><p>闭包：若对任意 <span class="math inline">\(\delta&gt;0\)</span> 均有<span class="math inline">\(N_\delta(\boldsymbol{x}) \cap \boldsymbol{D}\neq \varnothing\)</span>, 则称 <span class="math inline">\(\boldsymbol{x}\)</span> 属于集合的闭包, 记为 <span class="math inline">\(x \in c l D\)</span>​ 。</p><hr><p>根据以上定义可知，集合 <span class="math inline">\(\boldsymbol{D}\)</span> 的闭包 <span class="math inline">\(c \boldsymbol{D}=\boldsymbol{D} \cup \partial\boldsymbol{D}\)</span>, 它是包含集合 <span class="math inline">\(\boldsymbol{D}\)</span> 的最小的闭集。</p><h2 id="投影定理">2. 投影定理</h2><blockquote><p>设 <span class="math inline">\(\boldsymbol{D} \subset\mathbb{R}^n\)</span> 是非空闭凸集, <span class="math inline">\(\boldsymbol{y} \in \mathbb{R}^n\)</span> 且 <span class="math inline">\(\boldsymbol{y} \notin \boldsymbol{D}\)</span>, 则(1) 存在唯一的一点 <span class="math inline">\(\overline{\boldsymbol{x}}\in D\)</span>, 使得 <span class="math inline">\(\overline{\boldsymbol{x}} \in D\)</span> 是 <span class="math inline">\(\boldsymbol{y}\)</span> 到 <span class="math inline">\(D\)</span> 的距离最小的点（距离大于 0 ），即有 ：<span class="math display">\[\|\overline{\boldsymbol{x}}-\boldsymbol{y}\|=\min\{\|\boldsymbol{x}-\boldsymbol{y}\| \mid \boldsymbol{x} \in\boldsymbol{D}\}&gt;0\]</span> (2) <span class="math inline">\(\overline{\boldsymbol{x}} \in\boldsymbol{D}\)</span> 是 <span class="math inline">\(\boldsymbol{y}\)</span> 到 <span class="math inline">\(\boldsymbol{D}\)</span> 的距离最小的点的充要条件是<span class="math inline">\((\boldsymbol{x}-\overline{\boldsymbol{x}})^T(\overline{\boldsymbol{x}}-\boldsymbol{y})\geqslant\)</span> <span class="math inline">\(0, \forall \boldsymbol{x}\in \boldsymbol{D}\)</span></p></blockquote><h2 id="凸集的分离定理">3. 凸集的分离定理</h2><p>先回顾一下什么是超平面(Hyperplane)，超平面指的是比所处空间少一个维度的子空间。超平面<span class="math inline">\(H\)</span>的方程如下： <span class="math display">\[H=\left\{\boldsymbol{x} \in \mathbb{R}^n: \boldsymbol{u}^T\boldsymbol{x}=v\right\}\]</span> 也可以写成：在超平面<span class="math inline">\(H\)</span>内一点 <span class="math inline">\(\boldsymbol{a}\)</span> 和任一点 <span class="math inline">\(\boldsymbol{x}\)</span>。 <span class="math inline">\(\boldsymbol{u}\)</span> 为点 <span class="math inline">\(\boldsymbol{x}\)</span> 处的法向量，将满足 <span class="math inline">\(\boldsymbol{u^T}(\boldsymbol{x}-\boldsymbol{a})=0\)</span>​于是有： <span class="math display">\[H=\left\{\boldsymbol{x} \in \mathbb{R}^n\right. :\left.\boldsymbol{u^T}(\boldsymbol{x}-\boldsymbol{a})=0\right\}\]</span> 若 <span class="math inline">\(\boldsymbol{u}^T\boldsymbol{x}\geq v\)</span> 则表明点 <span class="math inline">\(\boldsymbol{x}\)</span> 在超平面<span class="math inline">\(H\)</span>的正面，若<span class="math inline">\(\boldsymbol{u}^T \boldsymbol{x}\leq v\)</span>则表明点 <span class="math inline">\(\boldsymbol{x}\)</span> 在超平面<span class="math inline">\(H\)</span> 的背面。</p><p>现在再给定两个集合 <span class="math inline">\(S_1\)</span> ，<span class="math inline">\(S_2\)</span>，</p><p>如果 <span class="math inline">\(\boldsymbol{u}^T\boldsymbol{x_1}\geq v\)</span> ，<span class="math inline">\(\forall\boldsymbol{x_1} \in S_1\)</span> ； <span class="math inline">\(\boldsymbol{u}^T \boldsymbol{x_1}\leq v\)</span>，<span class="math inline">\(\forall \boldsymbol{x_2} \in S_2\)</span>,则称 <span class="math inline">\(H\)</span> 分离 <span class="math inline">\(S_1\)</span> 和 <span class="math inline">\(S_2\)</span>。如下图所示：</p><figure><img src="../../../../images/最优化方法凸集和凸函数/p2.jpg" alt="p2.jpg"><figcaption aria-hidden="true">p2.jpg</figcaption></figure><p>图中超平面<span class="math inline">\(H\)</span>的式子为<span class="math inline">\(\boldsymbol{u}^T \boldsymbol{x_1}=v\)</span>，集合<span class="math inline">\(S_1\)</span>中的任意点代入方程后都在正面(或面上)，集合<span class="math inline">\(S_2\)</span>中的任意点代入方程后都在背面(或面上)，所以超平面<span class="math inline">\(H\)</span>分离开了集合<span class="math inline">\(S1\)</span>和<span class="math inline">\(S_2\)</span>。</p><h3 id="点和凸集的分离定理基本分离定理">3.1点和凸集的分离定理(基本分离定理)</h3><blockquote><p><code>定理</code>设 <span class="math inline">\(\boldsymbol{D}\subset \mathbb{R}^n\)</span> 是非空闭凸集, <span class="math inline">\(\boldsymbol{y} \in \mathbb{R}^n, \boldsymbol{y}\notin \boldsymbol{D}\)</span>, 则存在非零向量 <span class="math inline">\(\boldsymbol{\alpha} \in \mathbb{R}^n, \beta \in\mathbb{R}\)</span> 满足 <span class="math inline">\(\boldsymbol{\alpha}^{\boldsymbol{T}}\boldsymbol{x} \leqslant \beta&lt;\boldsymbol{\alpha}^{\boldsymbol{T}}\boldsymbol{y}, \forall \boldsymbol{x} \in \boldsymbol{D}\)</span></p></blockquote><p>这个定理表明如果在空间<span class="math inline">\(\mathbb{R}^n\)</span>内存在一个凸集<span class="math inline">\(\boldsymbol{D}\)</span>，凸集外有一点<span class="math inline">\(\boldsymbol{y}\)</span>，那么可以找到一个超平面<span class="math inline">\(\boldsymbol{\alpha}^{\boldsymbol{T}}\boldsymbol{x}=\beta\)</span> 将凸集<span class="math inline">\(\boldsymbol{D}\)</span>和点<span class="math inline">\(\boldsymbol{y}\)</span>分离开。</p><blockquote><p>证明思路:</p><p>利用投影定理，在凸集中找到距离点$ $ 最近的点 <span class="math inline">\(\overline{\boldsymbol{x}}\)</span>，然后做切平面(极限情况)，即可分离。</p></blockquote><blockquote><p><code>推论1</code>设 <span class="math inline">\(\boldsymbol{D}\subset \mathbb{R}^n\)</span> 是非空凸集, <span class="math inline">\(\boldsymbol{y} \in \partial\boldsymbol{D}\)</span>, 则存在非零向量 <span class="math inline">\(\boldsymbol{\alpha} \in \mathbb{R}^n\)</span> 满足<span class="math inline">\(\boldsymbol{\alpha}^T \boldsymbol{x}\leqslant \boldsymbol{\alpha}^T \boldsymbol{y}, \forall \boldsymbol{x}\in c l \boldsymbol{D}\)</span></p></blockquote><blockquote><p><code>推论2</code>设 <span class="math inline">\(\boldsymbol{D}\subset \mathbb{R}^n\)</span> 是非空凸集, <span class="math inline">\(\boldsymbol{y} \notin \boldsymbol{D}\)</span>,则存在非零向量 <span class="math inline">\(\boldsymbol{\alpha} \in\mathbb{R}^n\)</span> 满足 <span class="math inline">\(\boldsymbol{\alpha}^T x \leqslant\boldsymbol{\alpha}^T \boldsymbol{y}, \forall \boldsymbol{x}\in c l\boldsymbol{D}\)</span></p><p><span class="math inline">\(c l\)</span> 是闭包, <span class="math inline">\(\partial\)</span> 是边界。</p></blockquote><h3 id="支撑超平面定理">3.2 支撑超平面定理</h3><blockquote><p><code>定理</code>设 <span class="math inline">\(\boldsymbol{D}\subset \mathbb{R}^n\)</span> 是非空凸集, <span class="math inline">\(\overline{\boldsymbol{x}} \in \partial\boldsymbol{D}\)</span>, 则存在非零向量 <span class="math inline">\(\boldsymbol{\alpha} \in \mathbb{R}^n\)</span>,使得 <span class="math inline">\(\boldsymbol{\alpha}^T \boldsymbol{x}\leqslant \boldsymbol{\alpha}^T \overline{\boldsymbol{x}}, \forall\boldsymbol{x} \in c l \boldsymbol{D}\)</span>; 此时也称超平面 <span class="math inline">\(\boldsymbol{H}=\left\{\boldsymbol{x} \in\mathbb{R}^n \mid \boldsymbol{\alpha}^T(\boldsymbol{x}-\overline{\boldsymbol{x}})=0\right\}\)</span> 为集合<span class="math inline">\(\boldsymbol{D}\)</span> 在 <span class="math inline">\(\overline{\boldsymbol{x}}\)</span>处的支撑超平面。</p><p><span class="math inline">\(c l\)</span> 是闭包, <span class="math inline">\(\partial\)</span> 是边界。</p></blockquote><p>从其他角度理解支撑超平面：</p><figure><img src="../../../../images/最优化方法凸集和凸函数/p1.jpg" alt="p1.jpg"><figcaption aria-hidden="true">p1.jpg</figcaption></figure><p>下图为一个示意图：</p><figure><img src="../../../../images/最优化方法凸集和凸函数/p3.jpg" alt="p3.jpg"><figcaption aria-hidden="true">p3.jpg</figcaption></figure><h3 id="支撑分离定理边界点与凸集的分离">3.3支撑分离定理(边界点与凸集的分离)</h3><blockquote><p><code>定理</code> 若 <span class="math inline">\(S\)</span> 为 <span class="math inline">\(\mathbb{R}^n\)</span> 中的非空凸集(不需要为闭集)，令 <span class="math inline">\(\overline{\boldsymbol{x}}\in \partial S\)</span> ，则存在过点 <span class="math inline">\(\overline{\boldsymbol{x}}\)</span> 的 <span class="math inline">\(S\)</span> 的支撑超平面。</p></blockquote><h3 id="凸集和凸集的分离定理超平面分离定理">3.4凸集和凸集的分离定理(超平面分离定理)</h3><blockquote><p><code>定理</code>设 <span class="math inline">\(\boldsymbol{D}_1,\boldsymbol{D}_2 \subset \mathbb{R}^n\)</span> 是非空凸集，且 <span class="math inline">\(\boldsymbol{D}_1 \cap\boldsymbol{D}_2=\varnothing\)</span> 则存在非零向量 <span class="math inline">\(\boldsymbol{\alpha}\)</span> 使得： <span class="math display">\[\inf \left\{\boldsymbol{\alpha}^T \boldsymbol{x} \mid \boldsymbol{x} \in\boldsymbol{D}_1\right\} \geqslant \sup \left\{\boldsymbol{\alpha}^T\boldsymbol{x} \mid \boldsymbol{x} \in \boldsymbol{D}_2\right\}\]</span> <span class="math inline">\(inf\)</span>表示下确界(infimum)，<span class="math inline">\(sup\)</span>表示上确界(supremum)</p></blockquote><p>这个定理表明如果在空间<span class="math inline">\(\mathbb{R}^n\)</span>内存在两个没有交集的凸集<span class="math inline">\(\boldsymbol{D_1}\)</span>和<span class="math inline">\(\boldsymbol{D_2}\)</span>，那么可以找到一个平面将这两个凸集分隔开。</p><blockquote><p>证明思路：</p><p>由于凸集没有交集，所以<span class="math inline">\(\boldsymbol{D_1}-\boldsymbol{D_2}\)</span>一定不包含<span class="math inline">\(\boldsymbol{0}\)</span>这个点，根据这个特殊的点利用点和凸集的分离定理即可证明。</p><p>证明: 令 <span class="math inline">\(\boldsymbol{D}^{\prime}=\boldsymbol{D_2}-\boldsymbol{D_1}=\left\{\boldsymbol{z}\mid \boldsymbol{z}=\boldsymbol{x_2}-\boldsymbol{x_1}, \boldsymbol{x_1}\in \boldsymbol{D_1}, \boldsymbol{x_2} \in\boldsymbol{D_2}\right\}\)</span>,由于 <span class="math inline">\(\boldsymbol{D}_1, \boldsymbol{D}_2\)</span> 非空,所以 <span class="math inline">\(\boldsymbol{D}^{\prime}\)</span> 非空,由于 <span class="math inline">\(\boldsymbol{D}_1 \cap\boldsymbol{D}_2=\varnothing\)</span>, 所以 <span class="math inline">\(\boldsymbol{0} \notin\boldsymbol{D}^{\prime}\)</span>, <span class="math inline">\(\boldsymbol{0} \in \partial\boldsymbol{D'}\)</span>，根据点与凸集的分离定理的推论可知存在非零向量<span class="math inline">\(\boldsymbol{\alpha}\)</span>, 使得对每一个<span class="math inline">\(\boldsymbol{z} \in\boldsymbol{D}^{\prime}\)</span> 都有 <span class="math inline">\(\boldsymbol{\alpha}^T(\boldsymbol{z}-\boldsymbol{0})= \boldsymbol{\alpha}^T\boldsymbol{z}\leqslant 0\)</span>, 即 <span class="math display">\[\boldsymbol{\alpha}^T \boldsymbol{x}_1 \geqslant \boldsymbol{\alpha}^T\boldsymbol{x}_2, \forall \boldsymbol{x}_1 \in \boldsymbol{D}_1,\boldsymbol{x}_2 \in \boldsymbol{D}_2\]</span></p></blockquote><h2 id="凸函数">4.凸函数</h2><h3 id="凸函数的定义">4.1 凸函数的定义</h3><p>设 <span class="math inline">\(\boldsymbol{D} \subset\mathbb{R}^n\)</span> 是非空凸集, <span class="math inline">\(f(\boldsymbol{x})\)</span> 是定义在 <span class="math inline">\(\boldsymbol{D}\)</span> 上的函数, 如果对任 意的<span class="math inline">\(\boldsymbol{x}_1, \boldsymbol{x}_2 \in\boldsymbol{D}, \alpha \in(0,1)\)</span> 都有 <span class="math inline">\(f\left(\alpha \boldsymbol{x}_1+(1-\alpha)\boldsymbol{x}_2\right) \leqslant\)</span> <span class="math inline">\(\alpha f\left(\boldsymbol{x}_1\right)+(1-\alpha)f\left(\boldsymbol{x}_2\right)\)</span>, 则称 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\boldsymbol{D}\)</span> 上的凸函数(<span class="math inline">\(convex\quad function\)</span>)。</p><p>凸函数的定义和詹森 <span class="math inline">\((Jensen)\)</span>不等式是相同的。</p><blockquote><p>注意这个定义包含了两个条件。</p></blockquote><p>更进一步地，如果对任意的 <span class="math inline">\(\boldsymbol{x}_1, \boldsymbol{x}_2 \in\boldsymbol{D}, \alpha \in(0,1)\)</span> 都有 <span class="math inline">\(f\left(\alpha \boldsymbol{x}_1+(1-\alpha)\boldsymbol{x}_2\right)&lt;\)</span> <span class="math inline">\(\alphaf\left(\boldsymbol{x}_1\right)+(1-\alpha)f\left(\boldsymbol{x}_2\right)\)</span>, 则称 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\boldsymbol{D}\)</span> 上的严格凸函数(<span class="math inline">\(strictly\quad convex\quad function\)</span>)。</p><h3 id="凸函数的几何意义">4.2 凸函数的几何意义</h3><p>下图是一个凸函数：</p><figure><img src="../../../../images/最优化方法凸集和凸函数/p4.jpg" alt="p4.jpg"><figcaption aria-hidden="true">p4.jpg</figcaption></figure><blockquote><p>凸函数的几何意义在于，定义域中任意两点连线组成的线段都在这两点的函数曲线（面）上方。</p></blockquote><p>下列函数均为 <span class="math inline">\(\mathbb{R}^n\)</span>上的凸函数:</p><ul><li><p><span class="math inline">\(f(\boldsymbol{x})=\boldsymbol{c}^T\boldsymbol{x}\)</span></p></li><li><p><span class="math inline">\(f(\boldsymbol{x})=\|\boldsymbol{x}\|\)</span></p></li><li><p><span class="math inline">\(f(\boldsymbol{x})=\boldsymbol{x}^T\boldsymbol{A} \boldsymbol{x}\)</span>, 其中 <span class="math inline">\(\boldsymbol{A}\)</span> 为对称正定矩阵</p></li></ul><h3 id="凸函数的alpha水平集">4.3 凸函数的<span class="math inline">\(\alpha\)</span>水平集</h3><p><span class="math inline">\(f(\boldsymbol{x})\)</span> 是定义在 <span class="math inline">\(\boldsymbol{D} \subset \mathbb{R}^n\)</span>上的函数, <span class="math inline">\(\alpha \in \mathbb{R}\)</span>,集合 <span class="math inline">\(\boldsymbol{D}_\alpha=\{\boldsymbol{x}\mid f(\boldsymbol{x}) \leqslant\)</span> <span class="math inline">\(\alpha, \boldsymbol{x} \in\boldsymbol{D}\}\)</span> 称作 <span class="math inline">\(f\)</span>函数的 <span class="math inline">\(\alpha\)</span> 水平集(<span class="math inline">\(level\quad set\)</span>)。</p><p>实质上就是一个函数满足一定条件时的定义域上的一系列点的集合。</p><p>一个例子，如下图所示：</p><figure><img src="../../../../images/最优化方法凸集和凸函数/p5.jpg.png" alt="p5.jpg"><figcaption aria-hidden="true">p5.jpg</figcaption></figure><blockquote><p><code>性质</code>凸函数的任意 <span class="math inline">\(\alpha\)</span> 下水平集都是凸集。</p><p>注意：某个函数的下水平集都是凸集，但这个函数却不一定是凸函数 (如:<span class="math inline">\(f(x)=-e^x\)</span> )。</p></blockquote><h2 id="凸函数的判别定理">5. 凸函数的判别定理</h2><blockquote><p><code>判别定理1</code> 定义在 <span class="math inline">\(\mathbb{R}^n\)</span> 上的 <span class="math inline">\(f(\boldsymbol{x})\)</span>为凸函数的充要条件是对于任意 <span class="math inline">\(\boldsymbol{x},\boldsymbol{y} \in \mathbb{R}^n\)</span>, 一元函数 <span class="math inline">\(\phi(\alpha)=f(\boldsymbol{x}+\alpha\boldsymbol{y})\)</span> 是关于 <span class="math inline">\(\alpha\)</span>​ 的凸函数。</p></blockquote><blockquote><p><code>判别定理2</code>(一阶条件) 设 <span class="math inline">\(\boldsymbol{D} \subset \mathbb{R}^n\)</span>是非空开凸集, <span class="math inline">\(f: \boldsymbol{D} \subset\mathbb{R}^n \rightarrow \mathbb{R}\)</span>, 且 <span class="math inline">\(f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(\boldsymbol{D}\)</span> 上一阶连续可微,则 <span class="math inline">\(f(x)\)</span> 是 <span class="math inline">\(\boldsymbol{D}\)</span> 上的凸函数的充要条件是:<span class="math display">\[f(\boldsymbol{y}) \geqslant f(\boldsymbol{x})+\nablaf(\boldsymbol{x})^T(\boldsymbol{y}-\boldsymbol{x}), \forall\boldsymbol{x}, \boldsymbol{y} \in \boldsymbol{D}\]</span></p></blockquote><p>一阶条件的几何意义：<mark class="hl-label blue">凸函数永远位于其切线的上方</mark>  ,如下图所示：</p><figure><img src="../../../../images/最优化方法凸集和凸函数/p6.jpg" alt="p6.jpg"><figcaption aria-hidden="true">p6.jpg</figcaption></figure><p>事实上，<span class="math inline">\(f(\boldsymbol{y}) =f(\boldsymbol{x})+\nablaf(\boldsymbol{x})^T(\boldsymbol{y}-\boldsymbol{x})\)</span> 就是函数<span class="math inline">\(f\)</span> 在点 <span class="math inline">\(\boldsymbol{x}\)</span>处的一阶泰勒近似，那么上述条件就说明了对于凸函数而言，其任意位置处的一阶泰勒展开总是其本身的全局下界。而泰勒展开描述的是函数<span class="math inline">\(f\)</span>的局部性质，由此我们得到有关凸函数的一个重要性质：<strong>凸函数是一类可以由局部信息推导出全局信息的函数。</strong></p><p>一阶条件的引申：设 <span class="math inline">\(\boldsymbol{D} \subset\mathbb{R}^n\)</span> 是非空开凸集, <span class="math inline">\(f:\boldsymbol{D} \subset \mathbb{R}^n \rightarrow \mathbb{R}\)</span>, 且<span class="math inline">\(f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(\boldsymbol{D}\)</span> 上一阶连续可微, 则 <span class="math inline">\(f(x)\)</span> 是 <span class="math inline">\(\boldsymbol{D}\)</span>上的严格凸函数的充要条件是: <span class="math display">\[f(\boldsymbol{y})&gt;f(\boldsymbol{x})+\nablaf(\boldsymbol{x})^T(\boldsymbol{y}-\boldsymbol{x}), \forall\boldsymbol{x}, \boldsymbol{y} \in \boldsymbol{D} \text { 且 }\boldsymbol{x} \neq \boldsymbol{y}\]</span></p><blockquote><p><code>判别定理3</code> 设 <span class="math inline">\(\boldsymbol{D}\subset \mathbb{R}^n\)</span> 是非空开凸集, <span class="math inline">\(f: \boldsymbol{D} \subset \mathbb{R}^n \rightarrow\mathbb{R}\)</span>, 且 <span class="math inline">\(f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(\boldsymbol{D}\)</span> 上二阶连续可微,则 <span class="math inline">\(f(x)\)</span> 是 <span class="math inline">\(\boldsymbol{D}\)</span>上的凸函数的充要条件是:<span class="math inline">\(f(\boldsymbol{x})\)</span> 的<span class="math inline">\(Hesse\)</span>矩阵 <span class="math inline">\(\nabla^2 f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(\boldsymbol{D}\)</span> 上是半正定的。</p></blockquote><blockquote><p><code>判别定理4</code></p><p>设 <span class="math inline">\(\boldsymbol{D} \subset\mathbb{R}^n\)</span> 是非空开凸集, <span class="math inline">\(f:\boldsymbol{D} \subset \mathbb{R}^n \rightarrow \mathbb{R}\)</span>, 且<span class="math inline">\(f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(\boldsymbol{D}\)</span> 上二阶连续可微, 则：</p><ul><li><span class="math inline">\(f(\boldsymbol{x})\)</span> 的<span class="math inline">\(Hesse\)</span>矩阵 <span class="math inline">\(\nabla^2 f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(\boldsymbol{D}\)</span> 上正定 <span class="math inline">\(\Rightarrow f(\boldsymbol{x})\)</span> 是 <span class="math inline">\(\boldsymbol{D}\)</span> 上的严格凸函数;</li><li><span class="math inline">\(f(\boldsymbol{x})\)</span> 是 <span class="math inline">\(\boldsymbol{D}\)</span> 上的严格 凸函数 <span class="math inline">\(\Rightarrow f(\boldsymbol{x})\)</span> 的<span class="math inline">\(Hesse\)</span>矩阵 <span class="math inline">\(\nabla^2 f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(\boldsymbol{D}\)</span>​ 上半正定。</li></ul><hr><p>几个反例：<span class="math inline">\(y=x^4, x \in \mathbb{R}, y=x^6,x \in \mathbb{R}\)</span> 。</p><p>导致充分严格凸函数与严格正定不构成互为充要条件的原因: 对于 <span class="math inline">\(\alpha&gt;0\)</span>, 如果当 <span class="math inline">\(\alpha \rightarrow 0\)</span> 时 <span class="math inline">\(o(\alpha)&gt;0\)</span> 且 <span class="math inline">\(o(\alpha) \rightarrow 0\)</span>, 则有 <span class="math display">\[\begin{aligned}&amp; f(\boldsymbol{x})+\frac{o(\alpha)}{\alpha}&lt;0, \forall\boldsymbol{x} \in \mathbb{R}^n \Rightarrow f(\boldsymbol{x})&lt;0,\forall \boldsymbol{x} \in \mathbb{R}^n \\&amp;f(\boldsymbol{x})+\frac{o(\alpha)}{\alpha}&gt;0, \forall \boldsymbol{x}\in \mathbb{R}^n \Rightarrow f(\boldsymbol{x}) \geqslant 0, \forall\boldsymbol{x} \in \mathbb{R}^n \\&amp;f(\boldsymbol{x})+\frac{o(\alpha)}{\alpha} \leqslant 0, \forall\boldsymbol{x} \in \mathbb{R}^n \Rightarrow f(\boldsymbol{x})&lt;0,\forall \boldsymbol{x} \in \mathbb{R}^n \\&amp;f(\boldsymbol{x})+\frac{o(\alpha)}{\alpha} \geqslant 0, \forall\boldsymbol{x} \in \mathbb{R}^n \Rightarrow f(\boldsymbol{x}) \geqslant0, \forall \boldsymbol{x} \in \mathbb{R}^n\end{aligned}\]</span></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 最优化方法 </category>
          
          <category> 凸集和凸函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最优化方法 </tag>
            
            <tag> 凸集 </tag>
            
            <tag> 凸函数 </tag>
            
            <tag> 投影定理 </tag>
            
            <tag> 支撑超平面 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础知识回顾与拓展（一）</title>
      <link href="/2024/03/19/tu-you-hua-zhi-shi-hui-gu-yu-tuo-zhan/"/>
      <url>/2024/03/19/tu-you-hua-zhi-shi-hui-gu-yu-tuo-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="数学知识回顾与拓展一">数学知识回顾与拓展(一)</h1><h2 id="线性代数">1 线性代数</h2><h3 id="向量">1.1 向量</h3><p>在最优化方法的课程中，默认向量为列向量的形式。</p><p><span class="math inline">\(n\)</span>维列向量定义为包含<span class="math inline">\(n\)</span>个实数的数组，记作： <span class="math display">\[\boldsymbol{a}=\left[\begin{array}{c}a_1 \\ a_2 \\ \vdots \\a_n\end{array}\right]\]</span> <span class="math inline">\(a_i\)</span> 表示向量 <span class="math inline">\(\boldsymbol{a}\)</span> 的第 <span class="math inline">\(i\)</span> 个元素。定义 <span class="math inline">\(\mathbb{R}\)</span>为全体实数组成的集合，那么由实数组成的 <span class="math inline">\(n\)</span> 维列向量可表示为 <span class="math inline">\(\mathbb{R}^n\)</span>, 称为 <span class="math inline">\(n\)</span> 维实数向量空间。通常将 <span class="math inline">\(\mathbb{R}^n\)</span> 的元素(<span class="math inline">\(n\)</span>维向量)用小写粗体字母表示 (如 <span class="math inline">\(\boldsymbol{x}\)</span> )。向量 <span class="math inline">\(\boldsymbol{x} \in \mathbb{R}^n\)</span>中的元素记为 <span class="math inline">\(x_1, \cdots, x_n\)</span>。</p><p><span class="math inline">\(n\)</span> 维行向量记为 <span class="math inline">\(\left[a_1, a_2, \cdots, a_n\right]\)</span>, 向量<span class="math inline">\(\boldsymbol{a}\)</span> 的转置记为 <span class="math inline">\(\boldsymbol{a}^T\)</span> 。比如, 如果 <span class="math display">\[\boldsymbol{a}=\left[\begin{array}{c}a_1 \\a_2 \\\vdots \\a_n\end{array}\right]\]</span></p><p>那么 <span class="math display">\[\boldsymbol{a}^T=\left[a_1, a_2, \cdots, a_n\right]\]</span></p><p>相应的, 列向量<span class="math inline">\(\boldsymbol{a}\)</span>可以记为 <span class="math inline">\(\boldsymbol{a}=\left[a_1, a_2, \cdots,a_n\right]^T\)</span> 。</p><h3 id="线性相关">1.2 线性相关</h3><h4 id="线性相关与线性无关的定义">1.2.1 线性相关与线性无关的定义</h4><p>如果方程： <span class="math display">\[\alpha_1 \boldsymbol{a}_1+\alpha_2 \boldsymbol{a}_2+\cdots+\alpha_k\boldsymbol{a}_k=\mathbf{0}\]</span></p><p>只有在所有系数 <span class="math inline">\(\alpha_i(i=1, \cdots,k)\)</span> 都等于零的前提下等号成立, 那么称向量集 <span class="math inline">\(\left\{\boldsymbol{a}_1, \boldsymbol{a}_2, \cdots,\boldsymbol{a}_k\right\}\)</span>是线性无关的，否则称向量集是线性相关的。</p><blockquote><p>线性相关的一些结论</p></blockquote><blockquote><p>1.如果集合中只包括一个向量 <span class="math inline">\(\boldsymbol{0}\)</span>, 由于对于任意 <span class="math inline">\(\alpha \neq 0\)</span>, 都有 <span class="math inline">\(\alpha\mathbf{0}=\mathbf{0}\)</span>,因此，该集合是线性相关的。实际上，所有包含零向量的集合都是线性相关的，假设这个集合有<span class="math inline">\(n\)</span>个向量元素，令剩下的<span class="math inline">\((n-1)\)</span>个元素<span class="math inline">\(\alpha_1 \boldsymbol{a}_1+\alpha_2\boldsymbol{a}_2+\cdots+\alpha_{k-1}\boldsymbol{a}_{k-1}=\mathbf{0}\)</span> ，这些系数可以全部为<span class="math inline">\(0\)</span>，即： <span class="math inline">\(\alpha_i(i=1, \cdots, k-1)\)</span> 都为<span class="math inline">\(0\)</span>，剩下的零向量前的系数不为 <span class="math inline">\(0\)</span>即可，所以所有包含零向量的集合都是线性相关的。2.如果集合中只包括一个非零向量 ： <span class="math inline">\(\boldsymbol{a} \neq \mathbf{0}\)</span> , 只有<span class="math inline">\(\alpha=0\)</span>时, 才有 <span class="math inline">\(\alpha\boldsymbol{a}=\boldsymbol{0}\)</span>成立，因此，该集合是线性无关的。</p></blockquote><h4 id="线性组合">1.2.2 线性组合</h4><p>给定向量 <span class="math inline">\(\boldsymbol{a}\)</span>,如果存在标量 <span class="math inline">\(\alpha_1, \cdots,\alpha_k\)</span>, 使得 <span class="math display">\[\boldsymbol{a}=\alpha_1 \boldsymbol{a}_1+\alpha_2\boldsymbol{a}_2+\cdots+\alpha_k \boldsymbol{a}_k\]</span></p><p>那么称向量 <span class="math inline">\(\boldsymbol{a}\)</span>为向量<span class="math inline">\(\boldsymbol{a}_1, \boldsymbol{a}_2,\cdots, \boldsymbol{a}_k\)</span> 的线性组合。</p><blockquote><p><code>定理</code>向量集 <span class="math inline">\(\left\{\boldsymbol{a}_1, \boldsymbol{a}_2, \cdots,\boldsymbol{a}_k\right\}\)</span>是线性相关的，当且仅当集合中的一个向量可以表示为其他向量的线性组合。</p></blockquote><blockquote><p>证明：</p><p>必要性。如果 <span class="math inline">\(\left\{a_1, a_2, \cdots,a_k\right\}\)</span> 是线性相关的, 那么有 <span class="math display">\[\alpha_1 \boldsymbol{a}_1+\alpha_2 \boldsymbol{a}_2+\cdots+\alpha_k\boldsymbol{a}_k=\mathbf{0}\]</span></p><p>其中至少存在一个标量 <span class="math inline">\(\alpha_i \neq0\)</span>, 从而有 <span class="math display">\[\boldsymbol{a}_i=-\frac{\alpha_1}{\alpha_i}\boldsymbol{a}_1-\frac{\alpha_2}{\alpha_i}\boldsymbol{a}_2-\cdots-\frac{\alpha_k}{\alpha_i}\boldsymbol{a}_k\]</span> 充分性。不妨设向量 <span class="math inline">\(\boldsymbol{a_1}\)</span>可以被表示为其他向量的线性组合: <span class="math display">\[\boldsymbol{a}_1=\alpha_2 \boldsymbol{a}_2+\alpha_3\boldsymbol{a}_3+\cdots+\alpha_k \boldsymbol{a}_k\]</span></p><p>那么有 <span class="math display">\[(-1) \boldsymbol{a}_1+\alpha_2 \boldsymbol{a}_2+\cdots+\alpha_k\boldsymbol{a}_k=\mathbf{0}\]</span></p><p>因为第一个标量非零，所以向量集 <span class="math inline">\(\left\{\boldsymbol{a}_1, \boldsymbol{a}_2, \cdots,\boldsymbol{a}_k\right\}\)</span> 是线性相关的。</p><p>得证。</p></blockquote><h4 id="向量空间">1.2.3向量空间</h4><h5 id="子空间">1.2.3.1 子空间</h5><p>令 <span class="math inline">\(\mathcal{V}\)</span> 表示 <span class="math inline">\(\mathbb{R}^n\)</span> 的一个子集, 如果 <span class="math inline">\(\mathcal{V}\)</span>在向量加和运算及标量乘积运算下是封闭的，那么称 <span class="math inline">\(\mathcal{V}\)</span> 为 <span class="math inline">\(\mathbb{R}^n\)</span> 的一个子空间。</p><p>注：每个子空间都包含零向量。</p><p>假定 <span class="math inline">\(\boldsymbol{a}_1, \boldsymbol{a}_2,\cdots, \boldsymbol{a}_k\)</span> 是 <span class="math inline">\(\mathbb{R}^n\)</span> 中的任意向量,它们所有线性组合的集合称为 <span class="math inline">\(\boldsymbol{a}_1,\boldsymbol{a}_2, \cdots, \boldsymbol{a}_k\)</span> 张成的子空间。记为：<span class="math display">\[span\left[\boldsymbol{a}_1, \boldsymbol{a}_2, \cdots,\boldsymbol{a}_k\right]=\left\{\sum_{i=1}^k \alpha_i \boldsymbol{a}_i:\alpha_1, \cdots, \alpha_k \in \mathbb{R}\right\}\]</span></p><p>任意向量集合都能张成一个子空间。</p><h5 id="基">1.2.3.2 基</h5><p>给定子空间 <span class="math inline">\(\mathcal{V}\)</span>，如果存在线性无关的向量集合 <span class="math inline">\(\left\{\boldsymbol{a}_1, \boldsymbol{a}_2, \cdots,\boldsymbol{a}_k\right\} \subset \mathcal{V}\)</span> 使得 <span class="math inline">\(\mathcal{V}=\operatorname{span}\left[\boldsymbol{a}_1,\boldsymbol{a}_2, \cdots, \boldsymbol{a}_k\right]\)</span> ，那么称<span class="math inline">\(\left\{\boldsymbol{a}_1, \boldsymbol{a}_2,\cdots, \boldsymbol{a}_k\right\}\)</span> 是子空间 <span class="math inline">\(\mathcal{V}\)</span> 的一组基。子空间 <span class="math inline">\(\mathcal{V}\)</span>中的所有基都包含相同数量的向量, 这一数量称为 <span class="math inline">\(\mathcal{V}\)</span> 的维数, 记为 <span class="math inline">\(\operatorname{dim} \mathcal{V}\)</span> 。</p><p>如果 <span class="math inline">\(\left\{\boldsymbol{a}_1,\boldsymbol{a}_2, \cdots, \boldsymbol{a}_k\right\}\)</span> 是 <span class="math inline">\(\mathcal{V}\)</span> 的一组基, 那么 <span class="math inline">\(\mathcal{V}\)</span> 中的任一向量 <span class="math inline">\(\boldsymbol{a}\)</span> 可以唯一地表示为 <span class="math display">\[\boldsymbol{a}=\alpha_1 \boldsymbol{a}_1+\alpha_2\boldsymbol{a}_2+\cdots+\alpha_k \boldsymbol{a}_k\]</span></p><p>其中，<span class="math inline">\(\alpha_i \in \mathbb{R}, i=1,2,\cdots, k\)</span> 。</p><p>给定 <span class="math inline">\(\mathcal{V}\)</span> 的一组基 <span class="math inline">\(\left\{\boldsymbol{a}_1, \boldsymbol{a}_2, \cdots,\boldsymbol{a}_k\right\}\)</span> 和向量 <span class="math inline">\(\boldsymbol{a} \in \mathcal{V}\)</span> ，如果<span class="math display">\[\boldsymbol{a}=\alpha_1 \boldsymbol{a}_1+\alpha_2\boldsymbol{a}_2+\cdots+\alpha_k \boldsymbol{a}_k\]</span></p><p>那么系数 <span class="math inline">\(\alpha_i, i=1, \cdots,k\)</span> 称为 <span class="math inline">\(a\)</span> 对应于基 <span class="math inline">\(\left\{\boldsymbol{a}_1, \boldsymbol{a}_2, \cdots,\boldsymbol{a}_k\right\}\)</span> 的坐标。</p><p><span class="math inline">\(\mathbb{R}^n\)</span> 的标准基为 <span class="math display">\[\boldsymbol{e}_1=\left[\begin{array}{l}1 \\0 \\0 \\\vdots \\0\\0\end{array}\right], \boldsymbol{e}_2=\left[\begin{array}{l}0 \\1 \\0\\\vdots \\0 \\0\end{array}\right], \cdots,\boldsymbol{e}_n=\left[\begin{array}{l}0 \\0 \\0 \\\vdots \\0\\1\end{array}\right]\]</span></p><p>在标准基下，向量 <span class="math inline">\(x\)</span> 可表示为<span class="math display">\[\boldsymbol{x}=\left[\begin{array}{llll}x_1 &amp; x_2 &amp; \cdots &amp;x_n\end{array}\right]^T=x_1 \boldsymbol{e}_1+x_2\boldsymbol{e}_2+\cdots+x_n \boldsymbol{e}_n\]</span></p><h3 id="初等变换">1.3 初等变换</h3><p>对矩阵进行以下三种变换的称为行初等变换</p><ul><li><p>对换两行（对换 <span class="math inline">\(i, j\)</span> 两行,记作 <span class="math inline">\(r_i \leftrightarrow r_j\)</span>);</p></li><li><p>以数 <span class="math inline">\(k \neq 0\)</span>乘某一行中所有的元素（第 <span class="math inline">\(i\)</span> 行乘<span class="math inline">\(k\)</span>, 记作 <span class="math inline">\(r_i \times k\)</span> ）;</p></li><li><p>把某一行所有元的 <span class="math inline">\(k\)</span> 倍,加到另一行对应的元上去 (第 <span class="math inline">\(j\)</span> 行的<span class="math inline">\(k\)</span> 倍加到第 <span class="math inline">\(i\)</span> 行上, 记作 <span class="math inline">\(r_i+k r_j\)</span> ).矩阵的行初等变换与列初等变换, 统称为矩阵的初等变换。</p></li></ul><p>对一个矩阵每进行一次初等行变换相当于为这个矩阵左乘了一个初等矩阵，初等列变换相当于右乘一个初等矩阵。</p><h3 id="矩阵的秩">1.4 矩阵的秩</h3><p>矩阵 <span class="math inline">\(\boldsymbol{A}\)</span>中线性无关列的最大数目称为 <span class="math inline">\(\boldsymbol{A}\)</span> 的秩, 记为 <span class="math inline">\(r a n k \boldsymbol{A}\)</span> 。矩阵 <span class="math inline">\(A\)</span> 的秩等于它的非零子式的最高阶数。</p><p>注：对矩阵进行初等变换不改变矩阵的秩。</p><p>如果矩阵 <span class="math inline">\(\boldsymbol{A}\)</span>的行数等于列数, 那么该矩阵称为方阵。行列式是与每个方阵相对应的一个标量,记为 <span class="math inline">\(\operatorname{det}\boldsymbol{A}\)</span> 或 <span class="math inline">\(|\boldsymbol{A}|\)</span> 。</p><p>如果一个 <span class="math inline">\(m \times n(m \geq n)\)</span>矩阵 <span class="math inline">\(A\)</span> 具有非零的 <span class="math inline">\(n\)</span> 阶子式，那么 <span class="math inline">\(A\)</span> 的各列是线性无关的，即 <span class="math inline">\(r a n k \boldsymbol{A}=n\)</span> 。</p><h3 id="内积与范数">1.5 内积与范数</h3><p>对于 <span class="math inline">\(\boldsymbol{x}, \boldsymbol{y} \in\mathbb{R}^n\)</span>, 定义欧式内积为 <span class="math display">\[\langle\boldsymbol{x}, \boldsymbol{y}\rangle=\sum_{i=1}^n x_iy_i=\boldsymbol{x}^T \boldsymbol{y}\]</span></p><p>定义向量 <span class="math inline">\(\boldsymbol{x}\)</span>的欧氏范数为 <span class="math display">\[\|\boldsymbol{x}\|=\sqrt{\langle\boldsymbol{x},\boldsymbol{x}\rangle}=\sqrt{\boldsymbol{x}^T \boldsymbol{x}}\]</span></p><blockquote><p>向量 <span class="math inline">\(x\)</span> 的欧氏范数 <span class="math inline">\(\|x\|\)</span> 具有如下性质:</p><ol type="1"><li>非负性: <span class="math inline">\(\boldsymbol{x}\)</span>的欧氏范数 <span class="math inline">\(\|\boldsymbol{x}\| \geq0\)</span>, 当且仅当 <span class="math inline">\(\boldsymbol{x}=\boldsymbol{0}\)</span> 时, <span class="math inline">\(\|\boldsymbol{x}\|=0\)</span></li><li>齐次性: <span class="math inline">\(\|r\boldsymbol{x}\|=|r|\|\boldsymbol{x}\| \geq 0, r \in\mathbb{R}\)</span></li><li>三角不等式: <span class="math inline">\(\|\boldsymbol{x}+\boldsymbol{y}\|\leq\|\boldsymbol{x}\|+\|\boldsymbol{y}\|\)</span></li></ol></blockquote><h3 id="求方阵的逆">1.6 求方阵的逆</h3><p>设 <span class="math inline">\(\boldsymbol{A}\)</span> 为矩阵,如果存在 <span class="math inline">\(n\)</span> 阶方阵 <span class="math inline">\(\boldsymbol{B}\)</span>, 使得： <span class="math display">\[\boldsymbol{A}\boldsymbol{B}=\boldsymbol{B}\boldsymbol{A}=\boldsymbol{I}\]</span> 则称 <span class="math inline">\(\boldsymbol{A}\)</span>是可逆矩阵, <span class="math inline">\(\boldsymbol{B}\)</span> 是 <span class="math inline">\(\boldsymbol{A}\)</span> 的逆矩阵。</p><blockquote><p><code>定理1</code>如果 <span class="math inline">\(\boldsymbol{A}\)</span> 是一个 <span class="math inline">\(n\)</span> 阶可逆矩阵, 则 <span class="math inline">\(\boldsymbol{A}\)</span> 的逆矩阵是唯一的。</p><p><code>定理2</code><span class="math inline">\(n\)</span> 阶方阵 <span class="math inline">\(\boldsymbol{A}\)</span> 可逆的充分必要条件是行列式<span class="math inline">\(|\boldsymbol{A}| \neq 0\)</span></p></blockquote><h4 id="利用伴随矩阵求方阵的逆">1.6.1 利用伴随矩阵求方阵的逆</h4><p>当 <span class="math inline">\(|\boldsymbol{A}| \neq 0\)</span> 时,<span class="math display">\[\boldsymbol{A}^{-1}=\frac{1}{|\boldsymbol{A}|}\boldsymbol{A}^*=\frac{1}{|\boldsymbol{A}|}\left[\begin{array}{cccc}A_{11}&amp; A_{21} &amp; \cdots &amp; A_{n 1} \\A_{12} &amp; A_{22} &amp;\cdots &amp; A_{n 2} \\\vdots &amp; \vdots &amp; &amp; \vdots \\A_{1 n}&amp; A_{2 n} &amp; \cdots &amp; A n n\end{array}\right]\]</span></p><p>其中 <span class="math inline">\(\boldsymbol{A}^*\)</span> 是 <span class="math inline">\(\boldsymbol{A}\)</span> 的伴随阵, <span class="math inline">\(A_{i j}\)</span> 是 <span class="math inline">\(a_{i j}\)</span> 的代数余子式,注意伴随矩阵的行列关系。</p><h4 id="gauss-jordan方法">1.6.2 <span class="math inline">\(Gauss-Jordan\)</span>方法</h4><p>简而言之, <span class="math inline">\(Gauss-Jordan\)</span>的想法是:如果我们对 <span class="math inline">\(\boldsymbol{A}\)</span>执行一些行操作以获得 <span class="math inline">\(\boldsymbol{I}\)</span>, 那么对 <span class="math inline">\(\boldsymbol{I}\)</span> 执行相同的行操作会得到<span class="math inline">\(\boldsymbol{A^{-1}}\)</span> 。为什么?</p><ul><li><p>行操作对应于从 <span class="math inline">\(\boldsymbol{A}\)</span> 左边乘以一组矩阵 <span class="math inline">\(\boldsymbol{E}=\cdots \boldsymbol{E_2E_1}\)</span></p></li><li><p>所以, 对 <span class="math inline">\(\boldsymbol{A}\)</span>做行操作将其变成 <span class="math inline">\(\boldsymbol{I}\)</span>意思等价于 <span class="math inline">\(\boldsymbol{E}\boldsymbol{A}=\boldsymbol{I}\)</span>, 因此 <span class="math inline">\(\boldsymbol{E}=\boldsymbol{A^{-1}}\)</span>.</p></li><li><p>对 <span class="math inline">\(\boldsymbol{I}\)</span>执行相同的行操作, 相当于 <span class="math inline">\(\boldsymbol{I}\)</span>左乘矩阵 <span class="math inline">\(E\)</span>, 即 <span class="math inline">\(EI\)</span>, 因为 <span class="math inline">\(\boldsymbol{E}\boldsymbol{I}=\boldsymbol{E}\)</span> 并且 <span class="math inline">\(\boldsymbol{E}=\boldsymbol{A^{-1}}\)</span>,所以结果就是 <span class="math inline">\(\boldsymbol{A^{-1}}\)</span>。这就是我们可以用扩展矩阵来进行高斯消除,对 <span class="math inline">\(\boldsymbol{A}\)</span> 和 <span class="math inline">\(\boldsymbol{I}\)</span> 同时执行相同的行操作,即：</p></li></ul><p><span class="math display">\[\left(\begin{array}{ll}\boldsymbol{A} &amp;\boldsymbol{I}\end{array}\right) \underset{\text { row ops}}{\longrightarrow}\left(\begin{array}{ll}\boldsymbol{I} &amp;\boldsymbol{A^{-1}}\end{array}\right)\]</span></p><h3 id="特征值与特征向量">1.7 特征值与特征向量</h3><h4 id="基本概念与一些结论">1.7.1 基本概念与一些结论</h4><p>令 <span class="math inline">\(\boldsymbol{A}\)</span> 是 <span class="math inline">\(n \times n\)</span> 的实数方阵。存在标量 <span class="math inline">\(\lambda\)</span> (可能为复数) 和非零向量 <span class="math inline">\(\boldsymbol{v}\)</span> 满足等式： <span class="math display">\[\boldsymbol{A v}=\lambda \boldsymbol{v}\]</span> <span class="math inline">\(\lambda\)</span> 称为 <span class="math inline">\(\boldsymbol{A}\)</span> 的特征值, <span class="math inline">\(\boldsymbol{v}\)</span> 称为 <span class="math inline">\(\boldsymbol{A}\)</span> 的特征向量。</p><p>已知 <span class="math inline">\(n\)</span> 阶齐次线性方程组 <span class="math inline">\((\lambda \boldsymbol{I}-\boldsymbol{A})\boldsymbol{x}=0\)</span> 有非零解的充分必要条件是系数行列式为 <span class="math inline">\(0\)</span>。即矩阵 <span class="math inline">\(\lambda \boldsymbol{I}-\boldsymbol{A}\)</span> 有<span class="math inline">\(\operatorname{det}[\lambda\boldsymbol{I}-\boldsymbol{A}]=0\)</span>, 于是有 <span class="math inline">\(n\)</span> 次方程成立: <span class="math display">\[\operatorname{det}[\lambda\boldsymbol{I}-\boldsymbol{A}]=\lambda^n+a_{n-1}\lambda^{n-1}+\cdots+a_1 \lambda+a_0=0\]</span> 多项式 <span class="math inline">\(\operatorname{det}[\lambda\boldsymbol{I}-\boldsymbol{A}]\)</span> 称为矩阵 <span class="math inline">\(\boldsymbol{A}\)</span>的特征多项式,上面的方程称为特征方程。由代数的基本原理可知, 特征方程必定有 <span class="math inline">\(n\)</span>个根（可能存在相同的根）,即为<span class="math inline">\(\boldsymbol{A}\)</span>的<span class="math inline">\(n\)</span>个特征值。若 <span class="math inline">\(\boldsymbol{A}\)</span> 有 <span class="math inline">\(n\)</span> 个相异的特征值，那么它也有 <span class="math inline">\(n\)</span>个线性无关的特征向量。</p><h4 id="矩阵对角化">1.7.2 矩阵对角化</h4><p>设矩阵 <span class="math inline">\(\boldsymbol{A}\)</span> 为<span class="math inline">\(n\)</span>阶方阵。考虑其特征向量 <span class="math inline">\(\left\{\boldsymbol{v}_1, \boldsymbol{v}_2, \cdots,\boldsymbol{v}_n\right\}\)</span>构成的一组线性无关基。在这一组基下,可对矩阵 <span class="math inline">\(\boldsymbol{A}\)</span> 进行对角化, 即对所有的<span class="math inline">\(i \neq j\)</span>, 对角矩阵的第 <span class="math inline">\((i, j)\)</span> 个元素 <span class="math inline">\(a_{i j}=\)</span> 0 。令 <span class="math display">\[\boldsymbol{T}=\left[\boldsymbol{v}_1, \boldsymbol{v}_2, \cdots,\boldsymbol{v}_n\right]^{-1}\]</span> 则有： <span class="math display">\[\begin{aligned}\boldsymbol{T A T}^{-1} &amp; =\boldsymbol{T A}\left[\boldsymbol{v}_1,\boldsymbol{v}_2, \cdots, \boldsymbol{v}_n\right] \\&amp; =\boldsymbol{T}\left[\boldsymbol{A} \boldsymbol{v}_1,\boldsymbol{A} \boldsymbol{v}_2, \cdots, \boldsymbol{A}\boldsymbol{v}_n\right] \\&amp; =\boldsymbol{T}\left[\lambda_1 \boldsymbol{v}_1, \lambda_2\boldsymbol{v}_2, \cdots, \lambda_n \boldsymbol{v}_n\right] \\&amp;=\boldsymbol{T}\boldsymbol{T}^{-1}\left[\begin{array}{llll}\lambda_1 &amp; &amp; &amp;0 \\&amp; \lambda_2 &amp; &amp; \\&amp; &amp; \ddots &amp; \\0 &amp;&amp; &amp; \lambda_n\end{array}\right] \\&amp; =\left[\begin{array}{llll}\lambda_1 &amp; &amp; &amp; 0 \\&amp;\lambda_2 &amp; &amp; \\&amp; &amp; \ddots &amp; \\0 &amp; &amp; &amp;\lambda_n\end{array}\right]\end{aligned}\]</span></p><blockquote><p><code>定理</code>对于任意 <span class="math inline">\(n \timesn\)</span> 实对称矩阵, 存在 <span class="math inline">\(n\)</span>个相互正交的特征向量。</p></blockquote><blockquote><p>证明：假定 <span class="math inline">\(\boldsymbol{A}\boldsymbol{v}_1=\lambda_1 \boldsymbol{v}_1, \boldsymbol{A}\boldsymbol{v}_2=\lambda_2 \boldsymbol{v}_2\)</span>, 其中 <span class="math inline">\(\lambda_1 \neq \lambda_2\)</span>, 那么有 <span class="math display">\[\boldsymbol{v}_1^T \boldsymbol{A}\boldsymbol{v}_2=\boldsymbol{v}_1^T\left(\boldsymbol{A}\boldsymbol{v}_2\right)=\lambda_2\left(\boldsymbol{v}_1^T\boldsymbol{v}_2\right)\]</span></p><p>根据 <span class="math inline">\(\boldsymbol{A}=\boldsymbol{A}^T\)</span>, 有 <span class="math display">\[\boldsymbol{v}_1^T \boldsymbol{A}\boldsymbol{v}_2=\left(\boldsymbol{v}_1^T \boldsymbol{A}^T\right)\boldsymbol{v}_2=\left(\boldsymbol{A} \boldsymbol{v}_1\right)^T\boldsymbol{v}_2=\lambda_1\left(\boldsymbol{v}_1^T\boldsymbol{v}_2\right)\]</span></p><p>因此, <span class="math display">\[\lambda_1\left(\boldsymbol{v}_1^T\boldsymbol{v}_2\right)=\lambda_2\left(\boldsymbol{v}_1^T\boldsymbol{v}_2\right)\]</span></p><p>由于 <span class="math inline">\(\lambda_1 \neq \lambda_2\)</span>,可以推出 <span class="math display">\[\left(\boldsymbol{v}_1^T \boldsymbol{v}_2\right)=0\]</span> 所以特征向量相互正交。</p></blockquote><h3 id="二次型">1.8 二次型</h3><h4 id="二次型函数">1.8.1 二次型函数</h4><p>设二次型函数 <span class="math inline">\(f: \mathbb{R}^n \rightarrow\mathbb{R}\)</span> 定义为具有如下形式的函数: <span class="math display">\[f(\boldsymbol{x})=\boldsymbol{x}^T \boldsymbol{Q} \boldsymbol{x}\]</span></p><p>其中 <span class="math inline">\(\boldsymbol{Q}\)</span> 是一个 <span class="math inline">\(n \times n\)</span> 实数矩阵。 <span class="math display">\[\begin{aligned}f(\boldsymbol{x}) &amp; =q_{11} x_1^2+q_{12} x_1x_2+\cdots+q_{1 n} x_1 x_n \\&amp; +q_{21} x_2 x_1+q_{22}x_2^2+\cdots+q_{2 n} x_2 x_n \\&amp; +\cdots \\&amp; +q_{n 1} x_nx_1+q_{n 2} x_2^2+\cdots+q_{n n} x_n^2 \\&amp; =\left[x_1, x_2, \cdots,x_n\right]\left[\begin{array}{cccc}q_{11} &amp; q_{12} &amp; \cdots&amp; q_{1 n} \\q_{21} &amp; q_{22} &amp; \cdots &amp; q_{2 n} \\\vdots&amp; \vdots &amp; \vdots &amp; \vdots \\q_{n 1} &amp; q_{n 2} &amp;\cdots &amp; q_{n n}\end{array}\right]\left[\begin{array}{c}x_1 \\x_2\\\vdots \\x_n\end{array}\right]\\&amp;=\boldsymbol{x}^T \boldsymbol{Q}\boldsymbol{x}\end{aligned}\]</span></p><h4 id="正定">1.8.2 正定</h4><p>当对于任一非零向量 <span class="math inline">\(\boldsymbol{x}\)</span>, 都有 <span class="math inline">\(\boldsymbol{x}^T \boldsymbol{Q x}&gt;0\)</span>,则二次型 <span class="math inline">\(\boldsymbol{x^T}\boldsymbol{Q}\boldsymbol{x}\)</span> 是正定的, 若 <span class="math inline">\(\boldsymbol{x^T} \boldsymbol{Q}\boldsymbol{x} \geq0\)</span> 则此二次型是半正定。类似的, <span class="math inline">\(\boldsymbol{x}^T \boldsymbol{Q x}&lt;0\)</span>,或者 <span class="math inline">\(\boldsymbol{x^T}\boldsymbol{Q}\boldsymbol{x} \leq 0\)</span>则说明二次型是负定或半负定的。</p><p>矩阵 <span class="math inline">\(\boldsymbol{Q}\)</span>的顺序主子式为 <span class="math inline">\(\operatorname{det}\boldsymbol{Q}\)</span> 自身以及从矩阵 <span class="math inline">\(\boldsymbol{Q}\)</span>中依次移除最后一行和最后一列获得的所有子式, 即： <span class="math display">\[\begin{aligned}&amp; \Delta_1=q_{11}, \quad \Delta_2=\left[\begin{array}{ll}q_{11}&amp; q_{12} \\q_{21} &amp; q_{22}\end{array}\right] \\&amp; \Delta_3=\operatorname{det}\left[\begin{array}{lll}q_{11} &amp;q_{12} &amp; q_{13} \\q_{21} &amp; q_{22} &amp; q_{23} \\q_{31} &amp;q_{32} &amp; q_{33}\end{array}\right], \cdots,\Delta_n=\operatorname{det} \boldsymbol{Q} \\\end{aligned}\]</span></p><blockquote><p><code>定理1</code>给定二次型 <span class="math inline">\(\boldsymbol{x}^T \boldsymbol{Q}\boldsymbol{x}\)</span> ，其中 <span class="math inline">\(\boldsymbol{Q}=\boldsymbol{Q}^T\)</span>,该二次型是正定的，当且仅当的 <span class="math inline">\(Q\)</span>顺序主子式是正定的。</p><p><code>定理2</code>对称矩阵 <span class="math inline">\(\boldsymbol{Q}\)</span> 是正定（半正定）的,当且仅当 <span class="math inline">\(\boldsymbol{Q}\)</span>的所有特征值是正的 （非负的）。</p></blockquote><h2 id="线段与超平面">2 线段与超平面</h2><h3 id="线段">2.1 线段</h3><p>对于 <span class="math inline">\(n\)</span> 维向量 <span class="math inline">\(\boldsymbol{x}=\left[x_1, x_2, \cdots,x_n\right]^T, \quad \boldsymbol{y}=\left[y_1, y_2, \cdots,y_n\right]^T\)</span>, 两点之间的所有点的集合称为两点之间的线段。如果<span class="math inline">\(z\)</span> 在这条线段上，那么有 <span class="math display">\[\boldsymbol{z}=\boldsymbol{y}+\alpha(\boldsymbol{x}-\boldsymbol{y})\quad\alpha\in[0,1]\]</span> 其中<span class="math inline">\(\boldsymbol{y}\)</span>表示这个线段的起点，<span class="math inline">\(\boldsymbol{x}-\boldsymbol{y}\)</span>表示这个线段的方向，<span class="math inline">\(\alpha\)</span>表示在这个方向上的长度的系数。</p><p>这条线段还可以表示为： <span class="math display">\[\{\alpha \boldsymbol{x}+(1-\alpha) \boldsymbol{y}: \alpha \in[0,1]\}\]</span> <span class="math inline">\(\boldsymbol{x}、\boldsymbol{y}\)</span>前的系数相加为<span class="math inline">\(1\)</span>，易于记忆。</p><h3 id="超平面">2.2 超平面</h3><p>令 <span class="math inline">\(u_1, u_2, \cdots, u_n, v \in\mathbb{R}\)</span>, 其中至少存在一个不为零的 <span class="math inline">\(u_i\)</span> 。由所有满足线性方程 <span class="math display">\[u_1 x_1+u_2 x_2+\cdots+u_n x_n=v\]</span></p><p>的点 <span class="math inline">\(\boldsymbol{x}=\left[x_1, x_2,\cdots, x_n\right]^T\)</span> 组成的集合称为空间 <span class="math inline">\(\mathbb{R}^n\)</span> 的超平面。超平面可以写为：<span class="math display">\[\left\{\boldsymbol{x} \in \mathbb{R}^n: \boldsymbol{u}^T\boldsymbol{x}=v\right\}\]</span></p><p>其中<span class="math inline">\(u=\left[u_1, u_2, \cdots,u_n\right]^T\)</span>。</p><p>注意: 超平面不一定是 <span class="math inline">\(\mathbb{R}^n\)</span> 的子空间,因为超平面通常不包含原点。而且超平面不一定是一个平面,在二维空间中就是一条直线,而三维空间中是一些普通平面。这比较好理解，因为在二维空间中可以写成<span class="math inline">\(ax+by=c\)</span>，这是一条直线；三维空间中为<span class="math inline">\(ax+by+cz=d\)</span>，表示一个平面，可以看到超平面是一个相对于<span class="math inline">\(n\)</span>维空间下的平面。</p><figure><img src="../../../../images/最优化方法知识回顾与拓展/p1.jpg" alt="p1.jpg"><figcaption aria-hidden="true">p1.jpg</figcaption></figure><p>如上图，可以把超平面 <span class="math inline">\(H=\left\{\boldsymbol{x}: u_1 x_1+\cdots+u_nx_n=v\right\}\)</span> 可以换一种形式去表述。在超平面内一点 <span class="math inline">\(\boldsymbol{a}\)</span> 和任一点 <span class="math inline">\(\boldsymbol{x}\)</span>。 <span class="math inline">\(\boldsymbol{u}\)</span> 为点 <span class="math inline">\(\boldsymbol{x}\)</span> 处的法向量，将满足 <span class="math inline">\(\boldsymbol{u^T}(\boldsymbol{x}-\boldsymbol{a})=0\)</span>于是有： <span class="math display">\[H=\left\{\boldsymbol{x} \in \mathbb{R}^n\right. :\left.\boldsymbol{u^T}(\boldsymbol{x}-\boldsymbol{a})=0\right\}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 最优化方法 </category>
          
          <category> 前置基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最优化方法 </tag>
            
            <tag> 矩阵 </tag>
            
            <tag> 线性相关 </tag>
            
            <tag> 正定 </tag>
            
            <tag> 子空间 </tag>
            
            <tag> 基 </tag>
            
            <tag> 特征值 </tag>
            
            <tag> 特征向量 </tag>
            
            <tag> 二次型 </tag>
            
            <tag> 矩阵初等变换 </tag>
            
            <tag> 方阵的逆 </tag>
            
            <tag> 超平面 </tag>
            
            <tag> 多维向量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习基础知识</title>
      <link href="/2024/03/18/shen-du-xue-xi-ji-chu-zhi-shi/"/>
      <url>/2024/03/18/shen-du-xue-xi-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<p>#深度学习基础知识</p>]]></content>
      
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 损失函数 </tag>
            
            <tag> 激活函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp算法题之奇特的迷宫</title>
      <link href="/2024/03/18/cpp-suan-fa-ti-qi-te-de-mi-gong/"/>
      <url>/2024/03/18/cpp-suan-fa-ti-qi-te-de-mi-gong/</url>
      
        <content type="html"><![CDATA[<h1 id="蓝桥算法题奇特的迷宫">蓝桥算法题：奇特的迷宫</h1><p>题目来自蓝桥题库：<a href="https://www.lanqiao.cn/problems/1994/learning/?page=1&amp;first_category_id=1&amp;problem_id=1994">1.奇特的迷宫- 蓝桥云课 (lanqiao.cn)</a></p><h2 id="编号1994">编号：1994</h2><p><strong>题目：</strong></p><p>如以下图(a)所示的15行、15列的迷宫(相当于n=8)，迷宫中每个位置可能为S（表示起始位置）、D（表示目标位置）、1～9的数字，且S和D各只有1个。对于1～9的数字，表示从当前位置出发，可以沿上、下、左、右方向走的方格数（多一个、少一个方格都不行）；图(b)演示的是，数字2表示可以沿上、下、左、右方向走2个方格，到达的位置用星号（*）表示。从S出发，可以沿上、下、左、右方向走1个方格。现在要求从S到D的最少步数。</p><p><img src="/../images/lanqiao1994.jpg"></p><p><strong>输入描述：</strong></p><p>输入文件中包含多个测试数据。每个测试数据的第1行为一个整数n，2≤n≤10，表示迷宫的大小为2n-1行、2n-1列。接下来有2n-1行，为每行各位置上的数字（或者为S、D），第1行有1个字符，第2行有2个字符，…，第n行有n个字符，第n+1行有n-1个字符，…，第2n-1行有1个字符。输入文件中最后一行为0，表示测试数据结束。</p><p><strong>输出描述：</strong></p><p>对每个测试数据，如果能从S走到D，输出最少步数；否则（即从S走不到D），输出0。</p><p><strong>解答：</strong></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> g[<span class="number">2</span> * N][<span class="number">2</span> * N];</span><br><span class="line"><span class="type">int</span> d[<span class="number">2</span> * N][<span class="number">2</span> * N];</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = {{<span class="number">2</span>, <span class="number">0</span>}, {<span class="number">0</span>, <span class="number">2</span>}, {<span class="number">0</span>, <span class="number">-2</span>}, {<span class="number">-2</span>, <span class="number">0</span>}};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">//多组数据</span></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n) {</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="string">'.'</span>, <span class="built_in">sizeof</span>(g));</span><br><span class="line">        <span class="comment">//将地图存入二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">            <span class="type">int</span> l = n - i + <span class="number">1</span>;</span><br><span class="line">            string str;</span><br><span class="line">            cin &gt;&gt; str;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) {</span><br><span class="line">                g[i][l] = str[j];</span><br><span class="line">                l += <span class="number">2</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//将地图存入二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="type">int</span> l = i - n + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> s = n - (i - n);</span><br><span class="line">            string str;</span><br><span class="line">            cin &gt;&gt; str;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s; j++) {</span><br><span class="line">                g[i][l] = str[j];</span><br><span class="line">                l += <span class="number">2</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//将起点和终点下标计算出来</span></span><br><span class="line">        <span class="type">int</span> sx = <span class="number">0</span>, sy = <span class="number">0</span>, ex = <span class="number">0</span>, ey = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * n - <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">'S'</span>) {</span><br><span class="line">                    sx = i;</span><br><span class="line">                    sy = j;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">'D'</span>) {</span><br><span class="line">                    ex = i;</span><br><span class="line">                    ey = j;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//优先队列 存放了x,y,d1   x,y是下标  d1是到达该点的步数</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, vector&lt;pair&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; &gt; pq;</span><br><span class="line">        <span class="comment">//初始化到达所有下标的距离为0x3f3f3f3f表示无穷大无法到达</span></span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">        <span class="comment">//到起点的距离为0  因为开始就在起点</span></span><br><span class="line">        d[sx][sy] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//设置为1，因为从起点可以往上下左右走1步</span></span><br><span class="line">        g[sx][sy]=<span class="string">'1'</span>;</span><br><span class="line">        <span class="comment">//将起点加入到 队列中</span></span><br><span class="line">        pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="built_in">make_pair</span>(sx, sy)));</span><br><span class="line">        <span class="comment">//ans是记录到达终点的距离，初始无穷大，表示无法到达</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//BFS模板</span></span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">auto</span> cur = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> x = cur.second.first, y = cur.second.second, d1 = cur.first;</span><br><span class="line">            <span class="comment">//如果当前是终点，记录答案直接退出</span></span><br><span class="line">            <span class="keyword">if</span> (x == ex &amp;&amp; y == ey) {</span><br><span class="line">                ans = d1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//当前下标可以往上下左右走step步</span></span><br><span class="line">            <span class="type">int</span> step = (<span class="type">int</span>)(g[x][y] - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">                <span class="comment">//nx,ny表示新的下标</span></span><br><span class="line">                <span class="type">int</span> nx = x + dir[i][<span class="number">0</span>] * step;</span><br><span class="line">                <span class="type">int</span> ny = y + dir[i][<span class="number">1</span>] * step; </span><br><span class="line">                <span class="comment">//判断非法和边界情况的下标，不对就不执行下面代码</span></span><br><span class="line">                <span class="keyword">if</span> (nx &lt; <span class="number">1</span> || ny &lt; <span class="number">1</span> || nx &gt;= <span class="number">2</span> * n || ny &gt;= <span class="number">2</span> * n || g[nx][ny] == <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//如果到（nx ny 的步数) 大于 (x,y步数+1) ，表示可以把nx,ny步数更新的更小，同时把nx,ny加入到队列中</span></span><br><span class="line">                <span class="keyword">if</span> (d[nx][ny] &gt; d[x][y] + <span class="number">1</span>) {</span><br><span class="line">                    d[nx][ny] = d[x][y] + <span class="number">1</span>;</span><br><span class="line">                    pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(d[nx][ny], <span class="built_in">make_pair</span>(nx, ny)));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ans是记录到达终点的距离，初始无穷大，表示无法到达 ，如果到最后还是无法到达，输出0</span></span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> c/c++ </category>
          
          <category> BFS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树基于int类型key与Object类型value简单实现</title>
      <link href="/2024/03/18/binarysearchtree/"/>
      <url>/2024/03/18/binarysearchtree/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉搜索树基于int类型key与object类型value简单实现">二叉搜索树基于int类型key与Object类型value简单实现</h1><p><strong><em>403行代码没有一句废话,写的太累,后续闲下来了再补全注释与思路,后面可能还会实现基于泛型K,Vkey与value的实现</em></strong></p><p>以下只提供代码(部分方法使用递归与非递归两种方法实现):</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BSTree1</span> {</span><br><span class="line">    BSTNode root;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BSTNode</span> {</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        Object value;</span><br><span class="line">        BSTNode left;</span><br><span class="line">        BSTNode right;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BSTNode</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BSTNode</span><span class="params">(<span class="type">int</span> key, Object value)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BSTNode</span><span class="params">(<span class="type">int</span> key, Object value, BSTNode left, BSTNode right)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">查找关键字对应的值</span></span><br><span class="line"><span class="comment">递归实现</span></span><br><span class="line"><span class="comment">@param key - 关键字</span></span><br><span class="line"><span class="comment">@return 关键字对应的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*    </span></span><br><span class="line"><span class="comment">      public Object get(int key) {</span></span><br><span class="line"><span class="comment">          return doGet(root, key);</span></span><br><span class="line"><span class="comment">      }</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">      private Object doGet(BSTNode node, int key) {</span></span><br><span class="line"><span class="comment">          if (node == null) {</span></span><br><span class="line"><span class="comment">              return null;</span></span><br><span class="line"><span class="comment">          }</span></span><br><span class="line"><span class="comment">          if (node.key &lt; key) {</span></span><br><span class="line"><span class="comment">              return doGet(node.right, key);</span></span><br><span class="line"><span class="comment">          } else if (key &lt; node.key) {</span></span><br><span class="line"><span class="comment">              return doGet(node.left, key);</span></span><br><span class="line"><span class="comment">          } else {</span></span><br><span class="line"><span class="comment">              return node.value;</span></span><br><span class="line"><span class="comment">          }</span></span><br><span class="line"><span class="comment">      }</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     &lt;h3&gt;查找关键字对应的值&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">     非递归实现</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     <span class="doctag">@param</span> key 关键字</span></span><br><span class="line"><span class="comment">     <span class="doctag">@return</span> 关键字对应的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (node.key &lt; key) {</span><br><span class="line">                node = node.right;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; node.key) {</span><br><span class="line">                node = node.left;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> node.value;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 查找最小关键字对应的值</span></span><br><span class="line"><span class="comment">       * 递归实现</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> 关键字对应的值</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"><span class="comment">//    public Object min() {</span></span><br><span class="line"><span class="comment">//        return doMin(root);</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    private Object doMin(BSTNode node) {</span></span><br><span class="line"><span class="comment">//        if (node == null) {</span></span><br><span class="line"><span class="comment">//            return null;</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line"><span class="comment">//        if (node.left == null) {</span></span><br><span class="line"><span class="comment">//            return node.value;</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line"><span class="comment">//        return doMin(node.left);</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h3&gt;查找最小关键字对应的值&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">     * 非递归实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 关键字对应的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">min</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> min(root);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">min</span><span class="params">(BSTNode node)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="literal">null</span>) {</span><br><span class="line">            p = p.left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> p.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 查找最大关键字对应的值</span></span><br><span class="line"><span class="comment">       * 递归实现</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> 关键字对应的值</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> Object <span class="title function_">max</span><span class="params">()</span> {</span><br><span class="line">          <span class="keyword">return</span> doMax(root);</span><br><span class="line">      }</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">private</span> Object <span class="title function_">doMax</span><span class="params">(BSTNode node)</span>{</span><br><span class="line">          <span class="keyword">if</span> (node == <span class="literal">null</span>){</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">if</span> (node.right == <span class="literal">null</span>){</span><br><span class="line">              <span class="keyword">return</span> node.value;</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">return</span> doMax(node.right);</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h3&gt;查找最大关键字对应的值&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">     * 非递归实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 关键字对应的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">max</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> max(root);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">max</span><span class="params">(BSTNode node)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="keyword">while</span> (p.right != <span class="literal">null</span>) {</span><br><span class="line">            p = p.right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> p.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;H3&gt;存储关键字和对应值&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   关键字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, Object value)</span> {</span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) {</span><br><span class="line">            parent = node;</span><br><span class="line">            <span class="keyword">if</span> (node.key &lt; key) {</span><br><span class="line">                node = node.right;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; node.key) {</span><br><span class="line">                node = node.left;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                node.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">null</span>) {</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">BSTNode</span>(key, value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (key &lt; parent.key) {</span><br><span class="line">            parent.left = <span class="keyword">new</span> <span class="title class_">BSTNode</span>(key, value);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            parent.right = <span class="keyword">new</span> <span class="title class_">BSTNode</span>(key, value);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h3&gt;查找关键字的后驱值&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 情况1:节点有右子树,此时后任就是右子树的最小值&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 情况2:节点没有右子树,若离它最近的,自右而来的祖先就是后任</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 关键字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 前驱值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">successor</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">ancestorFromRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//这个循环先查找该key在树中是否存在</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (key &lt; p.key) {</span><br><span class="line">                ancestorFromRight = p;</span><br><span class="line">                p = p.left;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (p.key &lt; key) {</span><br><span class="line">                p = p.right;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (p.right != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> min(p.right);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ancestorFromRight != <span class="literal">null</span> ? ancestorFromRight.value : <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h3&gt;查找关键字的前继值&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 情况1:节点有左子树,此时前任就是左子树的最大值&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 情况2:节点没有左子树,若离它最近的,自左而来的祖先就是前任</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 关键字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 后继值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">predecessor</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            思路:</span></span><br><span class="line"><span class="comment">                先找当当前节点,如果没找到直接返回null</span></span><br><span class="line"><span class="comment">                然后判断第一种情况,当左子树不为null时,找到左子树中最大的并返回</span></span><br><span class="line"><span class="comment">                然后判断第二种情况,创建一个指针用于记录从左而来的祖先节点,最后如果从左而来的祖先节点不为null则返回</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">ancestorFromLeft</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//这个循环先查找该key在树中是否存在</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (key &lt; p.key) {</span><br><span class="line">                p = p.left;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (p.key &lt; key) {</span><br><span class="line">                ancestorFromLeft = p;</span><br><span class="line">                p = p.right;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (p.left != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> max(p.left);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ancestorFromLeft != <span class="literal">null</span> ? ancestorFromLeft.value : <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h3&gt;根据关键字删除&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">     * 非递归实现</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 情况1:删除节点没有左孩子,将右孩子托孤给Parent&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 情况2:删除节点没有右孩子,将左孩子托孤给Parent&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 情况3:删除的是叶子节点,这种情况处理方法可以涵盖到情况1,2中&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 情况4:删除节点的左右孩子都有,可以将它的后继节点(称为S) 托孤给Parent,再称S的父亲为SP,又分两种情况:&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;1:SP就是被删除节点,此时D与S紧邻,只需要将S托孤给Parent&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;2:SP不是被删除节点,此时D与S不相邻,此时需要将S的后代托孤给SP,再将S托孤给Parent&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 关键字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 被删除关键字对应的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">delete</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="comment">//首先也应该先找到该节点与该节点的父节点</span></span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//用于记录待删除节点的父亲</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (key &lt; p.key) {</span><br><span class="line">                parent = p;</span><br><span class="line">                p = p.left;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (p.key &lt; key) {</span><br><span class="line">                parent = p;</span><br><span class="line">                p = p.right;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//这是情况1</span></span><br><span class="line">        <span class="keyword">if</span> (p.left == <span class="literal">null</span>) {</span><br><span class="line">            shift(parent, p, p.right);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//这是情况2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.right == <span class="literal">null</span>) {</span><br><span class="line">            shift(parent, p, p.left);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//这是情况4</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//首先找到被删除节点的后继</span></span><br><span class="line">            <span class="type">BSTNode</span> <span class="variable">s</span> <span class="operator">=</span> p.right;</span><br><span class="line">            <span class="type">BSTNode</span> <span class="variable">sParent</span> <span class="operator">=</span> p; <span class="comment">//用来记录后继节点的父亲</span></span><br><span class="line">            <span class="keyword">while</span> (s.left != <span class="literal">null</span>) {</span><br><span class="line">                sParent = s;</span><br><span class="line">                s = s.left;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//循环结束后 s 就是后继节点</span></span><br><span class="line">            <span class="comment">//接下来判断是否需要处理被删除节点的后事</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                思路:</span></span><br><span class="line"><span class="comment">                    如果后继节点的sParent还是被删除节点,那么意味着被删除节点与后继节点紧邻,不用处理后事</span></span><br><span class="line"><span class="comment">                    如果后继节点的sParent不再是被删除节点,那么意味着被删除节点不与后继节点相邻,需要处理后事</span></span><br><span class="line"><span class="comment">                    因此先判断后继节点的sParent还是不是被删除节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//不相邻,处理后继节点的后事</span></span><br><span class="line">            <span class="keyword">if</span> (sParent != p) {</span><br><span class="line">                shift(sParent, s, s.right); <span class="comment">//s的后继节点不可能有左孩子,因为s就是最小的</span></span><br><span class="line">                s.right = p.right; <span class="comment">//改变指针,顶上去的后继节点的右指针应该指向被删除节点的右指针</span></span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//最后让后继节点顶上被删除节点就完成</span></span><br><span class="line">            shift(parent, p, s);</span><br><span class="line">            <span class="comment">//删除后,改变顶上来的节点的左右指针,指向被删除节点的左右孩子</span></span><br><span class="line">            s.left = p.left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> p.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 根据关键字删除</span></span><br><span class="line"><span class="comment">       * &lt;p&gt;递归实现&lt;/p&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> key 关键字</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> 被删除关键字对应的值</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> Object <span class="title function_">delete</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">          ArrayList&lt;Object&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//保存被删除节点的值</span></span><br><span class="line">          root = doDelete(root, key, result);</span><br><span class="line">          <span class="keyword">return</span> result.isEmpty() ? <span class="literal">null</span> : result.get(<span class="number">0</span>);</span><br><span class="line">      }</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      /**</span></span><br><span class="line"><span class="comment">       * 用于递归delete方法的内部方法</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * @param node 代表递归删除的起点</span></span><br><span class="line"><span class="comment">       * @param key  关键字</span></span><br><span class="line"><span class="comment">       * @return 被删除节点删除后剩下的孩子节点</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">private</span> BSTNode <span class="title function_">doDelete</span><span class="params">(BSTNode node, <span class="type">int</span> key, ArrayList&lt;Object&gt; result)</span> {</span><br><span class="line">          <span class="comment">//如下三个if条件在于找要删除节点</span></span><br><span class="line">          <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">if</span> (key &lt; node.key) {</span><br><span class="line">              node.left = doDelete(node.left, key, result);</span><br><span class="line">              <span class="keyword">return</span> node;</span><br><span class="line">          } <span class="keyword">else</span> <span class="keyword">if</span> (node.key &lt; key) {</span><br><span class="line">              node.right = doDelete(node.right, key, result);</span><br><span class="line">              <span class="keyword">return</span> node;</span><br><span class="line">          }</span><br><span class="line">          result.add(node.value);</span><br><span class="line">          <span class="comment">//如果执行到这里,代表已经找到了要删除节点</span></span><br><span class="line">          <span class="comment">//如果被删除节点只有一个孩子</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          if (node.left == null) {</span></span><br><span class="line"><span class="comment">              return node.right;</span></span><br><span class="line"><span class="comment">          }</span></span><br><span class="line"><span class="comment">          if (node.right == null) {</span></span><br><span class="line"><span class="comment">              return node.left;</span></span><br><span class="line"><span class="comment">          }</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          <span class="comment">//如果被删除节点有两个孩子</span></span><br><span class="line">          <span class="comment">//先找到后继节点,也就是右子树中最小的</span></span><br><span class="line"><span class="comment">//        BSTNode s = node.right;</span></span><br><span class="line">          <span class="comment">//一直向左走,走到头就是后继节点</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          while (s.left != null) {</span></span><br><span class="line"><span class="comment">              s = s.left;</span></span><br><span class="line"><span class="comment">          }</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          <span class="comment">//这里已经拿到了后继节点</span></span><br><span class="line">          <span class="comment">//顶上去之后,修改后继节点的指针</span></span><br><span class="line">          <span class="comment">//第四种情况,如果后继节点与被删除节点不相邻,那么应该先处理后继节点的后事</span></span><br><span class="line">          <span class="comment">//再次递归调用</span></span><br><span class="line"><span class="comment">//        s.right = doDelete(node.right, s.key, new ArrayList&lt;&gt;());</span></span><br><span class="line"><span class="comment">//        s.left = node.left;</span></span><br><span class="line">          <span class="comment">//最后返回s,也就是被删除节点剩下的孩子节点</span></span><br><span class="line"><span class="comment">//        return s;</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 托孤方法,用于将被删除节点的子树移交给被删除节点的父节点&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent  被删除节点的父节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> deleted 要被删除的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> child   被顶上去的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">shift</span><span class="params">(BSTNode parent, BSTNode deleted, BSTNode child)</span> {</span><br><span class="line">        <span class="comment">//如果被删除节点本身就是根节点,那么被删除节点没有parent,直接将被删除节点的child变为root</span></span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">null</span>) {</span><br><span class="line">            root = child;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (deleted == parent.left) {</span><br><span class="line">            parent.left = child;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            parent.right = child;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Java </category>
          
          <category> 二叉搜索树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉搜索树 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个重要的反常积分</title>
      <link href="/2024/03/18/yi-ge-chong-yao-de-fan-chang-ji-fen/"/>
      <url>/2024/03/18/yi-ge-chong-yao-de-fan-chang-ji-fen/</url>
      
        <content type="html"><![CDATA[<h1 id="一个重要的反常积分">一个重要的反常积分</h1><p>本文主要写一下反常积分<span class="math inline">\(\begin{aligned} A&amp; =\int_0^{+\infty} e^{-x^2} dx\end{aligned}\)</span>的结果及他(或变形)的计算方法，<span class="math inline">\(\begin{aligned} \int_0^{+\infty} e^{-x^2} dx\end{aligned}\)</span>是一个非常重要的反常积分，在高数、概率论中有重要的应用。</p><h2 id="方法一二重积分">方法一：二重积分</h2><p><span class="math display">\[\begin{align}A&amp;=\int_0^{+\infty} e^{-x^2} d x \\ &amp;=\sqrt{\left(\int_0^{+\infty} e^{-x^2} d x \cdot \int_0^{+\infty}e^{-x^2} d x\right)} \\ &amp; =\sqrt{\left(\int_0^{+\infty} e^{-x^2} d x\cdot \int_0^{+\infty} e^{-y^2} d y\right)} \\ &amp;=\sqrt{\int_0^{+\infty} \int_0^{+\infty} e^{-\left(x^2+y^2\right)} d x dy}\end{align}\]</span></p><blockquote><p>import 夹逼定理</p></blockquote><p>​这个样子就非常非常像一个二重积分的样子了，可以利用二重积分的计算方法进行计算：</p><figure><img src="../../../../images/一个重要的反常积分/p1.jpg" alt="p1.jpg"><figcaption aria-hidden="true">p1.jpg</figcaption></figure><p>​ 如上图所示，设： <span class="math display">\[\begin{aligned} &amp; D_1=\left\{(x, y) \mid x^2+y^2 \leqslant R^2, x\geqslant 0, y \geqslant 0\right\} \\ &amp; \left.D_2=\{x, y) \midx^2+y^2 \leqslant 2 R^2, x \geqslant 0, y \geqslant 0\right\} \\ &amp;S=\{(x, y) \mid 0 \leqslant x \leqslant R, 0 \leqslant y \leqslantR\}\end{aligned}\]</span> ​ 显然有：<span class="math inline">\(D_1 \subset S \subsetD_2\)</span>。</p><p>​ 因为：<span class="math inline">\(e^{-x^2-y^2}&gt;0\)</span>，所以：<span class="math display">\[\iint_{D_1} e^{-x^2-y^2} d x d y \leq \iint_S e^{-x^2-y^2} d x d y \leq\iint_{D_2} e^{-x^2-y^2} d x d y\]</span> ​ 分别对<span class="math inline">\(S、D_1、D_2\)</span>积分：<span class="math display">\[\left\{\begin{array}{l}\displaystyle I=\iint_S e^{-x^2-y^2} d x d y=\int_0^R e^{-x^2} d x\int_0^R e^{-y^2} d y=\left(\int_0^R e^{-x^2} d x\right)^2\\\displaystyle I_1=\iint_{D_1} e^{-x^2-y^2} d x dy=\frac{\pi}{4}\left(1-e^{-R^2}\right) \\\displaystyle I_2=\iint_{D_2}e^{-x^2-y^2} d x d y=\frac{\pi}{4}\left(1-e^{-2 R^2}\right)\end{array}\right.\]</span> ​ 有不等关系：<span class="math inline">\(I_1&lt;I&lt;I_2\)</span>。</p><p>​ 当<span class="math inline">\(R \rightarrow\infty\)</span> 时, <span class="math inline">\(I_1 \rightarrow \dfrac{\pi}{4}, I_2 \rightarrow\dfrac{\pi}{4}\)</span>，由<mark class="hl-label blue">夹逼定理</mark>  ：</p><p>​ 当<span class="math inline">\(R \rightarrow\infty\)</span> 时, <span class="math inline">\(I\rightarrow \dfrac{\pi}{4}\)</span>。即：<span class="math inline">\(\begin{aligned} \left(\int_0^{+\infty} e^{-x^2} dx\right)^2\end{aligned}=\dfrac{\pi}{4}\)</span>。</p><p>​ 所以<span class="math inline">\(\begin{aligned} A &amp;=\int_0^{+\infty} e^{-x^2} dx\end{aligned}=\dfrac{\sqrt{\pi}}{2}\)</span></p><blockquote><p>import 极坐标</p></blockquote><p>​ 也可以理解成这是在极坐标下对一个半径为<span class="math inline">\(+\infty\)</span>，在第一象限的扇形进行积分，设<span class="math inline">\(r^2=(x^2+y^2)\)</span>，也就是： <span class="math display">\[\begin{align}A^2&amp;= \int_0^{\frac{\pi}{2}} d\theta \int_0^{+\infty} e^{-r^2} r dr\\&amp;= \dfrac{\pi}{2} \int_0^{+\infty} e^{-r^2} r dr \\ &amp;=\dfrac{\pi}{4} \int_0^{+\infty} e^{-u} du \quad(u=r^2) \\&amp;=\dfrac{\pi}{4}\end{align}\]</span> ​ 所以<span class="math inline">\(\begin{aligned} A &amp;=\int_0^{+\infty} e^{-x^2} dx\end{aligned}=\dfrac{\sqrt{\pi}}{2}\)</span></p><h2 id="方法二标准正态分布">方法二：标准正态分布</h2><p>设<span class="math inline">\(r.v.X \simN\left(0,1\right)\)</span>，则<span class="math inline">\(X\)</span>的密度函数为： <span class="math display">\[p(x)=\frac{1}{\sqrt{2 \pi }} e^{-\frac{x^2}{2}},-\infty&lt;x&lt;+\infty\]</span> 由密度函数的正则性： <span class="math display">\[\int_0^{+\infty} \varphi(x) d x=\int_0^{+\infty} \frac{1}{\sqrt{2 \pi}}e^{-\frac{x^2}{2}} d x=\frac{1}{2}\]</span> 移项得：<span class="math inline">\(\begin{aligned} A &amp;=\int_0^{+\infty} e^{-x^2} dx\end{aligned}=\dfrac{\sqrt{\pi}}{2}\)</span></p><h2 id="方法三gamma函数">方法三：<span class="math inline">\(Gamma\)</span>函数</h2><p>​ <span class="math inline">\(Gamma\)</span>函数是一个特殊的函数，它的定义如下：<span class="math display">\[\Gamma(z)=\int_0^{\infty} t^{z-1} e^{-t} \mathrm{~d} t\]</span> ​ 在这里只介绍<span class="math inline">\(Gamma\)</span>函数的几个性质：</p><p>​ <code>性质1.</code><span class="math inline">\(\Gamma(z)\)</span>与阶乘的关系</p><p><span class="math display">\[\begin{aligned} \Gamma(z) &amp; =\int_0^{\infty} t^{z-1} e^{-t} d t \\&amp; =\left.t^{z-1}\left(-e^{-t}\right)\right|_0 ^{\infty}+(z-1)\int_0^{\infty} t^{z-2} e^{-t} d t \\ &amp; =(z-1) \int_0^{\infty}t^{(z-1)-1} e^{-t} d t \\ &amp; =(z-1) \Gamma(z-1)\end{aligned}\]</span> ​ 令<span class="math inline">\(z=1\)</span>有： <span class="math display">\[\Gamma(1)=\int_0^{\infty} e^{-t} \mathrm{~d} t=-\left.e^{-t}\right|_0^{\infty}=1\]</span> ​ <strong>当<span class="math inline">\(z\)</span>为整数时</strong>，有：<span class="math inline">\(\Gamma(z+1)=z\Gamma(z)=z(z-1)\Gamma(z-2)=\cdots=z(z-1)(z-2)\cdots1=z!\)</span></p><p>​ <code>性质2.</code><span class="math inline">\(\Gamma(\dfrac{1}{2})=\sqrt\pi\)</span> <span class="math display">\[\begin{aligned}    \Gamma(1/2)&amp;= \int_0^{+\infty} x^{-1/2} e^{-x} dx \\&amp;=\int_0^{+\infty} t^{-1} e^{-t^2} dt^2 \\ &amp;= \int_0^{+\infty} 2e^{-t^2} dt \\ &amp;= 2\cdot \dfrac{\sqrt\pi}{2} \\ &amp;= \sqrt\pi\end{aligned}\]</span> ​ 利用<span class="math inline">\(Gamma\)</span>函数计算一些变形式子的积分值： <span class="math display">\[\begin{aligned} &amp; \int_0^{+\infty} {x}^3 \mathrm{e}^{-2 {x}}{dx}=\frac{1}{16} \int_0^{+\infty}(2 {x})^3 \mathrm{e}^{-2{x}}\mathrm{d}(2 {x})=\frac{1}{16} \Gamma(3+1)=\frac{3 !}{16}=\frac{3}{8} \\&amp; \int_0^{+\infty} {x}^4 \mathrm{e}^{-{x}^2} {dx}=\frac{1}{2}\int_0^{+\infty}\left({x}^2\right)^{\frac{3}{2}}\mathrm{e}^{-{x}^2}{dx}=\frac{1}{2}\Gamma\left(\frac{3}{2}+1\right)=\frac{1}{2} \frac{3}{2}\Gamma\left(\frac{1}{2}+1\right)=\frac{1}{2} \frac{3}{2} \frac{1}{2}\Gamma\left(\frac{1}{2}\right)=\frac{1}{2} \frac{3}{2} \frac{1}{2}\sqrt{\pi}=\frac{3}{8} \sqrt{\pi}\end{aligned}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 杂但重要的文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反常积分 </tag>
            
            <tag> 二重积分 </tag>
            
            <tag> 夹逼定理 </tag>
            
            <tag> 正态分布 </tag>
            
            <tag> gamma函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二节 偏导数</title>
      <link href="/2024/03/17/9-2-pian-dao-shu/"/>
      <url>/2024/03/17/9-2-pian-dao-shu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iiaW51si6lbg">下载PDF点这里</a></p><figure><img src="../../../../images/9-2偏导数/47.jpg" alt="47.jpg"><figcaption aria-hidden="true">47.jpg</figcaption></figure><figure><img src="../../../../images/9-2偏导数/48.jpg" alt="48.jpg"><figcaption aria-hidden="true">48.jpg</figcaption></figure><figure><img src="../../../../images/9-2偏导数/49.jpg" alt="49.jpg"><figcaption aria-hidden="true">49.jpg</figcaption></figure><figure><img src="../../../../images/9-2偏导数/50.jpg" alt="50.jpg"><figcaption aria-hidden="true">50.jpg</figcaption></figure><figure><img src="../../../../images/9-2偏导数/51.jpg" alt="51.jpg"><figcaption aria-hidden="true">51.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第九章 多元函数微分法及其应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多元函数 </tag>
            
            <tag> 偏导数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一节 多元函数的基本概念</title>
      <link href="/2024/03/17/9-1-duo-yuan-han-shu-de-ji-ben-gai-nian/"/>
      <url>/2024/03/17/9-1-duo-yuan-han-shu-de-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iHV6q1si4t6h">下载PDF点这里</a></p><figure><img src="../../../../images/9-1多元函数的基本概念/39.jpg" alt="39.jpg"><figcaption aria-hidden="true">39.jpg</figcaption></figure><figure><img src="../../../../images/9-1多元函数的基本概念/40.jpg" alt="40.jpg"><figcaption aria-hidden="true">40.jpg</figcaption></figure><figure><img src="../../../../images/9-1多元函数的基本概念/41.jpg" alt="41.jpg"><figcaption aria-hidden="true">41.jpg</figcaption></figure><figure><img src="../../../../images/9-1多元函数的基本概念/42.jpg" alt="42.jpg"><figcaption aria-hidden="true">42.jpg</figcaption></figure><figure><img src="../../../../images/9-1多元函数的基本概念/43.jpg" alt="43.jpg"><figcaption aria-hidden="true">43.jpg</figcaption></figure><figure><img src="../../../../images/9-1多元函数的基本概念/44.jpg" alt="44.jpg"><figcaption aria-hidden="true">44.jpg</figcaption></figure><figure><img src="../../../../images/9-1多元函数的基本概念/45.jpg" alt="45.jpg"><figcaption aria-hidden="true">45.jpg</figcaption></figure><figure><img src="../../../../images/9-1多元函数的基本概念/46.jpg" alt="46.jpg"><figcaption aria-hidden="true">46.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第九章 多元函数微分法及其应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多元函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二节 微积分基本公式</title>
      <link href="/2024/03/17/yi-yuan-wei-ji-fen-5-2-wei-ji-fen-ji-ben-gong-shi/"/>
      <url>/2024/03/17/yi-yuan-wei-ji-fen-5-2-wei-ji-fen-ji-ben-gong-shi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iJ4z91smgcqb">下载PDF点这里</a></p><figure><img src="../../../../images/一元微积分5-2微积分基本公式/104.jpg" alt="104.jpg"><figcaption aria-hidden="true">104.jpg</figcaption></figure><figure><img src="../../../../images/一元微积分5-2微积分基本公式/105.jpg" alt="105.jpg"><figcaption aria-hidden="true">105.jpg</figcaption></figure><figure><img src="../../../../images/一元微积分5-2微积分基本公式/106.jpg" alt="106.jpg"><figcaption aria-hidden="true">106.jpg</figcaption></figure><figure><img src="../../../../images/一元微积分5-2微积分基本公式/107.jpg" alt="107.jpg"><figcaption aria-hidden="true">107.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 一元微积分 </category>
          
          <category> 第五章 定积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 定积分 </tag>
            
            <tag> 牛顿-莱布尼茨公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零篇 数列递推</title>
      <link href="/2024/03/17/shu-lie-di-tui/"/>
      <url>/2024/03/17/shu-lie-di-tui/</url>
      
        <content type="html"><![CDATA[<h1 id="第零篇-数列递推">第零篇 数列递推</h1><h2 id="partⅰ-一阶常系数线性齐次递推">PartⅠ 一阶常系数线性齐次递推</h2><p>​ 若数列<span class="math inline">\(\{a_n\}\)</span>满足以下形式：<span class="math display">\[a_{n+1}=pa_n+q\quad(p\neq0)\]</span> ​ 其中<span class="math inline">\(p、q\)</span>为给定的实数，数列首项为<span class="math inline">\(a_1\)</span>。</p><p>​ 称这个数列满足一阶常系数线性齐次递推的形式。</p><p>​ 这种数列的通项公式很容易求，可以分成两种情况：</p><p>​ <code>1.</code> 若<span class="math inline">\(p=1\)</span>，则<span class="math inline">\(a_{n+1}=a_{n}+q\)</span>，此时数列为一个公差为<span class="math inline">\(q\)</span>的等差数列，容易推得： <span class="math display">\[a_n=a_1+(n-1)q\]</span></p><p>​ <code>2.</code> 若<span class="math inline">\(p\neq1\)</span>，则可以通过<strong>待定系数法</strong> 来构造等比数列：假设存在一个系数<span class="math inline">\(A\)</span>，使得<span class="math inline">\(a_{n+1}=pa_n+q\)</span>可以写成<span class="math inline">\(a_{n+1}-A=p(a_n-A)\)</span>的形式，这样做的目的是为了转换成一个等比数列的形式，之后就可以进行递推来求解数列通项。</p><p>​ 将<span class="math inline">\(a_{n+1}-A=p(a_n-A)\)</span>展开：<span class="math inline">\(a_{n+1}=pa_n+(1-p)A\)</span>与<span class="math inline">\(a_{n+1}=pa_n+q\)</span>对比，解出系数<span class="math inline">\(A=\dfrac{q}{1-p}\)</span>。</p><p>​ 所以<span class="math inline">\(\left\{a_{n+1}-\dfrac{q}{1-p}\right\}\)</span>是首项为<span class="math inline">\(a_1-\dfrac{q}{1-p}\)</span>，公比为<span class="math inline">\(q\)</span>的等比数列，由等比数列递推公式(累乘)：<span class="math display">\[a_n=\dfrac{a_n}{a_{n-1}}\times\dfrac{a_{n-1}}{a_{n-2}}\times\cdots\times\dfrac{a_2}{a_{1}}\times{a_1}\]</span> ​ 可以推出：<span class="math inline">\(a_n-\dfrac{q}{1-p}=\left(a_1-\dfrac{q}{1-p}\right)q^{n-1}\)</span>，进而求得：<span class="math display">\[a_n=\left(a_1-\dfrac{q}{1-p}\right)p^{n-1}+\dfrac{q}{1-p}\]</span></p><h2 id="partⅱ-二阶常系数线性齐次递推">PartⅡ 二阶常系数线性齐次递推</h2><p>​ 若数列<span class="math inline">\(\{x_n\}\)</span>满足以下形式：<span class="math display">\[x_{n+1}=px_{n}+qx_{n-1}\quad(p、q\neq0)\]</span> ​ 其中<span class="math inline">\(p、q\)</span>为给定的实数，数列第一项和第二项分别为<span class="math inline">\(x_1\)</span>和<span class="math inline">\(x_2\)</span>。</p><p>​ 称这个数列满足二阶常系数线性齐次递推的形式。</p><p>​类比于一阶递推形式中构造等比数列的方法，我们还是尝试<strong>待定系数法</strong>构造这样的等比数列：</p><p>​ 假设存在实数<span class="math inline">\(a、b\)</span>，使得<span class="math inline">\(x_{n+1}=px_{n}+qx_{n-1}\)</span>可以写成<span class="math inline">\(x_{n+1}-ax_{n}=b(x_{n}-ax_{n-1})\)</span>，整理一下：<span class="math inline">\(x_{n+1}=(a+b)x_{n}-abx_{n-1}\)</span>，对比系数有：<span class="math display">\[\left\{\begin{array}{2}a+b=p \\ ab=-q\end{array}\right.\]</span> ​ 这个形式就非常像初中学过的一元二次方程，实数<span class="math inline">\(a、b\)</span>是方程<span class="math inline">\(x^2-px-q=0\)</span>的解。</p><p>​ <code>1.</code>方程解不相等<span class="math inline">\((a\neqb)\)</span>时：</p><p>​ 所以<span class="math inline">\(\{x_{n+1}-ax_n\}\)</span>是公比为<span class="math inline">\(b\)</span>的等比数列，由累乘得到：<span class="math inline">\(x_{n+1}-ax_n=(x_2-ax_1)b^{n-1}\)</span></p><p>​ <span class="math inline">\(x_{n+1}-ax_{n}=b(x_{n}-ax_{n-1})\)</span>还可以写成<span class="math inline">\(x_{n+1}-bx_{n}=a(x_{n}-bx_{n-1})\)</span>的形式，因此<span class="math inline">\(\{x_{n+1}-bx_n\}\)</span>是公比为<span class="math inline">\(a\)</span>的等比数列，累乘得到：<span class="math inline">\(x_{n+1}-bx_n=(x_2-bx_1)a^{n-1}\)</span></p><p>​ 将累乘得到的两个式子相减有： <span class="math display">\[x_n=\dfrac{x_2-bx_1}{a-b}\cdot a^{n-1}+\dfrac{x_2-ax_1}{b-a}\cdotb^{n-1}\]</span> ​ 为了便于记忆，我们令<span class="math inline">\(\left\{\begin{array}{2}\alpha=\dfrac{x_2-bx_1}{a-b}\cdot\dfrac{1}{a}\\\beta=\dfrac{x_2-ax_1}{b-a}\cdot\dfrac{1}{b}\end{array}\right.\)</span>，所以<span class="math inline">\(x_n = \alpha \cdot a^{n}+\beta\cdotb^{n}\)</span>。</p><p>​ 解题时只需要根据数列<span class="math inline">\(\{x_n\}\)</span>的递推公式写出相应的特征方程，得到解<span class="math inline">\(a、b\)</span>，再根据<span class="math inline">\(x_1、x_2\)</span>待定系数求解出<span class="math inline">\(\alpha、\beta\)</span>即可得到该数列通项公式。下面是一个例子：</p><p>​ <span class="math inline">\(Fibonacci\)</span>数列是大家非常熟悉的一个数列，它满足这样的条件：<span class="math inline">\(a_1=a_2=1\)</span>，<span class="math inline">\(a_{n+1}=a_n+a_{n-1}\)</span>，求<span class="math inline">\(Fibonacci\)</span>数列的通项公式。</p><p>​ 由递推关系式：<span class="math inline">\(a_{n+1}=a_n+a_{n-1}\)</span>得到特征方程：<span class="math inline">\(x^2-x-1=0\)</span>。</p><p>​ 这个方程的解为：<span class="math inline">\(a=\dfrac{\sqrt5+1}{2}\)</span>，<span class="math inline">\(b=\dfrac{-\sqrt5+1}{2}\)</span></p><p>​ 所以他的通项公式可以写成：<span class="math inline">\(x_n = \alpha\cdot \left( \dfrac{\sqrt{5}+1}{2} \right)^{n-1} + \beta \cdot \left(\dfrac{-\sqrt{5}+1}{2} \right)^{n-1}\)</span></p><p>​ 代入<span class="math inline">\(a_1=a_2=1\)</span>，解出<span class="math inline">\(\alpha=\dfrac{1}{\sqrt5}\)</span>，<span class="math inline">\(\beta=-\dfrac{1}{\sqrt5}\)</span>。</p><p>​ 所以<span class="math inline">\(Fibonacci\)</span>数列的通项为：$x_n = $</p><p>​</p><p>​ <code>2.</code>方程解相等<span class="math inline">\((a=b)\)</span>时：</p><p>​ <span class="math inline">\(x_{n+1}=px_{n}+qx_{n-1}\)</span>可以写成<span class="math inline">\(x_{n+1}-bx_{n}=b(x_{n}-bx_{n-1})\)</span>，对<span class="math inline">\(\{x_{n+1}-bx_n\}\)</span>​这个数列进行累乘得：<span class="math display">\[x_{n+1}-bx_n=b^{n-1}(x_2-bx_1)\]</span> ​ 两边同时除以<span class="math inline">\(b^{n+1}\)</span>有：</p><p>​<br><span class="math display">\[\dfrac{x_{n+1}}{b^{n+1}}-\dfrac{x_{n}}{b^{n}}=\dfrac{x_{2}}{b^2}-\dfrac{x_1}{b}\]</span> ​ 这说明数列<span class="math inline">\(\left\{\dfrac{x_{n}}{b^{n}}\right\}\)</span>是一个等差数列，公差为<span class="math inline">\(\dfrac{x_{2}}{b^2}-\dfrac{x_1}{b}\)</span>。</p><p>​ 由此可以求得：<span class="math inline">\(\dfrac{x_{n}}{b^{n}}=(n-1)\left(\dfrac{x_{2}}{b^{2}}-\dfrac{x_{1}}{b}\right)+\dfrac{x_{1}}{b}\)</span>，</p><p>​ 所以：<span class="math inline">\(x_n=x_1 \cdotb^{n-1}+(x_2-bx_1)(n-1)\cdot b^{n-2}\)</span>，</p><p>​ 整理一下，<span class="math inline">\(x_n=\left[\left(\dfrac{x_{1}}{b}-\dfrac{x_{2}}{b^2}+\dfrac{1}{b}\right)+\left(\dfrac{-x_{1}}{b}+\dfrac{-x_{2}}{b^2}\right)n\right]b^n\)</span>。</p><p>​ 同理我们可以令<span class="math inline">\(\left\{\begin{array}{2}\alpha=\dfrac{x_{1}}{b}-\dfrac{x_{2}}{b^2}+\dfrac{1}{b}\\\beta=\dfrac{-x_{1}}{b}+\dfrac{-x_{2}}{b^2}\end{array}\right.\)</span>，所以<span class="math inline">\(x_n=(\alpha+\beta n)\cdot b^n\)</span>。</p><p>​ 解题时只需要待定系数求出<span class="math inline">\(\alpha、\beta\)</span>即可得到通项公式。</p><h2 id="partⅲ-从递推到矩阵">PartⅢ 从递推到矩阵</h2><p>​上面都是低阶的问题，如果碰到更高阶的常系数线性齐次递推式子呢？由于是预备知识，在这里不详述，可以先看下面这一篇知乎上的文章↓：</p><p>​ <a href="https://zhuanlan.zhihu.com/p/33854447">二阶常系数齐次线性递推数列- 知乎 (zhihu.com)</a></p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 大学数学预备知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递推 </tag>
            
            <tag> 常系数线性齐次 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零篇 认识深度学习</title>
      <link href="/2024/03/17/di-ling-pian-ren-shi-shen-du-xue-xi/"/>
      <url>/2024/03/17/di-ling-pian-ren-shi-shen-du-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="第零篇-初识深度学习">第零篇 初识深度学习</h1>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
          <category> 深度学习简介 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 什么是深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

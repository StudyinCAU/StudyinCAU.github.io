<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第八节 一般周期函数的傅里叶级数</title>
      <link href="/2024/04/17/duo-yuan-wei-ji-fen-12-8-yi-ban-zhou-qi-han-shu-de-fu-li-xie-ji-shu/"/>
      <url>/2024/04/17/duo-yuan-wei-ji-fen-12-8-yi-ban-zhou-qi-han-shu-de-fu-li-xie-ji-shu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iPhKR1vdvfna">下载PDF点这里</a></p><p><img src="../../../../images/多元微积分12-8一般周期函数的傅里叶级数/96.jpg"></p><p><img src="../../../../images/多元微积分12-8一般周期函数的傅里叶级数/97.jpg"></p><p><img src="../../../../images/多元微积分12-8一般周期函数的傅里叶级数/98.jpg"></p><p><img src="../../../../images/多元微积分12-8一般周期函数的傅里叶级数/99.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十二章 无穷级数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 傅里叶级数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七节 傅里叶级数</title>
      <link href="/2024/04/17/duo-yuan-wei-ji-fen-12-7-fu-li-xie-ji-shu/"/>
      <url>/2024/04/17/duo-yuan-wei-ji-fen-12-7-fu-li-xie-ji-shu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iRay91vdukab">下载PDF点这里</a></p><p><img src="../../../../images/多元微积分12-7傅里叶级数/87.jpg"></p><p><img src="../../../../images/多元微积分12-7傅里叶级数/88.jpg"></p><p><img src="../../../../images/多元微积分12-7傅里叶级数/89.jpg"></p><p><img src="../../../../images/多元微积分12-7傅里叶级数/90.jpg"></p><p><img src="../../../../images/多元微积分12-7傅里叶级数/91.jpg"></p><p><img src="../../../../images/多元微积分12-7傅里叶级数/92.jpg"></p><p><img src="../../../../images/多元微积分12-7傅里叶级数/93.jpg"></p><p><img src="../../../../images/多元微积分12-7傅里叶级数/94.jpg"></p><p><img src="../../../../images/多元微积分12-7傅里叶级数/95.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十二章 无穷级数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 傅里叶级数 </tag>
            
            <tag> 延拓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五节 函数的幂级数展开式的应用</title>
      <link href="/2024/04/17/duo-yuan-wei-ji-fen-12-5-han-shu-de-mi-ji-shu-zhan-kai-shi-de-ying-yong/"/>
      <url>/2024/04/17/duo-yuan-wei-ji-fen-12-5-han-shu-de-mi-ji-shu-zhan-kai-shi-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iySGx1vdu81a">下载PDF点这里</a></p><p><img src="../../../../images/多元微积分12-5函数的幂级数展开式的应用/77.jpg"></p><p><img src="../../../../images/多元微积分12-5函数的幂级数展开式的应用/78.jpg"></p><p><img src="../../../../images/多元微积分12-5函数的幂级数展开式的应用/79.jpg"></p><p><img src="../../../../images/多元微积分12-5函数的幂级数展开式的应用/80.jpg"></p><p><img src="../../../../images/多元微积分12-5函数的幂级数展开式的应用/81.jpg"></p><p><img src="../../../../images/多元微积分12-5函数的幂级数展开式的应用/82.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十二章 无穷级数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 幂级数 </tag>
            
            <tag> 欧拉公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四节 函数展开成幂级数</title>
      <link href="/2024/04/16/duo-yuan-wei-ji-fen-12-4-han-shu-zhan-kai-cheng-mi-ji-shu/"/>
      <url>/2024/04/16/duo-yuan-wei-ji-fen-12-4-han-shu-zhan-kai-cheng-mi-ji-shu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iCY3A1vdtvef">下载PDF点这里</a></p><p><img src="../../../../images/多元微积分12-4函数展开成幂级数/71.jpg"></p><p><img src="../../../../images/多元微积分12-4函数展开成幂级数/72.jpg"></p><p><img src="../../../../images/多元微积分12-4函数展开成幂级数/73.jpg"></p><p><img src="../../../../images/多元微积分12-4函数展开成幂级数/74.jpg"></p><p><img src="../../../../images/多元微积分12-4函数展开成幂级数/75.jpg"></p><p><img src="../../../../images/多元微积分12-4函数展开成幂级数/76.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十二章 无穷级数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 幂级数 </tag>
            
            <tag> 麦克劳林展开式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三节 幂级数</title>
      <link href="/2024/04/16/duo-yuan-wei-ji-fen-12-3-mi-ji-shu/"/>
      <url>/2024/04/16/duo-yuan-wei-ji-fen-12-3-mi-ji-shu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iTN0y1vdtieh">下载PDF点这里</a></p><p><img src="../../../../images/多元微积分12-3幂级数/63.jpg"></p><p><img src="../../../../images/多元微积分12-3幂级数/64.jpg"></p><p><img src="../../../../images/多元微积分12-3幂级数/65.jpg"></p><p><img src="../../../../images/多元微积分12-3幂级数/66.jpg"></p><p><img src="../../../../images/多元微积分12-3幂级数/67.jpg"></p><p><img src="../../../../images/多元微积分12-3幂级数/68.jpg"></p><p><img src="../../../../images/多元微积分12-3幂级数/69.jpg"></p><p><img src="../../../../images/多元微积分12-3幂级数/70.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十二章 无穷级数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 幂级数 </tag>
            
            <tag> 阿贝尔定理 </tag>
            
            <tag> 收敛半径 </tag>
            
            <tag> 收敛域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学生成绩管理系统</title>
      <link href="/2024/04/16/xue-sheng-cheng-ji-guan-li-xi-tong/"/>
      <url>/2024/04/16/xue-sheng-cheng-ji-guan-li-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="学生成绩管理系统">学生成绩管理系统</h1><p><strong>系统功能：</strong></p><ol type="1"><li>成绩录入</li><li>成绩输出</li><li>成绩查询</li><li>成绩排序</li><li>身份验证</li></ol><h2 id="原来c语言代码为">原来c语言代码为：</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*******************************************************************</span></span><br><span class="line"><span class="comment">*名    称：学生成绩管理系统1.0                         *</span></span><br><span class="line"><span class="comment">*创建日期：2023-4-3                                 *</span></span><br><span class="line"><span class="comment">*最后修改：2023-4-3                                *</span></span><br><span class="line"><span class="comment">*版    权：中国农业大学信息与电气工程学院           *</span></span><br><span class="line"><span class="comment">*版 本 号：1.0                                      *</span></span><br><span class="line"><span class="comment">*******************************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 20   <span class="comment">//数组的长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">功能:显示菜单</span></span><br><span class="line"><span class="comment">参数：无</span></span><br><span class="line"><span class="comment">返回值：无</span></span><br><span class="line"><span class="comment">*******************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">displayMenu</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"++++++++++++++++++++++++++++++++++++++++++++++++++++\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"+                 学生成绩管理系统                 +\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"+                                                  +\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"+                    1. 录入                       +\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"+                    2. 输出                       +\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"+                    3. 查询                       +\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"+                    4. 排序                       +\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"+                    5. 结束                       +\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"+                                                  +\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"++++++++++++++++++++++++++++++++++++++++++++++++++++\n"</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">功能:登陆函数，验证口令</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">类型：char []</span></span><br><span class="line"><span class="comment">说明：用户输入口令</span></span><br><span class="line"><span class="comment">返回值：1或0</span></span><br><span class="line"><span class="comment">类型：int</span></span><br><span class="line"><span class="comment">说明：1表示通过验证；0表示没有通过</span></span><br><span class="line"><span class="comment">*******************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">login</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> password[<span class="number">8</span>];<span class="comment">/*用户输入的口令*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> key[<span class="number">8</span>] = <span class="string">"1234"</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*====验证用户的口令，如果三次输入均错误，则不允许进入系统====*/</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line">count++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入口令："</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;password;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(password, key) == <span class="number">0</span>)</span><br><span class="line">s = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">s = <span class="number">0</span>;</span><br><span class="line">} <span class="keyword">while</span> (s == <span class="number">0</span> &amp;&amp; count &lt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">功能:输入学生成绩到数组中</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">参数1：score[]</span></span><br><span class="line"><span class="comment">类型：int []</span></span><br><span class="line"><span class="comment">说明：学生成绩数组</span></span><br><span class="line"><span class="comment">参数2：length</span></span><br><span class="line"><span class="comment">类型：int</span></span><br><span class="line"><span class="comment">说明：要输入的学生成绩数组的长度</span></span><br><span class="line"><span class="comment">返回值：i</span></span><br><span class="line"><span class="comment">类型：int</span></span><br><span class="line"><span class="comment">说明：实际成绩数组的有效值个数</span></span><br><span class="line"><span class="comment">*******************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inputScore</span><span class="params">(<span class="type">int</span> score[], <span class="type">int</span> length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> tmp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入学生的成绩（以-1结束输入):\n"</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">"个学生："</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line"><span class="keyword">if</span> (tmp &gt;= <span class="number">0</span> &amp;&amp; tmp &lt;= <span class="number">100</span>)</span><br><span class="line">{</span><br><span class="line">score[i] = tmp;</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line">} <span class="keyword">while</span> (tmp != <span class="number">-1</span> &amp;&amp; i &lt; length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">功能:输出数组中的学生成绩</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">参数1：score[]</span></span><br><span class="line"><span class="comment">类型：int []</span></span><br><span class="line"><span class="comment">说明：学生成绩数组</span></span><br><span class="line"><span class="comment">参数2：length</span></span><br><span class="line"><span class="comment">类型：int</span></span><br><span class="line"><span class="comment">说明：要输出的成绩数组的长度</span></span><br><span class="line"><span class="comment">返回值：无</span></span><br><span class="line"><span class="comment">类型：void</span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">*******************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">outputScore</span><span class="params">(<span class="type">int</span> score[], <span class="type">int</span> length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"学生成绩如下：\n"</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; score[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">功能:查找某个学生成绩是否在数组中，如果找到，则输出下标，</span></span><br><span class="line"><span class="comment">否则，显示没有找到。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">参数1：score[]</span></span><br><span class="line"><span class="comment">类型：int []</span></span><br><span class="line"><span class="comment">说明：学生成绩数组</span></span><br><span class="line"><span class="comment">参数2：length</span></span><br><span class="line"><span class="comment">类型：int</span></span><br><span class="line"><span class="comment">说明：要输入的学生成绩数组的长度</span></span><br><span class="line"><span class="comment">参数2：xScore</span></span><br><span class="line"><span class="comment">类型：int</span></span><br><span class="line"><span class="comment">说明：要查找的学生成绩</span></span><br><span class="line"><span class="comment">返回值：k</span></span><br><span class="line"><span class="comment">类型：int</span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">*******************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">queryScore</span><span class="params">(<span class="type">int</span> score[], <span class="type">int</span> length, <span class="type">int</span> xScore)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (xScore == score[i])</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">功能:排序学生的成绩，按照从小到大顺序排序。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">参数1：score[]</span></span><br><span class="line"><span class="comment">类型：int []</span></span><br><span class="line"><span class="comment">说明：学生成绩数组</span></span><br><span class="line"><span class="comment">参数2：length</span></span><br><span class="line"><span class="comment">类型：int</span></span><br><span class="line"><span class="comment">说明：要输入的学生成绩数组的长度</span></span><br><span class="line"><span class="comment">返回值：无</span></span><br><span class="line"><span class="comment">类型：void</span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">*******************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sortScore</span><span class="params">(<span class="type">int</span> score[], <span class="type">int</span> length)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i, j, t;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"成绩排序如下：\n"</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; length - i - <span class="number">1</span>; j++)</span><br><span class="line"><span class="keyword">if</span> (score[j] &gt; score[j + <span class="number">1</span>])</span><br><span class="line">{</span><br><span class="line">t = score[j];</span><br><span class="line">score[j] = score[j + <span class="number">1</span>];</span><br><span class="line">score[j + <span class="number">1</span>] = t;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">功能:主函数</span></span><br><span class="line"><span class="comment">参数：无</span></span><br><span class="line"><span class="comment">返回值：无</span></span><br><span class="line"><span class="comment">*******************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> choice = <span class="number">0</span>; <span class="comment">/*代表用户选择的操作数字 */</span></span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>, datalen = <span class="number">0</span>, x, find;</span><br><span class="line"><span class="type">int</span> score[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*====验证用户的口令====*/</span></span><br><span class="line"><span class="keyword">if</span> (login() == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"口令错误，不允许进入本系统!\n"</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*====根据用户的选择，执行相应的操作.====*/</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">displayMenu();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n 请选择您的操作(1,2,3,4,5)：\n"</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (choice)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">datalen = inputScore(score, N);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">outputScore(score, datalen);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n 请输入要查找的成绩："</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">find = queryScore(score, datalen, x);</span><br><span class="line"><span class="keyword">if</span> (find &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"要查成绩在数组中的下表为:"</span> &lt;&lt; find &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"没有要查找的成绩:\n"</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">sortScore(score, datalen); outputScore(score, datalen);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p><strong>代码解释：</strong></p></li><li><p><code>void welcome();</code></p><p>​ 欢迎界面</p></li><li><p><code>int login();</code></p><ul><li>验证身份，成功返回<code>1</code>，否则返回<code>0</code></li><li>支持由数字和字符混合组成的口令</li><li>最长为8位</li><li>用户有三次录入机会，如果第三次失败，则不允许登录系统</li></ul></li><li><p><code>void displayMenu();</code></p><p>​ 功能显示提示菜单</p></li><li><p><code>int inputScore(int s[],int len);</code>或<code>int inputScore(int *s,int len);</code></p><p>​输入学生成绩数组中，如果学生的成绩输入<code>-1</code>，就表示输入结束，<code>s</code>为成绩数组，<code>len</code>为数组的最大列数；返回实际输入学生成绩的个数</p></li><li><p><code>void outputsScore(int s[],int len);</code>或<code>void outputsScore(int *s,int len);</code></p><p>​ 输出学生成绩，<code>s</code>为成绩数组，<code>len</code>为实际存储的成绩个数</p></li><li><p><code>int queryScore(int s[],int len,int xScore);</code>或<code>int queryScore(int *s,int len,int xScore);</code></p><p>​查询成绩。<code>s</code>为成绩数组，<code>len</code>为实际存储成绩个数；<code>xScore</code>为要查找的成绩，若找到该成绩，则返回该成绩的下标，否则返回<code>-1</code></p></li><li><p><code>void count(int a[],int n,int b[]);</code>或<code>void count(int *a,int n,int *b);</code></p><ul><li><p>统计成绩各个挡次中的人数<code>90 ~ 100</code>,<code>80 ~ 89</code>,<code>70 ~ 79</code>,<code>60 ~ 69</code>,<code>0 ~ 59</code></p></li><li><p><code>a</code>为学生成绩数组；<code>n</code>为数组实际长度；<code>b</code>为各挡人数数组</p></li></ul></li><li><p><code>void sortScore(int ps[],int len);</code>或<code>void sortScore(int *ps,int len);</code></p><ul><li>成绩升序排序</li><li><code>ps</code>为成绩数组</li><li><code>len</code>数组实际长度</li></ul></li></ul><h2 id="将c语言代码改写为c的类">将c语言代码改写为c++的类：</h2><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*******************************************************************</span></span><br><span class="line"><span class="comment">*名    称：学生成绩管理系统1.1                         *</span></span><br><span class="line"><span class="comment">*创建日期：2024-4-16                                 *</span></span><br><span class="line"><span class="comment">*最后修改：2024-4-16                                *</span></span><br><span class="line"><span class="comment">*版    权：中国农业大学信息与电气工程学院           *</span></span><br><span class="line"><span class="comment">*版 本 号：1.0                                      *</span></span><br><span class="line"><span class="comment">*******************************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 20   <span class="comment">//数组的长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">功能:显示菜单</span></span><br><span class="line"><span class="comment">参数：无</span></span><br><span class="line"><span class="comment">返回值：无</span></span><br><span class="line"><span class="comment">*******************************************************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"++++++++++++++++++++++++++++++++++++++++++++++++++++\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+                 学生成绩管理系统                 +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+                                                  +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+                    1. 录入                       +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+                    2. 输出                       +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+                    3. 查询                       +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+                    4. 排序                       +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+                    5. 结束                       +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"+                                                  +\n"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"++++++++++++++++++++++++++++++++++++++++++++++++++++\n"</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">功能:登陆函数，验证口令</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">类型：char []</span></span><br><span class="line"><span class="comment">说明：用户输入口令</span></span><br><span class="line"><span class="comment">返回值：1或0</span></span><br><span class="line"><span class="comment">类型：int</span></span><br><span class="line"><span class="comment">说明：1表示通过验证；0表示没有通过</span></span><br><span class="line"><span class="comment">*******************************************************/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">login</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">char</span> password[<span class="number">8</span>];<span class="comment">/*用户输入的口令*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> key[<span class="number">8</span>] = <span class="string">"1234"</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*====验证用户的口令，如果三次输入均错误，则不允许进入系统====*/</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line">count++;</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入口令："</span>;</span><br><span class="line">cin &gt;&gt; password;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(password, key) == <span class="number">0</span>)</span><br><span class="line">s = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">s = <span class="number">0</span>;</span><br><span class="line">} <span class="keyword">while</span> (s == <span class="number">0</span> &amp;&amp; count &lt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span>* score;</span><br><span class="line"><span class="type">int</span> Mlen;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Score</span>(<span class="type">int</span>* s, <span class="type">int</span> n)</span><br><span class="line">{</span><br><span class="line">Mlen = n;</span><br><span class="line">score = s;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inputScore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"请输入学生的成绩（以-1结束输入):\n"</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> tmp;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; <span class="string">"第"</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">"个学生："</span>;</span><br><span class="line">cin &gt;&gt; tmp;</span><br><span class="line"><span class="keyword">if</span> (tmp &gt;= <span class="number">0</span> &amp;&amp; tmp &lt;= <span class="number">100</span>)</span><br><span class="line">{</span><br><span class="line">score[i] = tmp;</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line">} <span class="keyword">while</span> (tmp != <span class="number">-1</span> &amp;&amp; i &lt; Mlen);</span><br><span class="line"></span><br><span class="line">length = i;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outputScore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"学生成绩如下：\n"</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">cout &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; score[i] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">queryScore</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line"><span class="keyword">if</span> (score[i] == x)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortScore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> i, j, t;</span><br><span class="line">cout &lt;&lt; <span class="string">"成绩排序如下：\n"</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; length - i - <span class="number">1</span>; j++)</span><br><span class="line"><span class="keyword">if</span> (score[j] &gt; score[j + <span class="number">1</span>])</span><br><span class="line">{</span><br><span class="line">t = score[j];</span><br><span class="line">score[j] = score[j + <span class="number">1</span>];</span><br><span class="line">score[j + <span class="number">1</span>] = t;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">功能:主函数</span></span><br><span class="line"><span class="comment">参数：无</span></span><br><span class="line"><span class="comment">返回值：无</span></span><br><span class="line"><span class="comment">*******************************************************/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> choice = <span class="number">0</span>; <span class="comment">/*代表用户选择的操作数字 */</span></span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>, datalen = <span class="number">0</span>, x, find;</span><br><span class="line"><span class="type">int</span> as[N];</span><br><span class="line"><span class="function">Score <span class="title">testS</span><span class="params">(as, N)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*====验证用户的口令====*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">login</span>() == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; <span class="string">"口令错误，不允许进入本系统!\n"</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*====根据用户的选择，执行相应的操作.====*/</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="built_in">displayMenu</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"\n 请选择您的操作(1,2,3,4,5)：\n"</span>;</span><br><span class="line">cin &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (choice)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">testS.<span class="built_in">inputScore</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">testS.<span class="built_in">outputScore</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">"\n 请输入要查找的成绩："</span>;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">find = testS.<span class="built_in">queryScore</span>(x);</span><br><span class="line"><span class="keyword">if</span> (find &gt;= <span class="number">0</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">"要查成绩在数组中的下表为:"</span> &lt;&lt; find &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">"没有要查找的成绩:\n"</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">testS.<span class="built_in">sortScore</span>();</span><br><span class="line">testS.<span class="built_in">outputScore</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="缺点及可补充功能">缺点及可补充功能：</h3><ol type="1"><li><p><strong>数据持久化：</strong>成绩数据只在程序运行期间存储在内存中，没有实现数据持久化。可以选择将数据保存在文件中</p></li><li><p><strong>错误处理和用户输入验证：</strong></p><ul><li><p>增加对用户输入的验证，确保输入的数据有效，检查成绩是否在合法范围<code>（0-100分）</code>之内。</p></li><li><p>在用户输入非法时，给出明确的错误信息，并允许重新输入而不是立即退出。</p></li></ul></li><li><p><strong>增加更多成绩管理功能：</strong></p><ul><li><p><strong>统计功能：</strong>计算全班的平均成绩、最高分、最低分等。</p></li><li><p><strong>成绩修改和删除：</strong>允许用户修改或删除已录入的成绩。</p></li><li><p><strong>分组排序显示：</strong>统计成绩各个挡次中的人数<code>90 ~ 100</code>,<code>80 ~ 89</code>,<code>70 ~ 79</code>,<code>60 ~ 69</code>,<code>0 ~ 59</code></p></li><li><p><strong>实现多科目动态输入：</strong>可输入多个学科的名称，实现对多个学科的成绩录入</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> c++/c </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>继承方式理解的作业</title>
      <link href="/2024/04/16/ji-cheng-fang-shi-li-jie-de-zuo-ye/"/>
      <url>/2024/04/16/ji-cheng-fang-shi-li-jie-de-zuo-ye/</url>
      
        <content type="html"><![CDATA[<p><strong>目标：</strong>验证公用继承下基类的公用成员在派生类依然为公用成员</p><h2 id="测试用程序代码"><strong>测试用程序代码：</strong></h2><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> a2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dsp</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"A : public a1 =  "</span> &lt;&lt; a1 &lt;&lt; <span class="string">", protected a2 =  "</span> &lt;&lt; a2 &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> b1 = <span class="number">30</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">seta2</span><span class="params">(<span class="type">int</span> i)</span> </span>{</span><br><span class="line">a2 = i;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dsp</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"B : public a1 =  "</span> &lt;&lt; a1 &lt;&lt; <span class="string">", protected a2 =  "</span> &lt;&lt; a2 &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dsp</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"C : public a1 =  "</span> &lt;&lt; a1 &lt;&lt; <span class="string">", protected a2 =  "</span> &lt;&lt; a2 &lt;&lt; <span class="string">", public b1 =  "</span> &lt;&lt; b1 &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">(A&amp; d, B&amp; d1, C&amp; d2)</span> </span>{</span><br><span class="line">d.<span class="built_in">dsp</span>(); d1.<span class="built_in">dsp</span>(); d2.<span class="built_in">dsp</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">"----------------------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">A d;</span><br><span class="line">B d1;</span><br><span class="line">C d2;</span><br><span class="line"><span class="built_in">Show</span>(d, d1, d2);</span><br><span class="line">d1.a1 = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">Show</span>(d, d1, d2);</span><br><span class="line">d2.a1 = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">Show</span>(d, d1, d2);</span><br><span class="line">d1.<span class="built_in">seta2</span>(<span class="number">300</span>);</span><br><span class="line"><span class="built_in">Show</span>(d, d1, d2);</span><br><span class="line">d2.<span class="built_in">seta2</span>(<span class="number">400</span>);</span><br><span class="line"><span class="built_in">Show</span>(d, d1, d2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="出现现象"><strong>出现现象：</strong></h2><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">A : public a1 =  10, protected a2 =  20</span><br><span class="line">B : public a1 =  10, protected a2 =  20</span><br><span class="line">C : public a1 =  10, protected a2 =  20, public b1 =  30</span><br><span class="line">----------------------</span><br><span class="line">A : public a1 =  10, protected a2 =  20</span><br><span class="line">B : public a1 =  100, protected a2 =  20</span><br><span class="line">C : public a1 =  10, protected a2 =  20, public b1 =  30</span><br><span class="line">----------------------</span><br><span class="line">A : public a1 =  10, protected a2 =  20</span><br><span class="line">B : public a1 =  100, protected a2 =  20</span><br><span class="line">C : public a1 =  200, protected a2 =  20, public b1 =  30</span><br><span class="line">----------------------</span><br><span class="line">A : public a1 =  10, protected a2 =  20</span><br><span class="line">B : public a1 =  100, protected a2 =  300</span><br><span class="line">C : public a1 =  200, protected a2 =  20, public b1 =  30</span><br><span class="line">----------------------</span><br><span class="line">A : public a1 =  10, protected a2 =  20</span><br><span class="line">B : public a1 =  100, protected a2 =  300</span><br><span class="line">C : public a1 =  200, protected a2 =  400, public b1 =  30</span><br><span class="line">----------------------</span><br></pre></td></tr></tbody></table></figure><h2 id="分析">分析：</h2><ol type="1"><li><p><strong>初始化</strong>：</p><ul><li><p>所有对象 (<code>d</code>, <code>d1</code>, <code>d2</code>) 的<code>a1</code> 初始化为 10，<code>a2</code> 初始化为20。<code>d1</code> 和 <code>d2</code> 中的 <code>b1</code> 初始化为30。</p><p>输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">A : public a1 =  10, protected a2 =  20</span><br><span class="line">B : public a1 =  10, protected a2 =  20</span><br><span class="line">C : public a1 =  10, protected a2 =  20, public b1 =  30</span><br><span class="line">----------------------</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>修改 <code>d1.a1</code> 为 100</strong>：</p><ul><li><p>只影响 <code>d1</code> 对象</p><p>输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">A : public a1 =  10, protected a2 =  20</span><br><span class="line">B : public a1 =  100, protected a2 =  20</span><br><span class="line">C : public a1 =  10, protected a2 =  20, public b1 =  30</span><br><span class="line">----------------------</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>修改 <code>d2.a1</code> 为 200</strong>：</p><ul><li><p>只影响 <code>d2</code> 对象</p><p>输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">A : public a1 =  10, protected a2 =  20</span><br><span class="line">B : public a1 =  100, protected a2 =  20</span><br><span class="line">C : public a1 =  200, protected a2 =  20, public b1 =  30</span><br><span class="line">----------------------</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>调用 <code>d1.seta2(300)</code></strong></p><p>设置了 <code>d1</code> 对象中的 <code>a2</code> 值为 300。</p><p>输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">A : public a1 =  10, protected a2 =  20</span><br><span class="line">B : public a1 =  100, protected a2 =  300</span><br><span class="line">C : public a1 =  200, protected a2 =  20, public b1 =  30</span><br><span class="line">----------------------</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>调用<code>d2.seta2(400)</code></strong></p><p>设置了 <code>d2</code> 对象中的 <code>a2</code> 值为 400。</p><p>输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">A : public a1 =  10, protected a2 =  20</span><br><span class="line">B : public a1 =  100, protected a2 =  300</span><br><span class="line">C : public a1 =  200, protected a2 =  400, public b1 =  30</span><br><span class="line">----------------------</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="结论"><strong>结论：</strong></h2><ul><li>每个对象维护自己独立的成员变量（包括继承的变量）状态。</li><li>受保护的成员虽然在类及其子类之间可以访问和修改，但它们的状态是在每个对象级别上独立管理的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> c++/c </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第二节 边际分布与随机变量的独立性</title>
      <link href="/2024/04/13/gai-lu-lun-3-2-bian-ji-fen-bu-yu-sui-ji-bian-liang-de-du-li-xing/"/>
      <url>/2024/04/13/gai-lu-lun-3-2-bian-ji-fen-bu-yu-sui-ji-bian-liang-de-du-li-xing/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iMuDz1uzldne">下载PDF点这里</a></p><p><span class="math inline">\(ps\)</span>：笔记配套书本为高等教育出版社《概率论与数理统计教程(第三版)》，是数学系同学的课本，对绝大部分非数学系同学来说笔记中题目难度要高于课程要求。</p><p><img src="../../../../images/概率论3-2边际分布与随机变量的独立性/50.jpg"></p><p><img src="../../../../images/概率论3-2边际分布与随机变量的独立性/51.jpg"></p><p><img src="../../../../images/概率论3-2边际分布与随机变量的独立性/52.jpg"></p><p><img src="../../../../images/概率论3-2边际分布与随机变量的独立性/53.jpg"></p><p><img src="../../../../images/概率论3-2边际分布与随机变量的独立性/54.jpg"></p><p><img src="../../../../images/概率论3-2边际分布与随机变量的独立性/55.jpg"></p><p><img src="../../../../images/概率论3-2边际分布与随机变量的独立性/56.jpg"></p><p><img src="../../../../images/概率论3-2边际分布与随机变量的独立性/57.jpg"></p><p><img src="../../../../images/概率论3-2边际分布与随机变量的独立性/58.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第三章 多维随机变量及其分布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多维随机变量 </tag>
            
            <tag> 边际分布 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一节 多维随机变量及其联合分布</title>
      <link href="/2024/04/13/gai-lu-lun-3-1-duo-wei-sui-ji-bian-liang-ji-qi-lian-he-fen-bu/"/>
      <url>/2024/04/13/gai-lu-lun-3-1-duo-wei-sui-ji-bian-liang-ji-qi-lian-he-fen-bu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/imep41uzdauf">下载PDF点这里</a></p><p><span class="math inline">\(ps\)</span>：笔记配套书本为高等教育出版社《概率论与数理统计教程(第三版)》，是数学系同学的课本，对绝大部分非数学系同学来说笔记中题目难度要高于课程要求。</p><p><img src="../../../../images/概率论3-1多维随机变量及其联合分布/43.jpg"></p><p><img src="../../../../images/概率论3-1多维随机变量及其联合分布/44.jpg"></p><p><img src="../../../../images/概率论3-1多维随机变量及其联合分布/45.jpg"></p><p><img src="../../../../images/概率论3-1多维随机变量及其联合分布/46.jpg"></p><p><img src="../../../../images/概率论3-1多维随机变量及其联合分布/47.jpg"></p><p><img src="../../../../images/概率论3-1多维随机变量及其联合分布/48.jpg"></p><p><img src="../../../../images/概率论3-1多维随机变量及其联合分布/49.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第三章 多维随机变量及其分布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多维随机变量 </tag>
            
            <tag> r项分布 </tag>
            
            <tag> 多维超几何分布 </tag>
            
            <tag> 多维均匀分布 </tag>
            
            <tag> 二元正态分布 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BST(二叉搜索树)</title>
      <link href="/2024/04/10/bst/"/>
      <url>/2024/04/10/bst/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p><strong>编写C++程序来实现执行以下操作：</strong></p><ol type="1"><li><p>向二叉搜索树中插入一个元素</p></li><li><p>从二叉搜索树中删除一个元素</p></li><li><p>显示所有叶子节点</p></li><li><p>遍历给定的二叉树</p><ul><li>深度优先算法<ul><li>中序遍历</li><li>前序遍历</li></ul></li></ul></li></ol><p><strong>程序描述：</strong></p><p>这个程序旨在通过各种操作来管理一个二叉搜索树（BST），如插入、删除、显示叶子节点和根据用户选择的方式遍历树。BST是一个基本的数据结构，它保持元素以排序的顺序存储，以便高效地进行搜索、插入和删除操作。每个节点包含一个键值和指向左右子节点的指针。节点的左子树仅包含键值小于该节点键值的节点，而右子树仅包含键值大于该节点键值的节点。</p><p><strong>该程序实现的操作包括：</strong></p><ul><li>插入：提示用户依次输入元素到BST中。</li><li>删除：询问用户要从BST中删除的特定元素。</li><li>显示叶子节点：遍历BST并显示所有叶子节点（没有子节点的节点）。</li><li>树遍历：允许用户选择中序遍历和前序遍历方法来遍历和显示树。</li></ul><h2 id="实现代码">实现代码</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义树的节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> key; <span class="comment">// 节点存储的值</span></span><br><span class="line">    Node* left, * right; <span class="comment">// 指向左子节点和右子节点的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点构造函数</span></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> item) {</span><br><span class="line">        key = item;</span><br><span class="line">        left = right = <span class="literal">nullptr</span>; <span class="comment">// 初始化时没有子节点</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉搜索树类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 插入新节点的辅助函数</span></span><br><span class="line">    <span class="function">Node* <span class="title">insert</span><span class="params">(Node* node, <span class="type">int</span> key)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Node</span>(key); <span class="comment">// 如果当前节点为空，创建新节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据二叉搜索树的性质进行递归插入</span></span><br><span class="line">        <span class="keyword">if</span> (key &lt; node-&gt;key)</span><br><span class="line">            node-&gt;left = <span class="built_in">insert</span>(node-&gt;left, key); <span class="comment">// 插入到左子树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node-&gt;key)</span><br><span class="line">            node-&gt;right = <span class="built_in">insert</span>(node-&gt;right, key); <span class="comment">// 插入到右子树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找并返回具有最小键值的节点的辅助函数</span></span><br><span class="line">    <span class="function">Node* <span class="title">minValueNode</span><span class="params">(Node* node)</span> </span>{</span><br><span class="line">        Node* current = node;</span><br><span class="line">        <span class="comment">// 持续向左子节点移动，直到找到最左侧节点</span></span><br><span class="line">        <span class="keyword">while</span> (current &amp;&amp; current-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点的辅助函数</span></span><br><span class="line">    <span class="function">Node* <span class="title">deleteNode</span><span class="params">(Node* root, <span class="type">int</span> key)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root; <span class="comment">// 如果根为空，直接返回</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据键值进行递归删除</span></span><br><span class="line">        <span class="keyword">if</span> (key &lt; root-&gt;key)</span><br><span class="line">            root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key); <span class="comment">// 从左子树删除</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key)</span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key); <span class="comment">// 从右子树删除</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 找到了要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span>) {</span><br><span class="line">                Node* temp = root-&gt;right;</span><br><span class="line">                <span class="keyword">delete</span> root; <span class="comment">// 删除当前节点</span></span><br><span class="line">                <span class="keyword">return</span> temp; <span class="comment">// 返回右子树</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span>) {</span><br><span class="line">                Node* temp = root-&gt;left;</span><br><span class="line">                <span class="keyword">delete</span> root; <span class="comment">// 删除当前节点</span></span><br><span class="line">                <span class="keyword">return</span> temp; <span class="comment">// 返回左子树</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 节点有两个子节点的情况</span></span><br><span class="line">            Node* temp = <span class="built_in">minValueNode</span>(root-&gt;right); <span class="comment">// 找到右子树中的最小节点</span></span><br><span class="line">            root-&gt;key = temp-&gt;key; <span class="comment">// 替换当前节点的键值</span></span><br><span class="line">            <span class="comment">// 删除右子树中的最小节点</span></span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, temp-&gt;key);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历的辅助函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="built_in">inorderTraversal</span>(root-&gt;left); <span class="comment">// 先左子树</span></span><br><span class="line">            cout &lt;&lt; root-&gt;key &lt;&lt; <span class="string">" "</span>; <span class="comment">// 再根节点</span></span><br><span class="line">            <span class="built_in">inorderTraversal</span>(root-&gt;right); <span class="comment">// 最后右子树</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历的辅助函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) {</span><br><span class="line">            cout &lt;&lt; root-&gt;key &lt;&lt; <span class="string">" "</span>; <span class="comment">// 先根节点</span></span><br><span class="line">            <span class="built_in">preorderTraversal</span>(root-&gt;left); <span class="comment">// 再左子树</span></span><br><span class="line">            <span class="built_in">preorderTraversal</span>(root-&gt;right); <span class="comment">// 最后右子树</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示所有叶子节点的辅助函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayLeafNodes</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) {</span><br><span class="line">                cout &lt;&lt; root-&gt;key &lt;&lt; <span class="string">" "</span>; <span class="comment">// 如果是叶子节点，打印其键值</span></span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 递归检查左右子树</span></span><br><span class="line">            <span class="built_in">displayLeafNodes</span>(root-&gt;left);</span><br><span class="line">            <span class="built_in">displayLeafNodes</span>(root-&gt;right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node* root; <span class="comment">// 树的根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">BST</span>() {</span><br><span class="line">        root = <span class="literal">nullptr</span>; <span class="comment">// 初始化时树为空</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入新节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> key)</span> </span>{</span><br><span class="line">        root = <span class="built_in">insert</span>(root, key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(<span class="type">int</span> key)</span> </span>{</span><br><span class="line">        root = <span class="built_in">deleteNode</span>(root, key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"InOrder Traversal: "</span>;</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"PreOrder Traversal: "</span>;</span><br><span class="line">        <span class="built_in">preorderTraversal</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示所有叶子节点的函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayLeafNodes</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Leaf nodes: "</span>;</span><br><span class="line">        <span class="built_in">displayLeafNodes</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    BST bst; <span class="comment">// 创建一个二叉搜索树实例</span></span><br><span class="line">    <span class="type">int</span> n, x;</span><br><span class="line">    <span class="type">bool</span> f = <span class="number">0</span>; <span class="comment">// 用于控制是否打印分隔线</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">if</span> (f) {</span><br><span class="line">            cout &lt;&lt; <span class="string">"--------------------------------\n"</span>;</span><br><span class="line">        }</span><br><span class="line">        f = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1. Insert Element into BST\n2. Delete Element from BST\n3. Display all leaf nodes\n4. Traverse the BST\n5. Exit\n"</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">"Enter your choice: "</span>; cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">switch</span> (n)</span><br><span class="line">        {</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 插入元素</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"Enter key to insert: "</span>;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            bst.<span class="built_in">insert</span>(x);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 删除元素</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"Enter key to delete: "</span>;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            bst.<span class="built_in">deleteNode</span>(x);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// 显示所有叶子节点</span></span><br><span class="line">            bst.<span class="built_in">displayLeafNodes</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">// 选择遍历方法</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"Choose traversal method (1 for InOrder, 2 for PreOrder): "</span>;</span><br><span class="line">            <span class="type">int</span> m; cin &gt;&gt; m;</span><br><span class="line">            <span class="keyword">if</span> (m == <span class="number">1</span>) bst.<span class="built_in">inorderTraversal</span>(); <span class="comment">// 中序遍历</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">2</span>) bst.<span class="built_in">preorderTraversal</span>(); <span class="comment">// 前序遍历</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: <span class="comment">// 退出程序</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> c++/c </category>
          
          <category> BST </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的组合作业2</title>
      <link href="/2024/04/07/lei-de-zu-he-zuo-ye/"/>
      <url>/2024/04/07/lei-de-zu-he-zuo-ye/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述">问题描述</h1><p>有代码如下。请运行程序，并按照要求完成如下任务。</p><p>1、请分析代码的运行结果，并画出程序运行期间，内存分配情况；</p><p>2、请在程序中添加<code>Point</code>的析构函数和<code>Line</code>的析构函数。在两个析构函数中只需要进行信息输出即可。请给出修改后的完整代码，并将自己添加的代码用红色标出；</p><p>3、运行加入析构函数后的代码，分析其运行结果，并说明其与未加析构函数的时候的结果的不同之处，并说明原因；</p><p>4、请将程序中语句<code>Line(Point pp1,Point pp2):p1(pp1),p2(pp2)</code>，修改为<code>Line(Point &amp;pp1,Point &amp;pp2):p1(pp1),p2(pp2)</code>。然后运行程序，说明修改前后程序的运行结果区别及其原因。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="built_in">Point</span>(<span class="type">int</span> a,<span class="type">int</span> b) </span><br><span class="line">    {</span><br><span class="line">        x=a;</span><br><span class="line">        y=b;</span><br><span class="line">        cout&lt;&lt;<span class="string">"构造了一个点"</span>&lt;&lt;<span class="string">"("</span>&lt;&lt;x&lt;&lt;<span class="string">","</span>&lt;&lt;y&lt;&lt;<span class="string">")"</span>&lt;&lt;endl;</span><br><span class="line">  }</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Getx</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">  }</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">Gety</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">  }          </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">  cout&lt;&lt;<span class="string">"横坐标:"</span>&lt;&lt;x&lt;&lt;<span class="string">",纵坐标:"</span>&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">  }                               </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> x,y;</span><br><span class="line">}; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Point p1,p2;   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Line</span>(Point pp1,Point pp2):<span class="built_in">p1</span>(pp1),<span class="built_in">p2</span>(pp2) </span><br><span class="line">    { </span><br><span class="line">    cout&lt;&lt;<span class="string">"构造了一条线段"</span>&lt;&lt;endl;        </span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">length</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">  </span>{ </span><br><span class="line"><span class="type">double</span> len;   </span><br><span class="line"><span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">  x1=p1.<span class="built_in">Getx</span>();</span><br><span class="line">  y1=p1.<span class="built_in">Gety</span>();</span><br><span class="line">x2=p2.<span class="built_in">Getx</span>();</span><br><span class="line">y2=p2.<span class="built_in">Gety</span>();</span><br><span class="line">len=<span class="built_in">sqrt</span>((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)); </span><br><span class="line">cout&lt;&lt;<span class="string">"线段的长度是"</span>&lt;&lt;len&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slope</span><span class="params">()</span> <span class="comment">//计算线段的斜率</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">double</span> k; </span><br><span class="line"><span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">x1=p1.<span class="built_in">Getx</span>();</span><br><span class="line">y1=p1.<span class="built_in">Gety</span>();</span><br><span class="line">x2=p2.<span class="built_in">Getx</span>();  </span><br><span class="line">y2=p2.<span class="built_in">Gety</span>(); </span><br><span class="line">k=(y2-y1)/(x2-x1);</span><br><span class="line">cout&lt;&lt;<span class="string">"线段的斜率是"</span>&lt;&lt;k&lt;&lt;endl;  </span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout&lt;&lt;<span class="string">"线段的起点"</span>; </span><br><span class="line">p1.<span class="built_in">show</span>();</span><br><span class="line">cout&lt;&lt;<span class="string">"线段的终点"</span>;</span><br><span class="line">p2.<span class="built_in">show</span>();</span><br><span class="line">}     </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line"><span class="function">Point <span class="title">mp1</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span>,<span class="title">mp2</span><span class="params">(<span class="number">16</span>,<span class="number">16</span>)</span></span>;        </span><br><span class="line">  <span class="function">Line <span class="title">line</span><span class="params">(mp1,mp2)</span></span>;</span><br><span class="line">  line.<span class="built_in">display</span>();  </span><br><span class="line">line.<span class="built_in">length</span>();</span><br><span class="line">line.<span class="built_in">slope</span>();  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>运行后输出</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">构造了一个点(1,1)</span><br><span class="line">构造了一个点(16,16)</span><br><span class="line">构造了一条线段</span><br><span class="line">线段的起点横坐标:1,纵坐标:1</span><br><span class="line">线段的终点横坐标:16,纵坐标:16</span><br><span class="line">线段的长度是21.2132</span><br><span class="line">线段的斜率是1</span><br></pre></td></tr></tbody></table></figure><h2 id="程序的运行结果与内存分配情况">1.程序的运行结果与内存分配情况</h2><ol type="1"><li><p><strong>调用构造函数<code>Point(int a,int b)</code>创建两个<code>Point</code>对象：<code>mp1</code>和<code>mp2</code>。</strong></p><ul><li>对于<code>mp1(1,1)</code>，输出：<code>构造了一个点(1,1)</code></li><li>对于<code>mp2(16,16)</code>，输出：<code>构造了一个点(16,16)</code></li></ul></li><li><p><strong>调用构造函数<code>Line(Point &amp;pp1,Point &amp;pp2):p1(pp1),p2(pp2)</code>创建一个<code>Line</code>对象<code>line</code>。</strong></p><ul><li>输出：<code>构造了一条线段</code></li></ul><p>事实上这里的值传递调用了默认的拷贝构造函数，要想打印日志可以在<code>class Point:public</code>中添加拷贝构造函数：</p><p></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">   <span class="built_in">Point</span>(<span class="type">const</span> Point &amp;p) {</span><br><span class="line">       x = p.x;</span><br><span class="line">       y = p.y;</span><br><span class="line">       cout &lt;&lt; <span class="string">"拷贝构造了一个点("</span> &lt;&lt; x &lt;&lt; <span class="string">","</span> &lt;&lt; y &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p></p><p>此时会输出：</p><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">拷贝构造了一个点(16,16)</span><br><span class="line">拷贝构造了一个点(1,1)</span><br><span class="line">拷贝构造了一个点(1,1)</span><br><span class="line">拷贝构造了一个点(16,16)</span><br><span class="line">构造了一条线段</span><br></pre></td></tr></tbody></table></figure><p></p><p>可以看到这两个点分别被高倍构造了两次，这是由于构造函数<code>Line(Point &amp;pp1,Point &amp;pp2):p1(pp1),p2(pp2)</code>使用了初始化列表。</p><p>具体过程如下：</p><ol type="1"><li><p>在创建<code>Line</code>对象时，由于按值传递，<code>mp1</code>和<code>mp2</code>被拷贝到构造函数的形参<code>pp1</code>和<code>pp2</code>。输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">拷贝构造了一个点(16,16)</span><br><span class="line">拷贝构造了一个点(1,1)</span><br></pre></td></tr></tbody></table></figure></li><li><p>初始化列表中<code>p1(pp1)</code>和<code>p2(pp2)</code>又各引发了一次拷贝构造调用，以初始化<code>Line</code>对象的<code>p1</code>和<code>p2</code>成员。输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">拷贝构造了一个点(1,1)</span><br><span class="line">拷贝构造了一个点(16,16)</span><br></pre></td></tr></tbody></table></figure></li><li><p>输出<code>构造了一条线段</code></p></li></ol></li><li><p><strong>调用<code>line.display()</code>方法。</strong></p><ul><li>输出：<code>线段的起点</code>，随后<code>p1.show()</code>输出：<code>横坐标:1,纵坐标:1</code></li><li>输出：<code>线段的终点</code>，随后<code>p2.show()</code>输出：<code>横坐标:16,纵坐标:16</code></li></ul></li><li><p><strong>调用<code>line.length()</code>方法。</strong></p><ul><li>输出<code>线段的长度是21.2132</code></li></ul></li><li><p><strong>调用<code>line.slope()</code>方法。</strong></p><ul><li>输出：<code>线段的斜率是1</code></li></ul></li></ol><p><strong>内存中的分配情况如动图所示：</strong></p><figure><img src="../../../../images/类的组合作业2/p2.gif" alt="内存分配动图"><figcaption aria-hidden="true">内存分配动图</figcaption></figure><iframe width="800" height="1000" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=%23include%3Ciostream%3E%0A%23include%3Cmath.h%3E%0Ausing%20namespace%20std%3B%0Aclass%20Point%20%7B%0Apublic%3A%20%0A%20%20%20%20Point%28int%20a,int%20b%29%20%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20x%3Da%3B%0A%20%20%20%20%20%20%20%20y%3Db%3B%0A%20%20%20%20%20%20%20%20cout%3C%3C%22%E6%9E%84%E9%80%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E7%82%B9%22%3C%3C%22%28%22%3C%3Cx%3C%3C%22,%22%3C%3Cy%3C%3C%22%29%22%3C%3Cendl%3B%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20//%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%0A%20%20%20%20Point%28const%20Point%20%26p%29%20%7B%0A%20%20%20%20%20%20%20%20x%20%3D%20p.x%3B%0A%20%20%20%20%20%20%20%20y%20%3D%20p.y%3B%0A%20%20%20%20%20%20%20%20cout%20%3C%3C%20%22%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E7%82%B9%28%22%20%3C%3C%20x%20%3C%3C%20%22,%22%20%3C%3C%20y%20%3C%3C%20%22%29%22%20%3C%3C%20endl%3B%0A%20%20%20%20%7D%0A%20%20%20%20%20%20int%20Getx%28%29%20%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20return%20x%3B%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20int%20Gety%28%29%20%0A%20%20%20%20%7B%0A%20%20%20%20%20%20return%20y%3B%0A%20%20%20%20%20%20%7D%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20void%20show%28%29%20%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20cout%3C%3C%22%E6%A8%AA%E5%9D%90%E6%A0%87%3A%22%3C%3Cx%3C%3C%22,%E7%BA%B5%E5%9D%90%E6%A0%87%3A%22%3C%3Cy%3C%3Cendl%3B%0A%20%20%20%20%20%20%7D%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0Aprivate%3A%0A%20%20%20%20%20%20int%20x,y%3B%0A%7D%3B%20%0A%0Aclass%20Line%20%7B%0Aprivate%3A%0A%20%20%20%20%20%20Point%20p1,p2%3B%0Apublic%3A%0A%20%20%20%20%20%20Line%28Point%20pp1,Point%20pp2%29%3Ap1%28pp1%29,p2%28pp2%29%0A%20%20%20%20%7B%20%0A%20%20%20%20%20%20%20%20cout%3C%3C%22%E6%9E%84%E9%80%A0%E4%BA%86%E4%B8%80%E6%9D%A1%E7%BA%BF%E6%AE%B5%22%3C%3Cendl%3B%0A%20%20%20%20%7D%0A%20%20%20%20void%20length%28%29%20%20%0A%20%20%20%20%20%20%7B%20%0A%20%20%20%20%20%20%20%20double%20len%3B%20%20%20%0A%20%20%20%20%20%20%20%20int%20x1,y1,x2,y2%3B%0A%20%20%20%20%20%20%20%20%20%20x1%3Dp1.Getx%28%29%3B%0A%20%20%20%20%20%20%20%20%20%20y1%3Dp1.Gety%28%29%3B%0A%20%20%20%20%20%20%20%20x2%3Dp2.Getx%28%29%3B%0A%20%20%20%20%20%20%20%20y2%3Dp2.Gety%28%29%3B%0A%20%20%20%20%20%20%20%20len%3Dsqrt%28%28x2-x1%29*%28x2-x1%29%2B%28y2-y1%29*%28y2-y1%29%29%3B%20%0A%20%20%20%20%20%20%20%20cout%3C%3C%22%E7%BA%BF%E6%AE%B5%E7%9A%84%E9%95%BF%E5%BA%A6%E6%98%AF%22%3C%3Clen%3C%3Cendl%3B%0A%20%20%20%20%7D%0A%20%20%20%20void%20slope%28%29%20//%E8%AE%A1%E7%AE%97%E7%BA%BF%E6%AE%B5%E7%9A%84%E6%96%9C%E7%8E%87%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20double%20k%3B%20%0A%20%20%20%20%20%20%20%20int%20x1,y1,x2,y2%3B%0A%20%20%20%20%20%20%20%20x1%3Dp1.Getx%28%29%3B%0A%20%20%20%20%20%20%20%20y1%3Dp1.Gety%28%29%3B%0A%20%20%20%20%20%20%20%20x2%3Dp2.Getx%28%29%3B%20%20%0A%20%20%20%20%20%20%20%20y2%3Dp2.Gety%28%29%3B%20%0A%20%20%20%20%20%20%20%20k%3D%28y2-y1%29/%28x2-x1%29%3B%0A%20%20%20%20%20%20%20%20cout%3C%3C%22%E7%BA%BF%E6%AE%B5%E7%9A%84%E6%96%9C%E7%8E%87%E6%98%AF%22%3C%3Ck%3C%3Cendl%3B%20%20%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20void%20display%28%29%20%20%20%20%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20cout%3C%3C%22%E7%BA%BF%E6%AE%B5%E7%9A%84%E8%B5%B7%E7%82%B9%22%3B%20%0A%20%20%20%20%20%20%20%20p1.show%28%29%3B%0A%20%20%20%20%20%20%20%20cout%3C%3C%22%E7%BA%BF%E6%AE%B5%E7%9A%84%E7%BB%88%E7%82%B9%22%3B%0A%20%20%20%20%20%20%20%20p2.show%28%29%3B%0A%20%20%20%20%20%20%20%20%7D%20%20%20%20%20%0A%7D%3B%0A%0Aint%20main%28%29%0A%7B%20%0A%20%20%20%20Point%20mp1%281,1%29,mp2%2816,16%29%3B%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20Line%20line%28mp1,mp2%29%3B%0A%20%20%20%20%20%20line.display%28%29%3B%20%20%0A%20%20%20%20line.length%28%29%3B%0A%20%20%20%20line.slope%28%29%3B%20%20%0A%7D&amp;codeDivHeight=400&amp;codeDivWidth=350&amp;cumulative=false&amp;curInstr=0&amp;heapPrimitives=nevernest&amp;origin=opt-frontend.js&amp;py=cpp_g%2B%2B9.3.0&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false"></iframe><h2 id="添加析构函数">2. 添加析构函数</h2><p>代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> a, <span class="type">int</span> b) {</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">        cout &lt;&lt; <span class="string">"构造了一个点"</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; x &lt;&lt; <span class="string">","</span> &lt;&lt; y &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">     <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">const</span> Point &amp;p) {</span><br><span class="line">        x = p.x;</span><br><span class="line">        y = p.y;</span><br><span class="line">        cout &lt;&lt; <span class="string">"拷贝构造了一个点("</span> &lt;&lt; x &lt;&lt; <span class="string">","</span> &lt;&lt; y &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">Point</span>() { <span class="comment">// 添加析构函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"销毁了一个点"</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; x &lt;&lt; <span class="string">","</span> &lt;&lt; y &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Getx</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Gety</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"横坐标:"</span> &lt;&lt; x &lt;&lt; <span class="string">",纵坐标:"</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Point p1, p2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Line</span>(Point pp1, Point pp2) : <span class="built_in">p1</span>(pp1), <span class="built_in">p2</span>(pp2) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"构造了一条线段"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">Line</span>() { <span class="comment">// 添加析构函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"销毁了一条线段"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">length</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">double</span> len;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">        x1 = p1.<span class="built_in">Getx</span>();</span><br><span class="line">        y1 = p1.<span class="built_in">Gety</span>();</span><br><span class="line">        x2 = p2.<span class="built_in">Getx</span>();</span><br><span class="line">        y2 = p2.<span class="built_in">Gety</span>();</span><br><span class="line">        len = <span class="built_in">sqrt</span>((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));</span><br><span class="line">        cout &lt;&lt; <span class="string">"线段的长度是"</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">slope</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">double</span> k;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">        x1 = p1.<span class="built_in">Getx</span>();</span><br><span class="line">        y1 = p1.<span class="built_in">Gety</span>();</span><br><span class="line">        x2 = p2.<span class="built_in">Getx</span>();</span><br><span class="line">        y2 = p2.<span class="built_in">Gety</span>();</span><br><span class="line">        k = (<span class="type">double</span>)(y2 - y1) / (x2 - x1);</span><br><span class="line">        cout &lt;&lt; <span class="string">"线段的斜率是"</span> &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"线段的起点"</span>;</span><br><span class="line">        p1.<span class="built_in">show</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">"线段的终点"</span>;</span><br><span class="line">        p2.<span class="built_in">show</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">Point <span class="title">mp1</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span>, <span class="title">mp2</span><span class="params">(<span class="number">16</span>, <span class="number">16</span>)</span></span>;</span><br><span class="line">    <span class="function">Line <span class="title">line</span><span class="params">(mp1, mp2)</span></span>;</span><br><span class="line">    line.<span class="built_in">display</span>();</span><br><span class="line">    line.<span class="built_in">length</span>();</span><br><span class="line">    line.<span class="built_in">slope</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="运行加入析构函数后的代码">3. 运行加入析构函数后的代码</h2><p>运行后输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">构造了一个点(1,1)</span><br><span class="line">构造了一个点(16,16)</span><br><span class="line">拷贝构造了一个点(16,16)</span><br><span class="line">拷贝构造了一个点(1,1)</span><br><span class="line">拷贝构造了一个点(1,1)</span><br><span class="line">拷贝构造了一个点(16,16)</span><br><span class="line">构造了一条线段</span><br><span class="line">销毁了一个点(1,1)</span><br><span class="line">销毁了一个点(16,16)</span><br><span class="line">线段的起点横坐标:1,纵坐标:1</span><br><span class="line">线段的终点横坐标:16,纵坐标:16</span><br><span class="line">线段的长度是21.2132</span><br><span class="line">线段的斜率是1</span><br><span class="line">销毁了一条线段</span><br><span class="line">销毁了一个点(16,16)</span><br><span class="line">销毁了一个点(1,1)</span><br><span class="line">销毁了一个点(16,16)</span><br><span class="line">销毁了一个点(1,1)</span><br></pre></td></tr></tbody></table></figure><p>可以看到，当对象的生命周期结束时，会自动调用析构函数。</p><ol type="1"><li><p>由于构造函数<code>Line(Point pp1, Point pp2) : p1(pp1), p2(pp2)</code>为值传递，故在函数执行完后形参被销毁，输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">销毁了一个点(1,1)</span><br><span class="line">销毁了一个点(16,16)</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>Line</code>对象的析构，输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">销毁了一条线段</span><br><span class="line">销毁了一个点(16,16)</span><br><span class="line">销毁了一个点(1,1)</span><br></pre></td></tr></tbody></table></figure></li><li><p><code>Point</code>对象的析构，输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">销毁了一个点(16,16)</span><br><span class="line">销毁了一个点(1,1)</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="修改line构造函数的参数为引用类型">4.修改<code>Line</code>构造函数的参数为引用类型</h2><p>将<code>Line(Point pp1,Point pp2):p1(pp1),p2(pp2)</code>，修改为<code>Line(Point &amp;pp1,Point &amp;pp2):p1(pp1),p2(pp2)</code></p><p>运行后输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">构造了一个点(1,1)</span><br><span class="line">构造了一个点(16,16)</span><br><span class="line">拷贝构造了一个点(1,1)</span><br><span class="line">拷贝构造了一个点(16,16)</span><br><span class="line">构造了一条线段</span><br><span class="line">线段的起点横坐标:1,纵坐标:1</span><br><span class="line">线段的终点横坐标:16,纵坐标:16</span><br><span class="line">线段的长度是21.2132</span><br><span class="line">线段的斜率是1</span><br><span class="line">销毁了一条线段</span><br><span class="line">销毁了一个点(16,16)</span><br><span class="line">销毁了一个点(1,1)</span><br><span class="line">销毁了一个点(16,16)</span><br><span class="line">销毁了一个点(1,1)</span><br></pre></td></tr></tbody></table></figure><p>可以看到，使用引用方法后，构造函数<code>Line(Point &amp;pp1,Point &amp;pp2):p1(pp1),p2(pp2)</code>在创建<code>pp1</code>,<code>pp2</code>时不会调用拷贝构造函数<code>Point(const Point &amp;p)</code>，所以只是在初始化列表中调用了拷贝构造函数<code>Point(const Point &amp;p)</code>，并且也不需要销毁临时变量。</p><p><strong>以下是程序运行动图：</strong> <img src="../../../../images/类的组合作业2/p3.gif" alt="gif"></p><iframe width="800" height="1000" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=%23include%3Ciostream%3E%0A%23include%3Cmath.h%3E%0Ausing%20namespace%20std%3B%0A%0Aclass%20Point%20%7B%0Apublic%3A%0A%20%20%20%20Point%28int%20a,%20int%20b%29%20%7B%0A%20%20%20%20%20%20%20%20x%20%3D%20a%3B%0A%20%20%20%20%20%20%20%20y%20%3D%20b%3B%0A%20%20%20%20%20%20%20%20cout%20%3C%3C%20%22%E6%9E%84%E9%80%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E7%82%B9%22%20%3C%3C%20%22%28%22%20%3C%3C%20x%20%3C%3C%20%22,%22%20%3C%3C%20y%20%3C%3C%20%22%29%22%20%3C%3C%20endl%3B%0A%20%20%20%20%7D%0A%20%20%20%20%20//%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%0A%20%20%20%20Point%28const%20Point%20%26p%29%20%7B%0A%20%20%20%20%20%20%20%20x%20%3D%20p.x%3B%0A%20%20%20%20%20%20%20%20y%20%3D%20p.y%3B%0A%20%20%20%20%20%20%20%20cout%20%3C%3C%20%22%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E7%82%B9%28%22%20%3C%3C%20x%20%3C%3C%20%22,%22%20%3C%3C%20y%20%3C%3C%20%22%29%22%20%3C%3C%20endl%3B%0A%20%20%20%20%7D%0A%20%20%20%20~Point%28%29%20%7B%20//%20%E6%B7%BB%E5%8A%A0%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%0A%20%20%20%20%20%20%20%20cout%20%3C%3C%20%22%E9%94%80%E6%AF%81%E4%BA%86%E4%B8%80%E4%B8%AA%E7%82%B9%22%20%3C%3C%20%22%28%22%20%3C%3C%20x%20%3C%3C%20%22,%22%20%3C%3C%20y%20%3C%3C%20%22%29%22%20%3C%3C%20endl%3B%0A%20%20%20%20%7D%0A%20%20%20%20int%20Getx%28%29%20%7B%0A%20%20%20%20%20%20%20%20return%20x%3B%0A%20%20%20%20%7D%0A%20%20%20%20int%20Gety%28%29%20%7B%0A%20%20%20%20%20%20%20%20return%20y%3B%0A%20%20%20%20%7D%0A%20%20%20%20void%20show%28%29%20%7B%0A%20%20%20%20%20%20%20%20cout%20%3C%3C%20%22%E6%A8%AA%E5%9D%90%E6%A0%87%3A%22%20%3C%3C%20x%20%3C%3C%20%22,%E7%BA%B5%E5%9D%90%E6%A0%87%3A%22%20%3C%3C%20y%20%3C%3C%20endl%3B%0A%20%20%20%20%7D%0Aprivate%3A%0A%20%20%20%20int%20x,%20y%3B%0A%7D%3B%0A%0Aclass%20Line%20%7B%0Aprivate%3A%0A%20%20%20%20Point%20p1,%20p2%3B%0Apublic%3A%0A%20%20%20%20Line%28Point%20%26pp1,%20Point%20%26pp2%29%20%3A%20p1%28pp1%29,%20p2%28pp2%29%20%7B%0A%20%20%20%20%20%20%20%20cout%20%3C%3C%20%22%E6%9E%84%E9%80%A0%E4%BA%86%E4%B8%80%E6%9D%A1%E7%BA%BF%E6%AE%B5%22%20%3C%3C%20endl%3B%0A%20%20%20%20%7D%0A%20%20%20%20~Line%28%29%20%7B%20//%20%E6%B7%BB%E5%8A%A0%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%0A%20%20%20%20%20%20%20%20cout%20%3C%3C%20%22%E9%94%80%E6%AF%81%E4%BA%86%E4%B8%80%E6%9D%A1%E7%BA%BF%E6%AE%B5%22%20%3C%3C%20endl%3B%0A%20%20%20%20%7D%0A%20%20%20%20void%20length%28%29%20%7B%0A%20%20%20%20%20%20%20%20double%20len%3B%0A%20%20%20%20%20%20%20%20int%20x1,%20y1,%20x2,%20y2%3B%0A%20%20%20%20%20%20%20%20x1%20%3D%20p1.Getx%28%29%3B%0A%20%20%20%20%20%20%20%20y1%20%3D%20p1.Gety%28%29%3B%0A%20%20%20%20%20%20%20%20x2%20%3D%20p2.Getx%28%29%3B%0A%20%20%20%20%20%20%20%20y2%20%3D%20p2.Gety%28%29%3B%0A%20%20%20%20%20%20%20%20len%20%3D%20sqrt%28%28x2%20-%20x1%29%20*%20%28x2%20-%20x1%29%20%2B%20%28y2%20-%20y1%29%20*%20%28y2%20-%20y1%29%29%3B%0A%20%20%20%20%20%20%20%20cout%20%3C%3C%20%22%E7%BA%BF%E6%AE%B5%E7%9A%84%E9%95%BF%E5%BA%A6%E6%98%AF%22%20%3C%3C%20len%20%3C%3C%20endl%3B%0A%20%20%20%20%7D%0A%20%20%20%20void%20slope%28%29%20%7B%0A%20%20%20%20%20%20%20%20double%20k%3B%0A%20%20%20%20%20%20%20%20int%20x1,%20y1,%20x2,%20y2%3B%0A%20%20%20%20%20%20%20%20x1%20%3D%20p1.Getx%28%29%3B%0A%20%20%20%20%20%20%20%20y1%20%3D%20p1.Gety%28%29%3B%0A%20%20%20%20%20%20%20%20x2%20%3D%20p2.Getx%28%29%3B%0A%20%20%20%20%20%20%20%20y2%20%3D%20p2.Gety%28%29%3B%0A%20%20%20%20%20%20%20%20k%20%3D%20%28double%29%28y2%20-%20y1%29%20/%20%28x2%20-%20x1%29%3B%0A%20%20%20%20%20%20%20%20cout%20%3C%3C%20%22%E7%BA%BF%E6%AE%B5%E7%9A%84%E6%96%9C%E7%8E%87%E6%98%AF%22%20%3C%3C%20k%20%3C%3C%20endl%3B%0A%20%20%20%20%7D%0A%20%20%20%20void%20display%28%29%20%7B%0A%20%20%20%20%20%20%20%20cout%20%3C%3C%20%22%E7%BA%BF%E6%AE%B5%E7%9A%84%E8%B5%B7%E7%82%B9%22%3B%0A%20%20%20%20%20%20%20%20p1.show%28%29%3B%0A%20%20%20%20%20%20%20%20cout%20%3C%3C%20%22%E7%BA%BF%E6%AE%B5%E7%9A%84%E7%BB%88%E7%82%B9%22%3B%0A%20%20%20%20%20%20%20%20p2.show%28%29%3B%0A%20%20%20%20%7D%0A%7D%3B%0A%0Aint%20main%28%29%20%7B%0A%20%20%20%20Point%20mp1%281,%201%29,%20mp2%2816,%2016%29%3B%0A%20%20%20%20Line%20line%28mp1,%20mp2%29%3B%0A%20%20%20%20line.display%28%29%3B%0A%20%20%20%20line.length%28%29%3B%0A%20%20%20%20line.slope%28%29%3B%0A%7D&amp;codeDivHeight=400&amp;codeDivWidth=350&amp;cumulative=false&amp;curInstr=0&amp;heapPrimitives=nevernest&amp;origin=opt-frontend.js&amp;py=cpp_g%2B%2B9.3.0&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false"></iframe>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> c++/c </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字典树</title>
      <link href="/2024/04/05/zi-dian-shu/"/>
      <url>/2024/04/05/zi-dian-shu/</url>
      
        <content type="html"><![CDATA[<p>Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较。Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p><h2 id="题目描述">题目描述</h2><p>维护一个字符串集合，支持两种操作：</p><ol type="1"><li><code>I x</code> 向集合中插入一个字符串<code>x</code>；</li><li><code>Q x</code> 询问字符串<code>x</code>在集合中出现了多少次。</li></ol><p>共有<code>n</code>个操作，所有输入的字符串总长度不超过 <span class="math inline">\(10^5\)</span>，字符串仅<strong>包含小写英文字母</strong>。</p><h2 id="输入格式">输入格式</h2><p>第一行包含整数<code>n</code>，表示操作数。</p><p>接下来<code>n</code>行，每行包含一个操作指令，指令为 <code>I x</code>或 <code>Q x</code> 中的一种。</p><h2 id="输出格式">输出格式</h2><p>对于每个询问指令<code>Q x</code>，都要输出一个整数作为结果，表示<code>x</code>在集合中出现的次数。</p><p>每个结果占一行。</p><h2 id="数据范围">数据范围</h2><p><span class="math inline">\(1≤N≤2×10^4\)</span></p><h2 id="解答">解答</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_NODES = <span class="number">1e6</span> + <span class="number">10</span>; <span class="comment">// 最大节点数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> children[MAX_NODES][<span class="number">26</span>], wordCount[MAX_NODES], nextIndex; <span class="comment">// children数组存储节点的子节点, wordCount记录单词出现次数, nextIndex记录下一个可用的节点索引</span></span><br><span class="line"><span class="type">char</span> buffer[MAX_NODES];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向Trie树中插入一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertString</span><span class="params">(<span class="type">char</span> str[])</span> </span>{</span><br><span class="line">    <span class="type">int</span> node = <span class="number">0</span>; <span class="comment">// 从根节点开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++) { <span class="comment">// 遍历字符串的每个字符</span></span><br><span class="line">        <span class="type">int</span> charIndex = str[i] - <span class="string">'a'</span>; <span class="comment">// 将字符转换为索引（0到25）</span></span><br><span class="line">        <span class="keyword">if</span> (!children[node][charIndex]) children[node][charIndex] = ++nextIndex; <span class="comment">// 如果不存在这个字符的边，则创建一个新节点</span></span><br><span class="line">        node = children[node][charIndex]; <span class="comment">// 移动到下一个节点</span></span><br><span class="line">    }</span><br><span class="line">    wordCount[node]++; <span class="comment">// 在字符串的最后一个字符对应的节点上增加计数</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串在Trie树中出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchString</span><span class="params">(<span class="type">char</span> str[])</span> </span>{</span><br><span class="line">    <span class="type">int</span> node = <span class="number">0</span>; <span class="comment">// 从根节点开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++) { <span class="comment">// 遍历字符串的每个字符</span></span><br><span class="line">        <span class="type">int</span> charIndex = str[i] - <span class="string">'a'</span>; <span class="comment">// 将字符转换为索引</span></span><br><span class="line">        <span class="keyword">if</span> (!children[node][charIndex]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果这个字符在Trie树中不存在，则这个字符串不存在</span></span><br><span class="line">        node = children[node][charIndex]; <span class="comment">// 移动到下一个节点</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> wordCount[node]; <span class="comment">// 返回字符串最后一个字符对应的节点上的计数器的值</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> operations; cin &gt;&gt; operations; <span class="comment">// 操作的数量</span></span><br><span class="line">    <span class="keyword">while</span> (operations--) {</span><br><span class="line">        <span class="type">char</span> operationType[<span class="number">2</span>];</span><br><span class="line">        cin &gt;&gt; operationType &gt;&gt; buffer;</span><br><span class="line">        <span class="keyword">if</span> (operationType[<span class="number">0</span>] == <span class="string">'I'</span>) <span class="built_in">insertString</span>(buffer); <span class="comment">// 如果是插入操作，调用insertString函数</span></span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">searchString</span>(buffer) &lt;&lt; endl; <span class="comment">// 如果是查询操作，调用searchString函数并输出结果</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但若是只是想要AC这道题的话，使用<code>map</code>可能会更简单。</p><h2 id="代码如下">代码如下</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; counter; <span class="comment">// 使用map来存储字符串及其出现次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入字符串，并增加其计数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string&amp; str)</span> </span>{</span><br><span class="line">counter[str]++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">const</span> string&amp; str)</span> </span>{</span><br><span class="line"><span class="keyword">if</span> (counter.<span class="built_in">find</span>(str) != counter.<span class="built_in">end</span>())</span><br><span class="line"><span class="keyword">return</span> counter.<span class="built_in">at</span>(str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> n;cin &gt;&gt; n;</span><br><span class="line">    StringCounter sc;</span><br><span class="line">    <span class="keyword">while</span>(n--) {</span><br><span class="line">        string op, word;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; word;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">"I"</span>) {</span><br><span class="line">            sc.<span class="built_in">insert</span>(word);</span><br><span class="line">        } </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"Q"</span>) {</span><br><span class="line">            cout &lt;&lt; sc.<span class="built_in">search</span>(word) &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> c++/c </category>
          
          <category> Tire树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tire </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP字符串</title>
      <link href="/2024/04/05/kmp/"/>
      <url>/2024/04/05/kmp/</url>
      
        <content type="html"><![CDATA[<p><strong>一个人能走的多远不在于他在顺境时能走的多快，而在于他在逆境时多久能找到曾经的自己。</strong>— <em>KMP</em></p><h2 id="题目描述">题目描述</h2><p>给定一个字符串<code>text</code>，以及一个子串<code>sub</code>，所有字符串中只包含大小写英文字母以及阿拉伯数字。</p><p>子串<code>sub</code>在字符串<code>text</code>中多次作为子串出现。</p><p>求出子串<code>sub</code>在字符串<code>text</code>中所有出现的位置的起始下标。</p><h2 id="输入格式">输入格式</h2><p>第一行输入整数<code>n</code>，表示字符串<code>sub</code>的长度。</p><p>第二行输入字符串<code>sub</code>。</p><p>第三行输入整数<code>m</code>，表示字符串<code>text</code>的长度。</p><p>第四行输入字符串<code>text</code>。</p><h2 id="输出格式">输出格式</h2><p>共一行，输出所有出现位置的起始下标（下标从<code>0</code>开始计数），整数之间用空格隔开。</p><h2 id="数据范围">数据范围</h2><p><span class="math inline">\(1≤n≤10^5\)</span>，<span class="math inline">\(1≤m≤10^6\)</span></p><p>可以先看<a href="https://www.bilibili.com/video/BV1Px411z7Yo?vd_source=02b4405e73478850578c2783699b3ee1">灯神的讲解</a>后，再来看代码。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nex[N], n, m; <span class="comment">// nex数组，n为子串长度，m为文本长度</span></span><br><span class="line"><span class="type">char</span> text[M], sub[N]; <span class="comment">// text为文本，sub为子串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 计算子串的next数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; sub[i] != sub[j + <span class="number">1</span>]) j = nex[j]; <span class="comment">// 当前字符不匹配，回溯</span></span><br><span class="line">        <span class="keyword">if</span> (sub[i] == sub[j + <span class="number">1</span>]) j++; <span class="comment">// 当前字符匹配，前进</span></span><br><span class="line">        nex[i] = j; <span class="comment">// 更新next数组</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在文本中查找子串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++) {</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; text[i] != sub[j + <span class="number">1</span>]) j = nex[j]; <span class="comment">// 文本与子串当前字符不匹配，根据next数组回溯</span></span><br><span class="line">        <span class="keyword">if</span> (text[i] == sub[j + <span class="number">1</span>]) j++; <span class="comment">// 当前字符匹配，前进</span></span><br><span class="line">        <span class="keyword">if</span> (j == n) { <span class="comment">// 找到一个子串的匹配</span></span><br><span class="line">            cout &lt;&lt; i - n &lt;&lt; <span class="string">' '</span>; <span class="comment">// 输出匹配的起始位置</span></span><br><span class="line">            j = nex[j]; <span class="comment">// 根据next数组继续搜索可能的下一个匹配</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; sub + <span class="number">1</span> &gt;&gt; m &gt;&gt; text + <span class="number">1</span>; <span class="comment">// 输入子串和文本，从数组的第1位开始存储字符串</span></span><br><span class="line">    <span class="built_in">kmp</span>(); <span class="comment">// 执行KMP算法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> c++/c </category>
          
          <category> KMP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二节 常数项级数的审敛法</title>
      <link href="/2024/04/03/duo-yuan-wei-ji-fen-12-2-chang-shu-xiang-ji-shu-de-shen-lian-fa/"/>
      <url>/2024/04/03/duo-yuan-wei-ji-fen-12-2-chang-shu-xiang-ji-shu-de-shen-lian-fa/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iYU741tsnpli">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分12-2常数项级数的审敛法/51.jpg" alt="51.jpg"><figcaption aria-hidden="true">51.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-2常数项级数的审敛法/52.jpg" alt="52.jpg"><figcaption aria-hidden="true">52.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-2常数项级数的审敛法/53.jpg" alt="53.jpg"><figcaption aria-hidden="true">53.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-2常数项级数的审敛法/54.jpg" alt="54.jpg"><figcaption aria-hidden="true">54.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-2常数项级数的审敛法/55.jpg" alt="55.jpg"><figcaption aria-hidden="true">55.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-2常数项级数的审敛法/56.jpg" alt="56.jpg"><figcaption aria-hidden="true">56.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-2常数项级数的审敛法/57.jpg" alt="57.jpg"><figcaption aria-hidden="true">57.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-2常数项级数的审敛法/58.jpg" alt="58.jpg"><figcaption aria-hidden="true">58.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-2常数项级数的审敛法/59.jpg" alt="59.jpg"><figcaption aria-hidden="true">59.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-2常数项级数的审敛法/60.jpg" alt="60.jpg"><figcaption aria-hidden="true">60.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-2常数项级数的审敛法/61.jpg" alt="61.jpg"><figcaption aria-hidden="true">61.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-2常数项级数的审敛法/62.jpg" alt="62.jpg"><figcaption aria-hidden="true">62.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十二章 无穷级数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常数项级数 </tag>
            
            <tag> 比较审敛法 </tag>
            
            <tag> 比值审敛法 </tag>
            
            <tag> 根值审敛法 </tag>
            
            <tag> 极限审敛法 </tag>
            
            <tag> 莱布尼茨定理 </tag>
            
            <tag> 绝对收敛与条件收敛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一节 常数项级数的概念和性质</title>
      <link href="/2024/04/03/duo-yuan-wei-ji-fen-12-1-chang-shu-xiang-ji-shu-de-gai-nian-he-xing-zhi/"/>
      <url>/2024/04/03/duo-yuan-wei-ji-fen-12-1-chang-shu-xiang-ji-shu-de-gai-nian-he-xing-zhi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iqVpq1tslugb">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分12-1常数项级数的概念和性质/44.jpg" alt="44.jpg"><figcaption aria-hidden="true">44.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-1常数项级数的概念和性质/45.jpg" alt="45.jpg"><figcaption aria-hidden="true">45.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-1常数项级数的概念和性质/46.jpg" alt="46.jpg"><figcaption aria-hidden="true">46.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-1常数项级数的概念和性质/47.jpg" alt="47.jpg"><figcaption aria-hidden="true">47.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-1常数项级数的概念和性质/48.jpg" alt="48.jpg"><figcaption aria-hidden="true">48.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-1常数项级数的概念和性质/49.jpg" alt="49.jpg"><figcaption aria-hidden="true">49.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分12-1常数项级数的概念和性质/50.jpg" alt="50.jpg"><figcaption aria-hidden="true">50.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十二章 无穷级数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常数项级数 </tag>
            
            <tag> 柯西审敛原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>折半查找之范围查找</title>
      <link href="/2024/04/02/zhe-ban-cha-zhao-zhi-fan-wei-cha-zhao/"/>
      <url>/2024/04/02/zhe-ban-cha-zhao-zhi-fan-wei-cha-zhao/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>利用折半查找算法进行范围查找。所谓范围查找是要找出在给定值 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 之间的所有元素 <span class="math inline">\((a\leq b)\)</span> 。</p><h2 id="输入格式">输入格式</h2><p>（1）第1行是序列中的元素个数</p><p>（2）第2行是有序序列（数与数之间用空格分隔）</p><p>（3）第3行是下限和上限（用空格分隔）</p><h2 id="输出格式">输出格式</h2><p>指定范围内的所有元素（数与数之间用空格分隔）</p><h2 id="示例">示例</h2><p>输入（Input）：</p><p>8</p><p>1 3 4 6 7 8 9 15</p><p>5 10</p><p>输出（Output）：</p><p>6 7 8 9</p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_SIZE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max, <span class="type">int</span> r[MAX_SIZE], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>{</span><br><span class="line">    <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r[mid] &lt; min) { <span class="comment">// 分治求解左侧范围</span></span><br><span class="line">        <span class="built_in">find</span>(min, max, r, mid, high);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r[mid] &gt; max) { <span class="comment">// 分治求解右侧范围</span></span><br><span class="line">        <span class="built_in">find</span>(min, max, r, low, mid);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> { <span class="comment">// 输出答案</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s; <span class="comment">// 利用栈将mid左侧数按原来数组的顺序输出</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = mid; r[i] &gt;= min &amp;&amp; i &gt;= low; i--) </span><br><span class="line">            s.<span class="built_in">push</span>(r[i]);</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,s.<span class="built_in">top</span>());</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = mid + <span class="number">1</span>; r[j] &lt;= max &amp;&amp; j &lt;= high; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, r[j]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="type">int</span> n;    cin &gt;&gt; n; <span class="comment">// 输入元素个数</span></span><br><span class="line"><span class="type">int</span> r[MAX_SIZE];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)    cin &gt;&gt; r[i];</span><br><span class="line"><span class="type">int</span> a, b;    cin &gt;&gt; a &gt;&gt; b; <span class="comment">// 输入查找范围的最小值和最大值</span></span><br><span class="line"><span class="built_in">find</span>(a, b, r, <span class="number">0</span>, n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> c++ </category>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 折半查找 </tag>
            
            <tag> 分治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六节 随机变量函数的分布</title>
      <link href="/2024/03/31/gai-lu-lun-2-6-sui-ji-bian-liang-han-shu-de-fen-bu/"/>
      <url>/2024/03/31/gai-lu-lun-2-6-sui-ji-bian-liang-han-shu-de-fen-bu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/ikUBk1tajnfi">下载PDF点这里</a></p><p><span class="math inline">\(ps\)</span>：笔记配套书本为高等教育出版社《概率论与数理统计教程(第三版)》，是数学系同学的课本，对绝大部分非数学系同学来说笔记中题目难度要高于课程要求。</p><figure><img src="../../../../images/概率论2-6随机变量函数的分布/37.jpg" alt="37.jpg"><figcaption aria-hidden="true">37.jpg</figcaption></figure><figure><img src="../../../../images/概率论2-6随机变量函数的分布/38.jpg" alt="38.jpg"><figcaption aria-hidden="true">38.jpg</figcaption></figure><figure><img src="../../../../images/概率论2-6随机变量函数的分布/39.jpg" alt="39.jpg"><figcaption aria-hidden="true">39.jpg</figcaption></figure><figure><img src="../../../../images/概率论2-6随机变量函数的分布/40.jpg" alt="40.jpg"><figcaption aria-hidden="true">40.jpg</figcaption></figure><figure><img src="../../../../images/概率论2-6随机变量函数的分布/41.jpg" alt="41.jpg"><figcaption aria-hidden="true">41.jpg</figcaption></figure><figure><img src="../../../../images/概率论2-6随机变量函数的分布/42.jpg" alt="42.jpg"><figcaption aria-hidden="true">42.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第二章 随机变量及其分布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随机变量函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五节 常用连续分布</title>
      <link href="/2024/03/31/gai-lu-lun-2-5-chang-yong-lian-xu-fen-bu/"/>
      <url>/2024/03/31/gai-lu-lun-2-5-chang-yong-lian-xu-fen-bu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/il4RZ1taj3gj">下载PDF点这里</a></p><p><span class="math inline">\(ps\)</span>：笔记配套书本为高等教育出版社《概率论与数理统计教程(第三版)》，是数学系同学的课本，对绝大部分非数学系同学来说笔记中题目难度要高于课程要求。</p><figure><img src="../../../../images/概率论2-5常用连续分布/30.jpg" alt="30.jpg"><figcaption aria-hidden="true">30.jpg</figcaption></figure><figure><img src="../../../../images/概率论2-5常用连续分布/31.jpg" alt="31.jpg"><figcaption aria-hidden="true">31.jpg</figcaption></figure><figure><img src="../../../../images/概率论2-5常用连续分布/32.jpg" alt="32.jpg"><figcaption aria-hidden="true">32.jpg</figcaption></figure><figure><img src="../../../../images/概率论2-5常用连续分布/33.jpg" alt="33.jpg"><figcaption aria-hidden="true">33.jpg</figcaption></figure><figure><img src="../../../../images/概率论2-5常用连续分布/34.jpg" alt="34.jpg"><figcaption aria-hidden="true">34.jpg</figcaption></figure><figure><img src="../../../../images/概率论2-5常用连续分布/35.jpg" alt="35.jpg"><figcaption aria-hidden="true">35.jpg</figcaption></figure><figure><img src="../../../../images/概率论2-5常用连续分布/36.jpg" alt="36.jpg"><figcaption aria-hidden="true">36.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第二章 随机变量及其分布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正态分布 </tag>
            
            <tag> 均匀分布 </tag>
            
            <tag> 指数分布 </tag>
            
            <tag> 伽马分布 </tag>
            
            <tag> 贝塔分布 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四节 常用离散分布</title>
      <link href="/2024/03/31/gai-lu-lun-2-4-chang-yong-chi-san-fen-bu/"/>
      <url>/2024/03/31/gai-lu-lun-2-4-chang-yong-chi-san-fen-bu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iHSXq1tag0ob">下载PDF点这里</a></p><p><span class="math inline">\(ps\)</span>：笔记配套书本为高等教育出版社《概率论与数理统计教程(第三版)》，是数学系同学的课本，对绝大部分非数学系同学来说笔记中题目难度要高于课程要求。</p><figure><img src="../../../../images/概率论2-4常用离散分布/24.jpg" alt="24.jpg"><figcaption aria-hidden="true">24.jpg</figcaption></figure><figure><img src="../../../../images/概率论2-4常用离散分布/25.jpg" alt="25.jpg"><figcaption aria-hidden="true">25.jpg</figcaption></figure><figure><img src="../../../../images/概率论2-4常用离散分布/26.jpg" alt="26.jpg"><figcaption aria-hidden="true">26.jpg</figcaption></figure><figure><img src="../../../../images/概率论2-4常用离散分布/27.jpg" alt="27.jpg"><figcaption aria-hidden="true">27.jpg</figcaption></figure><figure><img src="../../../../images/概率论2-4常用离散分布/28.jpg" alt="28.jpg"><figcaption aria-hidden="true">28.jpg</figcaption></figure><figure><img src="../../../../images/概率论2-4常用离散分布/29.jpg" alt="29.jpg"><figcaption aria-hidden="true">29.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第二章 随机变量及其分布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二项分布 </tag>
            
            <tag> 泊松分布 </tag>
            
            <tag> 超几何分布 </tag>
            
            <tag> 几何分布 </tag>
            
            <tag> 负二项分布 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三节 随机变量的方差与标准差</title>
      <link href="/2024/03/31/gai-lu-lun-2-3-sui-ji-bian-liang-de-fang-chai-yu-biao-zhun-chai/"/>
      <url>/2024/03/31/gai-lu-lun-2-3-sui-ji-bian-liang-de-fang-chai-yu-biao-zhun-chai/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/i8jhi1tafi7g">下载PDF点这里</a></p><p><span class="math inline">\(ps\)</span>：笔记配套书本为高等教育出版社《概率论与数理统计教程(第三版)》，是数学系同学的课本，对绝大部分非数学系同学来说笔记中题目难度要高于课程要求。</p><figure><img src="../../../../images/概率论2-3随机变量的方差与标准差/21.jpg" alt="21.jpg"><figcaption aria-hidden="true">21.jpg</figcaption></figure><figure><img src="../../../../images/概率论2-3随机变量的方差与标准差/22.jpg" alt="22.jpg"><figcaption aria-hidden="true">22.jpg</figcaption></figure><figure><img src="../../../../images/概率论2-3随机变量的方差与标准差/23.jpg" alt="23.jpg"><figcaption aria-hidden="true">23.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第二章 随机变量及其分布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方差 </tag>
            
            <tag> 标准差 </tag>
            
            <tag> 切比雪夫不等式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二节 随机变量的数学期望</title>
      <link href="/2024/03/31/gai-lu-lun-2-2-sui-ji-bian-liang-de-shu-xue-qi-wang/"/>
      <url>/2024/03/31/gai-lu-lun-2-2-sui-ji-bian-liang-de-shu-xue-qi-wang/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/i90XZ1tady7a">下载PDF点这里</a></p><p><span class="math inline">\(ps\)</span>：笔记配套书本为高等教育出版社《概率论与数理统计教程(第三版)》，是数学系同学的课本，对绝大部分非数学系同学来说笔记中题目难度要高于课程要求。</p><figure><img src="../../../../images/概率论2-2随机变量的数学期望/18.jpg" alt="18.jpg"><figcaption aria-hidden="true">18.jpg</figcaption></figure><figure><img src="../../../../images/概率论2-2随机变量的数学期望/19.jpg" alt="19.jpg"><figcaption aria-hidden="true">19.jpg</figcaption></figure><figure><img src="../../../../images/概率论2-2随机变量的数学期望/20.jpg" alt="20.jpg"><figcaption aria-hidden="true">20.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第二章 随机变量及其分布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析程序运行过程，说明拷贝造函数的调用过程</title>
      <link href="/2024/03/31/fen-xi-kao-bei-gou-zao-han-shu-zuo-ye/"/>
      <url>/2024/03/31/fen-xi-kao-bei-gou-zao-han-shu-zuo-ye/</url>
      
        <content type="html"><![CDATA[<p><strong>代码：</strong></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i);</span><br><span class="line"><span class="built_in">Complex</span>(Complex&amp; c);</span><br><span class="line"><span class="function">Complex <span class="title">add</span><span class="params">(Complex c)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> real, image;</span><br><span class="line">};</span><br><span class="line">Complex::<span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) :<span class="built_in">real</span>(r), <span class="built_in">image</span>(i)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; <span class="string">"调用两个参数的构造函数"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">Complex::<span class="built_in">Complex</span>(Complex&amp; c)</span><br><span class="line">{</span><br><span class="line">real = c.real;</span><br><span class="line">image = c.image;</span><br><span class="line">cout &lt;&lt; <span class="string">"调用拷贝构造函数"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Complex::print</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"("</span> &lt;&lt; real &lt;&lt; <span class="string">","</span> &lt;&lt; image &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function">Complex <span class="title">Complex::add</span><span class="params">(Complex c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="function">Complex <span class="title">y</span><span class="params">(real + c.real, image + c.image)</span></span>;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Complex n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"n="</span>;</span><br><span class="line">n.<span class="built_in">print</span>();</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">5.6</span>, <span class="number">7.9</span>)</span></span>;</span><br><span class="line"><span class="function">Complex <span class="title">c</span><span class="params">(a)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"a="</span>;</span><br><span class="line">a.<span class="built_in">print</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">"c="</span>;</span><br><span class="line">c.<span class="built_in">print</span>();</span><br><span class="line"><span class="built_in">f</span>(b);</span><br><span class="line">c = a.<span class="built_in">add</span>(b);</span><br><span class="line">c.<span class="built_in">print</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>运行代码后显示：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">调用两个参数的构造函数</span><br><span class="line">调用两个参数的构造函数</span><br><span class="line">调用拷贝构造函数</span><br><span class="line">a=(3,4)</span><br><span class="line">c=(3,4)</span><br><span class="line">调用拷贝构造函数</span><br><span class="line">n=(5.6,7.9)</span><br><span class="line">调用拷贝构造函数</span><br><span class="line">调用两个参数的构造函数</span><br><span class="line">(8.6,11.9)</span><br></pre></td></tr></tbody></table></figure><p><strong>分析程序的主要运行过程：</strong></p><ol type="1"><li><p><strong>初始化对象 <span class="math inline">\(a\)</span></strong>:使用<code>Complex(double r, double i)</code>构造函数，传入<code>3.0</code>和<code>4.0</code>作为参数，初始化对象<span class="math inline">\(a\)</span>的成员变量<code>real</code>和<code>image</code>。输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">调用两个参数的构造函数</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>初始化对象 <span class="math inline">\(b\)</span></strong>:使用<code>Complex(double r, double i)</code>构造函数，传入<code>5.6</code>和<code>7.9</code>作为参数，初始化对象<span class="math inline">\(b\)</span>。输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">调用两个参数的构造函数</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>初始化对象 <span class="math inline">\(c\)</span>通过拷贝构造函数</strong>:使用拷贝构造函数<code>Complex(Complex&amp; c)</code>，以 <span class="math inline">\(a\)</span> 作为参数，初始化 <span class="math inline">\(c\)</span>，调用拷贝构造函数，使 <span class="math inline">\(c\)</span> 的成员变量的值与 <span class="math inline">\(a\)</span> 相同。输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">调用拷贝构造函数</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>打印对象 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(c\)</span>的值</strong>：调用<code>print</code>方法输出 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(c\)</span> 的值。输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">a=(3,4)</span><br><span class="line">c=(3,4)</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>调用函数<code>f</code></strong>：函数<code>f</code>接受一个<code>Complex</code>类型的参数。这里将对象<span class="math inline">\(b\)</span>传递给函数<code>f</code>。因为<code>f</code>的参数是按值传递的，所以这里会调用<code>Complex(Complex&amp; c)</code>拷贝构造函数，创建<span class="math inline">\(b\)</span> 的一个副本 <span class="math inline">\(n\)</span> ，然后在<code>f</code>中打印 <span class="math inline">\(n\)</span> 的值。输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">调用拷贝构造函数</span><br><span class="line">n=(5.6,7.9)</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>使用<code>add</code>方法</strong>：调用<code>a.add(b)</code>，这里将对象<span class="math inline">\(b\)</span>传递给函数<code>add</code>。因为<code>add</code>的参数是按值传递的，所以这里会调用<code>Complex(Complex&amp; c)</code>拷贝构造函数，输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">调用拷贝构造函数</span><br></pre></td></tr></tbody></table></figure><p>在<code>add</code>方法内部，创建了一个名为 <span class="math inline">\(y\)</span>​的临时对象，用于存储相加后的结果。这一步调用了两个参数的构造函数<code>Complex(double r, double i)</code>，输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">调用两个参数的构造函数</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>将<code>add</code>方法的返回值赋给对象 <span class="math inline">\(c\)</span></strong></p></li><li><p><strong>打印c的值</strong>。输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">(8.6,11.9)</span><br></pre></td></tr></tbody></table></figure></li></ol><p><strong>若将代码：</strong></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">Complex::add</span><span class="params">(Complex c)</span></span></span><br></pre></td></tr></tbody></table></figure><p><strong>改为：</strong></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">Complex::add</span><span class="params">(Complex &amp; c)</span></span>; </span><br></pre></td></tr></tbody></table></figure><p>即使用引用传递。</p><p><strong>此时输出：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">调用两个参数的构造函数</span><br><span class="line">调用拷贝构造函数</span><br><span class="line">a=(3,4)</span><br><span class="line">c=(3,4)</span><br><span class="line">调用拷贝构造函数</span><br><span class="line">n=(5.6,7.9)</span><br><span class="line">调用两个参数的构造函数</span><br><span class="line">(8.6,11.9)</span><br></pre></td></tr></tbody></table></figure><p>可以看到通过引用传递可以避免创建参数的副本，不会触发<code>Complex::Complex(Complex&amp; c)</code>拷贝构造函数，可以提高程序的效率。</p><p>亦可使用<code>operator+</code>来避免创建参数的副本。可将代码改为：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i);</span><br><span class="line"><span class="built_in">Complex</span>(<span class="type">const</span> Complex&amp; c);<span class="comment">//将拷贝构造函数的参数更改为const引用</span></span><br><span class="line"><span class="function">Complex <span class="title">add</span><span class="params">(Complex &amp;c)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; c);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> real, image;</span><br><span class="line">};</span><br><span class="line">Complex::<span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) :<span class="built_in">real</span>(r), <span class="built_in">image</span>(i)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; <span class="string">"调用两个参数的构造函数"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">Complex::<span class="built_in">Complex</span>(<span class="type">const</span> Complex&amp; c)</span><br><span class="line">{</span><br><span class="line">real = c.real;</span><br><span class="line">image = c.image;</span><br><span class="line">cout &lt;&lt; <span class="string">"调用拷贝构造函数"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Complex::print</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"("</span> &lt;&lt; real &lt;&lt; <span class="string">","</span> &lt;&lt; image &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">Complex Complex::<span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; c) {<span class="comment">//将add方法更改为operator+</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Complex</span>(real + c.real, image + c.image);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Complex n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"n="</span>;</span><br><span class="line">n.<span class="built_in">print</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">5.6</span>, <span class="number">7.9</span>)</span></span>;</span><br><span class="line"><span class="function">Complex <span class="title">c</span><span class="params">(a)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"a="</span>;</span><br><span class="line">a.<span class="built_in">print</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">"c="</span>;</span><br><span class="line">c.<span class="built_in">print</span>();</span><br><span class="line"><span class="built_in">f</span>(b);</span><br><span class="line">c = a + b;<span class="comment">//使用operator+</span></span><br><span class="line">c.<span class="built_in">print</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果与上面相同。</p><p>此外，这里的<code>c = a + b;</code>在c++11或优化的编译器中使用了移动赋值操作符<code>operator=(Complex&amp;&amp;)</code>赋值给<code>c</code>，但在老版本或者未优化的编译器中会调用拷贝赋值操作符，执行复制而占用空间。</p><p>要想实现日志效果，则可以在对象中添加<code>operator=</code></p><p><strong>拷贝赋值操作符：</strong></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Complex&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Complex&amp; c) {</span><br><span class="line">real = c.real;</span><br><span class="line">image = c.image;</span><br><span class="line">cout &lt;&lt; <span class="string">"调用拷贝赋值操作符"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p><strong>移动赋值操作符：</strong></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Complex&amp; <span class="keyword">operator</span>=(Complex&amp;&amp; c) <span class="keyword">noexcept</span> {</span><br><span class="line">real = c.real;</span><br><span class="line">image = c.image;</span><br><span class="line">cout &lt;&lt; <span class="string">"调用移动赋值操作符"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> c++/c </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第一节 随机变量及其分布</title>
      <link href="/2024/03/31/gai-lu-lun-2-1-sui-ji-bian-liang-ji-qi-fen-bu/"/>
      <url>/2024/03/31/gai-lu-lun-2-1-sui-ji-bian-liang-ji-qi-fen-bu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iocz61t9vzlc">下载PDF点这里</a></p><p><span class="math inline">\(ps\)</span>：笔记配套书本为高等教育出版社《概率论与数理统计教程(第三版)》，是数学系同学的课本，对绝大部分非数学系同学来说笔记中题目难度要高于课程要求。</p><figure><img src="../../../../images/概率论2-1随机变量及其分布/14.jpg" alt="14.jpg"><figcaption aria-hidden="true">14.jpg</figcaption></figure><figure><img src="../../../../images/概率论2-1随机变量及其分布/15.jpg" alt="15.jpg"><figcaption aria-hidden="true">15.jpg</figcaption></figure><figure><img src="../../../../images/概率论2-1随机变量及其分布/16.jpg" alt="16.jpg"><figcaption aria-hidden="true">16.jpg</figcaption></figure><figure><img src="../../../../images/概率论2-1随机变量及其分布/17.jpg" alt="17.jpg"><figcaption aria-hidden="true">17.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第二章 随机变量及其分布 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随机变量 </tag>
            
            <tag> 分布函数 </tag>
            
            <tag> 概率分布列 </tag>
            
            <tag> 概率密度函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计数问题-数位统计DP</title>
      <link href="/2024/03/30/ji-shu-wen-ti/"/>
      <url>/2024/03/30/ji-shu-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>给定两个整数 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> ，求 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 之间的所有数字中 <span class="math inline">\(0∼9\)</span> 的出现次数。</p><h2 id="输入格式">输入格式</h2><p>输入包含多组测试数据。</p><p>每组测试数据占一行，包含两个整数 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 。</p><p>当读入一行为 <code>0 0</code>时，表示输入终止，且该行不作处理。</p><h2 id="输出格式">输出格式</h2><p>每组数据输出一个结果，每个结果占一行。</p><p>每个结果包含十个用空格隔开的数字，第一个数字表示 <code>0</code>出现的次数，第二个数字表示 <code>1</code> 出现的次数，以此类推。</p><h2 id="解答">解答</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数字序列从第l位到第r位转换为一个整数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">toInt</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>{</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &gt;= r; --i)</span><br><span class="line">        result = result * <span class="number">10</span> + digits[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算10的x次方</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow10</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">    <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (x--) result *= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算在0到n范围内数字x出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countX</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> x)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果n为0，直接返回0</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; digits; <span class="comment">// 存储n的每一位数字</span></span><br><span class="line">    <span class="keyword">while</span> (n) { <span class="comment">// 分解n到digits向量中</span></span><br><span class="line">        digits.<span class="built_in">push_back</span>(n % <span class="number">10</span>);</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line">    n = digits.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 用于累计数字x出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span> - !x; i &gt;= <span class="number">0</span>; --i) {</span><br><span class="line">        <span class="comment">// 不考虑最高位为0的情况（当x=0时）</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>) {</span><br><span class="line">            <span class="comment">// 当前位之前的数字组合成的数对结果的贡献</span></span><br><span class="line">            cnt += <span class="built_in">toInt</span>(digits, n - <span class="number">1</span>, i + <span class="number">1</span>) * <span class="built_in">pow10</span>(i);</span><br><span class="line">            <span class="comment">// 如果x为0，需要减去当前位为0时的情况</span></span><br><span class="line">            <span class="keyword">if</span> (!x) cnt -= <span class="built_in">pow10</span>(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果当前位等于x，加上当前位右侧数字组成的数+1</span></span><br><span class="line">        <span class="keyword">if</span> (digits[i] == x)</span><br><span class="line">            cnt += <span class="built_in">toInt</span>(digits, i - <span class="number">1</span>, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果当前位大于x，加上10的i次方</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (digits[i] &gt; x)</span><br><span class="line">            cnt += <span class="built_in">pow10</span>(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; a &gt;&gt; b &amp;&amp; (a || b)) { <span class="comment">// 循环直到输入0 0</span></span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) <span class="built_in">swap</span>(a, b); <span class="comment">// 确保a&lt;=b</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">            cout &lt;&lt; <span class="built_in">countX</span>(b, i) - <span class="built_in">countX</span>(a - <span class="number">1</span>, i) &lt;&lt; <span class="string">" \n"</span>[i == <span class="number">9</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> c++ </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2024/03/30/kuai-su-pai-xu/"/>
      <url>/2024/03/30/kuai-su-pai-xu/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>给定你一个长度为<span class="math inline">\(n\)</span>的整数数列。</p><p>请你对这个数列按照从小到大进行排序并输出。</p><h2 id="输入格式">输入格式</h2><p>输入共两行，第一行包含整数<span class="math inline">\(n\)</span>，第二行包含<span class="math inline">\(n\)</span>个整数表示整个数列。</p><h2 id="输出格式">输出格式</h2><p>输出一行排好序的数列。</p><h2 id="解答">解答</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Q_sort函数实现快速排序，参数为数组q、排序开始位置l和结束位置r</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Q_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>; <span class="comment">// 如果开始位置大于等于结束位置，则不进行排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 快排模板</span></span><br><span class="line">    <span class="type">int</span> x = q[l + (r - l) / <span class="number">2</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>; <span class="comment">// 选择中间位置的值作为基准值x，初始化左右指针i和j</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) { <span class="comment">// 当左指针小于右指针时进行循环</span></span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span> (q[i] &lt; x); <span class="comment">// 左指针右移，直到找到一个大于等于x的值</span></span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span> (q[j] &gt; x); <span class="comment">// 右指针左移，直到找到一个小于等于x的值</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]); <span class="comment">// 如果左指针仍然小于右指针，则交换两个指针所指的值</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 递归调用Q_sort函数，对基准值左右的两部分分别进行排序</span></span><br><span class="line">    <span class="built_in">Q_sort</span>(q, l, j);</span><br><span class="line">    <span class="built_in">Q_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q[i]);</span><br><span class="line">    <span class="built_in">Q_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>); <span class="comment">// 调用Q_sort函数进行快速排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> c++ </category>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七节 斯托克斯公式 环流量与旋度</title>
      <link href="/2024/03/29/duo-yuan-wei-ji-fen-11-7-si-tuo-ke-si-gong-shi-huan-liu-liang-yu-xuan-du/"/>
      <url>/2024/03/29/duo-yuan-wei-ji-fen-11-7-si-tuo-ke-si-gong-shi-huan-liu-liang-yu-xuan-du/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/icn6t1t2pwsd">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分11-7斯托克斯公式-环流量与旋度/35.jpg" alt="35.jpg"><figcaption aria-hidden="true">35.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-7斯托克斯公式-环流量与旋度/36.jpg" alt="36.jpg"><figcaption aria-hidden="true">36.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-7斯托克斯公式-环流量与旋度/37.jpg" alt="37.jpg"><figcaption aria-hidden="true">37.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-7斯托克斯公式-环流量与旋度/38.jpg" alt="38.jpg"><figcaption aria-hidden="true">38.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-7斯托克斯公式-环流量与旋度/39.jpg" alt="39.jpg"><figcaption aria-hidden="true">39.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-7斯托克斯公式-环流量与旋度/40.jpg" alt="40.jpg"><figcaption aria-hidden="true">40.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十一章 曲线积分与曲面积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 曲线积分 </tag>
            
            <tag> 斯托克斯公式 </tag>
            
            <tag> 环流量 </tag>
            
            <tag> 散旋度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六节 高斯公式 通量与散度</title>
      <link href="/2024/03/29/duo-yuan-wei-ji-fen-11-6-gao-si-gong-shi-tong-liang-yu-san-du/"/>
      <url>/2024/03/29/duo-yuan-wei-ji-fen-11-6-gao-si-gong-shi-tong-liang-yu-san-du/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iwTT11t2njgb">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分11-6高斯公式-通量与散度/29.jpg" alt="29.jpg"><figcaption aria-hidden="true">29.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-6高斯公式-通量与散度/30.jpg" alt="30.jpg"><figcaption aria-hidden="true">30.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-6高斯公式-通量与散度/31.jpg" alt="31.jpg"><figcaption aria-hidden="true">31.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-6高斯公式-通量与散度/32.jpg" alt="32.jpg"><figcaption aria-hidden="true">32.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-6高斯公式-通量与散度/33.jpg" alt="33.jpg"><figcaption aria-hidden="true">33.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-6高斯公式-通量与散度/34.jpg" alt="34.jpg"><figcaption aria-hidden="true">34.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十一章 曲线积分与曲面积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 曲面积分 </tag>
            
            <tag> 高斯公式 </tag>
            
            <tag> 通量 </tag>
            
            <tag> 散度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五节 对坐标的曲面积分</title>
      <link href="/2024/03/29/duo-yuan-wei-ji-fen-11-5-dui-zuo-biao-de-qu-mian-ji-fen/"/>
      <url>/2024/03/29/duo-yuan-wei-ji-fen-11-5-dui-zuo-biao-de-qu-mian-ji-fen/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/i8v5k1t2liah">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分11-5对坐标的曲面积分/22.jpg" alt="22.jpg"><figcaption aria-hidden="true">22.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-5对坐标的曲面积分/23.jpg" alt="23.jpg"><figcaption aria-hidden="true">23.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-5对坐标的曲面积分/24.jpg" alt="24.jpg"><figcaption aria-hidden="true">24.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-5对坐标的曲面积分/25.jpg" alt="25.jpg"><figcaption aria-hidden="true">25.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-5对坐标的曲面积分/26.jpg" alt="26.jpg"><figcaption aria-hidden="true">26.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-5对坐标的曲面积分/27.jpg" alt="27.jpg"><figcaption aria-hidden="true">27.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-5对坐标的曲面积分/28.jpg" alt="28.jpg"><figcaption aria-hidden="true">28.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十一章 曲线积分与曲面积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 曲面积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四节 对面积的曲面积分</title>
      <link href="/2024/03/29/duo-yuan-wei-ji-fen-11-4-dui-mian-ji-de-qu-mian-ji-fen/"/>
      <url>/2024/03/29/duo-yuan-wei-ji-fen-11-4-dui-mian-ji-de-qu-mian-ji-fen/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iZgaD1t2kjxa">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分11-4对面积的曲面积分/18.jpg" alt="18.jpg"><figcaption aria-hidden="true">18.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-4对面积的曲面积分/19.jpg" alt="19.jpg"><figcaption aria-hidden="true">19.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-4对面积的曲面积分/20.jpg" alt="20.jpg"><figcaption aria-hidden="true">20.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-4对面积的曲面积分/21.jpg" alt="21.jpg"><figcaption aria-hidden="true">21.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十一章 曲线积分与曲面积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 曲面积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三节 格林公式及其应用</title>
      <link href="/2024/03/29/duo-yuan-wei-ji-fen-11-3-ge-lin-gong-shi-ji-qi-ying-yong/"/>
      <url>/2024/03/29/duo-yuan-wei-ji-fen-11-3-ge-lin-gong-shi-ji-qi-ying-yong/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/ikpPX1t0ivlg">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分11-3格林公式及其应用/8.jpg" alt="8.jpg"><figcaption aria-hidden="true">8.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-3格林公式及其应用/9.jpg" alt="9.jpg"><figcaption aria-hidden="true">9.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-3格林公式及其应用/10.jpg" alt="10.jpg"><figcaption aria-hidden="true">10.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-3格林公式及其应用/11.jpg" alt="11.jpg"><figcaption aria-hidden="true">11.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-3格林公式及其应用/12.jpg" alt="12.jpg"><figcaption aria-hidden="true">12.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-3格林公式及其应用/13.jpg" alt="13.jpg"><figcaption aria-hidden="true">13.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-3格林公式及其应用/14.jpg" alt="14.jpg"><figcaption aria-hidden="true">14.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-3格林公式及其应用/15.jpg" alt="15.jpg"><figcaption aria-hidden="true">15.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-3格林公式及其应用/16.jpg" alt="16.jpg"><figcaption aria-hidden="true">16.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-3格林公式及其应用/17.jpg" alt="17.jpg"><figcaption aria-hidden="true">17.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十一章 曲线积分与曲面积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 曲线积分 </tag>
            
            <tag> 格林公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二节 对坐标的曲线积分</title>
      <link href="/2024/03/29/duo-yuan-wei-ji-fen-11-2-dui-zuo-biao-de-qu-xian-ji-fen/"/>
      <url>/2024/03/29/duo-yuan-wei-ji-fen-11-2-dui-zuo-biao-de-qu-xian-ji-fen/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iatBx1t0ih6h">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分11-2对坐标的曲线积分/1.jpg" alt="1.jpg"><figcaption aria-hidden="true">1.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-2对坐标的曲线积分/2.jpg" alt="2.jpg"><figcaption aria-hidden="true">2.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-2对坐标的曲线积分/3.jpg" alt="3.jpg"><figcaption aria-hidden="true">3.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-2对坐标的曲线积分/4.jpg" alt="4.jpg"><figcaption aria-hidden="true">4.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-2对坐标的曲线积分/5.jpg" alt="5.jpg"><figcaption aria-hidden="true">5.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-2对坐标的曲线积分/6.jpg" alt="6.jpg"><figcaption aria-hidden="true">6.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-2对坐标的曲线积分/7.jpg" alt="7.jpg"><figcaption aria-hidden="true">7.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十一章 曲线积分与曲面积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 曲线积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一节 对弧长的曲线积分</title>
      <link href="/2024/03/29/duo-yuan-wei-ji-fen-11-1-dui-hu-chang-de-qu-xian-ji-fen/"/>
      <url>/2024/03/29/duo-yuan-wei-ji-fen-11-1-dui-hu-chang-de-qu-xian-ji-fen/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iFZJX1t0i3yb">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分11-1对弧长的曲线积分/147.jpg" alt="147.jpg"><figcaption aria-hidden="true">147.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-1对弧长的曲线积分/148.jpg" alt="148.jpg"><figcaption aria-hidden="true">148.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-1对弧长的曲线积分/149.jpg" alt="149.jpg"><figcaption aria-hidden="true">149.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分11-1对弧长的曲线积分/150.jpg" alt="150.jpg"><figcaption aria-hidden="true">150.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十一章 曲线积分与曲面积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 曲线积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言实现π的高精度计算</title>
      <link href="/2024/03/27/gao-jing-du-pi/"/>
      <url>/2024/03/27/gao-jing-du-pi/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">题目描述</h1><p>限制使用双向链表作存储结构，请根据用户输入的一个整数（该整数表示精确到小数点后的位数，可能要求精确到小数点后500 位），高精度计算PI值。可以利用反三角函数幂级展开式来进行计算。</p><h2 id="测试说明">测试说明</h2><p><strong>输入说明：</strong>输入的一个正整数n。输出说明：输出PI的值，精确到小数点后n位，最后输出一个回车。平台会对你编写的代码进行测试：</p><p><strong>测试输入：</strong>5</p><p><strong>预期输出：</strong>3.14159</p><h2 id="解答">解答</h2><p>以下是数组实现的方法： 显然使用数组，时间复杂度更低。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> r[<span class="number">2800</span> + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> i, k;</span><br><span class="line"><span class="type">int</span> b, d;</span><br><span class="line"><span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">3000</span>];</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line"><span class="type">int</span> n;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);n++;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2800</span>; i++)</span><br><span class="line">r[i] = <span class="number">2000</span>;</span><br><span class="line">    r[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">2800</span>; k &gt; <span class="number">0</span>; k -= <span class="number">14</span>) {</span><br><span class="line">d = <span class="number">0</span>;</span><br><span class="line">i = k;</span><br><span class="line"><span class="keyword">for</span> (;;) {</span><br><span class="line">    d += r[i] * <span class="number">10000</span>;</span><br><span class="line">    b = <span class="number">2</span> * i - <span class="number">1</span>;</span><br><span class="line">    r[i] = d % b;</span><br><span class="line">    d /= b;</span><br><span class="line">    i--;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    d *= i;</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> tmp = c + d / <span class="number">10000</span>;</span><br><span class="line">ans[j+<span class="number">3</span>] = tmp % <span class="number">10</span>;</span><br><span class="line">ans[j+<span class="number">2</span>] = (tmp / <span class="number">10</span>) % <span class="number">10</span>;</span><br><span class="line">ans[j+<span class="number">1</span>] = (tmp / <span class="number">100</span>) % <span class="number">10</span>;</span><br><span class="line">ans[j+<span class="number">0</span>] = tmp / <span class="number">1000</span>;</span><br><span class="line">j+=<span class="number">4</span>;</span><br><span class="line">c = d % <span class="number">10000</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>&amp;&amp;n&gt;<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>k次循环实际上实在迭代： <span class="math display">\[2\left(1+\frac{1}{3}\left(1+\frac{2}{5}\left(1+\ldots\left(1+\frac{2799}{2\cdot 2799+1}(1+0)\right) \ldots\right)\right)\right)\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> c++/c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 双向链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五节 独立性</title>
      <link href="/2024/03/25/gai-lu-lun-1-5-du-li-xing/"/>
      <url>/2024/03/25/gai-lu-lun-1-5-du-li-xing/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/imne81smk7xc">下载PDF点这里</a></p><p><span class="math inline">\(ps\)</span>：笔记配套书本为高等教育出版社《概率论与数理统计教程(第三版)》，是数学系同学的课本，对绝大部分非数学系同学来说笔记中题目难度要高于课程要求。</p><figure><img src="../../../../images/概率论1-5独立性/11.jpg" alt="11.jpg"><figcaption aria-hidden="true">11.jpg</figcaption></figure><figure><img src="../../../../images/概率论1-5独立性/12.jpg" alt="12.jpg"><figcaption aria-hidden="true">12.jpg</figcaption></figure><figure><img src="../../../../images/概率论1-5独立性/13.jpg" alt="13.jpg"><figcaption aria-hidden="true">13.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第一章 随机事件与概率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 独立性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四节 条件概率</title>
      <link href="/2024/03/25/gai-lu-lun-1-4-tiao-jian-gai-lu/"/>
      <url>/2024/03/25/gai-lu-lun-1-4-tiao-jian-gai-lu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iJjON1smjmjc">下载PDF点这里</a></p><p><span class="math inline">\(ps\)</span>：笔记配套书本为高等教育出版社《概率论与数理统计教程(第三版)》，是数学系同学的课本，对绝大部分非数学系同学来说笔记中题目难度要高于课程要求。</p><figure><img src="../../../../images/概率论1-4条件概率/7.jpg" alt="7.jpg"><figcaption aria-hidden="true">7.jpg</figcaption></figure><figure><img src="../../../../images/概率论1-4条件概率/8.jpg" alt="8.jpg"><figcaption aria-hidden="true">8.jpg</figcaption></figure><figure><img src="../../../../images/概率论1-4条件概率/9.jpg" alt="9.jpg"><figcaption aria-hidden="true">9.jpg</figcaption></figure><figure><img src="../../../../images/概率论1-4条件概率/10.jpg" alt="10.jpg"><figcaption aria-hidden="true">10.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第一章 随机事件与概率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 条件概率 </tag>
            
            <tag> 乘法公式 </tag>
            
            <tag> 波利亚罐模型 </tag>
            
            <tag> 全概率公式 </tag>
            
            <tag> 摸彩模型 </tag>
            
            <tag> 赌徒破产模型 </tag>
            
            <tag> 贝叶斯公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三节 概率的性质</title>
      <link href="/2024/03/25/gai-lu-lun-1-3-gai-lu-de-xing-zhi/"/>
      <url>/2024/03/25/gai-lu-lun-1-3-gai-lu-de-xing-zhi/</url>
      
        <content type="html"><![CDATA[<p><span class="math inline">\(ps\)</span>：笔记配套书本为高等教育出版社《概率论与数理统计教程(第三版)》，是数学系同学的课本，对绝大部分非数学系同学来说笔记中题目难度要高于课程要求。</p><figure><img src="../../../../images/概率论1-3概率的性质/6.jpg" alt="6.jpg"><figcaption aria-hidden="true">6.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第一章 随机事件与概率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率加法公式 </tag>
            
            <tag> 匹配问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二节 概率的定义及其确定方法</title>
      <link href="/2024/03/25/gai-lu-lun-1-2-gai-lu-de-ding-yi-ji-qi-que-ding-fang-fa/"/>
      <url>/2024/03/25/gai-lu-lun-1-2-gai-lu-de-ding-yi-ji-qi-que-ding-fang-fa/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iUSrd1smi0di">下载PDF点这里</a></p><p><span class="math inline">\(ps\)</span>：笔记配套书本为高等教育出版社《概率论与数理统计教程(第三版)》，是数学系同学的课本，对绝大部分非数学系同学来说笔记中题目难度要高于课程要求。</p><figure><img src="../../../../images/概率论1-2概率的定义及其确定方法/4.jpg" alt="4.jpg"><figcaption aria-hidden="true">4.jpg</figcaption></figure><figure><img src="../../../../images/概率论1-2概率的定义及其确定方法/5.jpg" alt="5.jpg"><figcaption aria-hidden="true">5.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第一章 随机事件与概率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抽样模型 </tag>
            
            <tag> 盒子模型 </tag>
            
            <tag> 抽签问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一节 随机事件及其运算</title>
      <link href="/2024/03/25/gai-lu-lun-1-1-sui-ji-shi-jian-ji-qi-gai-lu/"/>
      <url>/2024/03/25/gai-lu-lun-1-1-sui-ji-shi-jian-ji-qi-gai-lu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iUNnj1smhbch">下载PDF点这里</a></p><p><span class="math inline">\(ps\)</span>：笔记配套书本为高等教育出版社《概率论与数理统计教程(第三版)》，是数学系同学的课本，对绝大部分非数学系同学来说笔记中题目难度要高于课程要求。</p><figure><img src="../../../../images/概率论1-1随机事件及其概率/2.jpg" alt="2.jpg"><figcaption aria-hidden="true">2.jpg</figcaption></figure><figure><img src="../../../../images/概率论1-1随机事件及其概率/3.jpg" alt="3.jpg"><figcaption aria-hidden="true">3.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
          <category> 第一章 随机事件与概率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随机事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一节 定积分的概念与性质</title>
      <link href="/2024/03/25/yi-yuan-wei-ji-fen-5-1-ding-ji-fen-de-gai-nian-yu-xing-zhi/"/>
      <url>/2024/03/25/yi-yuan-wei-ji-fen-5-1-ding-ji-fen-de-gai-nian-yu-xing-zhi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iWt1b1smez5g">下载PDF点这里</a></p><figure><img src="../../../../images/一元微积分5-1定积分的概念与性质/101.jpg" alt="101.jpg"><figcaption aria-hidden="true">101.jpg</figcaption></figure><figure><img src="../../../../images/一元微积分5-1定积分的概念与性质/102.jpg" alt="102.jpg"><figcaption aria-hidden="true">102.jpg</figcaption></figure><figure><img src="../../../../images/一元微积分5-1定积分的概念与性质/103.jpg" alt="103.jpg"><figcaption aria-hidden="true">103.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 一元微积分 </category>
          
          <category> 第五章 定积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 定积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法(Java实现)</title>
      <link href="/2024/03/25/shu-ju-jie-gou-yu-suan-fa/"/>
      <url>/2024/03/25/shu-ju-jie-gou-yu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="一.-初识算法">一. 初识算法</h1><h2 id="什么是算法">1.1 什么是算法？</h2><p><strong>定义</strong></p><p>在数学和计算机科学领域，算法是一系列有限的严谨指令，通常用于解决一类特定问题或执行计算</p><blockquote><p>In mathematics and computer science, an <strong>algorithm</strong>(/ˈælɡərɪðəm/) is a finite sequence of rigorous instructions, typicallyused to solve a class of specific problems or to perform acomputation.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p></blockquote><p><strong>Introduction to Algorithm<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></strong></p><p>不正式的说，算法就是任何定义优良的计算过程：接收一些值作为输入，在有限的时间内，产生一些值作为输出。</p><blockquote><p>Informally, an algorithm is any well-defined computational procedurethat takes some value, or set of values, as input and produces somevalue, or set of values, as output in a finite amount of time.</p></blockquote><h2 id="什么是数据结构">1.2 什么是数据结构？</h2><p><strong>定义</strong></p><p>在计算机科学领域，数据结构是一种数据组织、管理和存储格式，通常被选择用来高效访问数据</p><blockquote><p>In computer science, a <strong>data structure</strong> is a dataorganization, management, and storage format that is usually chosen forefficient access to data</p></blockquote><p><strong>Introduction to Algorithm<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></strong></p><p>数据结构是一种存储和组织数据的方式，旨在便于访问和修改</p><blockquote><p>A data structure is a way to store and organize data in order tofacilitate access and modifications</p></blockquote><p>可以说，<strong>程序 = 数据结构 +算法</strong>，它们是每一位程序员的基本功，下来我们通过对一个非常著名的二分查找算法的讲解来认识一下算法</p><h2 id="二分查找-3">1.3 二分查找 <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></h2><p>二分查找算法也称折半查找，是一种非常高效的工作于有序数组的查找算法。后续的课程中还会学习更多的查找算法，但在此之前，不妨用它作为入门。</p><h3 id="基础版">1) 基础版</h3><p>需求：在<strong>有序</strong>数组 <span class="math inline">\(A\)</span> 内，查找值 <span class="math inline">\(target\)</span></p><ul><li>如果找到返回索引</li><li>如果找不到返回 <span class="math inline">\(-1\)</span></li></ul><p>算法描述</p><table><colgroup><col style="width: 6%"><col style="width: 93%"></colgroup><tbody><tr class="odd"><td>前提</td><td>给定一个内含 <span class="math inline">\(n\)</span> 个元素的有序数组<span class="math inline">\(A\)</span>，满足 <span class="math inline">\(A_{0}\leq A_{1}\leq A_{2}\leq \cdots \leqA_{n-1}\)</span>，一个待查值 <span class="math inline">\(target\)</span></td></tr><tr class="even"><td>1</td><td>设置 <span class="math inline">\(i=0\)</span>，<span class="math inline">\(j=n-1\)</span></td></tr><tr class="odd"><td>2</td><td>如果 <span class="math inline">\(i \gtj\)</span>，结束查找，没找到</td></tr><tr class="even"><td>3</td><td>设置 <span class="math inline">\(m = floor(\frac {i+j}{2})\)</span>，<span class="math inline">\(m\)</span> 为中间索引，<span class="math inline">\(floor\)</span> 是向下取整（<span class="math inline">\(\leq \frac {i+j}{2}\)</span> 的最小整数）</td></tr><tr class="odd"><td>4</td><td>如果 <span class="math inline">\(target &lt; A_{m}\)</span> 设置<span class="math inline">\(j = m - 1\)</span>，跳到第2步</td></tr><tr class="even"><td>5</td><td>如果 <span class="math inline">\(A_{m} &lt; target\)</span> 设置<span class="math inline">\(i = m + 1\)</span>，跳到第2步</td></tr><tr class="odd"><td>6</td><td>如果 <span class="math inline">\(A_{m} =target\)</span>，结束查找，找到了</td></tr></tbody></table><blockquote><p><strong><em>P.S.</em></strong></p><ul><li>对于一个算法来讲，都有较为严谨的描述，上面是一个例子</li><li>后续讲解时，以简明直白为目标，不会总以上面的方式来描述算法</li></ul></blockquote><p>java 实现</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) {<span class="comment">// 在左边</span></span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) {<span class="comment">// 在右边</span></span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><span class="math inline">\(i,j\)</span> 对应着搜索区间 <span class="math inline">\([0,a.length-1]\)</span>（注意是闭合的区间），<span class="math inline">\(i&lt;=j\)</span>意味着搜索区间内还有未比较的元素，<span class="math inline">\(i,j\)</span> 指向的元素也可能是比较的目标<ul><li>思考：如果不加 <span class="math inline">\(i==j\)</span>行不行？</li><li>回答：不行，因为这意味着 <span class="math inline">\(i,j\)</span>指向的元素会漏过比较</li></ul></li><li><span class="math inline">\(m\)</span>对应着中间位置，中间位置左边和右边的元素可能不相等（差一个），不会影响结果</li><li>如果某次未找到，那么缩小后的区间内不包含 <span class="math inline">\(m\)</span></li></ul><h3 id="改变版">2) 改变版</h3><p>另一种写法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) {<span class="comment">// 在左边</span></span><br><span class="line">            j = m;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) {<span class="comment">// 在右边</span></span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><span class="math inline">\(i,j\)</span> 对应着搜索区间 <span class="math inline">\([0,a.length)\)</span>（注意是左闭右开的区间），<span class="math inline">\(i&lt;j\)</span>意味着搜索区间内还有未比较的元素，<span class="math inline">\(j\)</span>指向的<strong>一定不是</strong>查找目标<ul><li>思考：为啥这次不加 <span class="math inline">\(i==j\)</span>的条件了？</li><li>回答：这回 <span class="math inline">\(j\)</span>指向的不是查找目标，如果还加 <span class="math inline">\(i==j\)</span>条件，就意味着 <span class="math inline">\(j\)</span>指向的还会再次比较，找不到时，会死循环</li></ul></li><li>如果某次要缩小右边界，那么 <span class="math inline">\(j=m\)</span>，因为此时的 <span class="math inline">\(m\)</span>已经<strong>不是</strong>查找目标了</li></ul><h2 id="衡量算法好坏">1.4 衡量算法好坏</h2><p><strong>时间复杂度</strong></p><p>下面的查找算法也能得出与之前二分查找一样的结果，那你能说出它差在哪里吗？</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> k)</span> {</span><br><span class="line">    <span class="keyword">for</span> (</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        i &lt; a.length;</span><br><span class="line">        i++</span><br><span class="line">    ) {</span><br><span class="line">        <span class="keyword">if</span> (a[i] == k) {</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>考虑最坏情况下（没找到）例如 <code>[1,2,3,4]</code> 查找 5</p><ul><li><code>int i = 0</code> 只执行一次</li><li><code>i &lt; a.length</code> 受数组元素个数 <span class="math inline">\(n\)</span> 的影响，比较 <span class="math inline">\(n+1\)</span> 次</li><li><code>i++</code> 受数组元素个数 <span class="math inline">\(n\)</span> 的影响，自增 <span class="math inline">\(n\)</span> 次</li><li><code>a[i] == k</code> 受元素个数 <span class="math inline">\(n\)</span> 的影响，比较 <span class="math inline">\(n\)</span> 次</li><li><code>return -1</code>，执行一次</li></ul><p>粗略认为每行代码执行时间是 <span class="math inline">\(t\)</span>，假设 <span class="math inline">\(n=4\)</span> 那么</p><ul><li>总执行时间是 <span class="math inline">\((1+4+1+4+4+1)*t =15t\)</span></li><li>可以推导出更一般地公式为，<span class="math inline">\(T =(3*n+3)t\)</span></li></ul><p>如果套用二分查找算法，还是 <code>[1,2,3,4]</code> 查找 5</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) {<span class="comment">// 在左边</span></span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) {<span class="comment">// 在右边</span></span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>int i = 0, j = a.length - 1</code> 各执行 1 次</li><li><code>i &lt;= j</code> 比较 <span class="math inline">\(floor(\log_{2}(n)+1)\)</span> 再加 1 次</li><li><code>(i + j) &gt;&gt;&gt; 1</code> 计算 <span class="math inline">\(floor(\log_{2}(n)+1)\)</span> 次</li><li>接下来 <code>if() else if() else</code> 会执行 <span class="math inline">\(3* floor(\log_{2}(n)+1)\)</span> 次，分别为<ul><li>if 比较</li><li>else if 比较</li><li>else if 比较成立后的赋值语句</li></ul></li><li><code>return -1</code>，执行一次</li></ul><p>结果：</p><ul><li>总执行时间为 <span class="math inline">\((2 + (1+3) + 3 + 3 * 3+1)*t = 19t\)</span></li><li>更一般地公式为 <span class="math inline">\((4 + 5 *floor(\log_{2}(n)+1))*t\)</span></li></ul><blockquote><p><strong>注意：</strong></p><p>左侧未找到和右侧未找到结果不一样，这里不做分析</p></blockquote><p>两个算法比较，可以看到 <span class="math inline">\(n\)</span>在较小的时候，二者花费的次数差不多</p><p><img src="../../../../images/StrJava/image-20221108095747933.png" alt="image-20221108095747933" style="zoom:50%;"></p><p>但随着 <span class="math inline">\(n\)</span> 越来越大，比如说 <span class="math inline">\(n=1000\)</span> 时，用二分查找算法（红色）也就是<span class="math inline">\(54t\)</span>，而蓝色算法则需要 <span class="math inline">\(3003t\)</span></p><p><img src="../../../../images/StrJava/image-20221108100014451.png" alt="image-20221108100014451" style="zoom:50%;"></p><blockquote><p>画图采用的是 <a href="https://www.desmos.com/calculator?lang=zh-CN">Desmos |图形计算器</a></p></blockquote><p>计算机科学中，<strong>时间复杂度</strong>是用来衡量：一个算法的执行，随数据规模增大，而增长的时间成本</p><ul><li>不依赖于环境因素</li></ul><p>如何表示时间复杂度呢？</p><ul><li>假设算法要处理的数据规模是 <span class="math inline">\(n\)</span>，代码总的执行行数用函数 <span class="math inline">\(f(n)\)</span> 来表示，例如：<ul><li>线性查找算法的函数 <span class="math inline">\(f(n) = 3*n +3\)</span></li><li>二分查找算法的函数 <span class="math inline">\(f(n) =(floor(log_2(n)) + 1) * 5 + 4\)</span></li></ul></li><li>为了对 <span class="math inline">\(f(n)\)</span>进行化简，应当抓住主要矛盾，找到一个变化趋势与之相近的表示法</li></ul><p><strong>大 <span class="math inline">\(O\)</span> 表示法<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></strong></p><figure><img src="../../../../images/StrJava/image-20221108103846566.png" alt="image-20221108103846566"><figcaption aria-hidden="true">image-20221108103846566</figcaption></figure><p>其中</p><ul><li><span class="math inline">\(c, c_1, c_2\)</span> 都为一个常数</li><li><span class="math inline">\(f(n)\)</span> 是实际执行代码行数与 n的函数</li><li><span class="math inline">\(g(n)\)</span> 是经过化简，变化趋势与<span class="math inline">\(f(n)\)</span> 一致的 n 的函数</li></ul><p><strong>渐进上界</strong></p><p>渐进上界（asymptotic upper bound）：从某个常数 <span class="math inline">\(n_0\)</span>开始，<span class="math inline">\(c*g(n)\)</span> 总是位于 <span class="math inline">\(f(n)\)</span> 上方，那么记作 <span class="math inline">\(O(g(n))\)</span></p><ul><li>代表算法执行的最差情况</li></ul><p>例1</p><ul><li><span class="math inline">\(f(n) = 3*n+3\)</span></li><li><span class="math inline">\(g(n) = n\)</span></li><li>取 <span class="math inline">\(c=4\)</span>，在<span class="math inline">\(n_0=3\)</span> 之后，<span class="math inline">\(g(n)\)</span> 可以作为 <span class="math inline">\(f(n)\)</span> 的渐进上界，因此表示法写作 <span class="math inline">\(O(n)\)</span></li></ul><p>例2</p><ul><li><span class="math inline">\(f(n) = 5*floor(log_2(n)) +9\)</span></li><li><span class="math inline">\(g(n) = log_2(n)\)</span></li><li><span class="math inline">\(O(log_2(n))\)</span></li></ul><p>已知 <span class="math inline">\(f(n)\)</span> 来说，求 <span class="math inline">\(g(n)\)</span></p><ul><li>表达式中相乘的常量，可以省略，如<ul><li><span class="math inline">\(f(n) = 100*n^2\)</span> 中的 <span class="math inline">\(100\)</span></li></ul></li><li>多项式中数量规模更小（低次项）的表达式，如<ul><li><span class="math inline">\(f(n)=n^2+n\)</span> 中的 <span class="math inline">\(n\)</span></li><li><span class="math inline">\(f(n) = n^3 + n^2\)</span> 中的 <span class="math inline">\(n^2\)</span></li></ul></li><li>不同底数的对数，渐进上界可以用一个对数函数 <span class="math inline">\(\log n\)</span> 表示<ul><li>例如：<span class="math inline">\(log_2(n)\)</span> 可以替换为 <span class="math inline">\(log_{10}(n)\)</span>，因为 <span class="math inline">\(log_2(n) =\frac{log_{10}(n)}{log_{10}(2)}\)</span>，相乘的常量 <span class="math inline">\(\frac{1}{log_{10}(2)}\)</span> 可以省略</li></ul></li><li>类似的，对数的常数次幂可省略<ul><li>如：<span class="math inline">\(log(n^c) = c * log(n)\)</span></li></ul></li></ul><p><strong>常见大 <span class="math inline">\(O\)</span>表示法</strong></p><figure><img src="../../../../images/StrJava/image-20221108114915524.png" alt="image-20221108114915524"><figcaption aria-hidden="true">image-20221108114915524</figcaption></figure><p>按时间复杂度从低到高</p><ul><li>黑色横线 <span class="math inline">\(O(1)\)</span>，常量时间，意味着算法时间并不随数据规模而变化</li><li>绿色 <span class="math inline">\(O(log(n))\)</span>，对数时间</li><li>蓝色 <span class="math inline">\(O(n)\)</span>，线性时间，算法时间与数据规模成正比</li><li>橙色 <span class="math inline">\(O(n*log(n))\)</span>，拟线性时间</li><li>红色 <span class="math inline">\(O(n^2)\)</span> 平方时间</li><li>黑色朝上 <span class="math inline">\(O(2^n)\)</span> 指数时间</li><li>没画出来的 <span class="math inline">\(O(n!)\)</span></li></ul><p><strong>渐进下界</strong></p><p>渐进下界（asymptotic lower bound）：从某个常数 <span class="math inline">\(n_0\)</span>开始，<span class="math inline">\(c*g(n)\)</span> 总是位于 <span class="math inline">\(f(n)\)</span> 下方，那么记作 <span class="math inline">\(\Omega(g(n))\)</span></p><p><strong>渐进紧界</strong></p><p>渐进紧界（asymptotic tight bounds）：从某个常数 <span class="math inline">\(n_0\)</span>开始，<span class="math inline">\(f(n)\)</span> 总是在 <span class="math inline">\(c_1*g(n)\)</span> 和 <span class="math inline">\(c_2*g(n)\)</span> 之间，那么记作 <span class="math inline">\(\Theta(g(n))\)</span></p><p><strong>空间复杂度</strong></p><p>与时间复杂度类似，一般也使用大 <span class="math inline">\(O\)</span>表示法来衡量：一个算法执行随数据规模增大，而增长的<strong>额外</strong>空间成本</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchBasic</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;    <span class="comment">// 设置指针和初值</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) {                <span class="comment">// i~j 范围内有东西</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; a[m]) {         <span class="comment">// 目标在左边</span></span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) { <span class="comment">// 目标在右边</span></span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {                    <span class="comment">// 找到了</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>二分查找性能</strong></p><p>下面分析二分查找算法的性能</p><p>时间复杂度</p><ul><li>最坏情况：<span class="math inline">\(O(\log n)\)</span></li><li>最好情况：如果待查找元素恰好在数组中央，只需要循环一次 <span class="math inline">\(O(1)\)</span></li></ul><p>空间复杂度</p><ul><li>需要常数个指针 <span class="math inline">\(i,j,m\)</span>，因此额外占用的空间是 <span class="math inline">\(O(1)\)</span></li></ul><h2 id="再看二分查找">1.5 再看二分查找</h2><h3 id="平衡版">1) 平衡版</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchBalance</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span> &lt; j - i) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) {</span><br><span class="line">            j = m;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            i = m;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (a[i] == target) ? i : -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>思想：</p><ol type="1"><li>左闭右开的区间，<span class="math inline">\(i\)</span>指向的可能是目标，而 <span class="math inline">\(j\)</span>指向的不是目标</li><li>不奢望循环内通过 <span class="math inline">\(m\)</span> 找出目标,缩小区间直至剩 1 个, 剩下的这个可能就是要找的（通过 <span class="math inline">\(i\)</span>）<ul><li><span class="math inline">\(j - i &gt; 1\)</span>的含义是，在范围内待比较的元素个数 &gt; 1</li></ul></li><li>改变 <span class="math inline">\(i\)</span>边界时，它指向的可能是目标，因此不能 <span class="math inline">\(m+1\)</span></li><li>循环内的平均比较次数减少了</li><li>时间复杂度 <span class="math inline">\(\Theta(log(n))\)</span></li></ol><h3 id="java-版">2) Java 版</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch0</span><span class="params">(<span class="type">long</span>[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex,</span></span><br><span class="line"><span class="params">                                     <span class="type">long</span> key)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> fromIndex;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> toIndex - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">midVal</span> <span class="operator">=</span> a[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (midVal &lt; key)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; key)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// key found</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found.</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>例如 <span class="math inline">\([1,3,5,6]\)</span> 要插入 <span class="math inline">\(2\)</span>那么就是找到一个位置，这个位置左侧元素都比它小<ul><li>等循环结束，若没找到，low 左侧元素肯定都比 target 小，因此 low即插入点</li></ul></li><li>插入点取负是为了与找到情况区分</li><li>-1 是为了把索引 0 位置的插入点与找到的情况进行区分</li></ul><h3 id="leftmost-与-rightmost">3) Leftmost 与 Rightmost</h3><p>有时我们希望返回的是最左侧的重复元素，如果用 Basic 二分查找</p><ul><li><p>对于数组 <span class="math inline">\([1, 2, 3, 4, 4, 5, 6,7]\)</span>，查找元素4，结果是索引3</p></li><li><p>对于数组 <span class="math inline">\([1, 2, 4, 4, 4, 5, 6,7]\)</span>，查找元素4，结果也是索引3，并不是最左侧的元素</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchLeftmost1</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) {</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) {</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            candidate = m; <span class="comment">// 记录候选位置</span></span><br><span class="line">            j = m - <span class="number">1</span>;     <span class="comment">// 继续向左</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果希望返回的是最右侧元素</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchRightmost1</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) {</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) {</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            candidate = m; <span class="comment">// 记录候选位置</span></span><br><span class="line">            i = m + <span class="number">1</span>;   <span class="comment">// 继续向右</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>应用</strong></p><p>对于 Leftmost 与 Rightmost，可以返回一个比 -1 更有用的值</p><p>Leftmost 改为</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchLeftmost</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= a[m]) {</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> i; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>leftmost 返回值的另一层含义：<span class="math inline">\(\lttarget\)</span> 的元素个数</li><li>小于等于中间值，都要向左找</li></ul><p>Rightmost 改为</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchRightmost</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) {</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>大于等于中间值，都要向右找</li></ul><p>几个名词</p><figure><img src="../../../../images/StrJava/image-20221125174155058.png" alt="image-20221125174155058"><figcaption aria-hidden="true">image-20221125174155058</figcaption></figure><p><strong>范围查询</strong>：</p><ul><li>查询 <span class="math inline">\(x \lt 4\)</span>，<span class="math inline">\(0 .. leftmost(4) - 1\)</span></li><li>查询 <span class="math inline">\(x \leq 4\)</span>，<span class="math inline">\(0 .. rightmost(4)\)</span></li><li>查询 <span class="math inline">\(4 \lt x\)</span>，$rightmost(4) + 1.. $</li><li>查询 <span class="math inline">\(4 \leq x\)</span>， <span class="math inline">\(leftmost(4) .. \infty\)</span></li><li>查询 <span class="math inline">\(4 \leq x \leq 7\)</span>，<span class="math inline">\(leftmost(4) .. rightmost(7)\)</span></li><li>查询 <span class="math inline">\(4 \lt x \lt 7\)</span>，<span class="math inline">\(rightmost(4)+1 .. leftmost(7)-1\)</span></li></ul><p><strong>求排名</strong>：<span class="math inline">\(leftmost(target)+ 1\)</span></p><ul><li><span class="math inline">\(target\)</span> 可以不存在，如：<span class="math inline">\(leftmost(5)+1 = 6\)</span></li><li><span class="math inline">\(target\)</span> 也可以存在，如：<span class="math inline">\(leftmost(4)+1 = 3\)</span></li></ul><p><strong>求前任（predecessor）</strong>：<span class="math inline">\(leftmost(target) - 1\)</span></p><ul><li><span class="math inline">\(leftmost(3) - 1 = 1\)</span>，前任 <span class="math inline">\(a_1 = 2\)</span></li><li><span class="math inline">\(leftmost(4) - 1 = 1\)</span>，前任 <span class="math inline">\(a_1 = 2\)</span></li></ul><p><strong>求后任（successor）</strong>：<span class="math inline">\(rightmost(target)+1\)</span></p><ul><li><span class="math inline">\(rightmost(5) + 1 = 5\)</span>，后任<span class="math inline">\(a_5 = 7\)</span></li><li><span class="math inline">\(rightmost(4) + 1 = 5\)</span>，后任<span class="math inline">\(a_5 = 7\)</span></li></ul><p><strong>求最近邻居</strong>：</p><ul><li>前任和后任距离更近者</li></ul><h2 id="习题">习题</h2><h3 id="时间复杂度估算">1) 时间复杂度估算</h3><p>用函数 <span class="math inline">\(f(n)\)</span>表示算法效率与数据规模的关系，假设每次解决问题需要 1 微秒（<span class="math inline">\(10^{-6}\)</span> 秒），进行估算：</p><ol type="1"><li>如果 <span class="math inline">\(f(n) = n^2\)</span> 那么 1秒能解决多少次问题？1 天呢？</li><li>如果 <span class="math inline">\(f(n) = log_2(n)\)</span> 那么 1秒能解决多少次问题？1 天呢？</li><li>如果 <span class="math inline">\(f(n) = n!\)</span> 那么 1秒能解决多少次问题？1 天呢？</li></ol><p><strong>参考解答</strong></p><ol type="1"><li>1秒 <span class="math inline">\(\sqrt{10^6} = 1000\)</span> 次，1 天<span class="math inline">\(\sqrt{10^6 * 3600 * 24} \approx293938\)</span> 次</li><li>1秒 $2^{1,000,000} $ 次，一天 <span class="math inline">\(2^{86,400,000,000}\)</span></li><li>推算如下<ul><li><span class="math inline">\(10! = 3,628,800\)</span> 1秒能解决 <span class="math inline">\(1,000,000\)</span> 次，因此次数为 9 次</li><li><span class="math inline">\(14!=87,178,291,200\)</span>，一天能解决<span class="math inline">\(86,400,000,000\)</span> 次，因此次数为 13次</li></ul></li></ol><h3 id="耗时估算">2) 耗时估算</h3><p>一台机器对200个单词进行排序花了200秒(使用冒泡排序)，那么花费800秒，大概可以对多少个单词进行排序</p><ol type="a"><li><p>400</p></li><li><p>600</p></li><li><p>800</p></li><li><p>1600</p></li></ol><p><strong>答案</strong></p><ul><li>a</li></ul><p><strong>解释</strong></p><ul><li>冒泡排序时间复杂度是 <span class="math inline">\(O(N^2)\)</span></li><li>时间增长 4 倍，而因此能处理的数据量是原来的 <span class="math inline">\(\sqrt{4} = 2\)</span> 倍</li></ul><h3 id="e01.-二分查找-leetcode-704">3) E01. 二分查找-Leetcode 704</h3><p><strong>要点</strong>：减而治之，可以用递归或非递归实现</p><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回-1</p><p>例如</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>], target = <span class="number">9</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: <span class="number">9</span> 出现在 nums 中并且下标为 <span class="number">4</span></span><br><span class="line">    </span><br><span class="line">输入: nums = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>], target = <span class="number">2</span></span><br><span class="line">输出: -<span class="number">1</span></span><br><span class="line">解释: <span class="number">2</span> 不存在 nums 中因此返回 -<span class="number">1</span>    </span><br></pre></td></tr></tbody></table></figure><p><strong>参考答案</strong>：略，可以用讲过的任意一种二分求解</p><h3 id="e02.-搜索插入位置-leetcode-35">4) E02. 搜索插入位置-Leetcode35</h3><p><strong>要点</strong>：理解谁代表插入位置</p><p>给定一个排序数组和一个目标值</p><ul><li>在数组中找到目标值，并返回其索引</li><li>如果目标值不存在于数组中，返回它将会被按顺序插入的位置</li></ul><p>例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">输入: nums = [1,3,5,6], target = 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></tbody></table></figure><p><strong>参考答案1</strong>：用二分查找基础版代码改写，基础版中，找到返回m，没找到 i 代表插入点，因此有</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) {</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) {</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">// 原始 return -1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>参考答案2</strong>：用二分查找平衡版改写，平衡版中</p><ul><li>如果 target == a[i] 返回 i 表示找到</li><li>如果 target &lt; a[i]，例如 target = 2，a[i] = 3，这时就应该在 i位置插入 2</li><li>如果 a[i] &lt; target，例如 a[i] = 3，target = 4，这时就应该在 i+1位置插入 4</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span> &lt; j - i) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) {</span><br><span class="line">            j = m;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            i = m;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (target &lt;= a[i]) ? i : i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 原始 (target == a[i]) ? i : -1;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>参考答案3</strong>：用 leftmost版本解，返回值即为插入位置（并能处理元素重复的情况）</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= a[m]) {</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        } </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="e03.-搜索开始结束位置-leetcode-34">5) E03.搜索开始结束位置-Leetcode 34</h3><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题</p><p>例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br><span class="line"></span><br><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br><span class="line"></span><br><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></tbody></table></figure><p><strong>参考答案</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) {</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) {</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            candidate = m;</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) {</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) {</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            candidate = m;</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) {</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> left(nums, target);</span><br><span class="line">    <span class="keyword">if</span>(x == -<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] {-<span class="number">1</span>, -<span class="number">1</span>};</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] {x, right(nums, target)};</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="二.-基础数据结构">二. 基础数据结构</h1><h2 id="数组">2.1 数组</h2><h3 id="概述">1) 概述</h3><p><strong>定义</strong></p><p>在计算机科学中，数组是由一组元素（值或变量）组成的数据结构，每个元素有至少一个索引或键来标识</p><blockquote><p>In computer science, an <strong>array</strong> is a data structureconsisting of a collection of <em>elements</em> (values or variables),each identified by at least one <em>array index</em> or <em>key</em></p></blockquote><p>因为数组内的元素是<strong>连续存储</strong>的，所以数组中元素的地址，可以通过其索引计算出来，例如：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>}</span><br></pre></td></tr></tbody></table></figure><p>知道了数组的<strong>数据</strong>起始地址 <span class="math inline">\(BaseAddress\)</span>，就可以由公式 <span class="math inline">\(BaseAddress + i * size\)</span> 计算出索引 <span class="math inline">\(i\)</span> 元素的地址</p><ul><li><span class="math inline">\(i\)</span> 即索引，在 Java、C等语言都是从 0 开始</li><li><span class="math inline">\(size\)</span> 是每个元素占用字节，例如<span class="math inline">\(int\)</span> 占 <span class="math inline">\(4\)</span>，<span class="math inline">\(double\)</span> 占 <span class="math inline">\(8\)</span></li></ul><p><strong>小测试</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] array = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>}</span><br></pre></td></tr></tbody></table></figure><p>已知 array 的<strong>数据</strong>的起始地址是 0x7138f94c8，那么元素3 的地址是什么？</p><blockquote><p>答：0x7138f94c8 + 2 * 1 = 0x7138f94ca</p></blockquote><p><strong>空间占用</strong></p><p>Java 中数组结构为</p><ul><li>8 字节 markword</li><li>4 字节 class 指针（压缩 class 指针的情况）</li><li>4 字节 数组大小（决定了数组最大容量是 <span class="math inline">\(2^{32}\)</span>）</li><li>数组元素 + 对齐字节（java 中所有对象大小都是 8 字节的整数倍<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>，不足的要用对齐字节补足）</li></ul><p>例如</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br></pre></td></tr></tbody></table></figure><p>的大小为 40 个字节，组成如下</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">8 + 4 + 4 + 5*4 + 4(alignment)</span><br></pre></td></tr></tbody></table></figure><p><strong>随机访问性能</strong></p><p>即根据索引查找元素，时间复杂度是 <span class="math inline">\(O(1)\)</span></p><h3 id="动态数组">2) 动态数组</h3><p><strong>java 版本</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicArray</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 逻辑大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">8</span>; <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] array = {};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向最后位置 [size] 添加元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 待添加元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> element)</span> {</span><br><span class="line">        add(size, element);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向 [0 .. size] 位置添加元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index   索引位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 待添加元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> element)</span> {</span><br><span class="line">        checkAndGrow();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size) {</span><br><span class="line">            <span class="comment">// 向后挪动, 空出待插入位置</span></span><br><span class="line">            System.arraycopy(array, index,</span><br><span class="line">                    array, index + <span class="number">1</span>, size - index);</span><br><span class="line">        }</span><br><span class="line">        array[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkAndGrow</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 容量检查</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) {</span><br><span class="line">            array = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (size == capacity) {</span><br><span class="line">            <span class="comment">// 进行扩容, 1.5 1.618 2</span></span><br><span class="line">            capacity += capacity &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] newArray = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">            System.arraycopy(array, <span class="number">0</span>,</span><br><span class="line">                    newArray, <span class="number">0</span>, size);</span><br><span class="line">            array = newArray;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从 [0 .. size) 范围删除元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 被删除元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> { <span class="comment">// [0..size)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">removed</span> <span class="operator">=</span> array[index];</span><br><span class="line">        <span class="keyword">if</span> (index &lt; size - <span class="number">1</span>) {</span><br><span class="line">            <span class="comment">// 向前挪动</span></span><br><span class="line">            System.arraycopy(array, index + <span class="number">1</span>,</span><br><span class="line">                    array, index, size - index - <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> removed;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引位置, 在 [0..size) 区间内</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 该索引位置的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历方法1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumer 遍历要执行的操作, 入参: 每个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foreach</span><span class="params">(Consumer&lt;Integer&gt; consumer)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            <span class="comment">// 提供 array[i]</span></span><br><span class="line">            <span class="comment">// 返回 void</span></span><br><span class="line">            consumer.accept(array[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历方法2 - 迭代器遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;Integer&gt;() {</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> { <span class="comment">// 有没有下一个元素</span></span><br><span class="line">                <span class="keyword">return</span> i &lt; size;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> { <span class="comment">// 返回当前元素,并移动到下一个元素</span></span><br><span class="line">                <span class="keyword">return</span> array[i++];</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历方法3 - stream 遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> stream 流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> IntStream <span class="title function_">stream</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> IntStream.of(Arrays.copyOfRange(array, <span class="number">0</span>, size));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>这些方法实现，都简化了 index 的有效性判断，假设输入的 index都是合法的</li></ul><p><strong>插入或删除性能</strong></p><p>头部位置，时间复杂度是 <span class="math inline">\(O(n)\)</span></p><p>中间位置，时间复杂度是 <span class="math inline">\(O(n)\)</span></p><p>尾部位置，时间复杂度是 <span class="math inline">\(O(1)\)</span>（均摊来说）</p><h3 id="二维数组">3) 二维数组</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] array = {</span><br><span class="line">    {<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>},</span><br><span class="line">    {<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>},</span><br><span class="line">    {<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>},</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>内存图如下</p><p><img src="../../../../images/StrJava/image-20221104114132056.png" alt="image-20221104114132056" style="zoom:67%;"></p><ul><li><p>二维数组占 32 个字节，其中 array[0]，array[1]，array[2]三个元素分别保存了指向三个一维数组的引用</p></li><li><p>三个一维数组各占 40 个字节</p></li><li><p>它们在内层布局上是<strong>连续</strong>的</p></li></ul><p>更一般的，对一个二维数组 <span class="math inline">\(Array[m][n]\)</span></p><ul><li><span class="math inline">\(m\)</span> 是外层数组的长度，可以看作row 行</li><li><span class="math inline">\(n\)</span> 是内层数组的长度，可以看作column 列</li><li>当访问 <span class="math inline">\(Array[i][j]\)</span>，<span class="math inline">\(0\leq i \lt m, 0\leq j \lt n\)</span>时，就相当于<ul><li>先找到第 <span class="math inline">\(i\)</span>个内层数组（行）</li><li>再找到此内层数组中第 <span class="math inline">\(j\)</span>个元素（列）</li></ul></li></ul><p><strong>小测试</strong></p><p>Java环境下（不考虑类指针和引用压缩，此为默认情况），有下面的二维数组</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[][] array = {</span><br><span class="line">    {<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>},</span><br><span class="line">    {<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>},</span><br><span class="line">    {<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>},</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>已知 array <strong>对象</strong>起始地址是 0x1000，那么 23这个元素的地址是什么？</p><blockquote><p>答：</p><ul><li>起始地址 0x1000</li><li>外层数组大小：16字节对象头 + 3元素 * 每个引用4字节 + 4 对齐字节 = 32= 0x20</li><li>第一个内层数组大小：16字节对象头 + 5元素 * 每个byte1字节 + 3对齐字节 = 24 = 0x18</li><li>第二个内层数组，16字节对象头 = 0x10，待查找元素索引为 2</li><li>最后结果 = 0x1000 + 0x20 + 0x18 + 0x10 + 2*1 = 0x104a</li></ul></blockquote><h3 id="局部性原理">4) 局部性原理</h3><p>这里只讨论空间局部性</p><ul><li>cpu读取内存（速度慢）数据后，会将其放入高速缓存（速度快）当中，如果后来的计算再用到此数据，在缓存中能读到的话，就不必读内存了</li><li>缓存的最小存储单位是缓存行（cache line），一般是 64bytes，一次读的数据少了不划算啊，因此最少读 64 bytes填满一个缓存行，因此读入某个数据时也会读取其<strong>临近的数据</strong>，这就是所谓<strong>空间局部性</strong></li></ul><p><strong>对效率的影响</strong></p><p>比较下面 ij 和 ji 两个方法的执行效率</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">columns</span> <span class="operator">=</span> <span class="number">14</span>;</span><br><span class="line"><span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[rows][columns];</span><br><span class="line"></span><br><span class="line"><span class="type">StopWatch</span> <span class="variable">sw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">sw.start(<span class="string">"ij"</span>);</span><br><span class="line">ij(a, rows, columns);</span><br><span class="line">sw.stop();</span><br><span class="line">sw.start(<span class="string">"ji"</span>);</span><br><span class="line">ji(a, rows, columns);</span><br><span class="line">sw.stop();</span><br><span class="line">System.out.println(sw.prettyPrint());</span><br></pre></td></tr></tbody></table></figure><p>ij 方法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ij</span><span class="params">(<span class="type">int</span>[][] a, <span class="type">int</span> rows, <span class="type">int</span> columns)</span> {</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; columns; j++) {</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>ji 方法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ji</span><span class="params">(<span class="type">int</span>[][] a, <span class="type">int</span> rows, <span class="type">int</span> columns)</span> {</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; columns; j++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) {</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>执行结果</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line">StopWatch '': running time = 96283300 ns</span><br><span class="line">---------------------------------------------</span><br><span class="line">ns         %     Task name</span><br><span class="line">---------------------------------------------</span><br><span class="line">016196200  017%  ij</span><br><span class="line">080087100  083%  ji</span><br></pre></td></tr></tbody></table></figure><p>可以看到 ij 的效率比 ji 快很多，为什么呢？</p><ul><li>缓存是有限的，当新数据来了后，一些旧的缓存行数据就会被覆盖</li><li>如果不能充分利用缓存的数据，就会造成效率低下</li></ul><p>以 ji 执行为例，第一次内循环要读入 <span class="math inline">\([0,0]\)</span> 这条数据，由于局部性原理，读入<span class="math inline">\([0,0]\)</span> 的同时也读入了 <span class="math inline">\([0,1] ... [0,13]\)</span>，如图所示</p><figure><img src="../../../../images/StrJava/image-20221104164329026.png" alt="image-20221104164329026"><figcaption aria-hidden="true">image-20221104164329026</figcaption></figure><p>但很遗憾，第二次内循环要的是 <span class="math inline">\([1,0]\)</span>这条数据，缓存中没有，于是再读入了下图的数据</p><figure><img src="../../../../images/StrJava/image-20221104164716282.png" alt="image-20221104164716282"><figcaption aria-hidden="true">image-20221104164716282</figcaption></figure><p>这显然是一种浪费，因为 <span class="math inline">\([0,1] ...[0,13]\)</span> 包括 <span class="math inline">\([1,1] ...[1,13]\)</span>这些数据虽然读入了缓存，却没有及时用上，而缓存的大小是有限的，等执行到第九次内循环时</p><figure><img src="../../../../images/StrJava/image-20221104164947154.png" alt="image-20221104164947154"><figcaption aria-hidden="true">image-20221104164947154</figcaption></figure><p>缓存的第一行数据已经被新的数据 <span class="math inline">\([8,0] ...[8,13]\)</span> 覆盖掉了，以后如果再想读，比如 <span class="math inline">\([0,1]\)</span>，又得到内存去读了</p><p>同理可以分析 ij 函数则能充分利用局部性原理加载到的缓存数据</p><p><strong>举一反三</strong></p><ol type="1"><li><p>I/O 读写时同样可以体现局部性原理</p></li><li><p>数组可以充分利用局部性原理，那么链表呢？</p><blockquote><p>答：链表不行，因为链表的元素并非相邻存储</p></blockquote></li></ol><h3 id="越界检查">5) 越界检查</h3><p>java 中对数组元素的读写都有越界检查，类似于下面的代码</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_within_bounds</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span>        </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= index &amp;&amp; index &lt; <span class="built_in">length</span>(); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>代码位置：<code>openjdk\src\hotspot\share\oops\arrayOop.hpp</code></li></ul><p>只不过此检查代码，不需要由程序员自己来调用，JVM 会帮我们调用</p><h3 id="习题-1">习题</h3><h4 id="e01.-合并有序数组---对应-leetcode-88">E01. 合并有序数组 - 对应Leetcode 88</h4><p>将数组内两个区间内的有序元素合并</p><p>例</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[1, 5, 6, 2, 4, 10, 11]</span><br></pre></td></tr></tbody></table></figure><p>可以视作两个有序区间</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[1, 5, 6] 和 [2, 4, 10, 11]</span><br></pre></td></tr></tbody></table></figure><p>合并后，结果仍存储于原有空间</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[1, 2, 4, 5, 6, 10, 11]</span><br></pre></td></tr></tbody></table></figure><p><strong>方法1</strong></p><p>递归</p><ul><li>每次递归把更小的元素复制到结果数组</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">merge(left=[<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>],right=[<span class="number">2</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">11</span>],a2=[]){</span><br><span class="line">    merge(left=[<span class="number">5</span>,<span class="number">6</span>],right=[<span class="number">2</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">11</span>],a2=[<span class="number">1</span>]){</span><br><span class="line">        merge(left=[<span class="number">5</span>,<span class="number">6</span>],right=[<span class="number">4</span>,<span class="number">10</span>,<span class="number">11</span>],a2=[<span class="number">1</span>,<span class="number">2</span>]){</span><br><span class="line">            merge(left=[<span class="number">5</span>,<span class="number">6</span>],right=[<span class="number">10</span>,<span class="number">11</span>],a2=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]){</span><br><span class="line">                merge(left=[<span class="number">6</span>],right=[<span class="number">10</span>,<span class="number">11</span>],a2=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>]){</span><br><span class="line">                    merge(left=[],right=[<span class="number">10</span>,<span class="number">11</span>],a2=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]){</span><br><span class="line"><span class="comment">// 拷贝10，11</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span> i, <span class="type">int</span> iEnd, <span class="type">int</span> j, <span class="type">int</span> jEnd,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span>[] a2, <span class="type">int</span> k)</span> {</span><br><span class="line">    <span class="keyword">if</span> (i &gt; iEnd) {</span><br><span class="line">        System.arraycopy(a1, j, a2, k, jEnd - j + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (j &gt; jEnd) {</span><br><span class="line">        System.arraycopy(a1, i, a2, k, iEnd - i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (a1[i] &lt; a1[j]) {</span><br><span class="line">        a2[k] = a1[i];</span><br><span class="line">        merge(a1, i + <span class="number">1</span>, iEnd, j, jEnd, a2, k + <span class="number">1</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        a2[k] = a1[j];</span><br><span class="line">        merge(a1, i, iEnd, j + <span class="number">1</span>, jEnd, a2, k + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a1 = {<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">11</span>};</span><br><span class="line"><span class="type">int</span>[] a2 = <span class="keyword">new</span> <span class="title class_">int</span>[a1.length];</span><br><span class="line">merge(a1, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, a2, <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure><p><strong>方法2</strong></p><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span> i, <span class="type">int</span> iEnd,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> j, <span class="type">int</span> jEnd,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span>[] a2)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= iEnd &amp;&amp; j &lt;= jEnd) {</span><br><span class="line">        <span class="keyword">if</span> (a1[i] &lt; a1[j]) {</span><br><span class="line">            a2[k] = a1[i];</span><br><span class="line">            i++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            a2[k] = a1[j];</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        k++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (i &gt; iEnd) {</span><br><span class="line">        System.arraycopy(a1, j, a2, k, jEnd - j + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (j &gt; jEnd) {</span><br><span class="line">        System.arraycopy(a1, i, a2, k, iEnd - i + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a1 = {<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">11</span>};</span><br><span class="line"><span class="type">int</span>[] a2 = <span class="keyword">new</span> <span class="title class_">int</span>[a3.length];</span><br><span class="line">merge(a1, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, a2);</span><br></pre></td></tr></tbody></table></figure><h2 id="链表">2.2 链表</h2><h3 id="概述-1">1) 概述</h3><p><strong>定义</strong></p><p>在计算机科学中，链表是数据元素的线性集合，其每个元素都指向下一个元素，元素存储上并不连续</p><blockquote><p>In computer science, a <strong>linked list</strong> is a linearcollection of data elements whose order is not given by their physicalplacement in memory. Instead, each element points to the next.</p></blockquote><p>可以分类为<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p><ul><li>单向链表，每个元素只知道其下一个元素是谁</li></ul><figure><img src="../../../../images/StrJava/image-20221110083407176.png" alt="image-20221110083407176"><figcaption aria-hidden="true">image-20221110083407176</figcaption></figure><ul><li>双向链表，每个元素知道其上一个元素和下一个元素</li></ul><figure><img src="../../../../images/StrJava/image-20221110083427372.png" alt="image-20221110083427372"><figcaption aria-hidden="true">image-20221110083427372</figcaption></figure><ul><li>循环链表，通常的链表尾节点 tail 指向的都是 null，而循环链表的 tail指向的是头节点 head</li></ul><figure><img src="../../../../images/StrJava/image-20221110083538273.png" alt="image-20221110083538273"><figcaption aria-hidden="true">image-20221110083538273</figcaption></figure><p>链表内还有一种特殊的节点称为哨兵（Sentinel）节点，也叫做哑元（Dummy）节点，它不存储数据，通常用作头尾，用来简化边界判断，如下图所示</p><figure><img src="../../../../images/StrJava/image-20221110084611550.png" alt="image-20221110084611550"><figcaption aria-hidden="true">image-20221110084611550</figcaption></figure><p><strong>随机访问性能</strong></p><p>根据 index 查找，时间复杂度 <span class="math inline">\(O(n)\)</span></p><p><strong>插入或删除性能</strong></p><ul><li>起始位置：<span class="math inline">\(O(1)\)</span></li><li>结束位置：如果已知 tail 尾节点是 <span class="math inline">\(O(1)\)</span>，不知道 tail 尾节点是 <span class="math inline">\(O(n)\)</span></li><li>中间位置：根据 index 查找时间 + <span class="math inline">\(O(1)\)</span></li></ul><h3 id="单向链表">2) 单向链表</h3><p>根据单向链表的定义，首先定义一个存储 value 和 next 指针的类Node，和一个描述头部节点的引用</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node head; <span class="comment">// 头部节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> { <span class="comment">// 节点类</span></span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value, Node next)</span> {</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Node定义为内部类，是为了对外<strong>隐藏</strong>实现细节，没必要让类的使用者关心Node 结构</li><li>定义为 static 内部类，是因为 Node <strong>不需要</strong>与SinglyLinkedList 实例相关，多个 SinglyLinkedList实例能共用 Node类定义</li></ul><p><strong>头部添加</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line"><span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="built_in">this</span>.head);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 this.head == null，新增节点指向 null，并作为新的 this.head</li><li>如果 this.head != null，新增节点指向原来的 this.head，并作为新的this.head<ul><li>注意赋值操作执行顺序是从右到左</li></ul></li></ul><p><strong>while 遍历</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 做一些事</span></span><br><span class="line">            curr = curr.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>for 遍历</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="built_in">this</span>.head; curr != <span class="literal">null</span>; curr = curr.next) {</span><br><span class="line">            <span class="comment">// 做一些事</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>以上两种遍历都可以把<strong>要做的事</strong>以 Consumer函数的方式传递进来<ul><li>Consumer的规则是<strong>一个参数</strong>，<strong>无返回值</strong>，因此像System.out::println 方法等都是 Consumer</li><li>调用 Consumer 时，将当前节点 curr.value 作为参数传递给它</li></ul></li></ul><p><strong>迭代器遍历</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">NodeIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;Integer&gt; {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> curr != <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> curr.value;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NodeIterator</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>hasNext 用来判断是否还有必要调用 next</li><li>next 做两件事<ul><li>返回当前节点的 value</li><li>指向下一个节点</li></ul></li><li>NodeIterator 要定义为<strong>非 static 内部类</strong>，是因为它与SinglyLinkedList 实例相关，是对某个 SinglyLinkedList 实例的迭代</li></ul><p><strong>递归遍历</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> {</span><br><span class="line">        recursion(<span class="built_in">this</span>.head);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recursion</span><span class="params">(Node curr)</span> {</span><br><span class="line">        <span class="keyword">if</span> (curr == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 前面做些事</span></span><br><span class="line">        recursion(curr.next);</span><br><span class="line">        <span class="comment">// 后面做些事</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>尾部添加</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findLast</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.head == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        Node curr;</span><br><span class="line">        <span class="keyword">for</span> (curr = <span class="built_in">this</span>.head; curr.next != <span class="literal">null</span>; ) {</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> findLast();</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>) {</span><br><span class="line">            addFirst(value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        last.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>注意，找最后一个节点，终止条件是 curr.next == null</li><li>分成两个方法是为了代码清晰，而且 findLast() 之后还能复用</li></ul><p><strong>尾部添加多个</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span>... rest)</span> {</span><br><span class="line">        </span><br><span class="line">        <span class="type">Node</span> <span class="variable">sublist</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(first, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> sublist;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : rest) {</span><br><span class="line">            curr.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>);</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> findLast();</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>) {</span><br><span class="line">            <span class="built_in">this</span>.head = sublist;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        last.next = sublist;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>先串成一串 sublist</li><li>再作为一个整体添加</li></ul><p><strong>根据索引获取</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">findNode</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="built_in">this</span>.head; curr != <span class="literal">null</span>; curr = curr.next, i++) {</span><br><span class="line">            <span class="keyword">if</span> (index == i) {</span><br><span class="line">                <span class="keyword">return</span> curr;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> IllegalArgumentException <span class="title function_">illegalIndex</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">"index [%d] 不合法%n"</span>, index));</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findNode(index);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>同样，分方法可以实现复用</li></ul><p><strong>插入</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) {</span><br><span class="line">            addFirst(value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>); <span class="comment">// 找到上一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>) { <span class="comment">// 找不到</span></span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        }</span><br><span class="line">        prev.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, prev.next);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>插入包括下面的删除，都必须找到上一个节点</li></ul><p><strong>删除</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.head != <span class="literal">null</span>) {</span><br><span class="line">                <span class="built_in">this</span>.head = <span class="built_in">this</span>.head.next;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>);</span><br><span class="line">        Node curr;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; (curr = prev.next) != <span class="literal">null</span>) {</span><br><span class="line">            prev.next = curr.next;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>第一个 if 块对应着 removeFirst 情况</li><li>最后一个 if 块对应着至少得两个节点的情况<ul><li>不仅仅判断上一个节点非空，还要保证当前节点非空</li></ul></li></ul><h3 id="单向链表带哨兵">3) 单向链表（带哨兵）</h3><p>观察之前单向链表的实现，发现每个方法内几乎都有判断是不是 head这样的代码，能不能简化呢？</p><p>用一个不参与数据存储的特殊 Node作为哨兵，它一般被称为哨兵或哑元，拥有哨兵节点的链表称为带头链表</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedListSentinel</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Integer.MIN_VALUE, <span class="literal">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>具体存什么值无所谓，因为不会用到它的值</li></ul><p>加入哨兵节点后，代码会变得比较简单，先看几个工具方法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedListSentinel</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据索引获取节点</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findNode</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="built_in">this</span>.head; curr != <span class="literal">null</span>; curr = curr.next, i++) {</span><br><span class="line">            <span class="keyword">if</span> (i == index) {</span><br><span class="line">                <span class="keyword">return</span> curr;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取最后一个节点</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findLast</span><span class="params">()</span> {</span><br><span class="line">        Node curr;</span><br><span class="line">        <span class="keyword">for</span> (curr = <span class="built_in">this</span>.head; curr.next != <span class="literal">null</span>; ) {</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>findNode 与之前类似，只是 i 初始值设置为 -1 对应哨兵，实际传入的index 也是 <span class="math inline">\([-1, \infty)\)</span></li><li>findLast 绝不会返回 null了，就算没有其它节点，也会返回哨兵作为最后一个节点</li></ul><p>这样，代码简化为</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedListSentinel</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> findLast();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        改动前</span></span><br><span class="line"><span class="comment">        if (last == null) {</span></span><br><span class="line"><span class="comment">            this.head = new Node(value, null);</span></span><br><span class="line"><span class="comment">            return;</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        last.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        改动前</span></span><br><span class="line"><span class="comment">        if (index == 0) {</span></span><br><span class="line"><span class="comment">            this.head = new Node(value, this.head);</span></span><br><span class="line"><span class="comment">            return;</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// index 传入 0 时，返回的是哨兵</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span>) {</span><br><span class="line">            prev.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, prev.next);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        改动前</span></span><br><span class="line"><span class="comment">        if (index == 0) {</span></span><br><span class="line"><span class="comment">            if (this.head != null) {</span></span><br><span class="line"><span class="comment">                this.head = this.head.next;</span></span><br><span class="line"><span class="comment">                return;</span></span><br><span class="line"><span class="comment">            } else {</span></span><br><span class="line"><span class="comment">                throw illegalIndex(index);</span></span><br><span class="line"><span class="comment">            }</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// index 传入 0 时，返回的是哨兵</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>);</span><br><span class="line">        Node curr;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; (curr = prev.next) != <span class="literal">null</span>) {</span><br><span class="line">            prev.next = curr.next;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        改动前</span></span><br><span class="line"><span class="comment">        this.head = new Node(value, this.head);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="built_in">this</span>.head.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="built_in">this</span>.head.next);</span><br><span class="line">        <span class="comment">// 也可以视为 insert 的特例, 即 insert(0, value);</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>对于删除，前面说了【最后一个 if块对应着至少得两个节点的情况】，现在有了哨兵，就凑足了两个节点</li></ul><h3 id="双向链表带哨兵">4) 双向链表（带哨兵）</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoublyLinkedListSentinel</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoublyLinkedListSentinel</span><span class="params">()</span> {</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="number">666</span>, <span class="literal">null</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="number">888</span>, <span class="literal">null</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findNode</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head; p != tail; p = p.next, i++) {</span><br><span class="line">            <span class="keyword">if</span> (i == index) {</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">        insert(<span class="number">0</span>, value);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeFirst</span><span class="params">()</span> {</span><br><span class="line">        remove(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">added</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(prev, value, tail);</span><br><span class="line">        prev.next = added;</span><br><span class="line">        tail.prev = added;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeLast</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">removed</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        <span class="keyword">if</span> (removed == head) {</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> removed.prev;</span><br><span class="line">        prev.next = tail;</span><br><span class="line">        tail.prev = prev;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> prev.next;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">inserted</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(prev, value, next);</span><br><span class="line">        prev.next = inserted;</span><br><span class="line">        next.prev = inserted;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">removed</span> <span class="operator">=</span> prev.next;</span><br><span class="line">        <span class="keyword">if</span> (removed == tail) {</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> removed.next;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IllegalArgumentException <span class="title function_">illegalIndex</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                String.format(<span class="string">"index [%d] 不合法%n"</span>, index));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;Integer&gt;() {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head.next;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> p != tail;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> p.value;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">        Node prev;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Node prev, <span class="type">int</span> value, Node next)</span> {</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="环形链表带哨兵">5) 环形链表（带哨兵）</h3><p>双向环形链表带哨兵，这时哨兵<strong>既作为头，也作为尾</strong></p><figure><img src="../../../../images/StrJava/image-20221229144232651.png" alt="image-20221229144232651"><figcaption aria-hidden="true">image-20221229144232651</figcaption></figure><figure><img src="../../../../images/StrJava/image-20221229143756065.png" alt="image-20221229143756065"><figcaption aria-hidden="true">image-20221229143756065</figcaption></figure><figure><img src="../../../../images/StrJava/image-20221229153338425.png" alt="image-20221229153338425"><figcaption aria-hidden="true">image-20221229153338425</figcaption></figure><figure><img src="../../../../images/StrJava/image-20221229154248800.png" alt="image-20221229154248800"><figcaption aria-hidden="true">image-20221229154248800</figcaption></figure><p>参考实现</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoublyLinkedListSentinel</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;&gt;() {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> sentinel.next;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> p != sentinel;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> p.value;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">        Node prev;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Node prev, <span class="type">int</span> value, Node next)</span> {</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">sentinel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, -<span class="number">1</span>, <span class="literal">null</span>); <span class="comment">// 哨兵</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoublyLinkedListSentinel</span><span class="params">()</span> {</span><br><span class="line">        sentinel.next = sentinel;</span><br><span class="line">        sentinel.prev = sentinel;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加到第一个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 待添加值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> sentinel.next;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> sentinel;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">added</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(prev, value, next);</span><br><span class="line">        prev.next = added;</span><br><span class="line">        next.prev = added;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加到最后一个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 待添加值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> sentinel.prev;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> sentinel;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">added</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(prev, value, next);</span><br><span class="line">        prev.next = added;</span><br><span class="line">        next.prev = added;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除第一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeFirst</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">removed</span> <span class="operator">=</span> sentinel.next;</span><br><span class="line">        <span class="keyword">if</span> (removed == sentinel) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"非法"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">a</span> <span class="operator">=</span> sentinel;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">b</span> <span class="operator">=</span> removed.next;</span><br><span class="line">        a.next = b;</span><br><span class="line">        b.prev = a;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除最后一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeLast</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">removed</span> <span class="operator">=</span> sentinel.prev;</span><br><span class="line">        <span class="keyword">if</span> (removed == sentinel) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"非法"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">a</span> <span class="operator">=</span> removed.prev;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">b</span> <span class="operator">=</span> sentinel;</span><br><span class="line">        a.next = b;</span><br><span class="line">        b.prev = a;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据值删除节点</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;假定 value 在链表中作为 key, 有唯一性&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 待删除值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeByValue</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">removed</span> <span class="operator">=</span> findNodeByValue(value);</span><br><span class="line">        <span class="keyword">if</span> (removed != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> removed.prev;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> removed.next;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findNodeByValue</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> sentinel.next;</span><br><span class="line">        <span class="keyword">while</span> (p != sentinel) {</span><br><span class="line">            <span class="keyword">if</span> (p.value == value) {</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            }</span><br><span class="line">            p = p.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="习题-2">习题</h3><h4 id="e01.-反转单向链表-leetcode-206">E01. 反转单向链表-Leetcode206</h4><p>对应力扣题目 <a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表 -力扣（LeetCode）</a></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br><span class="line"></span><br><span class="line">输入：[1,2]</span><br><span class="line">输出：[2,1]</span><br><span class="line"></span><br><span class="line">输入：[]</span><br><span class="line">输出：[]</span><br></pre></td></tr></tbody></table></figure><p><strong>方法1</strong></p><p>构造一个新链表，从<strong>旧链表</strong>依次拿到每个节点，创建新节点添加至<strong>新链表</strong>头部，完成后新链表即是倒序的</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode o1)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> o1;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">        n1 = <span class="keyword">new</span> <span class="title class_">ListNode</span>(p.val, n1);</span><br><span class="line">        p = p.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> n1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>评价：简单直白，就是得新创建节点对象</p><p><strong>方法2</strong></p><p>与方法1类似，构造一个新链表，从<strong>旧链表头部</strong>移除节点，添加到<strong>新链表头部</strong>，完成后新链表即是倒序的，区别在于原题目未提供节点外层的容器类，这里提供一个，另外一个区别是并不去构造新节点</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">List</span> {</span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">List</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        <span class="built_in">this</span>.head = head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeFirst</span><span class="params">()</span>{</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="literal">null</span>) {</span><br><span class="line">            head = first.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(ListNode first)</span> {</span><br><span class="line">        first.next = head;</span><br><span class="line">        head = first;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> {</span><br><span class="line">    <span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">List</span>(head);</span><br><span class="line">    <span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">List</span>(<span class="literal">null</span>);</span><br><span class="line">    ListNode first;</span><br><span class="line">    <span class="keyword">while</span> ((first = list1.removeFirst()) != <span class="literal">null</span>) {</span><br><span class="line">        list2.addFirst(first);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> list2.head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>评价：更加面向对象，如果实际写代码而非刷题，更多会这么做</p><p><strong>方法3</strong></p><p>递归，在<strong>归</strong>时让 <span class="math inline">\(5\rightarrow 4\)</span>，<span class="math inline">\(4 \rightarrow3\)</span> ...</p><p>首先，写一个递归方法，返回值用来拿到最后一个节点</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode p)</span> {</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> || p.next == <span class="literal">null</span>) { <span class="comment">// 不足两个节点</span></span><br><span class="line">        <span class="keyword">return</span> p; <span class="comment">// 最后一个节点</span></span><br><span class="line">    }</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverseList(p.next);</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>注意1：递归终止条件是 curr.next ==null，目的是到最后一个节点就结束递归，与之前递归遍历不一样</li><li>注意2：需要考虑空链表即 p == null 的情况</li></ul><p>可以先测试一下</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">o5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">o4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>, o5);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">o3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>, o4);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>, o3);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>, o2);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E01Leetcode206</span>().reverseList(o1);</span><br><span class="line">System.out.println(n1);</span><br></pre></td></tr></tbody></table></figure><p>会打印</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[5]</span><br></pre></td></tr></tbody></table></figure><p>下面为<strong>伪码</strong>调用过程，假设节点分别是 <span class="math inline">\(1 \rightarrow 2 \rightarrow 3 \rightarrow 4\rightarrow 5 \rightarrow null\)</span>，先忽略返回值</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">reverseList(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>) {</span><br><span class="line">    reverseList(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">2</span>) {</span><br><span class="line">    reverseList(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">3</span>) {</span><br><span class="line">    reverseList(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">4</span>) {</span><br><span class="line">    reverseList(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">5</span>) {</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> || p.next == <span class="literal">null</span>) {</span><br><span class="line">                        <span class="keyword">return</span> p; <span class="comment">// 返回5</span></span><br><span class="line">                    }</span><br><span class="line">}</span><br><span class="line">                <span class="comment">// 此时p是4, p.next是5</span></span><br><span class="line">}</span><br><span class="line">            <span class="comment">// 此时p是3, p.next是4</span></span><br><span class="line">}</span><br><span class="line">        <span class="comment">// 此时p是2, p.next是3</span></span><br><span class="line">}</span><br><span class="line">    <span class="comment">// 此时p是1, p.next是2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来，从 p = 4 开始，要让 <span class="math inline">\(5 \rightarrow4\)</span>，<span class="math inline">\(4 \rightarrow 3\)</span> ...</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">reverseList(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>) {</span><br><span class="line">    reverseList(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">2</span>) {</span><br><span class="line">    reverseList(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">3</span>) {</span><br><span class="line">    reverseList(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">4</span>) {</span><br><span class="line">    reverseList(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">5</span>) {</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> || p.next == <span class="literal">null</span>) {</span><br><span class="line">                        <span class="keyword">return</span> p; <span class="comment">// 返回5</span></span><br><span class="line">                    }</span><br><span class="line">}</span><br><span class="line">                <span class="comment">// 此时p是4, p.next是5, 要让5指向4,代码写成 p.next.next=p</span></span><br><span class="line">                <span class="comment">// 还要注意4要指向 null, 否则就死链了</span></span><br><span class="line">}</span><br><span class="line">            <span class="comment">// 此时p是3, p.next是4</span></span><br><span class="line">}</span><br><span class="line">        <span class="comment">// 此时p是2, p.next是3</span></span><br><span class="line">}</span><br><span class="line">    <span class="comment">// 此时p是1, p.next是2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最终代码为：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode p)</span> {    </span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> || p.next == <span class="literal">null</span>) { <span class="comment">// 不足两个节点</span></span><br><span class="line">        <span class="keyword">return</span> p; <span class="comment">// 最后一个节点</span></span><br><span class="line">    }</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverseList(p.next);</span><br><span class="line">    p.next.next = p;</span><br><span class="line">    p.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Q：为啥不能在<strong>递</strong>的过程中倒序？</p><p>A：比如</p><ul><li>$ 1 $ 如果递的过程中让 <span class="math inline">\(2 \rightarrow1\)</span> 那么此时 <span class="math inline">\(2 \rightarrow 3\)</span>就被覆盖，不知道接下来递给谁</li><li>而归的时候让 <span class="math inline">\(3 \rightarrow 2\)</span>不会影响上一层的 <span class="math inline">\(1 \rightarrow2\)</span></li></ul><p>评价：单向链表没有 prev指针，但利用递归的特性【记住了】链表每次调用时相邻两个节点是谁</p><p><strong>方法4</strong></p><p>从链表每次拿到第二个节点，将其从链表断开，插入头部，直至它为 null结束</p><ol type="1"><li>设置指针o1(旧头)、n1(新头)、o2(旧老二)，分别指向第一，第一，第二节点</li></ol><p><span class="math inline">\(\frac{n1 \ o1}{1} \rightarrow\frac{o2}{2} \rightarrow 3 \rightarrow 4 \rightarrow 5 \rightarrownull\)</span></p><ol start="2" type="1"><li>将 o2 节点从链表断开，即 o1 节点指向第三节点</li></ol><p>$ null$ ，<span class="math inline">\(\frac{o2}{2}\)</span></p><ol start="3" type="1"><li>o2 节点链入链表头部，即</li></ol><p><span class="math inline">\(\frac{o2}{2} \rightarrow \frac{n1 \o1}{1} \rightarrow 3 \rightarrow 4 \rightarrow 5 \rightarrownull\)</span></p><ol start="4" type="1"><li>n1 指向 o2</li></ol><p><span class="math inline">\(\frac{n1 \ o2}{2} \rightarrow\frac{o1}{1} \rightarrow 3 \rightarrow 4 \rightarrow 5 \rightarrownull\)</span></p><ol start="5" type="1"><li>o2 指向 o1 的下一个节点，即</li></ol><p><span class="math inline">\(\frac{n1}{2} \rightarrow \frac{o1}{1}\rightarrow \frac{o2}{3} \rightarrow 4 \rightarrow 5 \rightarrownull\)</span></p><ol start="6" type="1"><li><p>重复以上 <span class="math inline">\(2\sim5\)</span> 步，直到 o2指向 null</p></li><li><p>还应当考虑边界条件，即链表中不满两个元素时，无需走以上逻辑</p></li></ol><p>参考答案</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode o1)</span> {    </span><br><span class="line">    <span class="keyword">if</span> (o1 == <span class="literal">null</span> || o1.next == <span class="literal">null</span>) { <span class="comment">// 不足两个节点</span></span><br><span class="line">        <span class="keyword">return</span> o1;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">o2</span> <span class="operator">=</span> o1.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> o1;</span><br><span class="line">    <span class="keyword">while</span> (o2 != <span class="literal">null</span>) {</span><br><span class="line">        o1.next = o2.next; </span><br><span class="line">        o2.next = n1;</span><br><span class="line">        n1 = o2;</span><br><span class="line">        o2 = o1.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> n1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>方法5</strong></p><p>要点：把链表分成两部分，思路就是不断从链表2的头，往链表1的头搬移</p><ol type="1"><li>n1 指向 null，代表<strong>新链表</strong>一开始没有元素，o1指向<strong>原链表</strong>的首节点</li></ol><p><span class="math inline">\(\frac{n1}{null}\)</span>，<span class="math inline">\(\frac{o1}{1} \rightarrow 2 \rightarrow 3\rightarrow 4 \rightarrow 5 \rightarrow null\)</span></p><ol start="2" type="1"><li>开始循环，o2 指向<strong>原链表</strong>次节点</li></ol><p><span class="math inline">\(\frac{n1}{null}\)</span>，<span class="math inline">\(\frac{o1}{1} \rightarrow \frac{o2}{2} \rightarrow3 \rightarrow 4 \rightarrow 5 \rightarrow null\)</span></p><ol start="3" type="1"><li>搬移</li></ol><p><span class="math inline">\(\frac{o1}{1} \rightarrow\frac{n1}{null}\)</span> ， <span class="math inline">\(\frac{o2}{2}\rightarrow 3 \rightarrow 4 \rightarrow 5 \rightarrow null\)</span></p><ol start="4" type="1"><li>指针复位</li></ol><p><span class="math inline">\(\frac{n1}{1} \rightarrow null\)</span> ，<span class="math inline">\(\frac{o1 \ o2}{2} \rightarrow 3 \rightarrow4 \rightarrow 5 \rightarrow null\)</span></p><ol start="5" type="1"><li>重复 <span class="math inline">\(2\sim4\)</span> 步</li><li>当 o1 = null 时退出循环</li></ol><p><strong>参考答案</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode o1)</span> {</span><br><span class="line">    <span class="keyword">if</span> (o1 == <span class="literal">null</span> || o1.next == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> o1;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (o1 != <span class="literal">null</span>) {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">o2</span> <span class="operator">=</span> o1.next;</span><br><span class="line">        o1.next = n1;</span><br><span class="line">        n1 = o1;</span><br><span class="line">        o1 = o2;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> n1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>评价：本质上与方法2 相同，只是方法2更为面向对象</p><h4 id="e02.-根据值删除节点-leetcode-203">E02. 根据值删除节点-Leetcode203</h4><p>例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2,6,3,6], val = 6</span><br><span class="line">输出：[1,2,3]</span><br><span class="line"></span><br><span class="line">输入：head = [], val = 1</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">输入：head = [7,7,7,7], val = 7</span><br><span class="line">输出：[]</span><br></pre></td></tr></tbody></table></figure><p><strong>方法1</strong></p><p>图中 s 代表 sentinel哨兵（如果不加哨兵，则删除第一个节点要特殊处理），例如要删除 6</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">p1   p2</span><br><span class="line">s -&gt; 1 -&gt; 2 -&gt; 6 -&gt; 3 -&gt; 6 -&gt; null</span><br></pre></td></tr></tbody></table></figure><ul><li>如果 p2 不等于目标，则 p1，p2 不断后移</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"> p1   p2</span><br><span class="line">s -&gt; 1 -&gt; 2 -&gt; 6 -&gt; 3 -&gt; 6 -&gt; null</span><br><span class="line"></span><br><span class="line">   p1   p2</span><br><span class="line">s -&gt; 1 -&gt; 2 -&gt; 6 -&gt; 3 -&gt; 6 -&gt; null</span><br></pre></td></tr></tbody></table></figure><ul><li>p2 == 6，删除它，注意 p1 此时保持不变，p2 后移</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">   p1   p2</span><br><span class="line">s -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 6 -&gt; null</span><br></pre></td></tr></tbody></table></figure><ul><li>p2 不等于目标，则 p1，p2 不断后移</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">      p1   p2</span><br><span class="line">s -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 6 -&gt; null</span><br></pre></td></tr></tbody></table></figure><ul><li>p2 == 6，删除它，注意 p1 此时保持不变，p2 后移</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">      p1   p2</span><br><span class="line">s -&gt; 1 -&gt; 2 -&gt; 3 -&gt; null</span><br></pre></td></tr></tbody></table></figure><ul><li>p2 == null 退出循环</li></ul><p>最后代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">sentinel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> sentinel;</span><br><span class="line">    ListNode p2;</span><br><span class="line">    <span class="keyword">while</span> ((p2 = p1.next) != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (p2.val == val) {</span><br><span class="line">            p1.next = p2.next;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sentinel.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>方法2</strong></p><p>思路，递归函数负责返回：从当前节点（我）开始，完成删除的子链表</p><ol type="1"><li>若我与 v 相等，应该返回下一个节点递归结果</li><li>若我与 v 不等，应该返回我，但我的 next应该更新（让我能带上后续删过的子链表）</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">removeElements(ListNode p=<span class="number">1</span>, <span class="type">int</span> v=<span class="number">6</span>){</span><br><span class="line">    <span class="number">1.</span>next=removeElements(ListNode p=<span class="number">2</span>, <span class="type">int</span> v=<span class="number">6</span>){</span><br><span class="line">    <span class="number">2.</span>next=removeElements(ListNode p=<span class="number">6</span>, <span class="type">int</span> v=<span class="number">6</span>){</span><br><span class="line">    removeElements(ListNode p=<span class="number">3</span>, <span class="type">int</span> v=<span class="number">6</span>){</span><br><span class="line">    <span class="number">3.</span>next=removeElements(ListNode p=<span class="number">6</span>, <span class="type">int</span> v=<span class="number">6</span>){</span><br><span class="line">    removeElements(ListNode p=<span class="literal">null</span>, <span class="type">int</span> v=<span class="number">6</span>){</span><br><span class="line">    <span class="comment">// 没有节点,返回</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">                <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> {</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (head.val == val) {</span><br><span class="line">        <span class="keyword">return</span> removeElements(head.next, val);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        head.next = removeElements(head.next, val);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e03.-删除倒数节点-leetcode-19">E03. 删除倒数节点-Leetcode19</h4><p>例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br><span class="line"></span><br><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></tbody></table></figure><p>另外题目提示</p><ul><li>链表至少一个节点</li><li>n 只会在合理范围</li></ul><p><strong>方法1</strong></p><p>思路，写一个递归函数，用来返回下一个节点的倒数序号</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">recursion(ListNode p=<span class="number">1</span>, <span class="type">int</span> n=<span class="number">2</span>) {</span><br><span class="line">    recursion(ListNode p=<span class="number">2</span>, <span class="type">int</span> n=<span class="number">2</span>) {</span><br><span class="line">    recursion(ListNode p=<span class="number">3</span>, <span class="type">int</span> n=<span class="number">2</span>) {</span><br><span class="line">    recursion(ListNode p=<span class="number">4</span>, <span class="type">int</span> n=<span class="number">2</span>) {</span><br><span class="line">    recursion(ListNode p=<span class="number">5</span>, <span class="type">int</span> n=<span class="number">2</span>) {</span><br><span class="line">    recursion(ListNode p=<span class="literal">null</span>, <span class="type">int</span> n=<span class="number">2</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 最内层序号0</span></span><br><span class="line">}</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 上一次返回值+1</span></span><br><span class="line">}</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line">            <span class="keyword">if</span>(返回值 == n == <span class="number">2</span>) {</span><br><span class="line">                <span class="comment">// 删除 next</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">}</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">}</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但上述代码有一个问题，就是若删除的是第一个节点，它没有上一个节点，因此可以加一个哨兵来解决</p><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">sentinel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">    recursion(sentinel, n);</span><br><span class="line">    <span class="keyword">return</span> sentinel.next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">recursion</span><span class="params">(ListNode p, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">nth</span> <span class="operator">=</span> recursion(p.next, n);</span><br><span class="line">    <span class="keyword">if</span> (nth == n) {</span><br><span class="line">        p.next = p.next.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> nth + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Q：p.next.next 不怕空指针吗？</p><p>A：</p><ul><li>p 是待删除节点的上一个节点，如果能递归回到 p，那么 p.next肯定有值，不会是 null</li><li>且题目说明了 n &gt;=1，不会因为 nth == 0 而让 p.next 指向最后的null</li></ul><p><strong>方法2</strong></p><p>快慢指针，p1 指向待删节点的上一个，p2 先走 n + 1 步</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">i=<span class="number">0</span></span><br><span class="line">p2</span><br><span class="line">s -&gt; <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">     i=<span class="number">1</span></span><br><span class="line">     p2</span><br><span class="line">s -&gt; <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">          i=<span class="number">2</span></span><br><span class="line">          p2</span><br><span class="line">s -&gt; <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">               i=<span class="number">3</span> 从此开始 p1 p2 依次向右平移, 直到 p2 移动到末尾</span><br><span class="line">p1             p2</span><br><span class="line">s -&gt; <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">               p1             p2</span><br><span class="line">s -&gt; <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="literal">null</span></span><br></pre></td></tr></tbody></table></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> s;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) {</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="literal">null</span>) {</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    }</span><br><span class="line">    p1.next = p1.next.next;</span><br><span class="line">    <span class="keyword">return</span> s.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>方法3</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="type">Composite</span> <span class="variable">c</span> <span class="operator">=</span> recursion(head, n);</span><br><span class="line">    <span class="keyword">return</span> c.node;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Composite</span> {</span><br><span class="line">    ListNode node;</span><br><span class="line">    <span class="type">int</span> nth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Composite</span><span class="params">(ListNode node, <span class="type">int</span> nth)</span> {</span><br><span class="line">        <span class="built_in">this</span>.node = node;</span><br><span class="line">        <span class="built_in">this</span>.nth = nth;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Composite <span class="title function_">recursion</span><span class="params">(ListNode p, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="literal">null</span>, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">Composite</span> <span class="variable">c</span> <span class="operator">=</span> recursion(p.next, n);</span><br><span class="line">    <span class="keyword">if</span> (c.nth != n) {</span><br><span class="line">        p.next = c.node;</span><br><span class="line">        c.node = p;</span><br><span class="line">    }</span><br><span class="line">    c.nth +=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e04.-有序链表去重-leetcode-83">E04. 有序链表去重-Leetcode83</h4><p>例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,1,2]</span><br><span class="line">输出：[1,2]</span><br><span class="line"></span><br><span class="line">输入：head = [1,1,2,3,3]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></tbody></table></figure><p>注意：<strong>重复元素保留一个</strong></p><p><strong>方法1</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">p1   p2</span><br><span class="line">1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 3 -&gt; null</span><br></pre></td></tr></tbody></table></figure><ul><li>p1.val == p2.val 那么删除 p2，注意 p1 此时保持不变</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">p1   p2</span><br><span class="line">1 -&gt; 2 -&gt; 3 -&gt; 3 -&gt; null</span><br></pre></td></tr></tbody></table></figure><ul><li>p1.val != p2.val 那么 p1，p2 向后移动</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">     p1   p2</span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">3</span> -&gt; <span class="literal">null</span></span><br><span class="line">         </span><br><span class="line">          p1   p2</span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">3</span> -&gt; <span class="literal">null</span>     </span><br></pre></td></tr></tbody></table></figure><ul><li>p1.val == p2.val 那么删除 p2</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">          p1   p2</span><br><span class="line">1 -&gt; 2 -&gt; 3 -&gt; null   </span><br></pre></td></tr></tbody></table></figure><ul><li>当 p2 == null 退出循环</li></ul><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> {</span><br><span class="line">    <span class="comment">// 链表节点 &lt; 2</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 链表节点 &gt;= 2</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head;</span><br><span class="line">    ListNode p2;</span><br><span class="line">    <span class="keyword">while</span> ((p2 = p1.next) != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (p1.val == p2.val) {</span><br><span class="line">            p1.next = p2.next;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>方法2</strong></p><p>递归函数负责返回：从当前节点（我）开始，完成去重的链表</p><ol type="1"><li>若我与 next 重复，返回 next</li><li>若我与 next 不重复，返回我，但 next 应当更新</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">deleteDuplicates(ListNode p=<span class="number">1</span>) {</span><br><span class="line">    deleteDuplicates(ListNode p=<span class="number">1</span>) {</span><br><span class="line">        <span class="number">1.</span>next=deleteDuplicates(ListNode p=<span class="number">2</span>) {</span><br><span class="line">            <span class="number">2.</span>next=deleteDuplicates(ListNode p=<span class="number">3</span>) {</span><br><span class="line">                deleteDuplicates(ListNode p=<span class="number">3</span>) {</span><br><span class="line"><span class="comment">// 只剩一个节点，返回</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">                }                </span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode p)</span> {</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> || p.next == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(p.val == p.next.val) {</span><br><span class="line">        <span class="keyword">return</span> deleteDuplicates(p.next);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        p.next = deleteDuplicates(p.next);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e05.-有序链表去重-leetcode-82">E05. 有序链表去重-Leetcode82</h4><p>例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,3,4,4,5]</span><br><span class="line">输出：[1,2,5]</span><br><span class="line"></span><br><span class="line">输入：head = [1,1,1,2,3]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></tbody></table></figure><p>注意：<strong>重复元素一个不留</strong></p><p><strong>方法1</strong></p><p>递归函数负责返回：从当前节点（我）开始，完成去重的链表</p><ol type="1"><li>若我与 next重复，一直找到下一个不重复的节点，以它的返回结果为准</li><li>若我与 next 不重复，返回我，同时更新 next</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">deleteDuplicates(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>) {</span><br><span class="line">    <span class="comment">// 找下个不重复的</span></span><br><span class="line">deleteDuplicates(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>) {</span><br><span class="line">        deleteDuplicates(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>) {</span><br><span class="line">deleteDuplicates(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">2</span>) {</span><br><span class="line">                <span class="number">2.</span>next=deleteDuplicates(<span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">3</span>) {</span><br><span class="line"><span class="comment">// 只剩一个节点，返回</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">}</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode p)</span> {</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> || p.next == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (p.val == p.next.val) {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">x</span> <span class="operator">=</span> p.next.next;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="literal">null</span> &amp;&amp; x.val == p.val) {</span><br><span class="line">            x = x.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> deleteDuplicates(x);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        p.next = deleteDuplicates(p.next);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>方法2</strong></p><p>p1 是待删除的上一个节点，每次循环对比 p2、p3 的值</p><ul><li>如果 p2 与 p3 的值重复，那么 p3 继续后移，直到找到与 p2不重复的节点，p1 指向 p3 完成删除</li><li>如果 p2 与 p3 的值不重复，p1，p2，p3向后平移一位，继续上面的操作</li><li>p2 或 p3 为 null 退出循环<ul><li>p2 为 null 的情况，比如链表为 1 1 1 null</li></ul></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">p1 p2 p3</span><br><span class="line">s, 1, 1, 1, 2, 3, null</span><br><span class="line"></span><br><span class="line">p1 p2    p3</span><br><span class="line">s, 1, 1, 1, 2, 3, null</span><br><span class="line"></span><br><span class="line">p1 p2       p3</span><br><span class="line">s, 1, 1, 1, 2, 3, null</span><br><span class="line"></span><br><span class="line">p1 p3</span><br><span class="line">s, 2, 3, null</span><br><span class="line"></span><br><span class="line">p1 p2 p3</span><br><span class="line">s, 2, 3, null</span><br><span class="line"></span><br><span class="line">   p1 p2 p3</span><br><span class="line">s, 2, 3, null</span><br></pre></td></tr></tbody></table></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> {</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> s;</span><br><span class="line">    ListNode p2;</span><br><span class="line">    ListNode p3;</span><br><span class="line">    <span class="keyword">while</span> ((p2 = p1.next) != <span class="literal">null</span> &amp;&amp; (p3 = p2.next) != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (p2.val == p3.val) {</span><br><span class="line">            <span class="keyword">while</span> ((p3 = p3.next) != <span class="literal">null</span> </span><br><span class="line">                   &amp;&amp; p3.val == p2.val) {</span><br><span class="line">            }</span><br><span class="line">            p1.next = p3;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e06.-合并有序链表-leetcode-21">E06. 合并有序链表-Leetcode21</h4><p>例</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br><span class="line">    </span><br><span class="line">输入：l1 = [], l2 = []</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">输入：l1 = [], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></tbody></table></figure><p><strong>方法1</strong></p><ul><li>谁小，把谁链给 p，p 和小的都向后平移一位</li><li>当 p1、p2 有一个为 null，退出循环，把不为 null 的链给 p</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">p1</span><br><span class="line">1389null</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">24null</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">snull</span><br></pre></td></tr></tbody></table></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode p1, ListNode p2)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> s;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (p1.val &lt; p2.val) {</span><br><span class="line">            p.next = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            p.next = p2;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        }</span><br><span class="line">        p = p.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (p1 != <span class="literal">null</span>) {</span><br><span class="line">        p.next = p1;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (p2 != <span class="literal">null</span>) {</span><br><span class="line">        p.next = p2;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>可以自行验证<strong>例</strong>中后两种情况</li></ul><p><strong>方法2</strong></p><p>递归函数应该返回</p><ul><li>更小的那个链表节点，并把它剩余节点与另一个链表再次递归</li><li>返回之前，更新此节点的 next</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">mergeTwoLists(p1=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>], p2=[<span class="number">2</span>,<span class="number">4</span>]) {</span><br><span class="line">    <span class="number">1.</span>next=mergeTwoLists(p1=[<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>], p2=[<span class="number">2</span>,<span class="number">4</span>]) {</span><br><span class="line">        <span class="number">2.</span>next=mergeTwoLists(p1=[<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>], p2=[<span class="number">4</span>]) {            </span><br><span class="line">            <span class="number">3.</span>next=mergeTwoLists(p1=[<span class="number">8</span>,<span class="number">9</span>], p2=[<span class="number">4</span>]) {</span><br><span class="line">                <span class="number">4.</span>next=mergeTwoLists(p1=[<span class="number">8</span>,<span class="number">9</span>], p2=<span class="literal">null</span>) {</span><br><span class="line">                    <span class="keyword">return</span> [<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    }</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e07.-合并多个有序链表-leetcode-23">E07.合并多个有序链表-Leetcode 23</h4><p>例</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></tbody></table></figure><p><strong>方法1</strong></p><p>递归</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> {</span><br><span class="line">    <span class="keyword">if</span> (lists.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> split(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">split</span><span class="params">(ListNode[] lists, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">    System.out.println(i + <span class="string">" "</span> + j);</span><br><span class="line">    <span class="keyword">if</span> (j == i) {</span><br><span class="line">        <span class="keyword">return</span> lists[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(</span><br><span class="line">        split(lists, i, m),</span><br><span class="line">        split(lists, m + <span class="number">1</span>, j)</span><br><span class="line">    );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>还可以用优先级队列求解，这个放在后面讲</p><h4 id="e08.-查找链表中间节点-leetcode-876">E08.查找链表中间节点-Leetcode 876</h4><p>例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5]</span><br><span class="line">输出：此列表中的结点 3 (序列化形式：[3,4,5])</span><br><span class="line"></span><br><span class="line">输入：[1,2,3,4,5,6]</span><br><span class="line">输出：此列表中的结点 4 (序列化形式：[4,5,6])</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>偶数</strong>节点时，中间点是靠右的那个</li></ul><p>解法：快慢指针，快指针一次走两步，慢指针一次走一步，当快指针到链表结尾时，慢指针恰好走到链表的一半</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head;<span class="comment">// 慢指针，中间点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> head;<span class="comment">// 快指针</span></span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="literal">null</span> &amp;&amp; p2.next != <span class="literal">null</span>) {</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e09.-回文链表-leetcode-234">E09. 回文链表-Leetcode 234</h4><p>所谓回文指正着读、反着读，结果一样，例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[1,2,2,1]</span><br><span class="line">[1,2,3,2,1]</span><br></pre></td></tr></tbody></table></figure><p>它们都是回文链表，不是回文的例子</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[1,2,3,1]  --反过来--&gt;  [1,3,2,1]</span><br></pre></td></tr></tbody></table></figure><p>解法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    步骤1. 找中间点</span></span><br><span class="line"><span class="comment">    步骤2. 中间点后半个链表反转</span></span><br><span class="line"><span class="comment">    步骤3. 反转后链表与原链表逐一比较</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">middle</span> <span class="operator">=</span> middle(head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverse(middle);</span><br><span class="line">    <span class="keyword">while</span> (newHead != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (newHead.val != head.val) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        newHead = newHead.next;</span><br><span class="line">        head = head.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode o1)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (o1 != <span class="literal">null</span>) {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">o2</span> <span class="operator">=</span> o1.next;</span><br><span class="line">        o1.next = n1;</span><br><span class="line">        n1 = o1;</span><br><span class="line">        o1 = o2;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> n1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">middle</span><span class="params">(ListNode head)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head; <span class="comment">// 慢</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> head; <span class="comment">// 快</span></span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="literal">null</span> &amp;&amp; p2.next != <span class="literal">null</span>) {</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>优化后解法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode h1)</span> {</span><br><span class="line">    <span class="keyword">if</span> (h1 == <span class="literal">null</span> || h1.next == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> h1; <span class="comment">// 慢指针，中间点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> h1; <span class="comment">// 快指针</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">// 新头</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">o1</span> <span class="operator">=</span> h1;<span class="comment">// 旧头</span></span><br><span class="line">    <span class="comment">// 快慢指针找中间点</span></span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="literal">null</span> &amp;&amp; p2.next != <span class="literal">null</span>) {</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反转前半部分</span></span><br><span class="line">        o1.next = n1;</span><br><span class="line">        n1 = o1;</span><br><span class="line">        o1 = p1;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (p2 != <span class="literal">null</span>) { <span class="comment">// 节点数为奇数</span></span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 同步比较新头和后半部分</span></span><br><span class="line">    <span class="keyword">while</span> (n1 != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (n1.val != p1.val) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e10.-环形链表-leetcode-141">E10. 环形链表-Leetcode 141</h4><p>本题以及下题，实际是 Floyd's Tortoise and Hare Algorithm （Floyd龟兔赛跑算法）<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a></p><blockquote><p>除了 Floyd 判环算法外，还有其它的判环算法，详见https://en.wikipedia.org/wiki/Cycle_detection</p></blockquote><p><img src="../../../../images/StrJava/image-20221229190646563.png" alt="image-20221229190646563" style="zoom: 50%;"></p><p>如果链表上存在环，那么在环上以不同速度前进的两个指针必定会在某个时刻相遇。算法分为两个阶段</p><p>阶段1</p><ul><li>龟一次走一步，兔子一次走两步</li><li>当兔子能走到终点时，不存在环</li><li>当兔子能追上龟时，可以判断存在环</li></ul><p>阶段2</p><ul><li>从它们第一次相遇开始，龟回到起点，兔子保持原位不变</li><li>龟和兔子一次都走一步</li><li>当再次相遇时，地点就是环的入口</li></ul><p>为什么呢？</p><ul><li>设起点到入口走 a 步（本例是 7），绕环一圈长度为 b（本例是 5），</li><li>那么<strong>从起点开始，走 a + 绕环 n圈，都能找到环入口</strong></li><li>第一次相遇时<ul><li>兔走了 a + 绕环 n 圈（本例 2 圈） + k，k是它们相遇距环入口位置（本例 3，不重要）</li><li>龟走了 a + 绕环 n 圈（本例 0 圈） + k，当然它绕的圈数比兔少</li><li>兔走的距离是龟的两倍，所以<strong>龟走的</strong> = 兔走的 - 龟走的= <strong>绕环 n 圈</strong></li></ul></li><li>而前面分析过，如果走 a + 绕环 n圈，都能找到环入口，因此从相遇点开始，再走 a 步，就是环入口</li></ul><p>阶段1 参考代码（判断是否有环）</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// 兔</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> head; <span class="comment">// 龟</span></span><br><span class="line">    <span class="keyword">while</span> (h != <span class="literal">null</span> &amp;&amp; h.next != <span class="literal">null</span>) {</span><br><span class="line">        t = t.next;</span><br><span class="line">        h = h.next.next;</span><br><span class="line">        <span class="keyword">if</span>(h == t){</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e11.-环形链表-leetcode-142">E11. 环形链表-Leetcode 142</h4><p>阶段2 参考代码（找到环入口）</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> head; <span class="comment">// 龟</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// 兔</span></span><br><span class="line">    <span class="keyword">while</span> (h != <span class="literal">null</span> &amp;&amp; h.next != <span class="literal">null</span>) {</span><br><span class="line">        t = t.next;</span><br><span class="line">        h = h.next.next;</span><br><span class="line">        <span class="keyword">if</span> (h == t) {</span><br><span class="line">            t = head;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                <span class="keyword">if</span> (h == t) {</span><br><span class="line">                    <span class="keyword">return</span> h;</span><br><span class="line">                }</span><br><span class="line">                h = h.next;</span><br><span class="line">                t = t.next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>还有一道扩展题目，也可以用判环算法思想来解：就是 287题，寻找重复数</li></ul><h4 id="ex1.-删除节点-leetcode-237">Ex1. 删除节点-Leetcode 237</h4><p>这道题目比较简单，留给大家自己练习</p><p>例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：head = [4,5,1,9], node = 5</span><br><span class="line">输出：[4,1,9]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：head = [4,5,1,9], node = 1</span><br><span class="line">输出：[4,5,9]</span><br></pre></td></tr></tbody></table></figure><p>注意：被删除的节点<strong>不是</strong>末尾节点</p><p><strong>参考答案</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ex1Leetcode237</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 待删除节点, 题目已说明肯定不是最后一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(ListNode node)</span> {</span><br><span class="line">        node.val = node.next.val;<span class="comment">// 下一个节点值赋值给待"删除"节点</span></span><br><span class="line">        node.next = node.next.next;<span class="comment">// 把下一个节点删除</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">o5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">o4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>, o5);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">o3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>, o4);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>, o3);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>, o2);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">E0xLeetcode237</span>().deleteNode(o3);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[1,2,3,4,5]</span><br><span class="line">[1,2,4,5]</span><br></pre></td></tr></tbody></table></figure><h4 id="ex2.-共尾链表-leetcode-160">Ex2. 共尾链表-Leetcode 160</h4><p>原题叫做<strong>相交</strong>链表，个人觉得用<strong>共尾</strong>链表更形象些，此题更像是一道脑筋急转弯，留给大家练习</p><p>例如，下图的两个链表 [1, 2, 4, 5] 与 [3, 4, 5] 它们中 [4, 5]是相同的，此时应返回节点 4</p><figure><img src="../../../../images/StrJava/image-20221228081715799.png" alt="image-20221228081715799"><figcaption aria-hidden="true">image-20221228081715799</figcaption></figure><p>非共尾的情况，如下图所示，此时返回 null</p><figure><img src="../../../../images/StrJava/image-20221228082002730.png" alt="image-20221228082002730"><figcaption aria-hidden="true">image-20221228082002730</figcaption></figure><p>思路，称两个链表为 a=[1, 2, 4, 5]，b=[3, 4, 5]，图中用 N 代表null</p><ol type="1"><li>遍历 a，遇到 null 时改道遍历 b</li><li>与此同时，遍历 b，遇到 null 时改道遍历 a</li><li>在此过程中，如果<strong>遇到相同</strong>的节点，即为找寻目标，返回即可，如下图中的第二次出现的4</li><li>相同节点应该比较其<strong>引用值</strong>，图中数字只是为了便于区分</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1245N345N</span><br><span class="line">345N1245N</span><br></pre></td></tr></tbody></table></figure><p>如果两个链表长度相同，则可以更早找到目标，例如 a=[1, 4, 5]，b=[3, 4,5]，第一次出现 4 时，即可返回</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">145N345N</span><br><span class="line">345N145N</span><br></pre></td></tr></tbody></table></figure><p>如果是非共尾的情况，如 a=[1, 2, 4]，b=[3,5]，可以看到，唯一相等的情况，是遍历到最后那个 N 此时退出循环</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">124N35N</span><br><span class="line">35N124N</span><br></pre></td></tr></tbody></table></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode a, ListNode b)</span> {</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> a;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> b;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="keyword">if</span> (p1 == p2) {</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">null</span>) {</span><br><span class="line">            p1 = b;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (p2 == <span class="literal">null</span>) {</span><br><span class="line">            p2 = a;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        }            </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="递归">2.3 递归</h2><h3 id="概述-2">1) 概述</h3><p><strong>定义</strong></p><p>计算机科学中，递归是一种解决计算问题的方法，其中解决方案取决于同一类问题的更小子集</p><blockquote><p>In computer science, <strong>recursion</strong> is a method ofsolving a computational problem where the solution depends on solutionsto smaller instances of the same problem.</p></blockquote><p>比如单链表递归遍历的例子：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Node node)</span> {</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    println(<span class="string">"before:"</span> + node.value)</span><br><span class="line">    f(node.next);</span><br><span class="line">    println(<span class="string">"after:"</span> + node.value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>说明：</p><ol type="1"><li>自己调用自己，如果说每个函数对应着一种解决方案，自己调用自己意味着解决方案是一样的（有规律的）</li><li>每次调用，函数处理的数据会较上次缩减（子集），而且最后会缩减至无需继续递归</li><li>内层函数调用（子集处理）完成，外层函数才能算调用完成</li></ol><p><strong>原理</strong></p><p>假设链表中有 3 个节点，value 分别为1，2，3，以上代码的执行流程就类似于下面的<strong>伪码</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 1 -&gt; 2 -&gt; 3 -&gt; null  f(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Node node = <span class="number">1</span>)</span> {</span><br><span class="line">    println(<span class="string">"before:"</span> + node.value) <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Node node = <span class="number">2</span>)</span> {</span><br><span class="line">        println(<span class="string">"before:"</span> + node.value) <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Node node = <span class="number">3</span>)</span> {</span><br><span class="line">            println(<span class="string">"before:"</span> + node.value) <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Node node = <span class="literal">null</span>)</span> {</span><br><span class="line">                <span class="keyword">if</span>(node == <span class="literal">null</span>) {</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            println(<span class="string">"after:"</span> + node.value) <span class="comment">// 3</span></span><br><span class="line">        }</span><br><span class="line">        println(<span class="string">"after:"</span> + node.value) <span class="comment">// 2</span></span><br><span class="line">    }</span><br><span class="line">    println(<span class="string">"after:"</span> + node.value) <span class="comment">// 1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>思路</strong></p><ol type="1"><li>确定能否使用递归求解</li><li>推导出递推关系，即父问题与子问题的关系，以及递归的结束条件</li></ol><p>例如之前遍历链表的递推关系为 <span class="math display">\[f(n) =\begin{cases}停止&amp; n = null \\f(n.next) &amp; n \neq null\end{cases}\]</span></p><ul><li>深入到最里层叫做<strong>递</strong></li><li>从最里层出来叫做<strong>归</strong></li><li>在<strong>递</strong>的过程中，外层函数内的局部变量（以及方法参数）并未消失，<strong>归</strong>的时候还可以用到</li></ul><h3 id="单路递归-single-recursion">2) 单路递归 Single Recursion</h3><h4 id="e01.-阶乘">E01. 阶乘</h4><p>用递归方法求阶乘</p><ul><li><p>阶乘的定义 <span class="math inline">\(n!=1⋅2⋅3⋯(n-2)⋅(n-1)⋅n\)</span>，其中 <span class="math inline">\(n\)</span> 为自然数，当然 <span class="math inline">\(0! = 1\)</span></p></li><li><p>递推关系</p></li></ul><p><span class="math display">\[f(n) =\begin{cases}1 &amp; n = 1\\n * f(n-1) &amp; n &gt; 1\end{cases}\]</span></p><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> n * f(n - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>拆解<strong>伪码</strong>如下，假设 n 初始值为 3</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">f(<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">3</span>) { <span class="comment">// 解决不了,递</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> * f(<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">2</span>) { <span class="comment">// 解决不了,继续递</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * f(<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) { <span class="comment">// 可以解决, 开始归</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e02.-反向打印字符串">E02. 反向打印字符串</h4><p>用递归反向打印字符串，n 为字符在整个字符串 str 中的索引位置</p><ul><li><strong>递</strong>：n 从 0 开始，每次 n + 1，一直递到 n ==str.length() - 1</li><li><strong>归</strong>：从 n == str.length()开始归，从归打印，自然是逆序的</li></ul><p>递推关系 <span class="math display">\[f(n) =\begin{cases}停止 &amp; n = str.length() \\f(n+1) &amp; 0 \leq n \leq str.length() - 1\end{cases}\]</span> 代码为</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(String str, <span class="type">int</span> index)</span> {</span><br><span class="line">    <span class="keyword">if</span> (index == str.length()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    reversePrint(str, index + <span class="number">1</span>);</span><br><span class="line">    System.out.println(str.charAt(index));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>拆解<strong>伪码</strong>如下，假设字符串为 "abc"</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(String str, <span class="type">int</span> index = <span class="number">0</span>)</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(String str, <span class="type">int</span> index = <span class="number">1</span>)</span> {</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(String str, <span class="type">int</span> index = <span class="number">2</span>)</span> {</span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(String str, <span class="type">int</span> index = <span class="number">3</span>)</span> { </span><br><span class="line">                <span class="keyword">if</span> (index == str.length()) {</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// 开始归</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            System.out.println(str.charAt(index)); <span class="comment">// 打印 c</span></span><br><span class="line">        }</span><br><span class="line">        System.out.println(str.charAt(index)); <span class="comment">// 打印 b</span></span><br><span class="line">    }</span><br><span class="line">    System.out.println(str.charAt(index)); <span class="comment">// 打印 a</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e03.-二分查找单路递归">E03. 二分查找（单路递归）</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="keyword">return</span> recursion(a, target, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">recursion</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">    <span class="keyword">if</span> (i &gt; j) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; a[m]) {</span><br><span class="line">        <span class="keyword">return</span> recursion(a, target, i, m - <span class="number">1</span>);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) {</span><br><span class="line">        <span class="keyword">return</span> recursion(a, target, m + <span class="number">1</span>, j);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e04.-冒泡排序单路递归">E04. 冒泡排序（单路递归）</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">int</span>[] a = {<span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>};</span><br><span class="line">    bubble(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    System.out.println(Arrays.toString(a));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> low, <span class="type">int</span> high)</span> {</span><br><span class="line">    <span class="keyword">if</span>(low == high) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low; i &lt; high; i++) {</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) {</span><br><span class="line">            swap(a, i, i + <span class="number">1</span>);</span><br><span class="line">            j = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    bubble(a, low, j);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = t;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>low 与 high 为未排序范围</li><li>j 表示的是未排序的边界，下一次递归时的 high<ul><li>发生交换，意味着有无序情况</li><li>最后一次交换（以后没有无序）时，左侧 i 仍是无序，右侧 i+1已然有序</li></ul></li><li>视频中讲解的是只考虑 high 边界的情况，参考以上代码，理解在 low ..high 范围内的处理方法</li></ul><h4 id="e05.-插入排序单路递归">E05. 插入排序（单路递归）</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">int</span>[] a = {<span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>};</span><br><span class="line">    insertion(a, <span class="number">1</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    System.out.println(Arrays.toString(a));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertion</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> low, <span class="type">int</span> high)</span> {</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[low];</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; a[i] &gt; i) {</span><br><span class="line">        a[i + <span class="number">1</span>] = a[i];</span><br><span class="line">        i--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(i + <span class="number">1</span> != low) {</span><br><span class="line">        a[i + <span class="number">1</span>] = t;</span><br><span class="line">    }    </span><br><span class="line">    insertion(a, low + <span class="number">1</span>, high);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>已排序区域：[0 .. i .. low-1]</li><li>未排序区域：[low .. high]</li><li>视频中讲解的是只考虑 low 边界的情况，参考以上代码，理解 low-1 ..high 范围内的处理方法</li><li>扩展：利用二分查找 leftmost 版本，改进寻找插入位置的代码</li></ul><h4 id="e06.-约瑟夫问题16单路递归">E06. 约瑟夫问题<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>（单路递归）</h4><p><span class="math inline">\(n\)</span>个人排成圆圈，从头开始报数，每次数到第 <span class="math inline">\(m\)</span> 个人（<span class="math inline">\(m\)</span> 从 <span class="math inline">\(1\)</span>开始）杀之，继续从下一个人重复以上过程，求最后活下来的人是谁？</p><p><strong>方法1</strong></p><p>根据最后的存活者 a 倒推出它在上一轮的索引号</p><table><colgroup><col style="width: 9%"><col style="width: 12%"><col style="width: 59%"><col style="width: 17%"></colgroup><thead><tr class="header"><th>f(n,m)</th><th>本轮索引</th><th>为了让 a 是这个索引，上一轮应当这样排</th><th>规律</th></tr></thead><tbody><tr class="odd"><td>f(1,3)</td><td>0</td><td>x x x a</td><td>(0 + 3) % 2</td></tr><tr class="even"><td>f(2,3)</td><td>1</td><td>x x x 0 a</td><td>(1 + 3) % 3</td></tr><tr class="odd"><td>f(3,3)</td><td>1</td><td>x x x 0 a</td><td>(1 + 3) % 4</td></tr><tr class="even"><td>f(4,3)</td><td>0</td><td>x x x a</td><td>(0 + 3) % 5</td></tr><tr class="odd"><td>f(5,3)</td><td>3</td><td>x x x 0 1 2 a</td><td>(3 + 3) % 6</td></tr><tr class="even"><td>f(6,3)</td><td>0</td><td>x x x a</td><td></td></tr></tbody></table><p><strong>方法2</strong></p><p>设 n 为总人数，m 为报数次数，解返回的是这些人的索引，从0开始</p><table><thead><tr class="header"><th>f(n, m)</th><th>解</th><th>规律</th></tr></thead><tbody><tr class="odd"><td>f(1, 3)</td><td>0</td><td></td></tr><tr class="even"><td>f(2, 3)</td><td>0 1 =&gt; 1</td><td>3%2=1</td></tr><tr class="odd"><td>f(3, 3)</td><td>0 1 2 =&gt; 0 1</td><td>3%3=0</td></tr><tr class="even"><td>f(4, 3)</td><td>0 1 2 3 =&gt; 3 0 1</td><td>3%4=3</td></tr><tr class="odd"><td>f(5, 3)</td><td>0 1 2 3 4 =&gt; 3 4 0 1</td><td>3%5=3</td></tr><tr class="even"><td>f(6, 3)</td><td>0 1 2 3 4 5 =&gt; 3 4 5 0 1</td><td>3%6=3</td></tr></tbody></table><p><strong>一. 找出等价函数</strong></p><p>规律：下次报数的起点为 <span class="math inline">\(k = m \%n\)</span></p><ul><li>首次出列人的序号是 <span class="math inline">\(k-1\)</span>，剩下的的 <span class="math inline">\(n-1\)</span> 个人重新组成约瑟夫环</li><li>下次从 <span class="math inline">\(k\)</span> 开始数，序号如下<ul><li><span class="math inline">\(k,\ k+1, \ ...\ ,\ 0,\ 1,\k-2\)</span>，如上例中 <span class="math inline">\(3\ 4\ 5\ 0\1\)</span></li></ul></li></ul><p>这个函数称之为 <span class="math inline">\(g(n-1,m)\)</span>，它的最终结果与 <span class="math inline">\(f(n,m)\)</span> 是相同的。</p><p><strong>二. 找到映射函数</strong></p><p>现在想办法找到 <span class="math inline">\(g(n-1,m)\)</span> 与 <span class="math inline">\(f(n-1, m)\)</span> 的对应关系，即 <span class="math display">\[3 \rightarrow 0 \\4 \rightarrow 1 \\5 \rightarrow 2 \\0 \rightarrow 3 \\1 \rightarrow 4 \\\]</span> 映射函数为 <span class="math display">\[mapping(x) =\begin{cases}x-k &amp; x=[k..n-1] \\x+n-k &amp; x=[0..k-2]\end{cases}\]</span> 等价于下面函数 <span class="math display">\[mapping(x) = (x + n - k)\%{n}\]</span> 代入测试一下 <span class="math display">\[3 \rightarrow (3+6-3)\%6 \rightarrow 0 \\4 \rightarrow (4+6-3)\%6 \rightarrow 1 \\5 \rightarrow (5+6-3)\%6 \rightarrow 2 \\0 \rightarrow (0+6-3)\%6 \rightarrow 3 \\1 \rightarrow (1+6-3)\%6 \rightarrow 4 \\\]</span> 综上有 <span class="math display">\[f(n-1,m) = mapping(g(n-1,m))\]</span></p><p><strong>三. 求逆映射函数</strong></p><p>映射函数是根据 x 计算 y，逆映射函数即根据 y 得到 x <span class="math display">\[mapping^{-1}(x) = (x + k)\%n\]</span> 代入测试一下 <span class="math display">\[0 \rightarrow (0+3)\%6 \rightarrow 3 \\1 \rightarrow (1+3)\%6 \rightarrow 4 \\2 \rightarrow (2+3)\%6 \rightarrow 5 \\3 \rightarrow (3+3)\%6 \rightarrow 0 \\4 \rightarrow (4+3)\%6 \rightarrow 1 \\\]</span> 因此可以求得 <span class="math display">\[g(n-1,m) = mapping^{-1}(f(n-1,m))\]</span></p><p><strong>四. 递推式</strong></p><p>代入推导 <span class="math display">\[\begin{aligned}f(n,m) = \ &amp; g(n-1,m) \\= \ &amp; mapping^{-1}(f(n-1,m)) \\= \ &amp; (f(n-1,m) + k) \% n \\= \ &amp; (f(n-1,m) + m\%n) \% n \\= \ &amp; (f(n-1,m) + m) \% n \\\end{aligned}\]</span> 最后一步化简是利用了模运算法则</p><p><span class="math inline">\((a+b)\%n = (a\%n + b\%n) \%n\)</span>例如</p><ul><li><span class="math inline">\((6+6)\%5 = 2 = (6+6\%5)\%5\)</span></li><li><span class="math inline">\((6+5)\%5 = 1 = (6+5\%5)\%5\)</span></li><li><span class="math inline">\((6+4)\%5 = 0 = (6+4\%5)\%5\)</span></li></ul><p>最终递推式 <span class="math display">\[f(n,m) =\begin{cases}(f(n-1,m) + m) \% n &amp; n&gt;1\\0 &amp; n = 1\end{cases}\]</span></p><h3 id="多路递归-multi-recursion">3) 多路递归 Multi Recursion</h3><h4 id="e01.-斐波那契数列-leetcode-70">E01. 斐波那契数列-Leetcode70</h4><ul><li>之前的例子是每个递归函数只包含一个自身的调用，这称之为 singlerecursion</li><li>如果每个递归函数例包含多个自身调用，称之为 multi recursion</li></ul><p><strong>递推关系</strong> <span class="math display">\[f(n) =\begin{cases}0 &amp; n=0 \\1 &amp; n=1 \\f(n-1) + f(n-2) &amp; n&gt;1\end{cases}\]</span></p><p>下面的表格列出了数列的前几项</p><table><colgroup><col style="width: 6%"><col style="width: 6%"><col style="width: 6%"><col style="width: 6%"><col style="width: 6%"><col style="width: 6%"><col style="width: 6%"><col style="width: 6%"><col style="width: 6%"><col style="width: 6%"><col style="width: 8%"><col style="width: 8%"><col style="width: 8%"><col style="width: 8%"></colgroup><thead><tr class="header"><th><em>F</em>0</th><th><em>F</em>1</th><th><em>F</em>2</th><th><em>F</em>3</th><th><em>F</em>4</th><th><em>F</em>5</th><th><em>F</em>6</th><th><em>F</em>7</th><th><em>F</em>8</th><th><em>F</em>9</th><th><em>F</em>10</th><th><em>F</em>11</th><th><em>F</em>12</th><th><em>F</em>13</th></tr></thead><tbody><tr class="odd"><td>0</td><td>1</td><td>1</td><td>2</td><td>3</td><td>5</td><td>8</td><td>13</td><td>21</td><td>34</td><td>55</td><td>89</td><td>144</td><td>233</td></tr></tbody></table><p><strong>实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>执行流程</strong></p><p><img src="../../../../images/StrJava/2.gif"></p><ul><li>绿色代表正在执行（对应递），灰色代表执行结束（对应归）</li><li>递不到头，不能归，对应着深度优先搜索</li></ul><p><strong>时间复杂度</strong></p><ul><li>递归的次数也符合斐波那契规律，<span class="math inline">\(2 *f(n+1)-1\)</span></li><li>时间复杂度推导过程<ul><li>斐波那契通项公式 <span class="math inline">\(f(n) =\frac{1}{\sqrt{5}}*({\frac{1+\sqrt{5}}{2}}^n -{\frac{1-\sqrt{5}}{2}}^n)\)</span></li><li>简化为：<span class="math inline">\(f(n) =\frac{1}{2.236}*({1.618}^n - {(-0.618)}^n)\)</span></li><li>带入递归次数公式 <span class="math inline">\(2*\frac{1}{2.236}*({1.618}^{n+1} -{(-0.618)}^{n+1})-1\)</span></li><li>时间复杂度为 <span class="math inline">\(\Theta(1.618^n)\)</span></li></ul></li></ul><blockquote><ol type="1"><li>更多 Fibonacci 参考<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a><a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a><a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a></li><li>以上时间复杂度分析，未考虑大数相加的因素</li></ol></blockquote><p><strong>变体1 - 兔子问题<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a></strong></p><figure><img src="../../../../images/StrJava/image-20221110155655827.png" alt="image-20221110155655827"><figcaption aria-hidden="true">image-20221110155655827</figcaption></figure><ul><li>第一个月，有一对未成熟的兔子（黑色，注意图中个头较小）</li><li>第二个月，它们成熟</li><li>第三个月，它们能产下一对新的小兔子（蓝色）</li><li>所有兔子遵循相同规律，求第 <span class="math inline">\(n\)</span>个月的兔子数</li></ul><p><strong>分析</strong></p><p>兔子问题如何与斐波那契联系起来呢？设第 n 个月兔子数为 <span class="math inline">\(f(n)\)</span></p><ul><li><span class="math inline">\(f(n)\)</span> = 上个月兔子数 +新生的小兔子数</li><li>而【新生的小兔子数】实际就是【上个月成熟的兔子数】</li><li>因为需要一个月兔子就成熟，所以【上个月成熟的兔子数】也就是【上上个月的兔子数】</li><li>上个月兔子数，即 <span class="math inline">\(f(n-1)\)</span></li><li>上上个月的兔子数，即 <span class="math inline">\(f(n-2)\)</span></li></ul><p>因此本质还是斐波那契数列，只是从其第一项开始</p><p><strong>变体2 - 青蛙爬楼梯</strong></p><ul><li>楼梯有 <span class="math inline">\(n\)</span> 阶</li><li>青蛙要爬到楼顶，可以一次跳一阶，也可以一次跳两阶</li><li>只能向上跳，问有多少种跳法</li></ul><p><strong>分析</strong></p><table><colgroup><col style="width: 3%"><col style="width: 44%"><col style="width: 52%"></colgroup><thead><tr class="header"><th>n</th><th>跳法</th><th>规律</th></tr></thead><tbody><tr class="odd"><td>1</td><td>(1)</td><td>暂时看不出</td></tr><tr class="even"><td>2</td><td>(1,1) (2)</td><td>暂时看不出</td></tr><tr class="odd"><td>3</td><td>(1,1,1) (1,2) (2,1)</td><td>暂时看不出</td></tr><tr class="even"><td>4</td><td>(1,1,1,1) (1,2,1) (2,1,1)<br>(1,1,2) (2,2)</td><td>最后一跳，跳一个台阶的，基于f(3)<br>最后一跳，跳两个台阶的，基于f(2)</td></tr><tr class="odd"><td>5</td><td>...</td><td>...</td></tr></tbody></table><ul><li><p>因此本质上还是斐波那契数列，只是从其第二项开始</p></li><li><p>对应 leetcode 题目 <a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯 -力扣（LeetCode）</a></p></li></ul><h4 id="e02.-汉诺塔13多路递归">E02. 汉诺塔<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a>（多路递归）</h4><p>Tower ofHanoi，是一个源于印度古老传说：大梵天创建世界时做了三根金刚石柱，在一根柱子从下往上按大小顺序摞着64片黄金圆盘，大梵天命令婆罗门把圆盘重新摆放在另一根柱子上，并且规定</p><ul><li>一次只能移动一个圆盘</li><li>小圆盘上不能放大圆盘</li></ul><p>下面的动图演示了4片圆盘的移动方法</p><p><img src="../../../../images/StrJava/Tower_of_Hanoi_4.gif"></p><p>使用程序代码模拟圆盘的移动过程，并估算出时间复杂度</p><p><strong>思路</strong></p><ul><li><p>假设每根柱子标号 a，b，c，每个圆盘用 1，2，3 ...表示其大小，圆盘初始在 a，要移动到的目标是 c</p></li><li><p>如果只有一个圆盘，此时是最小问题，可以直接求解</p><ul><li>移动圆盘1 <span class="math inline">\(a \mapsto c\)</span></li></ul><p><img src="../../../../images/StrJava/image-20221219090741078.png" alt="image-20221219090741078" style="zoom:50%;"></p></li><li><p>如果有两个圆盘，那么</p><ul><li>圆盘1 <span class="math inline">\(a \mapsto b\)</span></li><li>圆盘2 <span class="math inline">\(a \mapsto c\)</span></li><li>圆盘1 <span class="math inline">\(b \mapsto c\)</span></li></ul><p><img src="../../../../images/StrJava/image-20221219091316225.png" alt="image-20221219091316225" style="zoom:50%;"></p></li><li><p>如果有三个圆盘，那么</p><ul><li>圆盘12 <span class="math inline">\(a \mapsto b\)</span></li><li>圆盘3 <span class="math inline">\(a \mapsto c\)</span></li><li>圆盘12 <span class="math inline">\(b \mapsto c\)</span></li></ul><p><img src="../../../../images/StrJava/image-20221219091930614.png" alt="image-20221219091930614" style="zoom:50%;"></p></li><li><p>如果有四个圆盘，那么</p><ul><li>圆盘 123 <span class="math inline">\(a \mapsto b\)</span></li><li>圆盘4 <span class="math inline">\(a \mapsto c\)</span></li><li>圆盘 123 <span class="math inline">\(b \mapsto c\)</span></li></ul></li></ul><p><img src="../../../../images/StrJava/image-20221219092537323.png" alt="image-20221219092537323" style="zoom:50%;"></p><p><strong>题解</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E02HanoiTower</span> {</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">             源 借 目</span></span><br><span class="line"><span class="comment">        h(4, a, b, c) -&gt; h(3, a, c, b)</span></span><br><span class="line"><span class="comment">                         a -&gt; c</span></span><br><span class="line"><span class="comment">                         h(3, b, a, c)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> LinkedList&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> LinkedList&lt;Integer&gt; b = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> LinkedList&lt;Integer&gt; c = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &gt;= <span class="number">1</span>; i--) {</span><br><span class="line">            a.add(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">h</span><span class="params">(<span class="type">int</span> n, LinkedList&lt;Integer&gt; a, </span></span><br><span class="line"><span class="params">                  LinkedList&lt;Integer&gt; b, </span></span><br><span class="line"><span class="params">                  LinkedList&lt;Integer&gt; c)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        h(n - <span class="number">1</span>, a, c, b);</span><br><span class="line">        c.addLast(a.removeLast());</span><br><span class="line">        print();</span><br><span class="line">        h(n - <span class="number">1</span>, b, a, c);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        init(<span class="number">3</span>);</span><br><span class="line">        print();</span><br><span class="line">        h(<span class="number">3</span>, a, b, c);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e03.-杨辉三角6">E03. 杨辉三角<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a></h4><figure><img src="../../../../images/StrJava/image-20221219172514410.png" alt="image-20221219172514410"><figcaption aria-hidden="true">image-20221219172514410</figcaption></figure><p><strong>分析</strong></p><p>把它斜着看</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">        1</span><br><span class="line">      1   1</span><br><span class="line">    1   2   1</span><br><span class="line">  1   3   3   1</span><br><span class="line">1   4   6   4   1</span><br></pre></td></tr></tbody></table></figure><ul><li>行 <span class="math inline">\(i\)</span>，列 <span class="math inline">\(j\)</span>，那么 <span class="math inline">\([i][j]\)</span> 的取值应为 <span class="math inline">\([i-1][j-1] + [i-1][j]\)</span></li><li>当 <span class="math inline">\(j=0\)</span> 或 <span class="math inline">\(i=j\)</span> 时，<span class="math inline">\([i][j]\)</span> 取值为 <span class="math inline">\(1\)</span></li></ul><p><strong>题解</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>) {</span><br><span class="line">            System.out.printf(<span class="string">"%"</span> + <span class="number">2</span> * (n - <span class="number">1</span> - i) + <span class="string">"s"</span>, <span class="string">" "</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i + <span class="number">1</span>; j++) {</span><br><span class="line">            System.out.printf(<span class="string">"%-4d"</span>, element(i, j));</span><br><span class="line">        }</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">element</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">0</span> || i == j) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> element(i - <span class="number">1</span>, j - <span class="number">1</span>) + element(i - <span class="number">1</span>, j);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>优化1</strong></p><p>是 multiple recursion，因此很多递归调用是重复的，例如</p><ul><li>recursion(3, 1) 分解为<ul><li>recursion(2, 0) + recursion(2, 1)</li></ul></li><li>而 recursion(3, 2) 分解为<ul><li>recursion(2, 1) + recursion(2, 2)</li></ul></li></ul><p>这里 recursion(2, 1) 就重复调用了，事实上它会重复很多次，可以用static AtomicInteger counter = new AtomicInteger(0)来查看递归函数的调用总次数</p><p>事实上，可以用 <strong>memoization</strong> 来进行优化：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print1</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="type">int</span>[][] triangle = <span class="keyword">new</span> <span class="title class_">int</span>[n][];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="comment">// 打印空格</span></span><br><span class="line">        triangle[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= i; j++) {</span><br><span class="line">            System.out.printf(<span class="string">"%-4d"</span>, element1(triangle, i, j));</span><br><span class="line">        }</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">element1</span><span class="params">(<span class="type">int</span>[][] triangle, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">    <span class="keyword">if</span> (triangle[i][j] &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> triangle[i][j];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">0</span> || i == j) {</span><br><span class="line">        triangle[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> triangle[i][j];</span><br><span class="line">    }</span><br><span class="line">    triangle[i][j] = element1(triangle, i - <span class="number">1</span>, j - <span class="number">1</span>) + element1(triangle, i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">return</span> triangle[i][j];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>将数组作为递归函数内可以访问的遍历，如果 <span class="math inline">\(triangle[i][j]\)</span>已经有值，说明该元素已经被之前的递归函数计算过，就不必重复计算了</li></ul><p><strong>优化2</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print2</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="type">int</span>[] row = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="comment">// 打印空格</span></span><br><span class="line">        createRow(row, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= i; j++) {</span><br><span class="line">            System.out.printf(<span class="string">"%-4d"</span>, row[j]);</span><br><span class="line">        }</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createRow</span><span class="params">(<span class="type">int</span>[] row, <span class="type">int</span> i)</span> {</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) {</span><br><span class="line">        row[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span>; j--) {</span><br><span class="line">        row[j] = row[j - <span class="number">1</span>] + row[j];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意：还可以通过每一行的前一项计算出下一项，不必借助上一行，这与杨辉三角的另一个特性有关，暂不展开了</p></blockquote><h4 id="其它题目">其它题目</h4><p>力扣对应题目，但递归不适合在力扣刷高分，因此只列出相关题目，不做刷题讲解了</p><table><thead><tr class="header"><th>题号</th><th>名称</th></tr></thead><tbody><tr class="odd"><td>Leetcode118</td><td>杨辉三角</td></tr><tr class="even"><td>Leetcode119</td><td>杨辉三角II</td></tr><tr class="odd"><td></td><td></td></tr></tbody></table><h3 id="递归优化-记忆法">4) 递归优化-记忆法</h3><p>上述代码存在很多重复的计算，例如求 <span class="math inline">\(f(5)\)</span> 递归分解过程</p><figure><img src="../../../../images/StrJava/image-20221207092417933.png" alt="image-20221207092417933"><figcaption aria-hidden="true">image-20221207092417933</figcaption></figure><p>可以看到（颜色相同的是重复的）：</p><ul><li><span class="math inline">\(f(3)\)</span> 重复了 2 次</li><li><span class="math inline">\(f(2)\)</span> 重复了 3 次</li><li><span class="math inline">\(f(1)\)</span> 重复了 5 次</li><li><span class="math inline">\(f(0)\)</span> 重复了 3 次</li></ul><p>随着 <span class="math inline">\(n\)</span>的增大，重复次数非常可观，如何优化呢？</p><p><strong>Memoization</strong>记忆法（也称备忘录）是一种优化技术，通过存储函数调用结果（通常比较昂贵），当再次出现相同的输入（子问题）时，就能实现加速效果，改进后的代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line">    <span class="type">int</span>[] cache = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(cache, -<span class="number">1</span>);</span><br><span class="line">    cache[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    cache[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    System.out.println(f(cache, n));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] cache, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="keyword">if</span> (cache[n] != -<span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> cache[n];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cache[n] = f(cache, n - <span class="number">1</span>) + f(cache, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> cache[n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>优化后的图示，只要结果被缓存，就<strong>不会执行其子问题</strong></p><figure><img src="../../../../images/StrJava/image-20221213173225807.png" alt="image-20221213173225807"><figcaption aria-hidden="true">image-20221213173225807</figcaption></figure><ul><li>改进后的时间复杂度为 <span class="math inline">\(O(n)\)</span></li><li>请自行验证改进后的效果</li><li>请自行分析改进后的空间复杂度</li></ul><blockquote><p><strong>注意</strong></p><ol type="1"><li>记忆法是动态规划的一种情况，强调的是自顶向下的解决</li><li>记忆法的本质是空间换时间</li></ol></blockquote><h3 id="递归优化-尾递归">5) 递归优化-尾递归</h3><p><strong>爆栈</strong></p><p>用递归做 <span class="math inline">\(n + (n-1) + (n-2) ... +1\)</span></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">long</span> n)</span> {</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> n + sum(n - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在我的机器上 <span class="math inline">\(n = 12000\)</span>时，爆栈了</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Exception in thread "main" java.lang.StackOverflowError</span><br><span class="line">at Test.sum(Test.java:10)</span><br><span class="line">at Test.sum(Test.java:10)</span><br><span class="line">at Test.sum(Test.java:10)</span><br><span class="line">at Test.sum(Test.java:10)</span><br><span class="line">at Test.sum(Test.java:10)</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>为什么呢？</p><ul><li>每次方法调用是需要消耗一定的栈内存的，这些内存用来存储方法参数、方法内局部变量、返回地址等等</li><li>方法调用占用的内存需要等到<strong>方法结束时</strong>才会释放</li><li>而递归调用我们之前讲过，不到最深不会回头，最内层方法没完成之前，外层方法都结束不了<ul><li>例如，<span class="math inline">\(sum(3)\)</span>这个方法内有个需要执行 <span class="math inline">\(3 +sum(2)\)</span>，<span class="math inline">\(sum(2)\)</span>没返回前，加号前面的 <span class="math inline">\(3\)</span>不能释放</li><li>看下面伪码</li></ul></li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">long</span> n = <span class="number">3</span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> + <span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">long</span> n = <span class="number">2</span>)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> + <span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">long</span> n = <span class="number">1</span>)</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>尾调用</strong></p><p>如果函数的最后一步是调用一个函数，那么称为尾调用，例如</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">b</span>()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下面三段代码<strong>不能</strong>叫做尾调用</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">const</span> c = <span class="title function_">b</span>()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>因为最后一步并非调用函数</li></ul><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">b</span>() + <span class="number">1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>最后一步执行的是加法</li></ul><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">x</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">b</span>() + x</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>最后一步执行的是加法</li></ul><p><strong>一些语言</strong><a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a>的编译器能够对尾调用做优化，例如</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="comment">// 做前面的事</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">b</span>() </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="comment">// 做前面的事</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">c</span>()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1000</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="title function_">a</span>()</span><br></pre></td></tr></tbody></table></figure><p>没优化之前的<strong>伪码</strong></p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1000</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>优化后<strong>伪码</strong>如下</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="title function_">a</span>()</span><br><span class="line"><span class="title function_">b</span>()</span><br><span class="line"><span class="title function_">c</span>()</span><br></pre></td></tr></tbody></table></figure><p>为何尾递归才能优化？</p><p>调用 a 时</p><ul><li>a 返回时发现：没什么可留给 b 的，将来返回的结果 b提供就可以了，用不着我 a 了，我的内存就可以释放</li></ul><p>调用 b 时</p><ul><li>b 返回时发现：没什么可留给 c 的，将来返回的结果 c提供就可以了，用不着我 b 了，我的内存就可以释放</li></ul><p>如果调用 a 时</p><ul><li>不是尾调用，例如 return b() + 1，那么 a就不能提前结束，因为它还得利用 b 的结果做加法</li></ul><p><strong>尾递归</strong></p><p>尾递归是尾调用的一种特例，也就是最后一步执行的是同一个函数</p><p><strong>尾递归避免爆栈</strong></p><p>安装 Scala</p><figure><img src="../../../../images/StrJava/image-20221111122709227.png" alt="image-20221111122709227"><figcaption aria-hidden="true">image-20221111122709227</figcaption></figure><p>Scala 入门</p><figure class="highlight scala"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = {</span><br><span class="line">    println(<span class="string">"Hello Scala"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Scala 是 java 的近亲，java 中的类都可以拿来重用</li><li>类型是放在变量后面的</li><li>Unit 表示无返回值，类似于 void</li><li>不需要以分号作为结尾，当然加上也对</li></ul><p>还是先写一个会爆栈的函数</p><figure class="highlight scala"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(n: <span class="type">Long</span>): <span class="type">Long</span> = {</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> n + sum(n - <span class="number">1</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Scala 最后一行代码若作为返回值，可以省略 return</li></ul><p>不出所料，在 <span class="math inline">\(n = 11000\)</span>时，还是出了异常</p><figure class="highlight scala"><table><tbody><tr><td class="code"><pre><span class="line">println(sum(<span class="number">11000</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">Exception</span> in thread <span class="string">"main"</span> java.lang.<span class="type">StackOverflowError</span></span><br><span class="line">at <span class="type">Main</span>$.sum(<span class="type">Main</span>.scala:<span class="number">25</span>)</span><br><span class="line">at <span class="type">Main</span>$.sum(<span class="type">Main</span>.scala:<span class="number">25</span>)</span><br><span class="line">at <span class="type">Main</span>$.sum(<span class="type">Main</span>.scala:<span class="number">25</span>)</span><br><span class="line">at <span class="type">Main</span>$.sum(<span class="type">Main</span>.scala:<span class="number">25</span>)</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>这是因为以上代码，还不是尾调用，要想成为尾调用，那么：</p><ol type="1"><li>最后一行代码，必须是一次函数调用</li><li>内层函数必须<strong>摆脱</strong>与外层函数的关系，内层函数<strong>执行后</strong>不依赖于外层的变量或常量</li></ol><figure class="highlight scala"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(n: <span class="type">Long</span>): <span class="type">Long</span> = {</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> n + sum(n - <span class="number">1</span>)  <span class="comment">// 依赖于外层函数的 n 变量</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如何让它执行后就摆脱对 n 的依赖呢？</p><ul><li>不能等递归回来再做加法，那样就必须保留外层的 n</li><li>把 n 当做内层函数的一个参数传进去，这时 n 就属于内层函数了</li><li>传参时就完成累加, 不必等回来时累加</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sum(n - 1, n + 累加器)</span><br></pre></td></tr></tbody></table></figure><p>改写后代码如下</p><figure class="highlight scala"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@tailrec</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(n: <span class="type">Long</span>, accumulator: <span class="type">Long</span>): <span class="type">Long</span> = {</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + accumulator</span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">return</span> sum(n - <span class="number">1</span>, n + accumulator)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>accumulator 作为累加器</li><li><span class="citation" data-cites="tailrec">@tailrec</span> 注解是scala 提供的，用来检查方法是否符合尾递归</li><li>这回 sum(10000000, 0) 也没有问题，打印 50000005000000</li></ul><p>执行流程如下，以<strong>伪码</strong>表示 <span class="math inline">\(sum(4, 0)\)</span></p><figure class="highlight scala"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 首次调用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(n = <span class="number">4</span>, accumulator = <span class="number">0</span>): <span class="type">Long</span> = {</span><br><span class="line">    <span class="keyword">return</span> sum(<span class="number">4</span> - <span class="number">1</span>, <span class="number">4</span> + accumulator)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来调用内层 sum, 传参时就完成了累加, 不必等回来时累加，当内层 sum 调用后，外层 sum 空间没必要保留</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(n = <span class="number">3</span>, accumulator = <span class="number">4</span>): <span class="type">Long</span> = {</span><br><span class="line">    <span class="keyword">return</span> sum(<span class="number">3</span> - <span class="number">1</span>, <span class="number">3</span> + accumulator)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续调用内层 sum</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(n = <span class="number">2</span>, accumulator = <span class="number">7</span>): <span class="type">Long</span> = {</span><br><span class="line">    <span class="keyword">return</span> sum(<span class="number">2</span> - <span class="number">1</span>, <span class="number">2</span> + accumulator)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续调用内层 sum, 这是最后的 sum 调用完就返回最后结果 10, 前面所有其它 sum 的空间早已释放</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(n = <span class="number">1</span>, accumulator = <span class="number">9</span>): <span class="type">Long</span> = {</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + accumulator</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>本质上，尾递归优化是将函数的<strong>递归</strong>调用，变成了函数的<strong>循环</strong>调用</p><p><strong>改循环避免爆栈</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100000000</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> n; i &gt;= <span class="number">1</span>; i--) {</span><br><span class="line">        sum += i;</span><br><span class="line">    }</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="递归时间复杂度-master-theorem14">6) 递归时间复杂度-Mastertheorem<a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a></h3><p>若有递归式 <span class="math display">\[T(n) = aT(\frac{n}{b}) + f(n)\]</span> 其中</p><ul><li><span class="math inline">\(T(n)\)</span> 是问题的运行时间，<span class="math inline">\(n\)</span> 是数据规模</li><li><span class="math inline">\(a\)</span> 是子问题个数</li><li><span class="math inline">\(T(\frac{n}{b})\)</span>是子问题运行时间，每个子问题被拆成原问题数据规模的 <span class="math inline">\(\frac{n}{b}\)</span></li><li><span class="math inline">\(f(n)\)</span> 是除递归外执行的计算</li></ul><p>令 <span class="math inline">\(x = \log_{b}{a}\)</span>，即 <span class="math inline">\(x = \log_{子问题缩小倍数}{子问题个数}\)</span></p><p>那么 <span class="math display">\[T(n) =\begin{cases}\Theta(n^x) &amp; f(n) = O(n^c) 并且 c \lt x\\\Theta(n^x\log{n}) &amp; f(n) = \Theta(n^x)\\\Theta(n^c) &amp; f(n) = \Omega(n^c) 并且 c \gt x\end{cases}\]</span></p><p><strong>例1</strong></p><p><span class="math inline">\(T(n) = 2T(\frac{n}{2}) + n^4\)</span></p><ul><li>此时 <span class="math inline">\(x = 1 &lt;4\)</span>，由后者决定整个时间复杂度 <span class="math inline">\(\Theta(n^4)\)</span></li><li>如果觉得对数不好算，可以换为求【<span class="math inline">\(b\)</span> 的几次方能等于 <span class="math inline">\(a\)</span>】</li></ul><p><strong>例2</strong></p><p><span class="math inline">\(T(n) = T(\frac{7n}{10}) + n\)</span></p><ul><li><span class="math inline">\(a=1, b=\frac{10}{7}, x=0,c=1\)</span></li><li>此时 <span class="math inline">\(x = 0 &lt;1\)</span>，由后者决定整个时间复杂度 <span class="math inline">\(\Theta(n)\)</span></li></ul><p><strong>例3</strong></p><p><span class="math inline">\(T(n) = 16T(\frac{n}{4}) +n^2\)</span></p><ul><li><span class="math inline">\(a=16, b=4, x=2, c=2\)</span></li><li>此时 <span class="math inline">\(x=2 = c\)</span>，时间复杂度 <span class="math inline">\(\Theta(n^2 \log{n})\)</span></li></ul><p><strong>例4</strong></p><p><span class="math inline">\(T(n)=7T(\frac{n}{3}) + n^2\)</span></p><ul><li><span class="math inline">\(a=7, b=3, x=1.?, c=2\)</span></li><li>此时 <span class="math inline">\(x = \log_{3}{7} &lt;2\)</span>，由后者决定整个时间复杂度 <span class="math inline">\(\Theta(n^2)\)</span></li></ul><p><strong>例5</strong></p><p><span class="math inline">\(T(n) = 7T(\frac{n}{2}) + n^2\)</span></p><ul><li><span class="math inline">\(a=7, b=2, x=2.?, c=2\)</span></li><li>此时 <span class="math inline">\(x = log_2{7} &gt;2\)</span>，由前者决定整个时间复杂度 <span class="math inline">\(\Theta(n^{\log_2{7}})\)</span></li></ul><p><strong>例6</strong></p><p><span class="math inline">\(T(n) = 2T(\frac{n}{4}) +\sqrt{n}\)</span></p><ul><li><span class="math inline">\(a=2, b=4, x = 0.5, c=0.5\)</span></li><li>此时 <span class="math inline">\(x = 0.5 = c\)</span>，时间复杂度<span class="math inline">\(\Theta(\sqrt{n}\ \log{n})\)</span></li></ul><p><strong>例7. 二分查找递归</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">    <span class="keyword">if</span> (i &gt; j) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; a[m]) {</span><br><span class="line">        <span class="keyword">return</span> f(a, target, i, m - <span class="number">1</span>);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) {</span><br><span class="line">        <span class="keyword">return</span> f(a, target, m + <span class="number">1</span>, j);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>子问题个数 <span class="math inline">\(a = 1\)</span></li><li>子问题数据规模缩小倍数 <span class="math inline">\(b =2\)</span></li><li>除递归外执行的计算是常数级 <span class="math inline">\(c=0\)</span></li></ul><p><span class="math inline">\(T(n) = T(\frac{n}{2}) + n^0\)</span></p><ul><li>此时 <span class="math inline">\(x=0 = c\)</span>，时间复杂度 <span class="math inline">\(\Theta(\log{n})\)</span></li></ul><p><strong>例8. 归并排序递归</strong></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">void split(B[], i, j, A[])</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>)                    </span><br><span class="line">        <span class="keyword">return</span>;                                </span><br><span class="line">    m = (i + j) / <span class="number">2</span>;             </span><br><span class="line">    </span><br><span class="line">    // 递归</span><br><span class="line">    split(A, i, m, B);  </span><br><span class="line">    split(A, m, j, B); </span><br><span class="line">    </span><br><span class="line">    // 合并</span><br><span class="line">    merge(B, i, m, j, A);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>子问题个数 <span class="math inline">\(a=2\)</span></li><li>子问题数据规模缩小倍数 <span class="math inline">\(b=2\)</span></li><li>除递归外，主要时间花在合并上，它可以用 <span class="math inline">\(f(n) = n\)</span> 表示</li></ul><p><span class="math inline">\(T(n) = 2T(\frac{n}{2}) + n\)</span></p><ul><li>此时 <span class="math inline">\(x=1=c\)</span>，时间复杂度 <span class="math inline">\(\Theta(n\log{n})\)</span></li></ul><p><strong>例9. 快速排序递归</strong></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">algorithm quicksort(A, lo, hi) <span class="keyword">is</span> </span><br><span class="line">  <span class="keyword">if</span> lo &gt;= hi || lo &lt; <span class="number">0</span> then </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  </span><br><span class="line">  // 分区</span><br><span class="line">  p := partition(A, lo, hi) </span><br><span class="line">  </span><br><span class="line">  // 递归</span><br><span class="line">  quicksort(A, lo, p - <span class="number">1</span>) </span><br><span class="line">  quicksort(A, p + <span class="number">1</span>, hi) </span><br></pre></td></tr></tbody></table></figure><ul><li>子问题个数 <span class="math inline">\(a=2\)</span></li><li>子问题数据规模缩小倍数<ul><li>如果分区分的好，<span class="math inline">\(b=2\)</span></li><li>如果分区没分好，例如分区1 的数据是 0，分区 2 的数据是 <span class="math inline">\(n-1\)</span></li></ul></li><li>除递归外，主要时间花在分区上，它可以用 <span class="math inline">\(f(n) = n\)</span> 表示</li></ul><p>情况1 - 分区分的好</p><p><span class="math inline">\(T(n) = 2T(\frac{n}{2}) + n\)</span></p><ul><li>此时 <span class="math inline">\(x=1=c\)</span>，时间复杂度 <span class="math inline">\(\Theta(n\log{n})\)</span></li></ul><p>情况2 - 分区没分好</p><p><span class="math inline">\(T(n) = T(n-1) + T(1) + n\)</span></p><ul><li>此时不能用主定理求解</li></ul><h3 id="递归时间复杂度-展开求解">7) 递归时间复杂度-展开求解</h3><p>像下面的递归式，都不能用主定理求解</p><p><strong>例1 - 递归求和</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">long</span> n)</span> {</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> n + sum(n - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><span class="math inline">\(T(n) = T(n-1) + c\)</span>，<span class="math inline">\(T(1) = c\)</span></p><p>下面为展开过程</p><p><span class="math inline">\(T(n) = T(n-2) + c + c\)</span></p><p><span class="math inline">\(T(n) = T(n-3) + c + c + c\)</span></p><p>...</p><p><span class="math inline">\(T(n) = T(n-(n-1)) + (n-1)c\)</span></p><ul><li>其中 <span class="math inline">\(T(n-(n-1))\)</span> 即 <span class="math inline">\(T(1)\)</span></li><li>带入求得 <span class="math inline">\(T(n) = c + (n-1)c =nc\)</span></li></ul><p>时间复杂度为 <span class="math inline">\(O(n)\)</span></p><p><strong>例2 - 递归冒泡排序</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> high)</span> {</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == high) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; high; i++) {</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) {</span><br><span class="line">            swap(a, i, i + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    bubble(a, high - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><span class="math inline">\(T(n) = T(n-1) + n\)</span>，<span class="math inline">\(T(1) = c\)</span></p><p>下面为展开过程</p><p><span class="math inline">\(T(n) = T(n-2) + (n-1) + n\)</span></p><p><span class="math inline">\(T(n) = T(n-3) + (n-2) + (n-1) +n\)</span></p><p>...</p><p><span class="math inline">\(T(n) = T(1) + 2 + ... + n = T(1) +(n-1)\frac{2+n}{2} = c + \frac{n^2}{2} + \frac{n}{2} -1\)</span></p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span></p><blockquote><p>注：</p><ul><li>等差数列求和为 <span class="math inline">\(个数*\frac{\vert首项-末项\vert}{2}\)</span></li></ul></blockquote><p><strong>例3 - 递归快排</strong></p><p>快速排序分区没分好的极端情况</p><p><span class="math inline">\(T(n) = T(n-1) + T(1) + n\)</span>，<span class="math inline">\(T(1) = c\)</span></p><p><span class="math inline">\(T(n) = T(n-1) + c + n\)</span></p><p>下面为展开过程</p><p><span class="math inline">\(T(n) = T(n-2) + c + (n-1) + c +n\)</span></p><p><span class="math inline">\(T(n) = T(n-3) + c + (n-2) + c + (n-1) + c+ n\)</span></p><p>...</p><p><span class="math inline">\(T(n) = T(n-(n-1)) + (n-1)c + 2+...+n =\frac{n^2}{2} + \frac{2cn+n}{2} -1\)</span></p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span></p><p>不会推导的同学可以进入 https://www.wolframalpha.com/</p><ul><li>例1 输入 f(n) = f(n - 1) + c, f(1) = c</li><li>例2 输入 f(n) = f(n - 1) + n, f(1) = c</li><li>例3 输入 f(n) = f(n - 1) + n + c, f(1) = c</li></ul><h2 id="队列">2.4 队列</h2><h3 id="概述-3">1) 概述</h3><p>计算机科学中，queue是以顺序的方式维护的一组数据集合，在一端添加数据，从另一端移除数据。习惯来说，添加的一端称为<strong>尾</strong>，移除的一端称为<strong>头</strong>，就如同生活中的排队买商品</p><blockquote><p>In computer science, a <strong>queue</strong> is a collection ofentities that are maintained in a sequence and can be modified by theaddition of entities at one end of the sequence and the removal ofentities from the other end of the sequence</p></blockquote><p>先定义一个简化的队列接口</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Queue</span>&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向队列尾插入值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 待插入值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 插入成功返回 true, 插入失败返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E value)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从对列头获取值, 并移除</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果队列非空返回对头值, 否则返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    E <span class="title function_">poll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从对列头获取值, 不移除</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果队列非空返回对头值, 否则返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    E <span class="title function_">peek</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查队列是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 空返回 true, 否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查队列是否已满</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 满返回 true, 否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="链表实现">2) 链表实现</h3><p>下面以<strong>单向环形带哨兵</strong>链表方式来实现队列</p><figure><img src="../../../../images/StrJava/image-20221230150105089.png" alt="image-20221230150105089"><figcaption aria-hidden="true">image-20221230150105089</figcaption></figure><figure><img src="../../../../images/StrJava/image-20221230150141318.png" alt="image-20221230150141318"><figcaption aria-hidden="true">image-20221230150141318</figcaption></figure><figure><img src="../../../../images/StrJava/image-20221230150153271.png" alt="image-20221230150153271"><figcaption aria-hidden="true">image-20221230150153271</figcaption></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListQueue</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt;, Iterable&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; {</span><br><span class="line">        E value;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E value, Node&lt;E&gt; next)</span> {</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; tail = head;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        tail.next = head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListQueue</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListQueue</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E value)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        Node&lt;E&gt; added = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(value, head);</span><br><span class="line">        tail.next = added;</span><br><span class="line">        tail = added;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        Node&lt;E&gt; first = head.next;</span><br><span class="line">        head.next = first.next;</span><br><span class="line">        <span class="keyword">if</span> (first == tail) {</span><br><span class="line">            tail = head;</span><br><span class="line">        }</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> first.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head.next.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> head == tail;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == capacity;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;E&gt;() {</span><br><span class="line">            Node&lt;E&gt; p = head.next;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> p != head;</span><br><span class="line">            }</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">                <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> p.value;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="环形数组实现">3) 环形数组实现</h3><p><strong>好处</strong></p><ol type="1"><li>对比普通数组，起点和终点更为自由，不用考虑数据移动</li><li>“环”意味着不会存在【越界】问题</li><li>数组性能更佳</li><li>环形数组比较适合实现有界队列、RingBuffer 等</li></ol><figure><img src="../../../../images/StrJava/image-20221228175413998.png" alt="image-20221228175413998"><figcaption aria-hidden="true">image-20221228175413998</figcaption></figure><p><strong>下标计算</strong></p><p>例如，数组长度是 5，当前位置是 3 ，向前走 2 步，此时下标为 <span class="math inline">\((3 + 2)\%5 = 0\)</span></p><figure><img src="../../../../images/StrJava/image-20221228180357257.png" alt="image-20221228180357257"><figcaption aria-hidden="true">image-20221228180357257</figcaption></figure><p><span class="math display">\[(cur + step) \% length\]</span></p><ul><li>cur 当前指针位置</li><li>step 前进步数</li><li>length 数组长度</li></ul><blockquote><p>注意：</p><ul><li>如果 step = 1，也就是一次走一步，可以在 &gt;= length 时重置为 0即可</li></ul></blockquote><p><strong>判断空</strong></p><figure><img src="../../../../images/StrJava/image-20221231081009018.png" alt="image-20221231081009018"><figcaption aria-hidden="true">image-20221231081009018</figcaption></figure><p><strong>判断满</strong></p><figure><img src="../../../../images/StrJava/image-20221231080909475.png" alt="image-20221231080909475"><figcaption aria-hidden="true">image-20221231080909475</figcaption></figure><p>满之后的策略可以根据业务需求决定</p><ul><li>例如我们要实现的环形队列，满之后就拒绝入队</li></ul><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueue</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt;, Iterable&lt;E&gt;{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> E[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings("all")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        length = capacity + <span class="number">1</span>;</span><br><span class="line">        array = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[length];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E value)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        array[tail] = value;</span><br><span class="line">        tail = (tail + <span class="number">1</span>) % length;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> array[head];</span><br><span class="line">        head = (head + <span class="number">1</span>) % length;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> array[head];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> tail == head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> (tail + <span class="number">1</span>) % length == head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;E&gt;() {</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> p != tail;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">                <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> array[p];</span><br><span class="line">                p = (p + <span class="number">1</span>) % array.length;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>判断空、满方法2</strong></p><p>引入 size</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueue2</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt;, Iterable&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> E[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings("all")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue2</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        array = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E value)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        array[tail] = value;</span><br><span class="line">        tail = (tail + <span class="number">1</span>) % capacity;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> array[head];</span><br><span class="line">        head = (head + <span class="number">1</span>) % capacity;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> array[head];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == capacity;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;E&gt;() {</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> p != tail;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">                <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> array[p];</span><br><span class="line">                p = (p + <span class="number">1</span>) % capacity;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>判断空、满方法3</strong></p><ul><li>head 和 tail 不断递增，用到索引时，再用它们进行计算，两个问题<ul><li><p>如何保证 head 和 tail 自增超过正整数最大值的正确性</p></li><li><p>如何让取模运算性能更高</p></li></ul></li><li>答案：让 capacity 为 2 的幂</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueue3</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt;, Iterable&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> E[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings("all")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue3</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        <span class="keyword">if</span> ((capacity &amp; capacity - <span class="number">1</span>) != <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"capacity 必须为 2 的幂"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        array = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="built_in">this</span>.capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E value)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        array[tail &amp; capacity - <span class="number">1</span>] = value;</span><br><span class="line">        tail++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> array[head &amp; capacity - <span class="number">1</span>];</span><br><span class="line">        head++;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> array[head &amp; capacity - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> tail - head == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> tail - head == capacity;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;E&gt;() {</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> p != tail;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">                <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> array[p &amp; capacity - <span class="number">1</span>];</span><br><span class="line">                p++;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="习题-3">习题</h3><h4 id="e01.-二叉树层序遍历-leetcode-102">E01. 二叉树层序遍历-Leetcode102</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        LinkedListQueue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedListQueue</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">// 本层节点个数</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 下层节点个数</span></span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c1; i++) {</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                    c2++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                    c2++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            c1 = c2;</span><br><span class="line">            result.add(level);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义队列</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LinkedListQueue</span>&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; {</span><br><span class="line">            E value;</span><br><span class="line">            Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E value, Node&lt;E&gt; next)</span> {</span><br><span class="line">                <span class="built_in">this</span>.value = value;</span><br><span class="line">                <span class="built_in">this</span>.next = next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;E&gt; head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">private</span> Node&lt;E&gt; tail = head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        {</span><br><span class="line">            tail.next = head;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LinkedListQueue</span><span class="params">()</span> {</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LinkedListQueue</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">            <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E value)</span> {</span><br><span class="line">            <span class="keyword">if</span> (isFull()) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            Node&lt;E&gt; added = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(value, head);</span><br><span class="line">            tail.next = added;</span><br><span class="line">            tail = added;</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line">            Node&lt;E&gt; first = head.next;</span><br><span class="line">            head.next = first.next;</span><br><span class="line">            <span class="keyword">if</span> (first == tail) {</span><br><span class="line">                tail = head;</span><br><span class="line">            }</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> first.value;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> head.next.value;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> head == tail;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> size == capacity;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="ex1.-设计队列-leetcode-622">Ex1. 设计队列-Leetcode 622</h4><p>由于与课堂例题差别不大，这里只给出参考解答</p><p>基于链表的实现</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ex1Leetcode622</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        Node next;</span><br><span class="line">        Node(<span class="type">int</span> value, Node next) {</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">tail</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        tail.next = head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Ex1Leetcode622</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">enQueue</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">        <span class="keyword">if</span>(isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">added</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value, head);</span><br><span class="line">        tail.next = added;</span><br><span class="line">        tail = added;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deQueue</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> head.next;</span><br><span class="line">        head.next = first.next;</span><br><span class="line">        <span class="keyword">if</span> (first == tail) {</span><br><span class="line">            tail = head;</span><br><span class="line">        }</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Front</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head.next.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Rear</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> tail.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> head == tail;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == capacity;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意：</p><ul><li>Leetcode 的实现里deQueue（出队）返回值是布尔值，并不会返回队头元素</li><li>它期望用法是先用 Front 返回对头元素，再 deQueue 出队</li></ul><h2 id="栈">2.5 栈</h2><h3 id="概述-4">1) 概述</h3><p>计算机科学中，<strong>stack</strong>是一种线性的数据结构，只能在其一端添加数据和移除数据。习惯来说，这一端称之为<strong>栈顶</strong>，另一端不能操作数据的称之为<strong>栈底</strong>，就如同生活中的一摞书</p><p>先提供一个栈接口</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Stack</span>&lt;E&gt; {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向栈顶压入元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 待压入值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 压入成功返回 true, 否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">push</span><span class="params">(E value)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从栈顶弹出元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 栈非空返回栈顶元素, 栈为空返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    E <span class="title function_">pop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回栈顶元素, 不弹出</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 栈非空返回栈顶元素, 栈为空返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    E <span class="title function_">peek</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断栈是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 空返回 true, 否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断栈是否已满</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 满返回 true, 否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="链表实现-1">2) 链表实现</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListStack</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Stack</span>&lt;E&gt;, Iterable&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;E&gt; head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListStack</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">push</span><span class="params">(E value)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(value, head.next);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        Node&lt;E&gt; first = head.next;</span><br><span class="line">        head.next = first.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> first.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head.next.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> head.next == <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == capacity;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;E&gt;() {</span><br><span class="line">            Node&lt;E&gt; p = head.next;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> p != <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">                <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> p.value;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; {</span><br><span class="line">        E value;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E value, Node&lt;E&gt; next)</span> {</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="数组实现">3) 数组实现</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayStack</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Stack</span>&lt;E&gt;, Iterable&lt;E&gt;{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> E[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings("all")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        <span class="built_in">this</span>.array = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">push</span><span class="params">(E value)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        array[top++] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> array[--top];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> array[top-<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> top == array.length;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;E&gt;() {</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> top;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> p &gt; <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> array[--p];</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="应用">4) 应用</h3><p>模拟如下方法调用</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    System.out.println(<span class="string">"main1"</span>);</span><br><span class="line">    System.out.println(<span class="string">"main2"</span>);</span><br><span class="line">    method1();</span><br><span class="line">    method2();</span><br><span class="line">    System.out.println(<span class="string">"main3"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> {</span><br><span class="line">    System.out.println(<span class="string">"method1"</span>);</span><br><span class="line">    method3();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> {</span><br><span class="line">    System.out.println(<span class="string">"method2"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> {</span><br><span class="line">    System.out.println(<span class="string">"method3"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>模拟代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CPU</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Frame</span> {</span><br><span class="line">        <span class="type">int</span> exit;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Frame</span><span class="params">(<span class="type">int</span> exit)</span> {</span><br><span class="line">            <span class="built_in">this</span>.exit = exit;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">pc</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 模拟程序计数器 Program counter</span></span><br><span class="line">    <span class="keyword">static</span> ArrayStack&lt;Frame&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayStack</span>&lt;&gt;(<span class="number">100</span>); <span class="comment">// 模拟方法调用栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        stack.push(<span class="keyword">new</span> <span class="title class_">Frame</span>(-<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">            <span class="keyword">switch</span> (pc) {</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span> -&gt; {</span><br><span class="line">                    System.out.println(<span class="string">"main1"</span>);</span><br><span class="line">                    pc++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span> -&gt; {</span><br><span class="line">                    System.out.println(<span class="string">"main2"</span>);</span><br><span class="line">                    pc++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span> -&gt; {</span><br><span class="line">                    stack.push(<span class="keyword">new</span> <span class="title class_">Frame</span>(pc + <span class="number">1</span>));</span><br><span class="line">                    pc = <span class="number">100</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span> -&gt; {</span><br><span class="line">                    stack.push(<span class="keyword">new</span> <span class="title class_">Frame</span>(pc + <span class="number">1</span>));</span><br><span class="line">                    pc = <span class="number">200</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span> -&gt; {</span><br><span class="line">                    System.out.println(<span class="string">"main3"</span>);</span><br><span class="line">                    pc = stack.pop().exit;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">case</span> <span class="number">100</span> -&gt; {</span><br><span class="line">                    System.out.println(<span class="string">"method1"</span>);</span><br><span class="line">                    stack.push(<span class="keyword">new</span> <span class="title class_">Frame</span>(pc + <span class="number">1</span>));</span><br><span class="line">                    pc = <span class="number">300</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">case</span> <span class="number">101</span> -&gt; {</span><br><span class="line">                    pc = stack.pop().exit;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">case</span> <span class="number">200</span> -&gt; {</span><br><span class="line">                    System.out.println(<span class="string">"method2"</span>);</span><br><span class="line">                    pc = stack.pop().exit;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">case</span> <span class="number">300</span> -&gt; {</span><br><span class="line">                    System.out.println(<span class="string">"method3"</span>);</span><br><span class="line">                    pc = stack.pop().exit;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="习题-4">习题</h3><h4 id="e01.-有效的括号-leetcode-20">E01. 有效的括号-Leetcode 20</h4><p>一个字符串中可能出现 <code>[]</code> <code>()</code> 和<code>{}</code> 三种括号，判断该括号是否有效</p><p>有效的例子</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">()[]{}</span><br><span class="line"></span><br><span class="line">([{}])</span><br><span class="line"></span><br><span class="line">()</span><br></pre></td></tr></tbody></table></figure><p>无效的例子</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[)</span><br><span class="line"></span><br><span class="line">([)]</span><br><span class="line"></span><br><span class="line">([]</span><br></pre></td></tr></tbody></table></figure><p>思路</p><ul><li>遇到左括号, 把要配对的右括号放入栈顶</li><li>遇到右括号, 若此时栈为空, 返回 false，否则把它与栈顶元素对比<ul><li>若相等, 栈顶元素弹出, 继续对比下一组</li><li>若不等, 无效括号直接返回 false</li></ul></li><li>循环结束<ul><li>若栈为空, 表示所有括号都配上对, 返回 true</li><li>若栈不为空, 表示右没配对的括号, 应返回 false</li></ul></li></ul><p>答案（用到了课堂案例中的 ArrayStack 类）</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> {</span><br><span class="line">    ArrayStack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayStack</span>&lt;&gt;(s.length() / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) {</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'('</span>) {</span><br><span class="line">            stack.push(<span class="string">')'</span>);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'['</span>) {</span><br><span class="line">            stack.push(<span class="string">']'</span>);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'{'</span>) {</span><br><span class="line">            stack.push(<span class="string">'}'</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; stack.peek() == c) {</span><br><span class="line">                stack.pop();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e02.-后缀表达式求值-leetcode-120">E02. 后缀表达式求值-Leetcode120</h4><p>后缀表达式也称为逆波兰表达式，即运算符写在后面</p><ul><li>从左向右进行计算</li><li>不必考虑运算符优先级，即不用包含括号</li></ul><p>示例</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">输入：tokens = ["2","1","+","3","*"]</span><br><span class="line">输出：9</span><br><span class="line">即：(2 + 1) * 3</span><br><span class="line"></span><br><span class="line">输入：tokens = ["4","13","5","/","+"]</span><br><span class="line">输出：6</span><br><span class="line">即：4 + (13 / 5)</span><br></pre></td></tr></tbody></table></figure><p>题目假设</p><ul><li>数字都视为整数</li><li>数字和运算符个数给定正确，不会有除零发生</li></ul><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> {</span><br><span class="line">    LinkedList&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String t : tokens) {</span><br><span class="line">        <span class="keyword">switch</span> (t) {</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"+"</span> -&gt; {</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> numbers.pop();</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> numbers.pop();</span><br><span class="line">                numbers.push(a + b);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"-"</span> -&gt; {</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> numbers.pop();</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> numbers.pop();</span><br><span class="line">                numbers.push(a - b);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"*"</span> -&gt; {</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> numbers.pop();</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> numbers.pop();</span><br><span class="line">                numbers.push(a * b);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"/"</span> -&gt; {</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> numbers.pop();</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> numbers.pop();</span><br><span class="line">                numbers.push(a / b);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">default</span> -&gt; numbers.push(Integer.parseInt(t));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> numbers.pop();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e03.-中缀表达式转后缀">E03. 中缀表达式转后缀</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E03InfixToSuffix</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        思路</span></span><br><span class="line"><span class="comment">        1. 遇到数字, 拼串</span></span><br><span class="line"><span class="comment">        2. 遇到 + - * /</span></span><br><span class="line"><span class="comment">            - 优先级高于栈顶运算符 入栈</span></span><br><span class="line"><span class="comment">            - 否则将栈中高级或平级运算符出栈拼串, 本运算符入栈</span></span><br><span class="line"><span class="comment">        3. 遍历完成, 栈中剩余运算符出栈拼串</span></span><br><span class="line"><span class="comment">            - 先出栈,意味着优先运算</span></span><br><span class="line"><span class="comment">        4. 带 ()</span></span><br><span class="line"><span class="comment">            - 左括号直接入栈</span></span><br><span class="line"><span class="comment">            - 右括号要将栈中直至左括号为止的运算符出栈拼串</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        |   |</span></span><br><span class="line"><span class="comment">        |   |</span></span><br><span class="line"><span class="comment">        |   |</span></span><br><span class="line"><span class="comment">        _____</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        a+b</span></span><br><span class="line"><span class="comment">        a+b-c</span></span><br><span class="line"><span class="comment">        a+b*c</span></span><br><span class="line"><span class="comment">        a*b+c</span></span><br><span class="line"><span class="comment">        (a+b)*c</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(infixToSuffix(<span class="string">"a+b"</span>));</span><br><span class="line">        System.out.println(infixToSuffix(<span class="string">"a+b-c"</span>));</span><br><span class="line">        System.out.println(infixToSuffix(<span class="string">"a+b*c"</span>));</span><br><span class="line">        System.out.println(infixToSuffix(<span class="string">"a*b-c"</span>));</span><br><span class="line">        System.out.println(infixToSuffix(<span class="string">"(a+b)*c"</span>));</span><br><span class="line">        System.out.println(infixToSuffix(<span class="string">"a+b*c+(d*e+f)*g"</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">infixToSuffix</span><span class="params">(String exp)</span> {</span><br><span class="line">        LinkedList&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(exp.length());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; exp.length(); i++) {</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> exp.charAt(i);</span><br><span class="line">            <span class="keyword">switch</span> (c) {</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>, <span class="string">'-'</span>, <span class="string">'*'</span>, <span class="string">'/'</span> -&gt; {</span><br><span class="line">                    <span class="keyword">if</span> (stack.isEmpty()) {</span><br><span class="line">                        stack.push(c);</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        <span class="keyword">if</span> (priority(c) &gt; priority(stack.peek())) {</span><br><span class="line">                            stack.push(c);</span><br><span class="line">                        } <span class="keyword">else</span> {</span><br><span class="line">                            <span class="keyword">while</span> (!stack.isEmpty() </span><br><span class="line">                                   &amp;&amp; priority(stack.peek()) &gt;= priority(c)) {</span><br><span class="line">                                sb.append(stack.pop());</span><br><span class="line">                            }</span><br><span class="line">                            stack.push(c);</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'('</span> -&gt; {</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span> -&gt; {</span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() != <span class="string">'('</span>) {</span><br><span class="line">                        sb.append(stack.pop());</span><br><span class="line">                    }</span><br><span class="line">                    stack.pop();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">default</span> -&gt; {</span><br><span class="line">                    sb.append(c);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">            sb.append(stack.pop());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">priority</span><span class="params">(<span class="type">char</span> c)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">switch</span> (c) {</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span> -&gt; <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>, <span class="string">'/'</span> -&gt; <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>, <span class="string">'-'</span> -&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"不合法字符:"</span> + c);</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e04.-双栈模拟队列-leetcode-232">E04. 双栈模拟队列-Leetcode232</h4><p>给力扣题目用的<strong>自实现</strong>栈，可以定义为静态内部类</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span>&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> E[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> top; <span class="comment">// 栈顶指针</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings("all")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        <span class="built_in">this</span>.array = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">push</span><span class="params">(E value)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        array[top++] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> array[--top];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> array[top - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> top == array.length;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>参考解答，注意：题目已说明</p><ul><li>调用 push、pop 等方法的次数最多 100</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E04Leetcode232</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        队列头      队列尾</span></span><br><span class="line"><span class="comment">        s1       s2</span></span><br><span class="line"><span class="comment">        顶   底   底   顶</span></span><br><span class="line"><span class="comment">                 abc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        push(a)</span></span><br><span class="line"><span class="comment">        push(b)</span></span><br><span class="line"><span class="comment">        push(c)</span></span><br><span class="line"><span class="comment">        pop()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ArrayStack&lt;Integer&gt; s1 = <span class="keyword">new</span> <span class="title class_">ArrayStack</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">    ArrayStack&lt;Integer&gt; s2 = <span class="keyword">new</span> <span class="title class_">ArrayStack</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        s2.push(x);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (s1.isEmpty()) {</span><br><span class="line">            <span class="keyword">while</span> (!s2.isEmpty()) {</span><br><span class="line">                s1.push(s2.pop());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s1.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (s1.isEmpty()) {</span><br><span class="line">            <span class="keyword">while</span> (!s2.isEmpty()) {</span><br><span class="line">                s1.push(s2.pop());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s1.peek();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> s1.isEmpty() &amp;&amp; s2.isEmpty();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e05.-单队列模拟栈-leetcode-225">E05. 单队列模拟栈-Leetcode225</h4><p>给力扣题目用的<strong>自实现</strong>队列，可以定义为静态内部类</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueue3</span>&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> E[] array;</span><br><span class="line">    <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings("all")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue3</span><span class="params">(<span class="type">int</span> c)</span> {</span><br><span class="line">        c -= <span class="number">1</span>;</span><br><span class="line">        c |= c &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        c |= c &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        c |= c &gt;&gt; <span class="number">4</span>;</span><br><span class="line">        c |= c &gt;&gt; <span class="number">8</span>;</span><br><span class="line">        c |= c &gt;&gt; <span class="number">16</span>;</span><br><span class="line">        c += <span class="number">1</span>;</span><br><span class="line">        array = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[c];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E value)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }        </span><br><span class="line">        array[tail &amp; (array.length - <span class="number">1</span>)] = value;</span><br><span class="line">        tail++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> array[head &amp; (array.length - <span class="number">1</span>)];</span><br><span class="line">        head++;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> array[head &amp; (array.length - <span class="number">1</span>)];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> head == tail;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> tail - head == array.length;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>参考解答，注意：题目已说明</p><ul><li>调用 push、pop 等方法的次数最多 100</li><li>每次调用 pop 和 top 都能保证栈不为空</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E05Leetcode225</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        队列头     队列尾</span></span><br><span class="line"><span class="comment">        cba</span></span><br><span class="line"><span class="comment">        顶           底</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        queue.offer(a)</span></span><br><span class="line"><span class="comment">        queue.offer(b)</span></span><br><span class="line"><span class="comment">        queue.offer(c)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ArrayQueue3&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayQueue3</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">        }</span><br><span class="line">        size++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="双端队列">2.6 双端队列</h2><h3 id="概述-5">1) 概述</h3><p>双端队列、队列、栈对比</p><table><colgroup><col style="width: 20%"><col style="width: 48%"><col style="width: 31%"></colgroup><thead><tr class="header"><th></th><th>定义</th><th>特点</th></tr></thead><tbody><tr class="odd"><td>队列</td><td>一端删除（头）另一端添加（尾）</td><td>First In First Out</td></tr><tr class="even"><td>栈</td><td>一端删除和添加（顶）</td><td>Last In First Out</td></tr><tr class="odd"><td>双端队列</td><td>两端都可以删除、添加</td><td></td></tr><tr class="even"><td>优先级队列</td><td></td><td>优先级高者先出队</td></tr><tr class="odd"><td>延时队列</td><td></td><td>根据延时时间确定优先级</td></tr><tr class="even"><td>并发非阻塞队列</td><td>队列空或满时不阻塞</td><td></td></tr><tr class="odd"><td>并发阻塞队列</td><td>队列空时删除阻塞、队列满时添加阻塞</td><td></td></tr></tbody></table><blockquote><p>注1：</p><ul><li>Java 中 LinkedList 即为典型双端队列实现，不过它同时实现了 Queue接口，也提供了栈的 push pop 等方法</li></ul><p>注2：</p><ul><li><p>不同语言，操作双端队列的方法命名有所不同，参见下表</p><table><thead><tr class="header"><th>操作</th><th>Java</th><th>JavaScript</th><th>C++</th><th>leetCode 641</th></tr></thead><tbody><tr class="odd"><td>尾部插入</td><td>offerLast</td><td>push</td><td>push_back</td><td>insertLast</td></tr><tr class="even"><td>头部插入</td><td>offerFirst</td><td>unshift</td><td>push_front</td><td>insertFront</td></tr><tr class="odd"><td>尾部移除</td><td>pollLast</td><td>pop</td><td>pop_back</td><td>deleteLast</td></tr><tr class="even"><td>头部移除</td><td>pollFirst</td><td>shift</td><td>pop_front</td><td>deleteFront</td></tr><tr class="odd"><td>尾部获取</td><td>peekLast</td><td>at(-1)</td><td>back</td><td>getRear</td></tr><tr class="even"><td>头部获取</td><td>peekFirst</td><td>at(0)</td><td>front</td><td>getFront</td></tr></tbody></table></li><li><p>吐槽一下 leetCode 命名比较 low</p></li><li><p>常见的单词还有 enqueue 入队、dequeue 出队</p></li></ul></blockquote><p><strong>接口定义</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Deque</span>&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    E <span class="title function_">pollFirst</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    E <span class="title function_">pollLast</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    E <span class="title function_">peekFirst</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    E <span class="title function_">peekLast</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="链表实现-2">2) 链表实现</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于环形链表的双端队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt; 元素类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListDeque</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Deque</span>&lt;E&gt;, Iterable&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        size++;</span><br><span class="line">        Node&lt;E&gt; a = sentinel;</span><br><span class="line">        Node&lt;E&gt; b = sentinel.next;</span><br><span class="line">        Node&lt;E&gt; offered = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(a, e, b);</span><br><span class="line">        a.next = offered;</span><br><span class="line">        b.prev = offered;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        size++;</span><br><span class="line">        Node&lt;E&gt; a = sentinel.prev;</span><br><span class="line">        Node&lt;E&gt; b = sentinel;</span><br><span class="line">        Node&lt;E&gt; offered = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(a, e, b);</span><br><span class="line">        a.next = offered;</span><br><span class="line">        b.prev = offered;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        Node&lt;E&gt; a = sentinel;</span><br><span class="line">        Node&lt;E&gt; polled = sentinel.next;</span><br><span class="line">        Node&lt;E&gt; b = polled.next;</span><br><span class="line">        a.next = b;</span><br><span class="line">        b.prev = a;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> polled.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        Node&lt;E&gt; polled = sentinel.prev;</span><br><span class="line">        Node&lt;E&gt; a = polled.prev;</span><br><span class="line">        Node&lt;E&gt; b = sentinel;</span><br><span class="line">        a.next = b;</span><br><span class="line">        b.prev = a;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> polled.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peekFirst</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sentinel.next.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peekLast</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sentinel.prev.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == capacity;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;E&gt;() {</span><br><span class="line">            Node&lt;E&gt; p = sentinel.next;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> p != sentinel;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">                <span class="type">E</span> <span class="variable">value</span> <span class="operator">=</span> p.value;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; {</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        E value;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Node&lt;E&gt; prev, E value, Node&lt;E&gt; next)</span> {</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; sentinel = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListDeque</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        sentinel.next = sentinel;</span><br><span class="line">        sentinel.prev = sentinel;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="数组实现-1">3) 数组实现</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于循环数组实现, 特点</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;tail 停下来的位置不存储, 会浪费一个位置&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDeque1</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Deque</span>&lt;E&gt;, Iterable&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    h</span></span><br><span class="line"><span class="comment">            t</span></span><br><span class="line"><span class="comment">        0   1   2   3</span></span><br><span class="line"><span class="comment">        b           a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        head = dec(head, array.length);</span><br><span class="line">        array[head] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        array[tail] = e;</span><br><span class="line">        tail = inc(tail, array.length);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> array[head];</span><br><span class="line">        array[head] = <span class="literal">null</span>;</span><br><span class="line">        head = inc(head, array.length);</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        tail = dec(tail, array.length);</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> array[tail];</span><br><span class="line">        array[tail] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peekFirst</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> array[head];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peekLast</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> array[dec(tail, array.length)];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> head == tail;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (tail &gt; head) {</span><br><span class="line">            <span class="keyword">return</span> tail - head == array.length - <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (tail &lt; head) {</span><br><span class="line">            <span class="keyword">return</span> head - tail == <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;E&gt;() {</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> p != tail;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> {</span><br><span class="line">                <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> array[p];</span><br><span class="line">                p = inc(p, array.length);</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    E[] array;</span><br><span class="line">    <span class="type">int</span> head;</span><br><span class="line">    <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayDeque1</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        array = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity + <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> length)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= length) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> length)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i - <span class="number">1</span> &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> length - <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>数组实现中，如果存储的是基本类型，那么无需考虑内存释放，例如</p><figure><img src="../../../../images/StrJava/image-20230110084245095.png" alt="image-20230110084245095"><figcaption aria-hidden="true">image-20230110084245095</figcaption></figure><p>但如果存储的是引用类型，应当设置该位置的引用为null，以便内存及时释放</p><figure><img src="../../../../images/StrJava/image-20230110084632543.png" alt="image-20230110084632543"><figcaption aria-hidden="true">image-20230110084632543</figcaption></figure><h3 id="习题-5">习题</h3><h4 id="e01.-二叉树-z-字层序遍历-leetcode-103">E01. 二叉树 Z字层序遍历-Leetcode 103</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E01Leetcode103</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">leftToRight</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            LinkedList&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c1; i++) {</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">n</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (leftToRight) {</span><br><span class="line">                    deque.offerLast(n.val);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    deque.offerFirst(n.val);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (n.left != <span class="literal">null</span>) {</span><br><span class="line">                    queue.offer(n.left);</span><br><span class="line">                    c2++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (n.right != <span class="literal">null</span>) {</span><br><span class="line">                    queue.offer(n.right);</span><br><span class="line">                    c2++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            c1 = c2;</span><br><span class="line">            leftToRight = !leftToRight;</span><br><span class="line">            result.add(deque);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">TreeNode</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">4</span>),</span><br><span class="line">                        <span class="number">2</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">5</span>)</span><br><span class="line">                ),</span><br><span class="line">                <span class="number">1</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">TreeNode</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">6</span>),</span><br><span class="line">                        <span class="number">3</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">7</span>)</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> <span class="title class_">E01Leetcode103</span>().zigzagLevelOrder(root);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : lists) {</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="ex1.-设计双端队列-leetcode-641">Ex1. 设计双端队列-Leetcode641</h4><p>与课堂例题也是差别不大，略</p><h2 id="优先级队列">2.7 优先级队列</h2><h3 id="无序数组实现">1) 无序数组实现</h3><p><strong>要点</strong></p><ol type="1"><li>入队保持顺序</li><li>出队前找到优先级最高的出队，相当于一次选择排序</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueue1</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Priority</span>&gt; <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    Priority[] array;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PriorityQueue1</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        array = <span class="keyword">new</span> <span class="title class_">Priority</span>[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        array[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回优先级最高的索引值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">selectMax</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; size; i++) {</span><br><span class="line">            <span class="keyword">if</span> (array[i].priority() &gt; array[max].priority()) {</span><br><span class="line">                max = i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// O(n)</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> selectMax();</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) array[max];</span><br><span class="line">        remove(max);</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="keyword">if</span> (index &lt; size - <span class="number">1</span>) {</span><br><span class="line">            System.arraycopy(array, index + <span class="number">1</span>,</span><br><span class="line">                    array, index, size - <span class="number">1</span> - index);</span><br><span class="line">        }</span><br><span class="line">        array[--size] = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> selectMax();</span><br><span class="line">        <span class="keyword">return</span> (E) array[max];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == array.length;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>视频中忘记了 help GC，注意一下</li></ul><h3 id="有序数组实现">2) 有序数组实现</h3><p><strong>要点</strong></p><ol type="1"><li>入队后排好序，优先级最高的排列在尾部</li><li>出队只需删除尾部元素即可</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueue2</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Priority</span>&gt; <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    Priority[] array;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PriorityQueue2</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        array = <span class="keyword">new</span> <span class="title class_">Priority</span>[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(n)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        insert(e);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一轮插入排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(E e)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; array[i].priority() &gt; e.priority()) {</span><br><span class="line">            array[i + <span class="number">1</span>] = array[i];</span><br><span class="line">            i--;</span><br><span class="line">        }</span><br><span class="line">        array[i + <span class="number">1</span>] = e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(1)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) array[size - <span class="number">1</span>];</span><br><span class="line">        array[--size] = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> (E) array[size - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == array.length;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="堆实现">3) 堆实现</h3><p>计算机科学中，堆是一种基于树的数据结构，通常用<strong>完全二叉树</strong>实现。堆的特性如下</p><ul><li>在大顶堆中，任意节点 C 与它的父节点 P 符合 <span class="math inline">\(P.value \geq C.value\)</span></li><li>而小顶堆中，任意节点 C 与它的父节点 P 符合 <span class="math inline">\(P.value \leq C.value\)</span></li><li>最顶层的节点（没有父亲）称之为 root 根节点</li></ul><blockquote><p>In computer science, a <strong>heap</strong> is a specializedtree-based data structure which is essentially an almost complete treethat satisfies the <strong>heap property</strong>: in a <em>maxheap</em>, for any given node C, if P is a parent node of C, then the<em>key</em> (the <em>value</em>) of P is greater than or equal to thekey of C. In a <em>min heap</em>, the key of P is less than or equal tothe key of C. The node at the "top" of the heap (with no parents) iscalled the <strong>root</strong> node</p></blockquote><p>例1 - 满二叉树（Full Binary Tree）特点：每一层都是填满的</p><figure><img src="../../../../images/StrJava/image-20230112171444699.png" alt="image-20230112171444699"><figcaption aria-hidden="true">image-20230112171444699</figcaption></figure><p>例2 - 完全二叉树（Complete BinaryTree）特点：最后一层可能未填满，靠左对齐</p><figure><img src="../../../../images/StrJava/image-20230112171917135.png" alt="image-20230112171917135"><figcaption aria-hidden="true">image-20230112171917135</figcaption></figure><p>例3 - 大顶堆</p><figure><img src="../../../../images/StrJava/image-20230112170242265.png" alt="image-20230112170242265"><figcaption aria-hidden="true">image-20230112170242265</figcaption></figure><p>例4 - 小顶堆</p><figure><img src="../../../../images/StrJava/image-20230112171236067.png" alt="image-20230112171236067"><figcaption aria-hidden="true">image-20230112171236067</figcaption></figure><p>完全二叉树可以使用数组来表示</p><figure><img src="../../../../images/StrJava/image-20230112174351649.png" alt="image-20230112174351649"><figcaption aria-hidden="true">image-20230112174351649</figcaption></figure><p>特征</p><ul><li>如果从索引 0 开始存储节点数据<ul><li>节点 <span class="math inline">\(i\)</span> 的父节点为 <span class="math inline">\(floor((i-1)/2)\)</span>，当 <span class="math inline">\(i&gt;0\)</span> 时</li><li>节点 <span class="math inline">\(i\)</span> 的左子节点为 <span class="math inline">\(2i+1\)</span>，右子节点为 <span class="math inline">\(2i+2\)</span>，当然它们得 <span class="math inline">\(&lt; size\)</span></li></ul></li><li>如果从索引 1 开始存储节点数据<ul><li>节点 <span class="math inline">\(i\)</span> 的父节点为 <span class="math inline">\(floor(i/2)\)</span>，当 <span class="math inline">\(i &gt; 1\)</span> 时</li><li>节点 <span class="math inline">\(i\)</span> 的左子节点为 <span class="math inline">\(2i\)</span>，右子节点为 <span class="math inline">\(2i+1\)</span>，同样得 <span class="math inline">\(&lt; size\)</span></li></ul></li></ul><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueue4</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Priority</span>&gt; <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    Priority[] array;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PriorityQueue4</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        array = <span class="keyword">new</span> <span class="title class_">Priority</span>[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E offered)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isFull()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> size++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (child &gt; <span class="number">0</span> &amp;&amp; offered.priority() &gt; array[parent].priority()) {</span><br><span class="line">            array[child] = array[parent];</span><br><span class="line">            child = parent;</span><br><span class="line">            parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">        array[child] = offered;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">Priority</span> <span class="variable">t</span> <span class="operator">=</span> array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = t;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        swap(<span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="type">Priority</span> <span class="variable">e</span> <span class="operator">=</span> array[size];</span><br><span class="line">        array[size] = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        shiftDown(<span class="number">0</span>);        </span><br><span class="line">        <span class="keyword">return</span> (E) e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shiftDown</span><span class="params">(<span class="type">int</span> parent)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> parent;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; size &amp;&amp; array[left].priority() &gt; array[max].priority()) {</span><br><span class="line">            max = left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; array[right].priority() &gt; array[max].priority()) {</span><br><span class="line">            max = right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (max != parent) {</span><br><span class="line">            swap(max, parent);</span><br><span class="line">            shiftDown(max);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> (E) array[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == array.length;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="习题-6">习题</h3><h4 id="e01.-合并多个有序链表-leetcode-23">E01.合并多个有序链表-Leetcode 23</h4><p>这道题目之前解答过，现在用刚学的优先级队列来实现一下</p><p>题目中要从小到大排列，因此选择用小顶堆来实现，自定义小顶堆如下</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinHeap</span> {</span><br><span class="line"></span><br><span class="line">    ListNode[] array;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinHeap</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        array = <span class="keyword">new</span> <span class="title class_">ListNode</span>[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(ListNode offered)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> size++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (child &gt; <span class="number">0</span> &amp;&amp; offered.val &lt; array[parent].val) {</span><br><span class="line">            array[child] = array[parent];</span><br><span class="line">            child = parent;</span><br><span class="line">            parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">        array[child] = offered;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        swap(<span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">e</span> <span class="operator">=</span> array[size];</span><br><span class="line">        array[size] = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line"></span><br><span class="line">        down(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span> parent)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> parent;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; size &amp;&amp; array[left].val &lt; array[min].val) {</span><br><span class="line">            min = left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; array[right].val &lt; array[min].val) {</span><br><span class="line">            min = right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (min != parent) {</span><br><span class="line">            swap(min, parent);</span><br><span class="line">            down(min);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = t;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E01Leetcode23</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> {</span><br><span class="line">        <span class="comment">// 1. 使用 jdk 的优先级队列实现</span></span><br><span class="line"><span class="comment">//        PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;(Comparator.comparingInt(a -&gt; a.val));</span></span><br><span class="line">        <span class="comment">// 2. 使用自定义小顶堆实现</span></span><br><span class="line">        <span class="type">MinHeap</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MinHeap</span>(lists.length);</span><br><span class="line">        <span class="keyword">for</span> (ListNode head : lists) {</span><br><span class="line">            <span class="keyword">if</span> (head != <span class="literal">null</span>) {</span><br><span class="line">                queue.offer(head);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> s;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            p.next = node;</span><br><span class="line">            p = node;</span><br><span class="line">            <span class="keyword">if</span> (node.next != <span class="literal">null</span>) {</span><br><span class="line">                queue.offer(node.next);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>提问：</p><ul><li>能否将每个链表的所有元素全部加入堆，再一个个从堆顶移除？</li></ul><p>回答：</p><ul><li>可以是可以，但对空间占用就高了，堆的一个优点就是用有限的空间做事情</li></ul><h2 id="阻塞队列">2.8 阻塞队列</h2><p>之前的队列在很多场景下都不能很好地工作，例如</p><ol type="1"><li>大部分场景要求分离向队列放入（生产者）、从队列拿出（消费者）两个角色、它们得由不同的线程来担当，而之前的实现根本没有考虑线程安全问题</li><li>队列为空，那么在之前的实现里会返回null，如果就是硬要拿到一个元素呢？只能不断循环尝试</li><li>队列为满，那么再之前的实现里会返回false，如果就是硬要塞入一个元素呢？只能不断循环尝试</li></ol><p>因此我们需要解决的问题有</p><ol type="1"><li>用锁保证线程安全</li><li>用条件变量让<strong>等待非空线程</strong>与<strong>等待不满线程</strong>进入<strong>等待</strong>状态，而不是不断循环尝试，让CPU 空转</li></ol><p>有同学对线程安全还没有足够的认识，下面举一个反例，两个线程都要执行入队操作（几乎在同一时刻）</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadUnsafe</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] array = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(String e)</span> {</span><br><span class="line">        array[tail] = e;</span><br><span class="line">        tail++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(array);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">TestThreadUnsafe</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestThreadUnsafe</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; queue.offer(<span class="string">"e1"</span>), <span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; queue.offer(<span class="string">"e2"</span>), <span class="string">"t2"</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>执行的时间序列如下，假设初始状态 tail = 0，在执行过程中由于 CPU在两个线程之间切换，造成了指令交错</p><table><colgroup><col style="width: 15%"><col style="width: 15%"><col style="width: 68%"></colgroup><thead><tr class="header"><th>线程1</th><th>线程2</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>array[tail]=e1</td><td></td><td>线程1 向 tail 位置加入 e1 这个元素，但还没来得及执行 tail++</td></tr><tr class="even"><td></td><td>array[tail]=e2</td><td>线程2 向 tail 位置加入 e2 这个元素，覆盖掉了 e1</td></tr><tr class="odd"><td></td><td>tail++</td><td>tail 自增为1</td></tr><tr class="even"><td>tail++</td><td></td><td>tail 自增为2</td></tr><tr class="odd"><td></td><td></td><td>最后状态 tail 为 2，数组为 [e2, null, null ...]</td></tr></tbody></table><p>糟糕的是，由于指令交错的顺序不同，得到的结果不止以上一种，宏观上造成混乱的效果</p><h3 id="单锁实现">1) 单锁实现</h3><p>Java 中要防止代码段交错执行，需要使用锁，有两种选择</p><ul><li>synchronized 代码块，属于关键字级别提供锁保护，功能少</li><li>ReentrantLock 类，功能丰富</li></ul><p>以 ReentrantLock 为例</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(String e)</span> {</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        array[tail] = e;</span><br><span class="line">        tail++;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>只要两个线程执行上段代码时，锁对象是同一个，就能保证 try块内的代码的执行不会出现指令交错现象，即执行顺序只可能是下面两种情况之一</p><table><colgroup><col style="width: 22%"><col style="width: 22%"><col style="width: 55%"></colgroup><thead><tr class="header"><th>线程1</th><th>线程2</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>lock.lockInterruptibly()</td><td></td><td>t1对锁对象上锁</td></tr><tr class="even"><td>array[tail]=e1</td><td></td><td></td></tr><tr class="odd"><td></td><td>lock.lockInterruptibly()</td><td>即使 CPU切换到线程2，但由于t1已经对该对象上锁，因此线程2卡在这儿进不去</td></tr><tr class="even"><td>tail++</td><td></td><td>切换回线程1 执行后续代码</td></tr><tr class="odd"><td>lock.unlock()</td><td></td><td>线程1 解锁</td></tr><tr class="even"><td></td><td>array[tail]=e2</td><td>线程2 此时才能获得锁，执行它的代码</td></tr><tr class="odd"><td></td><td>tail++</td><td></td></tr></tbody></table><ul><li>另一种情况是线程2 先获得锁，线程1 被挡在外面</li><li>要明白<strong>保护的本质</strong>，本例中是保护的是 tail位置读写的安全</li></ul><p>事情还没有完，上面的例子是队列还没有放满的情况，考虑下面的代码（这回锁同时保护了tail 和 size 的读写安全）</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(String e)</span> {</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span>(isFull()) {</span><br><span class="line">            <span class="comment">// 满了怎么办?</span></span><br><span class="line">        }</span><br><span class="line">        array[tail] = e;</span><br><span class="line">        tail++;</span><br><span class="line">        </span><br><span class="line">        size++;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> size == array.length;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>之前是返回 false 表示添加失败，前面分析过想达到这么一种效果：</p><ul><li>在队列满时，不是立刻返回，而是当前线程进入等待</li><li>什么时候队列不满了，再唤醒这个等待的线程，从上次的代码处继续向下运行</li></ul><p>ReentrantLock 可以配合条件变量来实现，代码进化为</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">tailWaits</span> <span class="operator">=</span> lock.newCondition(); <span class="comment">// 条件变量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(String e)</span> {</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">while</span> (isFull()) {</span><br><span class="line">            tailWaits.await();<span class="comment">// 当队列满时, 当前线程进入 tailWaits 等待</span></span><br><span class="line">        }</span><br><span class="line">        array[tail] = e;</span><br><span class="line">        tail++;</span><br><span class="line">        </span><br><span class="line">        size++;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> size == array.length;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>条件变量底层也是个队列，用来存储这些需要等待的线程，当队列满了，就会将offer 线程加入条件队列，并暂时释放锁</li><li>将来我们的队列如果不满了（由 poll 线程那边得知）可以调用tailWaits.signal() 来唤醒 tailWaits中首个等待的线程，被唤醒的线程会再次抢到锁，从上次 await处继续向下运行</li></ul><p>思考为何要用 while 而不是 if，设队列容量是 3</p><table><colgroup><col style="width: 7%"><col style="width: 27%"><col style="width: 29%"><col style="width: 27%"><col style="width: 9%"></colgroup><thead><tr class="header"><th>操作前</th><th>offer(4)</th><th>offer(5)</th><th>poll()</th><th>操作后</th></tr></thead><tbody><tr class="odd"><td>[1 2 3]</td><td>队列满，进入tailWaits 等待</td><td></td><td></td><td>[1 2 3]</td></tr><tr class="even"><td>[1 2 3]</td><td></td><td></td><td>取走 1，队列不满，唤醒线程</td><td>[2 3]</td></tr><tr class="odd"><td>[2 3]</td><td></td><td>抢先获得锁，发现不满，放入 5</td><td></td><td>[2 3 5]</td></tr><tr class="even"><td>[2 3 5]</td><td>从上次等待处直接向下执行</td><td></td><td></td><td>[2 3 5 ?]</td></tr></tbody></table><p>关键点：</p><ul><li>从 tailWaits 中唤醒的线程，会与新来的 offer的线程争抢锁，谁能抢到是不一定的，如果后者先抢到，就会导致条件又发生变化</li><li>这种情况称之为<strong>虚假唤醒</strong>，唤醒后应该重新检查条件，看是不是得重新进入等待</li></ul><p>最后的实现代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单锁实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt; 元素类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueue1</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt; {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> E[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings("all")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockingQueue1</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        array = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">tailWaits</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">headWaits</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (isFull()) {</span><br><span class="line">                tailWaits.await();</span><br><span class="line">            }</span><br><span class="line">            array[tail] = e;</span><br><span class="line">            <span class="keyword">if</span> (++tail == array.length) {</span><br><span class="line">                tail = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            size++;</span><br><span class="line">            headWaits.signal();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(E e, <span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> TimeUnit.MILLISECONDS.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (isFull()) {</span><br><span class="line">                <span class="keyword">if</span> (t &lt;= <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">                t = tailWaits.awaitNanos(t);</span><br><span class="line">            }</span><br><span class="line">            array[tail] = e;</span><br><span class="line">            <span class="keyword">if</span> (++tail == array.length) {</span><br><span class="line">                tail = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            size++;</span><br><span class="line">            headWaits.signal();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (isEmpty()) {</span><br><span class="line">                headWaits.await();</span><br><span class="line">            }</span><br><span class="line">            <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> array[head];</span><br><span class="line">            array[head] = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">            <span class="keyword">if</span> (++head == array.length) {</span><br><span class="line">                head = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            size--;</span><br><span class="line">            tailWaits.signal();</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == array.length;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>public void offer(E e, long timeout) throws InterruptedException是带超时的版本，可以只等待一段时间，而不是永久等下去，类似的 poll也可以做带超时的版本，这个留给大家了</li></ul><blockquote><p><strong>注意</strong></p><ul><li>JDK 中 BlockingQueue 接口的方法命名与我的示例有些差异<ul><li>方法 offer(E e) 是非阻塞的实现，阻塞实现方法为 put(E e)</li><li>方法 poll() 是非阻塞的实现，阻塞实现方法为 take()</li></ul></li></ul></blockquote><h3 id="双锁实现">2) 双锁实现</h3><p>单锁的缺点在于：</p><ul><li>生产和消费几乎是不冲突的，唯一冲突的是生产者和消费者它们有可能同时修改size</li><li>冲突的主要是生产者之间：多个 offer 线程修改 tail</li><li>冲突的还有消费者之间：多个 poll 线程修改 head</li></ul><p>如果希望进一步提高性能，可以用两把锁</p><ul><li>一把锁保护 tail</li><li>另一把锁保护 head</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">headLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();  <span class="comment">// 保护 head 的锁</span></span><br><span class="line"><span class="type">Condition</span> <span class="variable">headWaits</span> <span class="operator">=</span> headLock.newCondition(); <span class="comment">// 队列空时，需要等待的线程集合</span></span><br><span class="line"></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">tailLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();  <span class="comment">// 保护 tail 的锁</span></span><br><span class="line"><span class="type">Condition</span> <span class="variable">tailWaits</span> <span class="operator">=</span> tailLock.newCondition(); <span class="comment">// 队列满时，需要等待的线程集合</span></span><br></pre></td></tr></tbody></table></figure><p>先看看 offer 方法的初步实现</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    tailLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 队列满等待</span></span><br><span class="line">        <span class="keyword">while</span> (isFull()) {</span><br><span class="line">            tailWaits.await();</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不满则入队</span></span><br><span class="line">        array[tail] = e;</span><br><span class="line">        <span class="keyword">if</span> (++tail == array.length) {</span><br><span class="line">            tail = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改 size （有问题）</span></span><br><span class="line">        size++;</span><br><span class="line">        </span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        tailLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码的缺点是 size 并不受 tailLock 保护，tailLock 与 headLock是两把不同的锁，并不能实现互斥的效果。因此，size需要用下面的代码保证原子性</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">size</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);   <span class="comment">// 保护 size 的原子变量</span></span><br><span class="line"></span><br><span class="line">size.getAndIncrement(); <span class="comment">// 自增</span></span><br><span class="line">size.getAndDecrement(); <span class="comment">// 自减</span></span><br></pre></td></tr></tbody></table></figure><p>代码修改为</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    tailLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 队列满等待</span></span><br><span class="line">        <span class="keyword">while</span> (isFull()) {</span><br><span class="line">            tailWaits.await();</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不满则入队</span></span><br><span class="line">        array[tail] = e;</span><br><span class="line">        <span class="keyword">if</span> (++tail == array.length) {</span><br><span class="line">            tail = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改 size</span></span><br><span class="line">        size.getAndIncrement();</span><br><span class="line">        </span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        tailLock.unlock();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对称地，可以写出 poll 方法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    E e;</span><br><span class="line">    headLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 队列空等待</span></span><br><span class="line">        <span class="keyword">while</span> (isEmpty()) {</span><br><span class="line">            headWaits.await();</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不空则出队</span></span><br><span class="line">        e = array[head];</span><br><span class="line">        <span class="keyword">if</span> (++head == array.length) {</span><br><span class="line">            head = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改 size</span></span><br><span class="line">        size.getAndDecrement();</span><br><span class="line">        </span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        headLock.unlock();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下面来看一个难题，就是如何通知 headWaits 和 tailWaits中等待的线程，比如 poll 方法拿走一个元素，通知tailWaits：我拿走一个，不满了噢，你们可以放了，因此代码改为</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    E e;</span><br><span class="line">    headLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 队列空等待</span></span><br><span class="line">        <span class="keyword">while</span> (isEmpty()) {</span><br><span class="line">            headWaits.await();</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不空则出队</span></span><br><span class="line">        e = array[head];</span><br><span class="line">        <span class="keyword">if</span> (++head == array.length) {</span><br><span class="line">            head = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改 size</span></span><br><span class="line">        size.getAndDecrement();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 tailWaits 不满（有问题）</span></span><br><span class="line">        tailWaits.signal();</span><br><span class="line">        </span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        headLock.unlock();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>问题在于要使用这些条件变量的 await()， signal()等方法需要先获得与之关联的锁，上面的代码若直接运行会出现以下错误</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">java.lang.IllegalMonitorStateException</span><br></pre></td></tr></tbody></table></figure><p>那有同学说，加上锁不就行了吗，于是写出了下面的代码</p><figure><img src="../../../../images/StrJava/image-20230208160343493.png" alt="image-20230208160343493"><figcaption aria-hidden="true">image-20230208160343493</figcaption></figure><p>发现什么问题了？两把锁这么嵌套使用，非常容易出现死锁，如下所示</p><figure><img src="../../../../images/StrJava/image-20230208160143386.png" alt="image-20230208160143386"><figcaption aria-hidden="true">image-20230208160143386</figcaption></figure><p>因此得避免嵌套，两段加锁的代码变成了下面平级的样子</p><figure><img src="../../../../images/StrJava/image-20230208162857435.png" alt="image-20230208162857435"><figcaption aria-hidden="true">image-20230208162857435</figcaption></figure><p>性能还可以进一步提升</p><ol type="1"><li>代码调整后 offer 并没有同时获取 tailLock 和 headLock两把锁，因此两次加锁之间会有<strong>空隙</strong>，这个空隙内可能有其它的offer 线程添加了更多的元素，那么这些线程都要执行 signal()，通知 poll线程队列非空吗？<ul><li>每次调用 signal() 都需要这些 offer 线程先获得 headLock锁，成本较高，要想法减少 offer 线程获得 headLock 锁的次数</li><li>可以加一个条件：当 offer 增加前队列为空，即从 0 变化到不空，才由此offer 线程来通知 headWaits，其它情况不归它管</li></ul></li><li>队列从 0 变化到不空，会唤醒一个等待的 poll线程，这个线程被唤醒后，肯定能拿到 headLock 锁，因此它具备了唤醒headWaits 上其它 poll 线程的先决条件。如果检查出此时有其它 offer线程新增了元素（不空，但不是从0变化而来），那么不妨由此 poll线程来唤醒其它 poll 线程</li></ol><p>这个技巧被称之为级联通知（cascading notifies），类似的原因</p><ol start="3" type="1"><li>在 poll 时队列从满变化到不满，才由此 poll 线程来唤醒一个等待的 offer线程，目的也是为了减少 poll 线程对 tailLock 上锁次数，剩下等待的 offer线程由这个 offer 线程间接唤醒</li></ol><p>最终的代码为</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueue2</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> E[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">size</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">headLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">headWaits</span> <span class="operator">=</span> headLock.newCondition();</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">tailLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">tailWaits</span> <span class="operator">=</span> tailLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockingQueue2</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        <span class="built_in">this</span>.array = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">        tailLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (isFull()) {</span><br><span class="line">                tailWaits.await();</span><br><span class="line">            }</span><br><span class="line">            array[tail] = e;</span><br><span class="line">            <span class="keyword">if</span> (++tail == array.length) {</span><br><span class="line">                tail = <span class="number">0</span>;</span><br><span class="line">            }            </span><br><span class="line">            c = size.getAndIncrement();</span><br><span class="line">            <span class="comment">// a. 队列不满, 但不是从满-&gt;不满, 由此offer线程唤醒其它offer线程</span></span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; array.length) {</span><br><span class="line">                tailWaits.signal();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            tailLock.unlock();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// b. 从0-&gt;不空, 由此offer线程唤醒等待的poll线程</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) {</span><br><span class="line">            headLock.lock();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                headWaits.signal();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                headLock.unlock();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        E e;</span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">        headLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span> (isEmpty()) {</span><br><span class="line">                headWaits.await(); </span><br><span class="line">            }</span><br><span class="line">            e = array[head]; </span><br><span class="line">            <span class="keyword">if</span> (++head == array.length) {</span><br><span class="line">                head = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            c = size.getAndDecrement();</span><br><span class="line">            <span class="comment">// b. 队列不空, 但不是从0变化到不空，由此poll线程通知其它poll线程</span></span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>) {</span><br><span class="line">                headWaits.signal();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            headLock.unlock();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// a. 从满-&gt;不满, 由此poll线程唤醒等待的offer线程</span></span><br><span class="line">        <span class="keyword">if</span> (c == array.length) {</span><br><span class="line">            tailLock.lock();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                tailWaits.signal();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                tailLock.unlock();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size.get() == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size.get() == array.length;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>双锁实现的非常精巧，据说作者 Doug Lea花了一年的时间才完善了此段代码</p><h2 id="堆">2.9 堆</h2><p>以大顶堆为例，相对于之前的优先级队列，增加了堆化等方法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxHeap</span> {</span><br><span class="line">    <span class="type">int</span>[] array;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxHeap</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        <span class="built_in">this</span>.array = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取堆顶元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 堆顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除堆顶元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 堆顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        swap(<span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">        size--;</span><br><span class="line">        down(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定索引处元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 被删除元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">deleted</span> <span class="operator">=</span> array[index];</span><br><span class="line">        up(Integer.MAX_VALUE, index);</span><br><span class="line">        poll();</span><br><span class="line">        <span class="keyword">return</span> deleted;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 替换堆顶元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replaced 新元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replace</span><span class="params">(<span class="type">int</span> replaced)</span> {</span><br><span class="line">        array[<span class="number">0</span>] = replaced;</span><br><span class="line">        down(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆的尾部添加元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offered 新元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(<span class="type">int</span> offered)</span> {</span><br><span class="line">        <span class="keyword">if</span> (size == array.length) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        up(offered, size);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 offered 元素上浮: 直至 offered 小于父元素或到堆顶</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">up</span><span class="params">(<span class="type">int</span> offered, <span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> index;</span><br><span class="line">        <span class="keyword">while</span> (child &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (offered &gt; array[parent]) {</span><br><span class="line">                array[child] = array[parent];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            child = parent;</span><br><span class="line">        }</span><br><span class="line">        array[child] = offered;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxHeap</span><span class="params">(<span class="type">int</span>[] array)</span> {</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.size = array.length;</span><br><span class="line">        heapify();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建堆</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 如何找到最后这个非叶子节点  size / 2 - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            down(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 parent 索引处的元素下潜: 与两个孩子较大者交换, 直至没孩子或孩子没它大</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span> parent)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> parent;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; size &amp;&amp; array[left] &gt; array[max]) {</span><br><span class="line">            max = left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; array[right] &gt; array[max]) {</span><br><span class="line">            max = right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (max != parent) { <span class="comment">// 找到了更大的孩子</span></span><br><span class="line">            swap(max, parent);</span><br><span class="line">            down(max);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换两个索引处的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = t;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] array = {<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">        <span class="type">MaxHeap</span> <span class="variable">heap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MaxHeap</span>(array);</span><br><span class="line">        System.out.println(Arrays.toString(heap.array));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (heap.size &gt; <span class="number">1</span>) {</span><br><span class="line">            heap.swap(<span class="number">0</span>, heap.size - <span class="number">1</span>);</span><br><span class="line">            heap.size--;</span><br><span class="line">            heap.down(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(heap.array));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="建堆">建堆</h3><p>Floyd 建堆算法作者（也是之前龟兔赛跑判环作者）：</p><figure><img src="../../../../images/StrJava/image-20230213095110902.png" alt="image-20230213095110902"><figcaption aria-hidden="true">image-20230213095110902</figcaption></figure><ol type="1"><li>找到最后一个非叶子节点</li><li>从后向前，对每个节点执行下潜</li></ol><p>一些规律</p><ul><li>一棵满二叉树节点个数为 <span class="math inline">\(2^h-1\)</span>，如下例中高度 <span class="math inline">\(h=3\)</span> 节点数是 <span class="math inline">\(2^3-1=7\)</span></li><li>非叶子节点范围为 <span class="math inline">\([0,size/2-1]\)</span></li></ul><p>算法时间复杂度分析</p><figure><img src="../../../../images/StrJava/image-20230213114024607.png" alt="image-20230213114024607"><figcaption aria-hidden="true">image-20230213114024607</figcaption></figure><p>下面看交换次数的推导：设节点高度为 3</p><table><thead><tr class="header"><th></th><th>本层节点数</th><th>高度</th><th>下潜最多交换次数（高度-1）</th></tr></thead><tbody><tr class="odd"><td>4567 这层</td><td>4</td><td>1</td><td>0</td></tr><tr class="even"><td>23这层</td><td>2</td><td>2</td><td>1</td></tr><tr class="odd"><td>1这层</td><td>1</td><td>3</td><td>2</td></tr></tbody></table>每一层的交换次数为：<span class="math inline">\(节点个数*此节点交换次数\)</span>，总的交换次数为$$<span class="math display">\[\begin{aligned}&amp; 4 * 0 + 2 * 1 + 1 * 2 \\&amp; \frac{8}{2}*0 + \frac{8}{4}*1 + \frac{8}{8}*2 \\&amp; \frac{8}{2^1}*0 + \frac{8}{2^2}*1 + \frac{8}{2^3}*2\\\end{aligned}\]</span><p><span class="math display">\[即\]</span> _{i=1}^{h}(*(i-1)) $$ 在 https://www.wolframalpha.com/输入</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Sum[\(40)Divide[Power[2,x],Power[2,i]]*\(40)i-1\(41)\(41),{i,1,x}]</span><br></pre></td></tr></tbody></table></figure><p>推导出 <span class="math display">\[2^h -h -1\]</span> 其中 <span class="math inline">\(2^h \approx n\)</span>，<span class="math inline">\(h \approx \log_2{n}\)</span>，因此有时间复杂度<span class="math inline">\(O(n)\)</span></p><h3 id="习题-7">习题</h3><h4 id="e01.-堆排序">E01. 堆排序</h4><p>算法描述</p><ol type="1"><li>heapify 建立大顶堆</li><li>将堆顶与堆底交换（最大元素被交换到堆底），缩小并下潜调整堆</li><li>重复第二步直至堆里剩一个元素</li></ol><p>可以使用之前课堂例题的大顶堆来实现</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>};</span><br><span class="line"><span class="type">MaxHeap</span> <span class="variable">maxHeap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MaxHeap</span>(array);</span><br><span class="line">System.out.println(Arrays.toString(maxHeap.array));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (maxHeap.size &gt; <span class="number">1</span>) {</span><br><span class="line">    maxHeap.swap(<span class="number">0</span>, maxHeap.size - <span class="number">1</span>);</span><br><span class="line">    maxHeap.size--;</span><br><span class="line">    maxHeap.down(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line">System.out.println(Arrays.toString(maxHeap.array));</span><br></pre></td></tr></tbody></table></figure><h4 id="e02.-数组中第k大元素-leetcode-215">E02. 数组中第K大元素-Leetcode215</h4><p>小顶堆（可删去用不到代码）</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinHeap</span> {</span><br><span class="line">    <span class="type">int</span>[] array;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinHeap</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">        array = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (size &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            down(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        swap(<span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">        size--;</span><br><span class="line">        down(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> array[size];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        swap(index, size - <span class="number">1</span>);</span><br><span class="line">        size--;</span><br><span class="line">        down(index);</span><br><span class="line">        <span class="keyword">return</span> array[size];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(<span class="type">int</span> offered)</span> {</span><br><span class="line">        <span class="keyword">if</span> (size == array.length) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        up(offered);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replace</span><span class="params">(<span class="type">int</span> replaced)</span> {</span><br><span class="line">        array[<span class="number">0</span>] = replaced;</span><br><span class="line">        down(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">up</span><span class="params">(<span class="type">int</span> offered)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="keyword">while</span> (child &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (child - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (offered &lt; array[parent]) {</span><br><span class="line">                array[child] = array[parent];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            child = parent;</span><br><span class="line">        }</span><br><span class="line">        array[child] = offered;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span> parent)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> (parent &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> parent;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; size &amp;&amp; array[left] &lt; array[min]) {</span><br><span class="line">            min = left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; array[right] &lt; array[min]) {</span><br><span class="line">            min = right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (min != parent) {</span><br><span class="line">            swap(min, parent);</span><br><span class="line">            down(min);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换两个索引处的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = t;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>题解</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] numbers, <span class="type">int</span> k)</span> {</span><br><span class="line">    <span class="type">MinHeap</span> <span class="variable">heap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MinHeap</span>(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) {</span><br><span class="line">        heap.offer(numbers[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; numbers.length; i++) {</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] &gt; heap.peek()){</span><br><span class="line">            heap.replace(numbers[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> heap.peek();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>求数组中的第 K 大元素，使用堆并不是最佳选择，可以采用快速选择算法</p></blockquote><h4 id="e03.-数据流中第k大元素-leetcode-703">E03.数据流中第K大元素-Leetcode 703</h4><p>上题的小顶堆加一个方法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinHeap</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size == array.length;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>题解</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MinHeap heap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">KthLargest</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] nums)</span> {</span><br><span class="line">        heap = <span class="keyword">new</span> <span class="title class_">MinHeap</span>(k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            add(nums[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="keyword">if</span>(!heap.isFull()){</span><br><span class="line">            heap.offer(val);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(val &gt; heap.peek()){</span><br><span class="line">            heap.replace(val);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> heap.peek();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>求数据流中的第 K 大元素，使用堆最合适不过</p></blockquote><h4 id="e04.-数据流的中位数-leetcode-295">E04. 数据流的中位数-Leetcode295</h4><p>可以扩容的 heap, max 用于指定是大顶堆还是小顶堆</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heap</span> {</span><br><span class="line">    <span class="type">int</span>[] array;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">boolean</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> max)</span> {</span><br><span class="line">        <span class="built_in">this</span>.array = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">        <span class="built_in">this</span>.max = max;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取堆顶元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 堆顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除堆顶元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 堆顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        swap(<span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">        size--;</span><br><span class="line">        down(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定索引处元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 被删除元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">deleted</span> <span class="operator">=</span> array[index];</span><br><span class="line">        swap(index, size - <span class="number">1</span>);</span><br><span class="line">        size--;</span><br><span class="line">        down(index);</span><br><span class="line">        <span class="keyword">return</span> deleted;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 替换堆顶元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replaced 新元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replace</span><span class="params">(<span class="type">int</span> replaced)</span> {</span><br><span class="line">        array[<span class="number">0</span>] = replaced;</span><br><span class="line">        down(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆的尾部添加元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offered 新元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(<span class="type">int</span> offered)</span> {</span><br><span class="line">        <span class="keyword">if</span> (size == array.length) {</span><br><span class="line">            grow();</span><br><span class="line">        }</span><br><span class="line">        up(offered);</span><br><span class="line">        size++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> size + (size &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span>[] newArray = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>,</span><br><span class="line">                newArray, <span class="number">0</span>, size);</span><br><span class="line">        array = newArray;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 offered 元素上浮: 直至 offered 小于父元素或到堆顶</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">up</span><span class="params">(<span class="type">int</span> offered)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="keyword">while</span> (child &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">cmp</span> <span class="operator">=</span> max ? offered &gt; array[parent] : offered &lt; array[parent];</span><br><span class="line">            <span class="keyword">if</span> (cmp) {</span><br><span class="line">                array[child] = array[parent];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            child = parent;</span><br><span class="line">        }</span><br><span class="line">        array[child] = offered;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">boolean</span> max)</span> {</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.size = array.length;</span><br><span class="line">        <span class="built_in">this</span>.max = max;</span><br><span class="line">        heapify();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建堆</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 如何找到最后这个非叶子节点  size / 2 - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            down(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 parent 索引处的元素下潜: 与两个孩子较大者交换, 直至没孩子或孩子没它大</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span> parent)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> parent;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; size &amp;&amp; (max ? array[left] &gt; array[min] : array[left] &lt; array[min])) {</span><br><span class="line">            min = left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; (max ? array[right] &gt; array[min] : array[right] &lt; array[min])) {</span><br><span class="line">            min = right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (min != parent) { <span class="comment">// 找到了更大的孩子</span></span><br><span class="line">            swap(min, parent);</span><br><span class="line">            down(min);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换两个索引处的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = t;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>题解</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Heap</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Heap</span>(<span class="number">10</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="type">Heap</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Heap</span>(<span class="number">10</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 为了保证两边数据量的平衡</span></span><br><span class="line"><span class="comment"> &lt;ul&gt;</span></span><br><span class="line"><span class="comment">  &lt;li&gt;两边数据一样时,加入左边&lt;/li&gt;</span></span><br><span class="line"><span class="comment">  &lt;li&gt;两边数据不一样时,加入右边&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> 但是, 随便一个数能直接加入吗?</span></span><br><span class="line"><span class="comment"> &lt;ul&gt;</span></span><br><span class="line"><span class="comment">  &lt;li&gt;加入左边前, 应该挑右边最小的加入&lt;/li&gt;</span></span><br><span class="line"><span class="comment">  &lt;li&gt;加入右边前, 应该挑左边最大的加入&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> {</span><br><span class="line">    <span class="keyword">if</span> (left.size() == right.size()) {</span><br><span class="line">        right.offer(num);</span><br><span class="line">        left.offer(right.poll());</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        left.offer(num);</span><br><span class="line">        right.offer(left.poll());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;两边数据一致, 左右各取堆顶元素求平均&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;左边多一个, 取左边元素&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (left.size() == right.size()) {</span><br><span class="line">        <span class="keyword">return</span> (left.peek() + right.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> left.peek();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>本题还可以使用平衡二叉搜索树求解，不过代码比两个堆复杂</p></blockquote><h2 id="二叉树">2.10 二叉树</h2><p>二叉树是这么一种树状结构：每个节点最多有两个孩子，左孩子和右孩子</p><p>重要的二叉树结构</p><ul><li>完全二叉树（complete binarytree）是一种二叉树结构，除最后一层以外，每一层都必须填满，填充时要遵从先左后右</li><li>平衡二叉树（balance binarytree）是一种二叉树结构，其中每个节点的左右子树高度相差不超过 1</li></ul><h3 id="存储">1) 存储</h3><p>存储方式分为两种</p><ol type="1"><li>定义树节点与左、右孩子引用（TreeNode）</li><li>使用数组，前面讲堆时用过，若以 0作为树的根，索引可以通过如下方式计算<ul><li>父 = floor((子 - 1) / 2)</li><li>左孩子 = 父 * 2 + 1</li><li>右孩子 = 父 * 2 + 2</li></ul></li></ol><h3 id="遍历">2) 遍历</h3><p>遍历也分为两种</p><ol type="1"><li>广度优先遍历（Breadth-firstorder）：尽可能先访问距离根最近的节点，也称为层序遍历</li><li>深度优先遍历（Depth-firstorder）：对于二叉树，可以进一步分成三种（要深入到叶子节点）<ol type="1"><li>pre-order前序遍历，对于每一棵子树，先访问该节点，然后是左子树，最后是右子树</li><li>in-order中序遍历，对于每一棵子树，先访问左子树，然后是该节点，最后是右子树</li><li>post-order后序遍历，对于每一棵子树，先访问左子树，然后是右子树，最后是该节点</li></ol></li></ol><h4 id="广度优先">广度优先</h4><figure><img src="../../../../images/StrJava/image-20230216153607396.png" alt="image-20230216153607396"><figcaption aria-hidden="true">image-20230216153607396</figcaption></figure><table><thead><tr class="header"><th>本轮开始时队列</th><th>本轮访问节点</th></tr></thead><tbody><tr class="odd"><td>[1]</td><td>1</td></tr><tr class="even"><td>[2, 3]</td><td>2</td></tr><tr class="odd"><td>[3, 4]</td><td>3</td></tr><tr class="even"><td>[4, 5, 6]</td><td>4</td></tr><tr class="odd"><td>[5, 6]</td><td>5</td></tr><tr class="even"><td>[6, 7, 8]</td><td>6</td></tr><tr class="odd"><td>[7, 8]</td><td>7</td></tr><tr class="even"><td>[8]</td><td>8</td></tr><tr class="odd"><td>[]</td><td></td></tr></tbody></table><ol type="1"><li>初始化，将根节点加入队列</li><li>循环处理队列中每个节点，直至队列为空</li><li>每次循环内处理节点后，将它的孩子节点（即下一层的节点）加入队列</li></ol><blockquote><p>注意</p><ul><li><p>以上用队列来层序遍历是针对 TreeNode 这种方式表示的二叉树</p></li><li><p>对于数组表现的二叉树，则直接遍历数组即可，自然为层序遍历的顺序</p></li></ul></blockquote><h4 id="深度优先">深度优先</h4><figure><img src="../../../../images/StrJava/image-20230221110443230.png" alt="image-20230221110443230"><figcaption aria-hidden="true">image-20230221110443230</figcaption></figure><table><colgroup><col style="width: 13%"><col style="width: 62%"><col style="width: 11%"><col style="width: 11%"></colgroup><thead><tr class="header"><th>栈暂存</th><th>已处理</th><th>前序遍历</th><th>中序遍历</th></tr></thead><tbody><tr class="odd"><td>[1]</td><td>1 ✔️ 左💤 右💤</td><td>1</td><td></td></tr><tr class="even"><td>[1, 2]</td><td>2✔️ 左💤 右💤<br>1✔️ 左💤 右💤</td><td>2</td><td></td></tr><tr class="odd"><td>[1, 2, 4]</td><td>4✔️ 左✔️ 右✔️<br>2✔️ 左💤 右💤<br>1✔️ 左💤 右💤</td><td>4</td><td>4</td></tr><tr class="even"><td>[1, 2]</td><td>2✔️ 左✔️ 右✔️<br>1✔️ 左💤 右💤</td><td></td><td>2</td></tr><tr class="odd"><td>[1]</td><td>1✔️ 左✔️ 右💤</td><td></td><td>1</td></tr><tr class="even"><td>[1, 3]</td><td>3✔️ 左💤 右💤<br>1✔️ 左✔️ 右💤</td><td>3</td><td></td></tr><tr class="odd"><td>[1, 3, 5]</td><td>5✔️ 左✔️ 右✔️<br>3✔️ 左💤 右💤<br>1✔️ 左✔️ 右💤</td><td>5</td><td>5</td></tr><tr class="even"><td>[1, 3]</td><td>3✔️ 左✔️ 右💤<br>1✔️ 左✔️ 右💤</td><td></td><td>3</td></tr><tr class="odd"><td>[1, 3, 6]</td><td>6✔️ 左✔️ 右✔️<br>3✔️ 左✔️ 右💤<br>1✔️ 左✔️ 右💤</td><td>6</td><td>6</td></tr><tr class="even"><td>[1, 3]</td><td>3✔️ 左✔️ 右✔️<br>1✔️ 左✔️ 右💤</td><td></td><td></td></tr><tr class="odd"><td>[1]</td><td>1✔️ 左✔️ 右✔️</td><td></td><td></td></tr><tr class="even"><td>[]</td><td></td><td></td><td></td></tr></tbody></table><h4 id="递归实现">递归实现</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;前序遍历&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode node)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    System.out.print(node.val + <span class="string">"\t"</span>); <span class="comment">// 值</span></span><br><span class="line">    preOrder(node.left); <span class="comment">// 左</span></span><br><span class="line">    preOrder(node.right); <span class="comment">// 右</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;中序遍历&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode node)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    inOrder(node.left); <span class="comment">// 左</span></span><br><span class="line">    System.out.print(node.val + <span class="string">"\t"</span>); <span class="comment">// 值</span></span><br><span class="line">    inOrder(node.right); <span class="comment">// 右</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;后序遍历&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode node)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    postOrder(node.left); <span class="comment">// 左</span></span><br><span class="line">    postOrder(node.right); <span class="comment">// 右</span></span><br><span class="line">    System.out.print(node.val + <span class="string">"\t"</span>); <span class="comment">// 值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="非递归实现">非递归实现</h4><p><strong>前序遍历</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">LinkedListStack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedListStack</span>&lt;&gt;();</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty() || curr != <span class="literal">null</span>) {</span><br><span class="line">    <span class="keyword">if</span> (curr != <span class="literal">null</span>) {</span><br><span class="line">        stack.push(curr);</span><br><span class="line">        System.out.println(curr);</span><br><span class="line">        curr = curr.left;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        curr = pop.right;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>中序遍历</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">LinkedListStack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedListStack</span>&lt;&gt;();</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty() || curr != <span class="literal">null</span>) {</span><br><span class="line">    <span class="keyword">if</span> (curr != <span class="literal">null</span>) {</span><br><span class="line">        stack.push(curr);</span><br><span class="line">        curr = curr.left;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        System.out.println(pop);</span><br><span class="line">        curr = pop.right;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>后序遍历</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">LinkedListStack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedListStack</span>&lt;&gt;();</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty() || curr != <span class="literal">null</span>) {</span><br><span class="line">    <span class="keyword">if</span> (curr != <span class="literal">null</span>) {</span><br><span class="line">        stack.push(curr);</span><br><span class="line">        curr = curr.left;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">peek</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">        <span class="keyword">if</span> (peek.right == <span class="literal">null</span> || peek.right == pop) {</span><br><span class="line">            pop = stack.pop();</span><br><span class="line">            System.out.println(pop);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            curr = peek.right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于后序遍历，向回走时，需要处理完右子树才能 pop出栈。如何知道右子树处理完成呢？</p><ul><li><p>如果栈顶元素的 <span class="math inline">\(right \equivnull\)</span> 表示没啥可处理的，可以出栈</p></li><li><p>如果栈顶元素的 <span class="math inline">\(right \neqnull\)</span>，</p><ul><li>那么使用 lastPop 记录最近出栈的节点，即表示从这个节点向回走</li><li>如果栈顶元素的 <span class="math inline">\(right==lastPop\)</span>此时应当出栈</li></ul></li></ul><p>对于前、中两种遍历，实际以上代码从右子树向回走时，并未走完全程（stack提前出栈了）后序遍历以上代码是走完全程了</p><p><strong>统一写法</strong></p><p>下面是一种统一的写法，依据后序遍历修改</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root; <span class="comment">// 代表当前节点</span></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 最近一次弹栈的元素</span></span><br><span class="line"><span class="keyword">while</span> (curr != <span class="literal">null</span> || !stack.isEmpty()) {</span><br><span class="line">    <span class="keyword">if</span> (curr != <span class="literal">null</span>) {</span><br><span class="line">        colorPrintln(<span class="string">"前: "</span> + curr.val, <span class="number">31</span>);</span><br><span class="line">        stack.push(curr); <span class="comment">// 压入栈，为了记住回来的路</span></span><br><span class="line">        curr = curr.left;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">peek</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">        <span class="comment">// 右子树可以不处理, 对中序来说, 要在右子树处理之前打印</span></span><br><span class="line">        <span class="keyword">if</span> (peek.right == <span class="literal">null</span>) {</span><br><span class="line">            colorPrintln(<span class="string">"中: "</span> + peek.val, <span class="number">36</span>);</span><br><span class="line">            pop = stack.pop();</span><br><span class="line">            colorPrintln(<span class="string">"后: "</span> + pop.val, <span class="number">34</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 右子树处理完成, 对中序来说, 无需打印</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (peek.right == pop) {</span><br><span class="line">            pop = stack.pop();</span><br><span class="line">            colorPrintln(<span class="string">"后: "</span> + pop.val, <span class="number">34</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 右子树待处理, 对中序来说, 要在右子树处理之前打印</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            colorPrintln(<span class="string">"中: "</span> + peek.val, <span class="number">36</span>);</span><br><span class="line">            curr = peek.right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">colorPrintln</span><span class="params">(String origin, <span class="type">int</span> color)</span> {</span><br><span class="line">    System.out.printf(<span class="string">"\033[%dm%s\033[0m%n"</span>, color, origin);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>一张图演示三种遍历</p><figure><img src="../../../../images/StrJava/Sorted_binary_tree_ALL_RGB.svg.png" alt="Sorted_binary_tree_ALL_RGB.svg"><figcaption aria-hidden="true">Sorted_binary_tree_ALL_RGB.svg</figcaption></figure><ul><li>红色：前序遍历顺序</li><li>绿色：中序遍历顺序</li><li>蓝色：后续遍历顺序</li></ul><h3 id="习题-8">习题</h3><h4 id="e01.-前序遍历二叉树-leetcode-144">E01. 前序遍历二叉树-Leetcode144</h4><h4 id="e02.-中序遍历二叉树-leetcode-94">E02. 中序遍历二叉树-Leetcode94</h4><h4 id="e03.-后序遍历二叉树-leetcode-145">E03. 后序遍历二叉树-Leetcode145</h4><h4 id="e04.-对称二叉树-leetcode-101">E04. 对称二叉树-Leetcode 101</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">return</span> check(root.left, root.right);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode left, TreeNode right)</span> {</span><br><span class="line">    <span class="comment">// 若同时为 null</span></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 若有一个为 null (有上一轮筛选，另一个肯定不为 null)</span></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">null</span> || right == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (left.val != right.val) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> check(left.left, right.right) &amp;&amp; check(left.right, right.left);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>类似题目：Leetcode 100 题 - 相同的树</p><h4 id="e05.-二叉树最大深度-leetcode-104">E05. 二叉树最大深度-Leetcode104</h4><p><strong>后序遍历求解</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">    1. 得到左子树深度, 得到右子树深度, 二者最大者加一, 就是本节点深度</span></span><br><span class="line"><span class="comment">    2. 因为需要先得到左右子树深度, 很显然是后序遍历典型应用</span></span><br><span class="line"><span class="comment">    3. 关于深度的定义：从根出发, 离根最远的节点总边数,</span></span><br><span class="line"><span class="comment">        注意: 力扣里的深度定义要多一</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        深度2         深度3         深度1</span></span><br><span class="line"><span class="comment">        1            1            1</span></span><br><span class="line"><span class="comment">       / \          / \</span></span><br><span class="line"><span class="comment">      2   3        2   3</span></span><br><span class="line"><span class="comment">                        \</span></span><br><span class="line"><span class="comment">                         4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode node)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 非力扣题目改为返回 -1</span></span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">d1</span> <span class="operator">=</span> maxDepth(node.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">d2</span> <span class="operator">=</span> maxDepth(node.right);</span><br><span class="line">    <span class="keyword">return</span> Integer.max(d1, d2) + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>后序遍历求解-非递归</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">    1. 使用非递归后序遍历, 栈的最大高度即为最大深度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">null</span> || !stack.isEmpty()) {</span><br><span class="line">        <span class="keyword">if</span> (curr != <span class="literal">null</span>) {</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stack.size();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; max) {</span><br><span class="line">                max = size;</span><br><span class="line">            }</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">peek</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(peek.right == <span class="literal">null</span> || peek.right == pop) {</span><br><span class="line">                pop = stack.pop();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                curr = peek.right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>层序遍历求解</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">    1. 使用层序遍历, 层数即最大深度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">        level++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e06.-二叉树最小深度-leetcode-111">E06. 二叉树最小深度-Leetcode111</h4><p><strong>后序遍历求解</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode node)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">d1</span> <span class="operator">=</span> minDepth(node.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">d2</span> <span class="operator">=</span> minDepth(node.right);</span><br><span class="line">    <span class="keyword">if</span> (d1 == <span class="number">0</span> || d2 == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> d1 + d2 + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> Integer.min(d1, d2) + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>相较于求最大深度，应当考虑：</p><ul><li>当右子树为 null，应当返回左子树深度加一</li><li>当左子树为 null，应当返回右子树深度加一</li></ul><p>上面两种情况满足时，不应该再把为 null 子树的深度 0参与最小值比较，例如这样</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> /</span><br><span class="line">2</span><br></pre></td></tr></tbody></table></figure><ul><li>正确深度为 2，若把为 null 的右子树的深度 0 考虑进来，会得到错误结果1</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  3</span><br><span class="line">   \</span><br><span class="line">    4</span><br></pre></td></tr></tbody></table></figure><ul><li>正确深度为 3，若把为 null 的左子树的深度 0 考虑进来，会得到错误结果1</li></ul><p><strong>层序遍历求解</strong></p><p>遇到的第一个叶子节点所在层就是最小深度</p><p>例如，下面的树遇到的第一个叶子节点 3 所在的层就是最小深度，其他 4，7等叶子节点深度更深，也更晚遇到</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \     </span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5 </span><br><span class="line">   /</span><br><span class="line">  7 </span><br></pre></td></tr></tbody></table></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">        level++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> level;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>效率会高于之前后序遍历解法，因为找到第一个叶子节点后，就无需后续的层序遍历了</p><h4 id="e07.-翻转二叉树-leetcode-226">E07. 翻转二叉树-Leetcode 226</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    fn(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fn</span><span class="params">(TreeNode node)</span>{</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">t</span> <span class="operator">=</span> node.left;</span><br><span class="line">    node.left = node.right;</span><br><span class="line">    node.right = t;</span><br><span class="line">    fn(node.left);</span><br><span class="line">    fn(node.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>先交换、再递归或是先递归、再交换都可以</p><h4 id="e08.-后缀表达式转二叉树">E08. 后缀表达式转二叉树</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> {</span><br><span class="line">    <span class="keyword">public</span> String val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(String val)</span> {</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(TreeNode left, String val, TreeNode right)</span> {</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.val;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    中缀表达式           (2-1)*3</span></span><br><span class="line"><span class="comment">    后缀（逆波兰）表达式   21-3*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    1.遇到数字入栈</span></span><br><span class="line"><span class="comment">    2.遇到运算符, 出栈两次, 与当前节点建立父子关系, 当前节点入栈</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    栈</span></span><br><span class="line"><span class="comment">    |   |</span></span><br><span class="line"><span class="comment">    |   |</span></span><br><span class="line"><span class="comment">    |   |</span></span><br><span class="line"><span class="comment">    _____</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    表达式树</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">       / \</span></span><br><span class="line"><span class="comment">      -   3</span></span><br><span class="line"><span class="comment">     / \</span></span><br><span class="line"><span class="comment">    2   1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    21-3*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">constructExpressionTree</span><span class="params">(String[] tokens)</span> {</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String t : tokens) {</span><br><span class="line">        <span class="keyword">switch</span> (t) {</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"+"</span>, <span class="string">"-"</span>, <span class="string">"*"</span>, <span class="string">"/"</span> -&gt; { <span class="comment">// 运算符</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(t);</span><br><span class="line">                parent.left = left;</span><br><span class="line">                parent.right = right;</span><br><span class="line">                stack.push(parent);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">default</span> -&gt; { <span class="comment">// 数字</span></span><br><span class="line">                stack.push(<span class="keyword">new</span> <span class="title class_">TreeNode</span>(t));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> stack.peek();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e09.-根据前序与中序遍历结果构造二叉树-leetcode-105">E09.根据前序与中序遍历结果构造二叉树-Leetcode 105</h4><ul><li>先通过前序遍历结果定位根节点</li><li>再结合中序遍历结果切分左右子树</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E09Leetcode105</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        preOrder = {1,2,4,3,6,7}</span></span><br><span class="line"><span class="comment">        inOrder = {4,2,1,6,3,7}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        根 1</span></span><br><span class="line"><span class="comment">            pre         in</span></span><br><span class="line"><span class="comment">        左  2,4         4,2</span></span><br><span class="line"><span class="comment">        右  3,6,7       6,3,7</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        根 2</span></span><br><span class="line"><span class="comment">        左 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        根 3</span></span><br><span class="line"><span class="comment">        左 6</span></span><br><span class="line"><span class="comment">        右 7</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preOrder, <span class="type">int</span>[] inOrder)</span> {</span><br><span class="line">        <span class="keyword">if</span> (preOrder.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 创建根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootValue</span> <span class="operator">=</span> preOrder[<span class="number">0</span>];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootValue);</span><br><span class="line">        <span class="comment">// 区分左右子树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inOrder.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (inOrder[i] == rootValue) {</span><br><span class="line">                <span class="comment">// 0 ~ i-1 左子树</span></span><br><span class="line">                <span class="comment">// i+1 ~ inOrder.length -1 右子树</span></span><br><span class="line">                <span class="type">int</span>[] inLeft = Arrays.copyOfRange(inOrder, <span class="number">0</span>, i); <span class="comment">// [4,2]</span></span><br><span class="line">                <span class="type">int</span>[] inRight = Arrays.copyOfRange(inOrder, i + <span class="number">1</span>, inOrder.length); <span class="comment">// [6,3,7]</span></span><br><span class="line"></span><br><span class="line">                <span class="type">int</span>[] preLeft = Arrays.copyOfRange(preOrder, <span class="number">1</span>, i + <span class="number">1</span>); <span class="comment">// [2,4]</span></span><br><span class="line">                <span class="type">int</span>[] preRight = Arrays.copyOfRange(preOrder, i + <span class="number">1</span>, inOrder.length); <span class="comment">// [3,6,7]</span></span><br><span class="line"></span><br><span class="line">                root.left = buildTree(preLeft, inLeft); <span class="comment">// 2</span></span><br><span class="line">                root.right = buildTree(preRight, inRight); <span class="comment">// 3</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>代码可以进一步优化，涉及新数据结构，以后实现</li></ul><h4 id="e10.-根据中序与后序遍历结果构造二叉树-leetcode-106">E10.根据中序与后序遍历结果构造二叉树-Leetcode 106</h4><ul><li>先通过后序遍历结果定位根节点</li><li>再结合中序遍历结果切分左右子树</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inOrder, <span class="type">int</span>[] postOrder)</span> {</span><br><span class="line">    <span class="keyword">if</span> (inOrder.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 根</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rootValue</span> <span class="operator">=</span> postOrder[postOrder.length - <span class="number">1</span>];</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootValue);</span><br><span class="line">    <span class="comment">// 切分左右子树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inOrder.length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (inOrder[i] == rootValue) {</span><br><span class="line">            <span class="type">int</span>[] inLeft = Arrays.copyOfRange(inOrder, <span class="number">0</span>, i);</span><br><span class="line">            <span class="type">int</span>[] inRight = Arrays.copyOfRange(inOrder, i + <span class="number">1</span>, inOrder.length);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span>[] postLeft = Arrays.copyOfRange(postOrder, <span class="number">0</span>, i);</span><br><span class="line">            <span class="type">int</span>[] postRight = Arrays.copyOfRange(postOrder, i, postOrder.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            root.left = buildTree(inLeft, postLeft);</span><br><span class="line">            root.right = buildTree(inRight, postRight);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>代码可以进一步优化，涉及新数据结构，以后实现</li></ul><h1 id="三.-基础算法">三. 基础算法</h1><h2 id="查找概述">3.1 查找概述</h2><p>查找算法是一种在数据集中寻找特定数据项的方法。通常，数据集是在计算机程序中存储的，例如数组、链表或散列表。在编写程序时，查找算法是非常重要的，它有助于快速找到所需的数据。在本文中，我们将介绍一些基本的查找算法及其特点。</p><h3 id="线性查找">线性查找</h3><p>线性查找也称为顺序查找，是一种最简单的查找算法。在这种算法中，我们从数据集的开头开始，逐个比较每个数据项，以寻找要查找的数据。如果我们找到了目标数据，查找过程就结束了。如果我们到达数据集的末尾，仍然找不到目标数据，则可以认为它不存在于数据集中。</p><p>线性查找的时间复杂度是O(n)，其中n是数据集的大小。因此，它在大型数据集中可能会很慢。然而，在小型数据集中，它仍然是一种非常有用的算法。</p><h3 id="二分查找">二分查找</h3><p>二分查找也称为折半查找，是一种更快速的查找算法。但前提是，数据集必须已经排序。在二分查找中，我们取数据集的中间值，然后将目标与中间值进行比较。如果目标小于中间值，则在左侧子集中继续查找；如果目标大于中间值，则在右侧子集中继续查找。每次比较都会缩小要搜索的数据集的大小。</p><p>二分查找的时间复杂度是O(logn)，其中n是数据集的大小。这种算法在大型数据集中非常有效，但在小型数据集中可能并不是最快的选择。</p><h3 id="哈希表查找">哈希表查找</h3><p>哈希表查找也称为散列表查找，是另一种常见的查找算法。它利用哈希函数将数据项映射到散列表中的位置。在查找过程中，我们只需通过哈希函数计算目标数据的位置，然后检查该位置是否包含目标数据。</p><p>哈希表查找的时间复杂度是O(1)。这使得它成为大型数据集中最快的查找算法之一。但是，哈希表查找的效率取决于哈希函数的质量。如果两个数据项映射到相同的位置，就会发生哈希冲突，这可能会导致性能下降。</p><h3 id="小结">小结</h3><p>在编写程序时，我们需要选择适合数据集大小和其他要求的最佳查找算法。例如，如果数据集很小，则线性查找可能是最快的选择；如果数据集已经排序，则二分查找是非常有用的。然而，在大型数据集中，哈希表查找通常是最好的选择。了解不同类型的查找算法及其特点可以帮助我们在编写程序时做出明智的选择。</p><p>不管是之前学过的数组、链表、队列、还是栈，这些线性结构中，如果想在其中查找一个元素，效率是比较慢的，只有<span class="math inline">\(O(N)\)</span>，因此如果你的需求是实现数据的快速查找，那么就需要<strong>新的数据结构</strong>支持。</p><p>还记得最先介绍的那个二分查找算法吗？它的查找效率能够达到 <span class="math inline">\(O(\log{N})\)</span>，是不是还不错？不过呢，它需要对数组事先排好序，而排序的成本是比较高的。那么有没有一个折中的办法呢？有，那就是接下来要给大家介绍的<strong>二叉搜索树</strong>，它插入元素后，自然就是排好序的，接下来的查询也自然而然可以应用二分查找算法进行高效搜索。</p><h2 id="二叉搜索树">3.2 二叉搜索树</h2><h3 id="概述-6">概述</h3><h4 id="历史">历史</h4><blockquote><p>二叉搜索树最早是由Bernoulli兄弟在18世纪中提出的，但是真正推广和应用该数据结构的是1960年代的D.L.Gries。他的著作《The Science ofProgramming》中详细介绍了二叉搜索树的实现和应用。</p><p>在计算机科学的发展中，二叉搜索树成为了一种非常基础的数据结构，被广泛应用在各种领域，包括搜索、排序、数据库索引等。随着计算机算力的提升和对数据结构的深入研究，二叉搜索树也不断被优化和扩展，例如AVL树、红黑树等。</p></blockquote><h4 id="特性">特性</h4><p>二叉搜索树（也称二叉排序树）是符合下面特征的二叉树：</p><ol type="1"><li>树节点增加 key 属性，用来比较谁大谁小，key 不可以重复</li><li>对于任意一个树节点，它的 key 比左子树的 key 都大，同时也比右子树的key 都小，例如下图所示</li></ol><figure><img src="../../../../images/StrJava/image-20230228090412983.png" alt="image-20230228090412983"><figcaption aria-hidden="true">image-20230228090412983</figcaption></figure><p>轻易看出要查找 7（从根开始）自然就可应用二分查找算法，只需三次比较</p><ul><li>与 4 比，较之大，向右找</li><li>与 6 比，较之大，继续向右找</li><li>与 7 比，找到</li></ul><p>查找的时间复杂度与<strong>树高</strong>相关，插入、删除也是如此。</p><ul><li>如果这棵树长得还不赖（左右平衡）上图，那么时间复杂度均是 <span class="math inline">\(O(\log{N})\)</span></li><li>当然，这棵树如果长得丑（左右高度相差过大）下图，那么这时是最糟的情况，时间复杂度是<span class="math inline">\(O(N)\)</span></li></ul><figure><img src="../../../../images/StrJava/image-20230228091405293.png" alt="image-20230228091405293"><figcaption aria-hidden="true">image-20230228091405293</figcaption></figure><blockquote><p>注：</p><ul><li>二叉搜索树 - 英文 binary search tree，简称 BST</li><li>二叉排序树 - 英文 binary ordered tree 或 binary sorted tree</li></ul></blockquote><h3 id="实现">实现</h3><h4 id="定义节点">定义节点</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BSTNode</span> {</span><br><span class="line">    <span class="type">int</span> key; <span class="comment">// 若希望任意类型作为 key, 则后续可以将其设计为 Comparable 接口</span></span><br><span class="line">    Object value;</span><br><span class="line">    BSTNode left;</span><br><span class="line">    BSTNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTNode</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = key;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTNode</span><span class="params">(<span class="type">int</span> key, Object value)</span> {</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTNode</span><span class="params">(<span class="type">int</span> key, Object value, BSTNode left, BSTNode right)</span> {</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="查询">查询</h4><p><strong>递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="keyword">return</span> doGet(root, key);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">doGet</span><span class="params">(BSTNode node, <span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 没找到</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.key) {</span><br><span class="line">        <span class="keyword">return</span> doGet(node.left, key); <span class="comment">// 向左找</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (node.key &lt; key) {</span><br><span class="line">        <span class="keyword">return</span> doGet(node.right, key); <span class="comment">// 向右找</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> node.value; <span class="comment">// 找到了</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>非递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (key &lt; node.key) {</span><br><span class="line">            node = node.left;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (node.key &lt; key) {</span><br><span class="line">            node = node.right;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="comparable">Comparable</h4><p>如果希望让除 int 外更多的类型能够作为 key，一种方式是 key 必须实现Comparable 接口。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BSTTree2</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BSTNode</span>&lt;T&gt; {</span><br><span class="line">        T key; <span class="comment">// 若希望任意类型作为 key, 则后续可以将其设计为 Comparable 接口</span></span><br><span class="line">        Object value;</span><br><span class="line">        BSTNode&lt;T&gt; left;</span><br><span class="line">        BSTNode&lt;T&gt; right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BSTNode</span><span class="params">(T key)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = key;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BSTNode</span><span class="params">(T key, Object value)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BSTNode</span><span class="params">(T key, Object value, BSTNode&lt;T&gt; left, BSTNode&lt;T&gt; right)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    BSTNode&lt;T&gt; root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(T key)</span> {</span><br><span class="line">        <span class="keyword">return</span> doGet(root, key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">doGet</span><span class="params">(BSTNode&lt;T&gt; node, T key)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> node.key.compareTo(key);</span><br><span class="line">        <span class="keyword">if</span> (result &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> doGet(node.left, key);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (result &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> doGet(node.right, key);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>还有一种做法不要求 key 实现 Comparable 接口，而是在构造 Tree时把比较规则作为 Comparator 传入，将来比较 key 大小时都调用此 Comparator进行比较，这种做法可以参考 Java 中的 java.util.TreeMap</p><h4 id="最小">最小</h4><p><strong>递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">min</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> doMin(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">doMin</span><span class="params">(BSTNode node)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 左边已走到头</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span>) { </span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> doMin(node.left);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>非递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">min</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="comment">// 左边未走到头</span></span><br><span class="line">    <span class="keyword">while</span> (p.left != <span class="literal">null</span>) {</span><br><span class="line">        p = p.left;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> p.value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="最大">最大</h4><p><strong>递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">max</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> doMax(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">doMax</span><span class="params">(BSTNode node)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 右边已走到头</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span>) { </span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> doMin(node.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>非递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">max</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="comment">// 右边未走到头</span></span><br><span class="line">    <span class="keyword">while</span> (p.right != <span class="literal">null</span>) {</span><br><span class="line">        p = p.right;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> p.value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="新增">新增</h4><p><strong>递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, Object value)</span> {</span><br><span class="line">    root = doPut(root, key, value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BSTNode <span class="title function_">doPut</span><span class="params">(BSTNode node, <span class="type">int</span> key, Object value)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BSTNode</span>(key, value);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.key) {</span><br><span class="line">        node.left = doPut(node.left, key, value);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (node.key &lt; key) {</span><br><span class="line">        node.right = doPut(node.right, key, value);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        node.value = value;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>若找到 key，走 else 更新找到节点的值</li><li>若没找到 key，走第一个 if，创建并返回新节点<ul><li>返回的新节点，作为上次递归时 node 的左孩子或右孩子</li><li>缺点是，会有很多不必要的赋值操作</li></ul></li></ul><p><strong>非递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, Object value)</span> {</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) {</span><br><span class="line">        parent = node;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; node.key) {</span><br><span class="line">            node = node.left;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (node.key &lt; key) {</span><br><span class="line">            node = node.right;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 1. key 存在则更新</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 2. key 不存在则新增</span></span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">null</span>) {</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">BSTNode</span>(key, value);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; parent.key) {</span><br><span class="line">        parent.left = <span class="keyword">new</span> <span class="title class_">BSTNode</span>(key, value);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        parent.right = <span class="keyword">new</span> <span class="title class_">BSTNode</span>(key, value);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="前驱后继">前驱后继</h4><figure><img src="../../../../images/StrJava/image-20230228144422128.png" alt="image-20230228144422128"><figcaption aria-hidden="true">image-20230228144422128</figcaption></figure><p>一个节点的前驱（前任）节点是指比它小的节点中，最大的那个</p><p>一个节点的后继（后任）节点是指比它大的节点中，最小的那个</p><p>例如上图中</p><ul><li>1 没有前驱，后继是 2</li><li>2 前驱是 1，后继是 3</li><li>3 前驱是 2，后继是 4</li><li>...</li></ul><p>简单的办法是中序遍历，即可获得排序结果，此时很容易找到前驱后继</p><p>要效率更高，需要研究一下规律，<strong>找前驱</strong>分成 2种情况：</p><figure><img src="../../../../images/StrJava/image-20230228144422128.png" alt="image-20230228144422128"><figcaption aria-hidden="true">image-20230228144422128</figcaption></figure><ol type="1"><li>节点有左子树，此时前驱节点就是左子树的最大值，图中属于这种情况的有<ul><li>2 的前驱是1</li><li>4 的前驱是 3</li><li>6 的前驱是 5</li><li>7 的前驱是 6</li></ul></li><li>节点没有左子树，若离它最近的祖先自从左而来，此祖先即为前驱，如<ul><li>3 的祖先 2 自左而来，前驱 2</li><li>5 的祖先 4 自左而来，前驱 4</li><li>8 的祖先 7 自左而来，前驱 7</li><li>1 没有这样的祖先，前驱 null</li></ul></li></ol><p><strong>找后继</strong>也分成 2 种情况</p><figure><img src="../../../../images/StrJava/image-20230228152715296.png" alt="image-20230228152715296"><figcaption aria-hidden="true">image-20230228152715296</figcaption></figure><ol type="1"><li>节点有右子树，此时后继节点即为右子树的最小值，如<ul><li>2 的后继 3</li><li>3 的后继 4</li><li>5 的后继 6</li><li>7 的后继 8</li></ul></li><li>节点没有右子树，若离它最近的祖先自从右而来，此祖先即为后继，如<ul><li>1 的祖先 2 自右而来，后继 2</li><li>4 的祖先 5 自右而来，后继 5</li><li>6 的祖先 7 自右而来，后继 7</li><li>8 没有这样的祖先，后继 null</li></ul></li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">predecessor</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">ancestorFromLeft</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (key &lt; p.key) {</span><br><span class="line">            p = p.left;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (p.key &lt; key) {</span><br><span class="line">            ancestorFromLeft = p;</span><br><span class="line">            p = p.right;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 情况1 - 有左孩子</span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> max(p.left);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 情况2 - 有祖先自左而来</span></span><br><span class="line">    <span class="keyword">return</span> ancestorFromLeft != <span class="literal">null</span> ? ancestorFromLeft.value : <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">successor</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">ancestorFromRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (key &lt; p.key) {</span><br><span class="line">            ancestorFromRight = p;</span><br><span class="line">            p = p.left;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (p.key &lt; key) {</span><br><span class="line">            p = p.right;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 情况1 - 有右孩子</span></span><br><span class="line">    <span class="keyword">if</span> (p.right != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> min(p.right);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 情况2 - 有祖先自右而来</span></span><br><span class="line">    <span class="keyword">return</span> ancestorFromRight != <span class="literal">null</span> ? ancestorFromRight.value : <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="删除">删除</h4><p>要删除某节点（称为 D），必须先找到被删除节点的父节点，这里称为Parent</p><ol type="1"><li>删除节点没有左孩子，将右孩子托孤给 Parent</li><li>删除节点没有右孩子，将左孩子托孤给 Parent</li><li>删除节点左右孩子都没有，已经被涵盖在情况1、情况2 当中，把 null托孤给 Parent</li><li>删除节点左右孩子都有，可以将它的后继节点（称为 S）托孤给 Parent，设S 的父亲为 SP，又分两种情况<ol type="1"><li>SP 就是被删除节点，此时 D 与 S 紧邻，只需将 S 托孤给 Parent</li><li>SP 不是被删除节点，此时 D 与 S 不相邻，此时需要将 S 的后代托孤给SP，再将 S 托孤给 Parent</li></ol></li></ol><p><strong>非递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;根据关键字删除&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 关键字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 被删除关键字对应值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">delete</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (key &lt; p.key) {</span><br><span class="line">            parent = p;</span><br><span class="line">            p = p.left;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (p.key &lt; key) {</span><br><span class="line">            parent = p;</span><br><span class="line">            p = p.right;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 删除操作</span></span><br><span class="line">    <span class="keyword">if</span> (p.left == <span class="literal">null</span>) {</span><br><span class="line">        shift(parent, p, p.right); <span class="comment">// 情况1</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (p.right == <span class="literal">null</span>) {</span><br><span class="line">        shift(parent, p, p.left); <span class="comment">// 情况2</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 情况4</span></span><br><span class="line">        <span class="comment">// 4.1 被删除节点找后继</span></span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">s</span> <span class="operator">=</span> p.right;</span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">sParent</span> <span class="operator">=</span> p; <span class="comment">// 后继父亲</span></span><br><span class="line">        <span class="keyword">while</span> (s.left != <span class="literal">null</span>) {</span><br><span class="line">            sParent = s;</span><br><span class="line">            s = s.left;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 4.2 删除和后继不相邻, 处理后继的后事</span></span><br><span class="line">        <span class="keyword">if</span> (sParent != p) {                </span><br><span class="line">            shift(sParent, s, s.right); <span class="comment">// 不可能有左孩子</span></span><br><span class="line">            s.right = p.right;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 4.3 后继取代被删除节点</span></span><br><span class="line">        shift(parent, p, s);</span><br><span class="line">        s.left = p.left;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> p.value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 托孤方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent  被删除节点的父亲</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> deleted 被删除节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> child   被顶上去的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 只考虑让 n1父亲的左或右孩子指向 n2, n1自己的左或右孩子并未在方法内改变</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">shift</span><span class="params">(BSTNode parent, BSTNode deleted, BSTNode child)</span> {</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">null</span>) {</span><br><span class="line">        root = child;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (deleted == parent.left) {</span><br><span class="line">        parent.left = child;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        parent.right = child;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">delete</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    ArrayList&lt;Object&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    root = doDelete(root, key, result);</span><br><span class="line">    <span class="keyword">return</span> result.isEmpty() ? <span class="literal">null</span> : result.get(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BSTNode <span class="title function_">doDelete</span><span class="params">(BSTNode node, <span class="type">int</span> key, ArrayList&lt;Object&gt; result)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.key) {</span><br><span class="line">        node.left = doDelete(node.left, key, result);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (node.key &lt; key) {</span><br><span class="line">        node.right = doDelete(node.right, key, result);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    result.add(node.value);</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span> &amp;&amp; node.right != <span class="literal">null</span>) {</span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">s</span> <span class="operator">=</span> node.right;</span><br><span class="line">        <span class="keyword">while</span> (s.left != <span class="literal">null</span>) {</span><br><span class="line">            s = s.left;</span><br><span class="line">        }</span><br><span class="line">        s.right = doDelete(node.right, s.key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        s.left = node.left;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> node.left != <span class="literal">null</span> ? node.left : node.right;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>说明</p><ol type="1"><li><code>ArrayList&lt;Object&gt; result</code>用来保存被删除节点的值</li><li>第二、第三个 if 对应没找到的情况，继续递归查找和删除，注意后续的doDelete 返回值代表删剩下的，因此需要更新</li><li>最后一个 return对应删除节点只有一个孩子的情况，返回那个不为空的孩子，待删节点自己因没有返回而被删除</li><li>第四个 if对应删除节点有两个孩子的情况，此时需要找到后继节点，并在待删除节点的右子树中删掉后继节点，最后用后继节点替代掉待删除节点返回，别忘了改变后继节点的左右指针</li></ol><h4 id="找小的">找小的</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">less</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    ArrayList&lt;Object&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    LinkedList&lt;BSTNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> || !stack.isEmpty()) {</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">BSTNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (pop.key &lt; key) {</span><br><span class="line">                result.add(pop.value);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            p = pop.right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="找大的">找大的</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">greater</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    ArrayList&lt;Object&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    LinkedList&lt;BSTNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> || !stack.isEmpty()) {</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">BSTNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (pop.key &gt; key) {</span><br><span class="line">                result.add(pop.value);</span><br><span class="line">            }</span><br><span class="line">            p = pop.right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但这样效率不高，可以用 RNL 遍历</p><blockquote><p>注：</p><ul><li>Pre-order, NLR</li><li>In-order, LNR</li><li>Post-order, LRN</li><li>Reverse pre-order, NRL</li><li>Reverse in-order, RNL</li><li>Reverse post-order, RLN</li></ul></blockquote><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">greater</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    ArrayList&lt;Object&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    LinkedList&lt;BSTNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> || !stack.isEmpty()) {</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.right;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">BSTNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (pop.key &gt; key) {</span><br><span class="line">                result.add(pop.value);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            p = pop.left;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="找之间">找之间</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">between</span><span class="params">(<span class="type">int</span> key1, <span class="type">int</span> key2)</span> {</span><br><span class="line">    ArrayList&lt;Object&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    LinkedList&lt;BSTNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> || !stack.isEmpty()) {</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">BSTNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (pop.key &gt;= key1 &amp;&amp; pop.key &lt;= key2) {</span><br><span class="line">                result.add(pop.value);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (pop.key &gt; key2) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            p = pop.right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="小结-1">小结</h4><p>优点：</p><ol type="1"><li>如果每个节点的左子树和右子树的大小差距不超过一，可以保证搜索操作的时间复杂度是O(log n)，效率高。</li><li>插入、删除结点等操作也比较容易实现，效率也比较高。</li><li>对于有序数据的查询和处理，二叉查找树非常适用，可以使用中序遍历得到有序序列。</li></ol><p>缺点：</p><ol type="1"><li>如果输入的数据是有序或者近似有序的，就会出现极度不平衡的情况，可能导致搜索效率下降，时间复杂度退化成O(n)。</li><li>对于频繁地插入、删除操作，需要维护平衡二叉查找树，例如红黑树、AVL树等，否则搜索效率也会下降。</li><li>对于存在大量重复数据的情况，需要做相应的处理，否则会导致树的深度增加，搜索效率下降。</li><li>对于结点过多的情况，由于树的空间开销较大，可能导致内存消耗过大，不适合对内存要求高的场景。</li></ol><h3 id="习题-9">习题</h3><h4 id="e01.-删除节点-leetcode-450">E01. 删除节点-Leetcode 450</h4><p>例题已经讲过，用非递归和递归均可实现，这里只给出递归参考代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode node, <span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.val) {</span><br><span class="line">        node.left = deleteNode(node.left, key);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (node.val &lt; key) {</span><br><span class="line">        node.right = deleteNode(node.right, key);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span>) { <span class="comment">// 情况1 - 只有右孩子</span></span><br><span class="line">        <span class="keyword">return</span> node.right;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (node.right == <span class="literal">null</span>) { <span class="comment">// 情况2 - 只有左孩子</span></span><br><span class="line">        <span class="keyword">return</span> node.left;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">s</span> <span class="operator">=</span> node.right; <span class="comment">// 情况3 - 有两个孩子</span></span><br><span class="line">    <span class="keyword">while</span> (s.left != <span class="literal">null</span>) {</span><br><span class="line">        s = s.left;</span><br><span class="line">    }</span><br><span class="line">    s.right = deleteNode(node.right, s.val);</span><br><span class="line">    s.left = node.left;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>树节点 TreeNode 相当于例题中的 BSTNode<ul><li>TreeNode 有属性：val, left, right，并未区分键值</li><li>BSTNode 有属性：key, value, left, right，区分了键值</li></ul></li><li>它的 TreeNode 没有 key，比较用的是 TreeNode.val 属性与待删除 key进行比较</li></ul><h4 id="e02.-新增节点-leetcode-701">E02. 新增节点-Leetcode 701</h4><p>例题也讲过了（put），下面给出递归实现</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode node, <span class="type">int</span> val)</span> {</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(val &lt; node.val) {</span><br><span class="line">        node.left = insertIntoBST(node.left, val);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span>(node.val &lt; val) {</span><br><span class="line">        node.right = insertIntoBST(node.right, val);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>注意事项与上题相同，不再赘述</li><li>题目提示输入的 val一定与树中节点不同，因此只需考虑<strong>新增</strong>情况，不会出现<strong>更新</strong>情况</li></ul><h4 id="e03.-查询节点-leetcode-700">E03. 查询节点-Leetcode 700</h4><p>例题讲过，下面给出递归实现</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode node, <span class="type">int</span> val)</span> {</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(val &lt; node.val) {</span><br><span class="line">        <span class="keyword">return</span> searchBST(node.left, val);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span>(node.val &lt; val) {</span><br><span class="line">        <span class="keyword">return</span> searchBST(node.right, val);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e04.-验证二叉搜索树-leetcode-98">E04. 验证二叉搜索树-Leetcode98</h4><p><strong>中序非递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">long</span> <span class="variable">prev</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> || !stack.isEmpty()) {</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (prev &gt;= pop.val) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            prev = pop.val;</span><br><span class="line">            p = pop.right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>记录 prev 需要用 long，否则若测试用例中最小的节点为Integer.MIN_VALUE 则测试会失败</li><li>注意，如果相邻两个节点相等，也不应当通过测试，例如，下面的树也是不合法的</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">2</span><br><span class="line">  / </span><br><span class="line"> 2 </span><br></pre></td></tr></tbody></table></figure><p><strong>中序递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> doValid(<span class="keyword">new</span> <span class="title class_">AtomicLong</span>(Long.MIN_VALUE),root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doValid</span><span class="params">(AtomicLong prev, TreeNode node)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">a</span> <span class="operator">=</span> doValid(prev, node.left);</span><br><span class="line">    <span class="keyword">if</span> (prev.get() &gt;= node.val) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    prev.set(node.val);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> doValid(prev, node.right);</span><br><span class="line">    <span class="keyword">return</span> a &amp;&amp; b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>为何不能用 Long 或long？因为它们都是局部变量且不可变，因此每次赋值时，并不会改变其它方法调用时的prev</p></li><li><p>要么把 prev 设置为 AtomicLong，要么把 prev设置为全局变量，而不要采用方法参数这样的局部变量</p></li><li><p>上述代码并不是最有效率的，分析过程见视频讲解</p></li></ul><p><strong>上下限递归</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode node)</span> {</span><br><span class="line">    <span class="keyword">return</span> doValid(node, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">doValid</span><span class="params">(TreeNode node, <span class="type">long</span> min, <span class="type">long</span> max)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (node.val &lt;= min || node.val &gt;= max) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> doValid(node.left, min, node.val) &amp;&amp; doValid(node.right, node.val, max);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>设每个节点必须在一个范围内：<span class="math inline">\((min,max)\)</span>，不包含边界，若节点值超过这个范围，则返回 false</li><li>对于 node.left 范围肯定是 <span class="math inline">\((min,node.val)\)</span></li><li>对于 node.right 范围肯定是 <span class="math inline">\((node.val,max)\)</span></li><li>一开始不知道 min，max 则取 java 中长整数的最小、最大值</li><li>本质是前序遍历 + 剪枝</li></ul><h4 id="e05.-求范围和-leetcode-938">E05. 求范围和-Leetcode 938</h4><p><strong>中序递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(TreeNode node, <span class="type">int</span> low, <span class="type">int</span> high)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> rangeSumBST(node.left, low, high);</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.val &gt;= low &amp;&amp; node.val &lt;= high) {</span><br><span class="line">        b = node.val;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> a + b + rangeSumBST(node.right, low, high);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>中序非递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(TreeNode node, <span class="type">int</span> low, <span class="type">int</span> high)</span> {</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> node;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">null</span> || !stack.isEmpty()) {</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (pop.val &gt; high) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (pop.val &gt;= low) {</span><br><span class="line">                sum += pop.val;</span><br><span class="line">            }</span><br><span class="line">            p = pop.right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>leedcode 执行耗时 4ms</li></ul><p><strong>上下限递归实现</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(TreeNode node, <span class="type">int</span> low, <span class="type">int</span> high)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (node.val &lt; low) {</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(node.right, low, high);</span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">if</span> (node.val &gt; high) {</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(node.left, low, high);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> node.val + </span><br><span class="line">        rangeSumBST(node.left, low, high) + </span><br><span class="line">        rangeSumBST(node.right, low, high);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>leetcode 执行耗时 0 ms</li><li>node.val &lt; low 只需考虑它右子树的累加结果</li><li>node.val &gt; high 只需考虑它左子树的累加结果</li><li>node.val 在范围内，需要把当前节点的值加上其左右子树的累加结果</li></ul><h4 id="e06.-根据前序遍历结果构造二叉搜索树-leetcode-1008">E06.根据前序遍历结果构造二叉搜索树-Leetcode 1008</h4><p><strong>直接插入</strong></p><p>注意：根据前序遍历的结果，可以唯一地构造出一个二叉搜索树</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">bstFromPreorder</span><span class="params">(<span class="type">int</span>[] preorder)</span> {</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> insert(<span class="literal">null</span>, preorder[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; preorder.length; i++) {</span><br><span class="line">        insert(root, preorder[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">insert</span><span class="params">(TreeNode node, <span class="type">int</span> val)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(val &lt; node.val) {</span><br><span class="line">        node.left = insert(node.left, val);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span>(node.val &lt; val){</span><br><span class="line">        node.right = insert(node.right, val);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>上限法</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">bstFromPreorder</span><span class="params">(<span class="type">int</span>[] preorder)</span> {</span><br><span class="line">    <span class="keyword">return</span> insert(preorder, Integer.MAX_VALUE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">insert</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> max)</span> {</span><br><span class="line">    <span class="keyword">if</span> (i == preorder.length) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> preorder[i];</span><br><span class="line">    System.out.println(val + String.format(<span class="string">"[%d]"</span>, max));</span><br><span class="line">    <span class="keyword">if</span> (val &gt; max) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">    i++;</span><br><span class="line">    node.left = insert(preorder, node.val); </span><br><span class="line">    node.right = insert(preorder, max);     </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>依次处理 prevorder 中每个值, 返回创建好的节点或 null作为上个节点的孩子</p><ol type="1"><li>如果超过上限, 返回 null</li><li>如果没超过上限, 创建节点, 并将其左右孩子设置完整后返回<ul><li>i++ 需要放在设置左右孩子之前，意思是从剩下的元素中挑选左右孩子</li></ul></li></ol><p><strong>分治法</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">bstFromPreorder</span><span class="params">(<span class="type">int</span>[] preorder)</span> {</span><br><span class="line">    <span class="keyword">return</span> partition(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> start, <span class="type">int</span> end)</span> {</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[start]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> start + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt;= end) {</span><br><span class="line">        <span class="keyword">if</span> (preorder[index] &gt; preorder[start]) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        index++;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// index 就是右子树的起点</span></span><br><span class="line">    root.left = partition(preorder, start + <span class="number">1</span>, index - <span class="number">1</span>);</span><br><span class="line">    root.right = partition(preorder, index, end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>刚开始 8, 5, 1, 7, 10,12，方法每次执行，确定本次的根节点和左右子树的分界线</li><li>第一次确定根节点为 8，左子树 5, 1, 7，右子树 10, 12</li><li>对 5, 1, 7 做递归操作，确定根节点是 5， 左子树是 1， 右子树是 7</li><li>对 1 做递归操作，确定根节点是 1，左右子树为 null</li><li>对 7 做递归操作，确定根节点是 7，左右子树为 null</li><li>对 10, 12 做递归操作，确定根节点是 10，左子树为 null，右子树为12</li><li>对 12 做递归操作，确定根节点是 12，左右子树为 null</li><li>递归结束，返回本范围内的根节点</li></ul><h4 id="e07.-二叉搜索树的最近公共祖先-leetcode-235">E07.二叉搜索树的最近公共祖先-Leetcode 235</h4><p>要点：若 p，q 在 ancestor 的两侧，则 ancestor就是它们的最近公共祖先</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> {</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">ancestor</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (ancestor.val &gt; p.val &amp;&amp; ancestor.val &gt; q.val || </span><br><span class="line">           ancestor.val &lt; p.val &amp;&amp; ancestor.val &lt; q.val) {</span><br><span class="line">        <span class="keyword">if</span> (ancestor.val &gt; p.val) {</span><br><span class="line">            ancestor = ancestor.left;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            ancestor = ancestor.right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ancestor;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="其它题目-1">其它题目</h4><table><thead><tr class="header"><th>题号</th><th>名称</th></tr></thead><tbody><tr class="odd"><td>Leetcode 236</td><td>二叉树的最近公共祖先</td></tr><tr class="even"><td>Leetcode 114</td><td>二叉树展开为链表</td></tr><tr class="odd"><td>Leetcode 108</td><td>有序数组构造平衡二叉搜索树</td></tr><tr class="even"><td>Leetcode 1382</td><td>二叉搜索树变为平衡</td></tr></tbody></table><h2 id="avl-树">3.3 AVL 树</h2><h3 id="概述-7">概述</h3><h4 id="历史-1">历史</h4><blockquote><p>AVL 树是一种自平衡二叉搜索树，由托尔·哈斯特罗姆在 1960 年提出并在1962 年发表。它的名字来源于发明者的名字：Adelson-Velsky 和Landis，他们是苏联数学家，于 1962 年发表了一篇论文，详细介绍了 AVL树的概念和性质。</p><p>在二叉搜索树中，如果插入的元素按照特定的顺序排列，可能会导致树变得非常不平衡，从而降低搜索、插入和删除的效率。为了解决这个问题，AVL树通过在每个节点中维护一个平衡因子来确保树的平衡。平衡因子是左子树的高度减去右子树的高度。如果平衡因子的绝对值大于等于2，则通过旋转操作来重新平衡树。</p><p>AVL树是用于存储有序数据的一种重要数据结构，它是二叉搜索树的一种改进和扩展。它不仅能够提高搜索、插入和删除操作的效率，而且还能够确保树的深度始终保持在O(log n) 的水平。随着计算机技术的不断发展，AVL树已经成为了许多高效算法和系统中必不可少的一种基础数据结构。</p></blockquote><p>前面介绍过，如果一棵二叉搜索树长的不平衡，那么查询的效率会受到影响，如下图</p><figure><img src="../../../../images/StrJava/image-20230313090500760.png" alt="image-20230313090500760"><figcaption aria-hidden="true">image-20230313090500760</figcaption></figure><p>通过旋转可以让树重新变得平衡，并且不会改变二叉搜索树的性质（即左边仍然小，右边仍然大）</p><figure><img src="../../../../images/StrJava/image-20230313090817485.png" alt="image-20230313090817485"><figcaption aria-hidden="true">image-20230313090817485</figcaption></figure><h4 id="如何判断失衡">如何判断失衡？</h4><blockquote><p>如果一个节点的<strong>左右孩子，高度差超过1</strong>，则此节点失衡，才需要旋转</p></blockquote><h4 id="处理高度">处理高度</h4><p>如何得到节点高度？一种方式之前做过的一道题目：E05.求二叉树的最大深度（高度），但由于求高度是一个非常频繁的操作，因此将高度作为节点的一个属性，将来新增或删除时及时更新，默认为1（按力扣说法）</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AVLNode</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    Object value;</span><br><span class="line">    AVLNode left;</span><br><span class="line">    AVLNode right;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>求高度代码</strong></p><p>这里加入了 height 函数方便求节点为 null 时的高度</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(AVLNode node)</span> {</span><br><span class="line">    <span class="keyword">return</span> node == <span class="literal">null</span> ? <span class="number">0</span> : node.height;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>更新高度代码</strong></p><p>将来新增、删除、旋转时，高度都可能发生变化，需要更新。下面是更新高度的代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateHeight</span><span class="params">(AVLNode node)</span> {</span><br><span class="line">    node.height = Integer.max(height(node.left), height(node.right)) + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="何时触发失衡判断">何时触发失衡判断？</h4><p>定义平衡因子（balance factor）如下 <span class="math display">\[平衡因子 = 左子树高度 - 右子树高度\]</span> 当平衡因子</p><ul><li>bf = 0，1，-1 时，表示左右平衡</li><li>bf &gt; 1 时，表示左边太高</li><li>bf &lt; -1 时，表示右边太高</li></ul><p>对应代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bf</span><span class="params">(AVLNode node)</span> {</span><br><span class="line">    <span class="keyword">return</span> height(node.left) - height(node.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当插入新节点，或删除节点时，引起高度变化时，例如</p><figure><img src="../../../../images/StrJava/image-20230310153645397.png" alt="image-20230310153645397"><figcaption aria-hidden="true">image-20230310153645397</figcaption></figure><p>目前此树平衡，当再插入一个 4 时，节点们的高度都产生了相应的变化，8节点失衡了</p><figure><img src="../../../../images/StrJava/image-20230310153803661.png" alt="image-20230310153803661"><figcaption aria-hidden="true">image-20230310153803661</figcaption></figure><p>在比如说，下面这棵树一开始也是平衡的</p><figure><img src="../../../../images/StrJava/image-20230310154155728.png" alt="image-20230310154155728"><figcaption aria-hidden="true">image-20230310154155728</figcaption></figure><p>当删除节点 8 时，节点们的高度都产生了相应的变化，6 节点失衡了</p><figure><img src="../../../../images/StrJava/image-20230310154232729.png" alt="image-20230310154232729"><figcaption aria-hidden="true">image-20230310154232729</figcaption></figure><h4 id="失衡的四种情况">失衡的四种情况</h4><p><strong>LL</strong></p><figure><img src="../../../../images/StrJava/image-20230310154459709.png" alt="image-20230310154459709"><figcaption aria-hidden="true">image-20230310154459709</figcaption></figure><ul><li>失衡节点（图中 8 红色）的 bf &gt; 1，即左边更高</li><li>失衡节点的左孩子（图中 6）的 bf &gt;= 0即左孩子这边也是左边更高或等高</li></ul><p><strong>LR</strong></p><figure><img src="../../../../images/StrJava/image-20230310154858754.png" alt="image-20230310154858754"><figcaption aria-hidden="true">image-20230310154858754</figcaption></figure><ul><li>失衡节点（图中 8）的 bf &gt; 1，即左边更高</li><li>失衡节点的左孩子（图中 6 红色）的 bf &lt; 0即左孩子这边是右边更高</li></ul><p>对称的还有两种情况</p><p><strong>RL</strong></p><figure><img src="../../../../images/StrJava/image-20230310155048187.png" alt="image-20230310155048187"><figcaption aria-hidden="true">image-20230310155048187</figcaption></figure><ul><li>失衡节点（图中 3）的 bf &lt;-1，即右边更高</li><li>失衡节点的右孩子（图中 6 红色）的 bf &gt;0，即右孩子这边左边更高</li></ul><p><strong>RR</strong></p><figure><img src="../../../../images/StrJava/image-20230310155347349.png" alt="image-20230310155347349"><figcaption aria-hidden="true">image-20230310155347349</figcaption></figure><ul><li>失衡节点（图中 3）的 bf &lt;-1，即右边更高</li><li>失衡节点的右孩子（图中 6 红色）的 bf &lt;=0，即右孩子这边右边更高或等高</li></ul><h3 id="实现-1">实现</h3><h4 id="解决失衡">解决失衡</h4><p>失衡可以通过树的旋转解决。什么是树的旋转呢？它是在不干扰元素顺序的情况下更改结构，通常用来让树的高度变得平衡。</p><p>观察下面一棵二叉搜索树，可以看到，旋转后，并未改变树的左小右大特性，但根、父、孩子节点都发生了变化</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">    4                                   2</span><br><span class="line">   / \             4 right             / \</span><br><span class="line">  2   5      --------------------&gt;    1   4</span><br><span class="line"> / \         &lt;--------------------       / \</span><br><span class="line">1   3              2 left               3   5</span><br></pre></td></tr></tbody></table></figure><p><strong>右旋</strong></p><p>旋转前</p><figure><img src="../../../../images/StrJava/image-20230310162158692.png" alt="image-20230310162158692"><figcaption aria-hidden="true">image-20230310162158692</figcaption></figure><ul><li>红色节点，旧根（失衡节点）</li><li>黄色节点，旧根的左孩子，将来作为新根，旧根是它右孩子</li><li>绿色节点，新根的右孩子，将来要换爹作为旧根的左孩子</li></ul><p>旋转后</p><figure><img src="../../../../images/StrJava/image-20230310162442932.png" alt="image-20230310162442932"><figcaption aria-hidden="true">image-20230310162442932</figcaption></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AVLNode <span class="title function_">rightRotate</span><span class="params">(AVLNode red)</span> {</span><br><span class="line">    <span class="type">AVLNode</span> <span class="variable">yellow</span> <span class="operator">=</span> red.left;</span><br><span class="line">    <span class="type">AVLNode</span> <span class="variable">green</span> <span class="operator">=</span> yellow.right;</span><br><span class="line">    yellow.right = red;</span><br><span class="line">    red.left = green;</span><br><span class="line">    <span class="keyword">return</span> yellow;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>左旋</strong></p><p>旋转前</p><figure><img src="../../../../images/StrJava/image-20230310162945078.png" alt="image-20230310162945078"><figcaption aria-hidden="true">image-20230310162945078</figcaption></figure><ul><li>红色节点，旧根（失衡节点）</li><li>黄色节点，旧根的右孩子，将来作为新根，旧根是它左孩子</li><li>绿色节点，新根的左孩子，将来要换爹作为旧根的右孩子</li></ul><p>旋转后</p><figure><img src="../../../../images/StrJava/image-20230310163019508.png" alt="image-20230310163019508"><figcaption aria-hidden="true">image-20230310163019508</figcaption></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AVLNode <span class="title function_">leftRotate</span><span class="params">(AVLNode red)</span> {</span><br><span class="line">    <span class="type">AVLNode</span> <span class="variable">yellow</span> <span class="operator">=</span> red.right;</span><br><span class="line">    <span class="type">AVLNode</span> <span class="variable">green</span> <span class="operator">=</span> yellow.left;</span><br><span class="line">    yellow.left = red;</span><br><span class="line">    red.right = green;</span><br><span class="line">    <span class="keyword">return</span> yellow;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>左右旋</strong></p><p>指先左旋左子树，再右旋根节点（失衡），这时一次旋转并不能解决失衡</p><figure><img src="../../../../images/StrJava/image-20230310171424362.png" alt="image-20230310171424362"><figcaption aria-hidden="true">image-20230310171424362</figcaption></figure><p>左子树旋转后</p><figure><img src="../../../../images/StrJava/image-20230310171636904.png" alt="image-20230310171636904"><figcaption aria-hidden="true">image-20230310171636904</figcaption></figure><p>根右旋前</p><figure><img src="../../../../images/StrJava/image-20230310171821578.png" alt="image-20230310171821578"><figcaption aria-hidden="true">image-20230310171821578</figcaption></figure><p>根右旋后</p><figure><img src="../../../../images/StrJava/image-20230310171903417.png" alt="image-20230310171903417"><figcaption aria-hidden="true">image-20230310171903417</figcaption></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AVLNode <span class="title function_">leftRightRotate</span><span class="params">(AVLNode root)</span> {</span><br><span class="line">    root.left = leftRotate(root.left);</span><br><span class="line">    <span class="keyword">return</span> rightRotate(root);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>右左旋</strong></p><p>指先右旋右子树，再左旋根节点（失衡）</p><figure><img src="../../../../images/StrJava/image-20230310172212302.png" alt="image-20230310172212302"><figcaption aria-hidden="true">image-20230310172212302</figcaption></figure><p>右子树右旋后</p><figure><img src="../../../../images/StrJava/image-20230310172234154.png" alt="image-20230310172234154"><figcaption aria-hidden="true">image-20230310172234154</figcaption></figure><p>根左旋前</p><figure><img src="../../../../images/StrJava/image-20230310172303012.png" alt="image-20230310172303012"><figcaption aria-hidden="true">image-20230310172303012</figcaption></figure><p>根左旋后</p><figure><img src="../../../../images/StrJava/image-20230310172317379.png" alt="image-20230310172317379"><figcaption aria-hidden="true">image-20230310172317379</figcaption></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AVLNode <span class="title function_">rightLeftRotate</span><span class="params">(AVLNode root)</span> {</span><br><span class="line">    root.right = rightRotate(root.right);</span><br><span class="line">    <span class="keyword">return</span> leftRotate(root);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>判断及调整平衡代码</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> AVLNode <span class="title function_">balance</span><span class="params">(AVLNode node)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">bf</span> <span class="operator">=</span> bf(node);</span><br><span class="line">    <span class="keyword">if</span> (bf &gt; <span class="number">1</span> &amp;&amp; bf(node.left) &gt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (bf &gt; <span class="number">1</span> &amp;&amp; bf(node.left) &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> rightLeftRotate(node);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (bf &lt; -<span class="number">1</span> &amp;&amp; bf(node.right) &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> leftRightRotate(node);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (bf &lt; -<span class="number">1</span> &amp;&amp; bf(node.right) &lt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以上四种旋转代码里，都需要更新高度，需要更新的节点是红色、黄色，而绿色节点高度不变</p><h4 id="新增-1">新增</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, Object value)</span> {</span><br><span class="line">    root = doPut(root, key, value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AVLNode <span class="title function_">doPut</span><span class="params">(AVLNode node, <span class="type">int</span> key, Object value)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AVLNode</span>(key, value);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (key == node.key) {</span><br><span class="line">        node.value = value;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.key) {</span><br><span class="line">        node.left = doPut(node.left, key, value);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        node.right = doPut(node.right, key, value);</span><br><span class="line">    }</span><br><span class="line">    updateHeight(node);</span><br><span class="line">    <span class="keyword">return</span> balance(node);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="删除-1">删除</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    root = doRemove(root, key);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AVLNode <span class="title function_">doRemove</span><span class="params">(AVLNode node, <span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (key &lt; node.key) {</span><br><span class="line">        node.left = doRemove(node.left, key);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (node.key &lt; key) {</span><br><span class="line">        node.right = doRemove(node.right, key);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span>) {</span><br><span class="line">            node = node.right;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>) {</span><br><span class="line">            node = node.left;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">AVLNode</span> <span class="variable">s</span> <span class="operator">=</span> node.right;</span><br><span class="line">            <span class="keyword">while</span> (s.left != <span class="literal">null</span>) {</span><br><span class="line">                s = s.left;</span><br><span class="line">            }</span><br><span class="line">            s.right = doRemove(node.right, s.key);</span><br><span class="line">            s.left = node.left;</span><br><span class="line">            node = s;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    updateHeight(node);</span><br><span class="line">    <span class="keyword">return</span> balance(node);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完整代码备份</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AVLTree</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AVLNode</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        Object value;</span><br><span class="line">        AVLNode left;</span><br><span class="line">        AVLNode right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AVLNode</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AVLNode</span><span class="params">(<span class="type">int</span> key, Object value)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AVLNode</span><span class="params">(<span class="type">int</span> key, Object value, AVLNode left, AVLNode right)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    AVLNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AVLNode <span class="title function_">leftRotate</span><span class="params">(AVLNode p)</span> {</span><br><span class="line">        <span class="type">AVLNode</span> <span class="variable">r</span> <span class="operator">=</span> p.right;</span><br><span class="line">        <span class="type">AVLNode</span> <span class="variable">b</span> <span class="operator">=</span> r.left;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.right = b;</span><br><span class="line">        updateHeight(p);</span><br><span class="line">        updateHeight(r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateHeight</span><span class="params">(AVLNode node)</span> {</span><br><span class="line">        node.height = Integer.max(height(node.left), height(node.right)) + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AVLNode <span class="title function_">rightRotate</span><span class="params">(AVLNode r)</span> {</span><br><span class="line">        <span class="type">AVLNode</span> <span class="variable">a</span> <span class="operator">=</span> r.left;</span><br><span class="line">        <span class="type">AVLNode</span> <span class="variable">b</span> <span class="operator">=</span> a.right;</span><br><span class="line">        a.right = r;</span><br><span class="line">        r.left = b;</span><br><span class="line">        updateHeight(r);</span><br><span class="line">        updateHeight(a);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AVLNode <span class="title function_">leftRightRotate</span><span class="params">(AVLNode p)</span> {</span><br><span class="line">        <span class="type">AVLNode</span> <span class="variable">r</span> <span class="operator">=</span> p.left;</span><br><span class="line">        p.left = leftRotate(r);</span><br><span class="line">        <span class="keyword">return</span> rightRotate(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AVLNode <span class="title function_">rightLeftRotate</span><span class="params">(AVLNode p)</span> {</span><br><span class="line">        <span class="type">AVLNode</span> <span class="variable">r</span> <span class="operator">=</span> p.right;</span><br><span class="line">        p.right = rightRotate(r);</span><br><span class="line">        <span class="keyword">return</span> leftRotate(p);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(AVLNode node)</span> {</span><br><span class="line">        <span class="keyword">return</span> node == <span class="literal">null</span> ? <span class="number">0</span> : node.height;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        root = doRemove(root, key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AVLNode <span class="title function_">doRemove</span><span class="params">(AVLNode node, <span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (key &lt; node.key) {</span><br><span class="line">            node.left = doRemove(node.left, key);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (node.key &lt; key) {</span><br><span class="line">            node.right = doRemove(node.right, key);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span>) {</span><br><span class="line">                node = node.right;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>) {</span><br><span class="line">                node = node.left;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="type">AVLNode</span> <span class="variable">s</span> <span class="operator">=</span> node.right;</span><br><span class="line">                <span class="keyword">while</span> (s.left != <span class="literal">null</span>) {</span><br><span class="line">                    s = s.left;</span><br><span class="line">                }</span><br><span class="line">                s.right = doRemove(node.right, s.key);</span><br><span class="line">                s.left = node.left;</span><br><span class="line">                node = s;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        updateHeight(node);</span><br><span class="line">        <span class="keyword">return</span> balance(node);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, Object value)</span> {</span><br><span class="line">        root = doPut(root, key, value);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AVLNode <span class="title function_">doPut</span><span class="params">(AVLNode node, <span class="type">int</span> key, Object value)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AVLNode</span>(key, value);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (key == node.key) {</span><br><span class="line">            node.value = value;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (key &lt; node.key) {</span><br><span class="line">            node.left = doPut(node.left, key, value);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            node.right = doPut(node.right, key, value);</span><br><span class="line">        }</span><br><span class="line">        updateHeight(node);</span><br><span class="line">        <span class="keyword">return</span> balance(node);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">bf</span><span class="params">(AVLNode node)</span> {</span><br><span class="line">        <span class="keyword">return</span> height(node.left) - height(node.right);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AVLNode <span class="title function_">balance</span><span class="params">(AVLNode node)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">bf</span> <span class="operator">=</span> bf(node);</span><br><span class="line">        <span class="keyword">if</span> (bf &gt; <span class="number">1</span> &amp;&amp; bf(node.left) &gt;= <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (bf &gt; <span class="number">1</span> &amp;&amp; bf(node.left) &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> rightLeftRotate(node);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (bf &lt; -<span class="number">1</span> &amp;&amp; bf(node.right) &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> leftRightRotate(node);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (bf &lt; -<span class="number">1</span> &amp;&amp; bf(node.right) &lt;= <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="小结-2">小结</h4><p>AVL树的优点：</p><ol type="1"><li>AVL树是一种自平衡树，保证了树的高度平衡，从而保证了树的查询和插入操作的时间复杂度均为O(logn)。</li><li>相比于一般二叉搜索树，AVL树对查询效率的提升更为显著，因为其左右子树高度的差值不会超过1，避免了二叉搜索树退化为链表的情况，使得整棵树的高度更低。</li><li>AVL树的删除操作比较简单，只需要像插入一样旋转即可，在旋转过程中树的平衡性可以得到维护。</li></ol><p>AVL树的缺点：</p><ol type="1"><li>AVL树每次插入或删除节点时需要进行旋转操作，这个操作比较耗时，因此在一些应用中不太适用。</li><li>在AVL树进行插入或删除操作时，为保持树的平衡需要不断进行旋转操作，在一些高并发环节和大数据量环境下，这可能会导致多余的写锁导致性能瓶颈。</li><li>AVL树的旋转操作相对较多，因此在一些应用中可能会造成较大的空间浪费。</li></ol><h2 id="红黑树">3.4 红黑树</h2><h3 id="概述-8">概述</h3><h4 id="历史-2">历史</h4><blockquote><p>红黑树是一种自平衡二叉查找树，最早由一位名叫RudolfBayer的德国计算机科学家于1972年发明。然而，最初的树形结构不是现在的红黑树，而是一种称为B树的结构，它是一种多叉树，可用于在磁盘上存储大量数据。</p><p>在1980年代早期，计算机科学家Leonard Adleman和DanielSleator推广了红黑树，并证明了它的自平衡性和高效性。从那时起，红黑树成为了最流行的自平衡二叉查找树之一，并被广泛应用于许多领域，如编译器、操作系统、数据库等。</p><p>红黑树的名字来源于红色节点和黑色节点的交替出现，它们的颜色是用来维护树的平衡性的关键。它们的颜色具有特殊的意义，黑色节点代表普通节点，而红色节点代表一个新添加的节点，它们必须满足一些特定的规则才能维持树的平衡性。</p></blockquote><p>红黑树也是一种自平衡的二叉搜索树，较之AVL，插入和删除时旋转次数更少</p><h4 id="红黑树特性">红黑树特性</h4><ol type="1"><li>所有节点都有两种颜色：红<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>、黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>所有 null 视为黑色<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>红色<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>节点不能相邻</li><li>根节点是黑色<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>从根到任意一个叶子节点，路径中的黑色<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>节点数一样</li></ol><h3 id="实现-2">实现</h3><h4 id="插入情况">插入情况</h4><p>插入节点均视为红色<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>case 1：插入节点为根节点，将根节点变黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>case2：插入节点的父亲若为黑色<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，树的红黑性质不变，无需调整</p><p>插入节点的父亲为红色<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，触发红红相邻</p><p>case 3：叔叔为红色<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><ul><li><p>父亲变为黑色<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，为了保证黑色平衡，连带的叔叔也变为黑色<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></li><li><p>祖父如果是黑色不变，会造成这颗子树黑色过多，因此祖父节点变为红色<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></li><li><p>祖父如果变成红色，可能会接着触发红红相邻，因此对将祖父进行递归调整</p></li></ul><p>case 4：叔叔为黑色<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><ol type="1"><li>父亲为左孩子，插入节点也是左孩子，此时即 LL 不平衡<ul><li>让父亲变黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，为了保证这颗子树黑色不变，将祖父变成红<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，但叔叔子树少了一个黑色</li><li>祖父右旋，补齐一个黑色给叔叔，父亲旋转上去取代祖父，由于它是黑色，不会再次触发红红相邻</li></ul></li><li>父亲为左孩子，插入节点是右孩子，此时即 LR 不平衡<ul><li>父亲左旋，变成 LL 情况，按 1. 来后续处理</li></ul></li><li>父亲为右孩子，插入节点也是右孩子，此时即 RR 不平衡<ul><li>让父亲变黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，为了保证这颗子树黑色不变，将祖父变成红<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，但叔叔子树少了一个黑色</li><li>祖父左旋，补齐一个黑色给叔叔，父亲旋转上去取代祖父，由于它是黑色，不会再次触发红红相邻</li></ul></li><li>父亲为右孩子，插入节点是左孩子，此时即 RL 不平衡<ul><li>父亲右旋，变成 RR 情况，按 3. 来后续处理</li></ul></li></ol><h4 id="删除情况">删除情况</h4><p>case0：如果删除节点有两个孩子</p><ul><li>交换删除节点和后继节点的key，value，递归删除后继节点，直到该节点没有孩子或只剩一个孩子</li></ul><p>如果删除节点没有孩子或只剩一个孩子</p><p>case 1：删的是根节点</p><ul><li>删完了，直接将 root = null</li><li>用剩余节点替换了根节点的 key，value，根节点孩子 =null，颜色保持黑色<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>不变</li></ul><p>删黑色会失衡，删红色不会失衡，但删黑色有一种简单情况</p><p>case2：删的是黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，剩下的是红<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，剩下这个红节点变黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>删除节点和剩下节点都是黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，触发双黑，双黑意思是，<strong>少了一个黑</strong></p><p>case 3：被调整节点的兄弟为红<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，此时两个侄子定为黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><ul><li>删除节点是左孩子，父亲左旋</li><li>删除节点是右孩子，父亲右旋</li><li>父亲和兄弟要变色，保证旋转后颜色平衡</li><li>旋转的目的是让黑侄子变为删除节点的黑兄弟，对删除节点再次递归，进入case 4 或 case 5</li></ul><p>case 4：被调整节点的兄弟为黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，两个侄子都为黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><ul><li>将兄弟变红<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，目的是将删除节点和兄弟那边的黑色高度同时减少1</li><li>如果父亲是红<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，则需将父亲变为黑，避免红红，此时路径黑节点数目不变</li><li>如果父亲是黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，说明这条路径还是少黑，再次让父节点触发双黑</li></ul><p>case5：被调整节点的兄弟为黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，至少一个红<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>侄子</p><ul><li>如果兄弟是左孩子，左侄子是红<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，LL 不平衡<ul><li>将来删除节点这边少个黑，所以最后旋转过来的父亲需要变成黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，平衡起见，左侄子也是黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>原来兄弟要成为父亲，需要保留父亲颜色</li></ul></li><li>如果兄弟是左孩子，右侄子是红<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，LR 不平衡<ul><li>将来删除节点这边少个黑，所以最后旋转过来的父亲需要变成黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>右侄子会取代原来父亲，因此它保留父亲颜色</li><li>兄弟已经是黑了<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，无需改变</li></ul></li><li>如果兄弟是右孩子，右侄子是红<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，RR 不平衡<ul><li>将来删除节点这边少个黑，所以最后旋转过来的父亲需要变成黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，平衡起见，右侄子也是黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>原来兄弟要成为父亲，需要保留父亲颜色</li></ul></li><li>如果兄弟是右孩子，左侄子是红<span class="github-emoji"><span>🔴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f534.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，RL 不平衡<ul><li>将来删除节点这边少个黑，所以最后旋转过来的父亲需要变成黑<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>左侄子会取代原来父亲，因此它保留父亲颜色</li><li>兄弟已经是黑了<span class="github-emoji"><span>⚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，无需改变</li></ul></li></ul><h4 id="完整代码">完整代码</h4><p></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.datastructure.redblacktree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.itheima.datastructure.redblacktree.RedBlackTree.Color.BLACK;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.itheima.datastructure.redblacktree.RedBlackTree.Color.RED;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;红黑树&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedBlackTree</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Color</span> {</span><br><span class="line">        RED, BLACK;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        Object value;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        Node parent;        <span class="comment">// 父节点</span></span><br><span class="line">        <span class="type">Color</span> <span class="variable">color</span> <span class="operator">=</span> RED;  <span class="comment">// 颜色</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, Object value)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, Color color)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.color = color;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, Color color, Node left, Node right)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.color = color;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">null</span>) {</span><br><span class="line">                left.parent = <span class="built_in">this</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">null</span>) {</span><br><span class="line">                right.parent = <span class="built_in">this</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否是左孩子</span></span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">isLeftChild</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> parent != <span class="literal">null</span> &amp;&amp; parent.left == <span class="built_in">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 叔叔</span></span><br><span class="line">        Node <span class="title function_">uncle</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">if</span> (parent == <span class="literal">null</span> || parent.parent == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (parent.isLeftChild()) {</span><br><span class="line">                <span class="keyword">return</span> parent.parent.right;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> parent.parent.left;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 兄弟</span></span><br><span class="line">        Node <span class="title function_">sibling</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">if</span> (parent == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isLeftChild()) {</span><br><span class="line">                <span class="keyword">return</span> parent.right;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> parent.left;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断红</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRed</span><span class="params">(Node node)</span> {</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">null</span> &amp;&amp; node.color == RED;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断黑</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isBlack</span><span class="params">(Node node)</span> {</span><br><span class="line"><span class="comment">//        return !isRed(node);</span></span><br><span class="line">        <span class="keyword">return</span> node == <span class="literal">null</span> || node.color == BLACK;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右旋 1. parent 的处理 2. 旋转后新根的父子关系</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rightRotate</span><span class="params">(Node pink)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> pink.parent;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">yellow</span> <span class="operator">=</span> pink.left;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">green</span> <span class="operator">=</span> yellow.right;</span><br><span class="line">        <span class="keyword">if</span> (green != <span class="literal">null</span>) {</span><br><span class="line">            green.parent = pink;</span><br><span class="line">        }</span><br><span class="line">        yellow.right = pink;</span><br><span class="line">        yellow.parent = parent;</span><br><span class="line">        pink.left = green;</span><br><span class="line">        pink.parent = yellow;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">null</span>) {</span><br><span class="line">            root = yellow;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (parent.left == pink) {</span><br><span class="line">            parent.left = yellow;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            parent.right = yellow;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左旋</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">leftRotate</span><span class="params">(Node pink)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> pink.parent;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">yellow</span> <span class="operator">=</span> pink.right;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">green</span> <span class="operator">=</span> yellow.left;</span><br><span class="line">        <span class="keyword">if</span> (green != <span class="literal">null</span>) {</span><br><span class="line">            green.parent = pink;</span><br><span class="line">        }</span><br><span class="line">        yellow.left = pink;</span><br><span class="line">        yellow.parent = parent;</span><br><span class="line">        pink.right = green;</span><br><span class="line">        pink.parent = yellow;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">null</span>) {</span><br><span class="line">            root = yellow;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (parent.left == pink) {</span><br><span class="line">            parent.left = yellow;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            parent.right = yellow;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增或更新</span></span><br><span class="line"><span class="comment">     * &lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 正常增、遇到红红不平衡进行调整</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, Object value)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            parent = p;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; p.key) {</span><br><span class="line">                p = p.left;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (p.key &lt; key) {</span><br><span class="line">                p = p.right;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                p.value = value; <span class="comment">// 更新</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">inserted</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">null</span>) {</span><br><span class="line">            root = inserted;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; parent.key) {</span><br><span class="line">            parent.left = inserted;</span><br><span class="line">            inserted.parent = parent;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            parent.right = inserted;</span><br><span class="line">            inserted.parent = parent;</span><br><span class="line">        }</span><br><span class="line">        fixRedRed(inserted);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fixRedRed</span><span class="params">(Node x)</span> {</span><br><span class="line">        <span class="comment">// case 1 插入节点是根节点，变黑即可</span></span><br><span class="line">        <span class="keyword">if</span> (x == root) {</span><br><span class="line">            x.color = BLACK;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// case 2 插入节点父亲是黑色，无需调整</span></span><br><span class="line">        <span class="keyword">if</span> (isBlack(x.parent)) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">/* case 3 当红红相邻，叔叔为红时</span></span><br><span class="line"><span class="comment">            需要将父亲、叔叔变黑、祖父变红，然后对祖父做递归处理</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> x.parent;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">uncle</span> <span class="operator">=</span> x.uncle();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">grandparent</span> <span class="operator">=</span> parent.parent;</span><br><span class="line">        <span class="keyword">if</span> (isRed(uncle)) {</span><br><span class="line">            parent.color = BLACK;</span><br><span class="line">            uncle.color = BLACK;</span><br><span class="line">            grandparent.color = RED;</span><br><span class="line">            fixRedRed(grandparent);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// case 4 当红红相邻，叔叔为黑时</span></span><br><span class="line">        <span class="keyword">if</span> (parent.isLeftChild() &amp;&amp; x.isLeftChild()) { <span class="comment">// LL</span></span><br><span class="line">            parent.color = BLACK;</span><br><span class="line">            grandparent.color = RED;</span><br><span class="line">            rightRotate(grandparent);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (parent.isLeftChild()) { <span class="comment">// LR</span></span><br><span class="line">            leftRotate(parent);</span><br><span class="line">            x.color = BLACK;</span><br><span class="line">            grandparent.color = RED;</span><br><span class="line">            rightRotate(grandparent);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (!x.isLeftChild()) { <span class="comment">// RR</span></span><br><span class="line">            parent.color = BLACK;</span><br><span class="line">            grandparent.color = RED;</span><br><span class="line">            leftRotate(grandparent);</span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">// RL</span></span><br><span class="line">            rightRotate(parent);</span><br><span class="line">            x.color = BLACK;</span><br><span class="line">            grandparent.color = RED;</span><br><span class="line">            leftRotate(grandparent);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除</span></span><br><span class="line"><span class="comment">     * &lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 正常删、会用到李代桃僵技巧、遇到黑黑不平衡进行调整</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">deleted</span> <span class="operator">=</span> find(key);</span><br><span class="line">        <span class="keyword">if</span> (deleted == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        doRemove(deleted);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="keyword">return</span> find(key) != <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找删除节点</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">find</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (key &lt; p.key) {</span><br><span class="line">                p = p.left;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (p.key &lt; key) {</span><br><span class="line">                p = p.right;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找剩余节点</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findReplaced</span><span class="params">(Node deleted)</span> {</span><br><span class="line">        <span class="keyword">if</span> (deleted.left == <span class="literal">null</span> &amp;&amp; deleted.right == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (deleted.left == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> deleted.right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (deleted.right == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> deleted.left;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> deleted.right;</span><br><span class="line">        <span class="keyword">while</span> (s.left != <span class="literal">null</span>) {</span><br><span class="line">            s = s.left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理双黑 (case3、case4、case5)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixDoubleBlack</span><span class="params">(Node x)</span> {</span><br><span class="line">        <span class="keyword">if</span> (x == root) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> x.parent;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">sibling</span> <span class="operator">=</span> x.sibling();</span><br><span class="line">        <span class="comment">// case 3 兄弟节点是红色</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(sibling)) {</span><br><span class="line">            <span class="keyword">if</span> (x.isLeftChild()) {</span><br><span class="line">                leftRotate(parent);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                rightRotate(parent);</span><br><span class="line">            }</span><br><span class="line">            parent.color = RED;</span><br><span class="line">            sibling.color = BLACK;</span><br><span class="line">            fixDoubleBlack(x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (sibling != <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// case 4 兄弟是黑色, 两个侄子也是黑色</span></span><br><span class="line">            <span class="keyword">if</span> (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) {</span><br><span class="line">                sibling.color = RED;</span><br><span class="line">                <span class="keyword">if</span> (isRed(parent)) {</span><br><span class="line">                    parent.color = BLACK;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    fixDoubleBlack(parent);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// case 5 兄弟是黑色, 侄子有红色</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// LL</span></span><br><span class="line">                <span class="keyword">if</span> (sibling.isLeftChild() &amp;&amp; isRed(sibling.left)) {</span><br><span class="line">                    rightRotate(parent);</span><br><span class="line">                    sibling.left.color = BLACK;</span><br><span class="line">                    sibling.color = parent.color;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// LR</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sibling.isLeftChild() &amp;&amp; isRed(sibling.right)) {</span><br><span class="line">                    sibling.right.color = parent.color;</span><br><span class="line">                    leftRotate(sibling);</span><br><span class="line">                    rightRotate(parent);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// RL</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!sibling.isLeftChild() &amp;&amp; isRed(sibling.left)) {</span><br><span class="line">                    sibling.left.color = parent.color;</span><br><span class="line">                    rightRotate(sibling);</span><br><span class="line">                    leftRotate(parent);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// RR</span></span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    leftRotate(parent);</span><br><span class="line">                    sibling.right.color = BLACK;</span><br><span class="line">                    sibling.color = parent.color;</span><br><span class="line">                }</span><br><span class="line">                parent.color = BLACK;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// @TODO 实际也不会出现，触发双黑后，兄弟节点不会为 null</span></span><br><span class="line">            fixDoubleBlack(parent);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doRemove</span><span class="params">(Node deleted)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">replaced</span> <span class="operator">=</span> findReplaced(deleted);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> deleted.parent;</span><br><span class="line">        <span class="comment">// 没有孩子</span></span><br><span class="line">        <span class="keyword">if</span> (replaced == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// case 1 删除的是根节点</span></span><br><span class="line">            <span class="keyword">if</span> (deleted == root) {</span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (isBlack(deleted)) {</span><br><span class="line">                    <span class="comment">// 双黑调整</span></span><br><span class="line">                    fixDoubleBlack(deleted);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// 红色叶子, 无需任何处理</span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (deleted.isLeftChild()) {</span><br><span class="line">                    parent.left = <span class="literal">null</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    parent.right = <span class="literal">null</span>;</span><br><span class="line">                }</span><br><span class="line">                deleted.parent = <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 有一个孩子</span></span><br><span class="line">        <span class="keyword">if</span> (deleted.left == <span class="literal">null</span> || deleted.right == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// case 1 删除的是根节点</span></span><br><span class="line">            <span class="keyword">if</span> (deleted == root) {</span><br><span class="line">                root.key = replaced.key;</span><br><span class="line">                root.value = replaced.value;</span><br><span class="line">                root.left = root.right = <span class="literal">null</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (deleted.isLeftChild()) {</span><br><span class="line">                    parent.left = replaced;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    parent.right = replaced;</span><br><span class="line">                }</span><br><span class="line">                replaced.parent = parent;</span><br><span class="line">                deleted.left = deleted.right = deleted.parent = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (isBlack(deleted) &amp;&amp; isBlack(replaced)) {</span><br><span class="line">                    <span class="comment">// @TODO 实际不会有这种情况 因为只有一个孩子时 被删除节点是黑色 那么剩余节点只能是红色不会触发双黑</span></span><br><span class="line">                    fixDoubleBlack(replaced);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// case 2 删除是黑，剩下是红</span></span><br><span class="line">                    replaced.color = BLACK;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// case 0 有两个孩子 =&gt; 有一个孩子 或 没有孩子</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> deleted.key;</span><br><span class="line">        deleted.key = replaced.key;</span><br><span class="line">        replaced.key = t;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> deleted.value;</span><br><span class="line">        deleted.value = replaced.value;</span><br><span class="line">        replaced.value = v;</span><br><span class="line">        doRemove(replaced);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>以上代码中的 TODO 未作改正</li></ul><h4 id="小结-3">小结</h4><table style="width:100%;"><colgroup><col style="width: 16%"><col style="width: 28%"><col style="width: 19%"><col style="width: 35%"></colgroup><thead><tr class="header"><th>维度</th><th>普通二叉搜索树</th><th>AVL树</th><th>红黑树</th></tr></thead><tbody><tr class="odd"><td>查询</td><td>平均O(logn)，最坏O(n)</td><td>O(logn)</td><td>O(logn)</td></tr><tr class="even"><td>插入</td><td>平均O(logn)，最坏O(n)</td><td>O(logn)</td><td>O(logn)</td></tr><tr class="odd"><td>删除</td><td>平均O(logn)，最坏O(n)</td><td>O(logn)</td><td>O(logn)</td></tr><tr class="even"><td>平衡性</td><td>不平衡</td><td>严格平衡</td><td>近似平衡</td></tr><tr class="odd"><td>结构</td><td>二叉树</td><td>自平衡的二叉树</td><td>具有红黑性质的自平衡二叉树</td></tr><tr class="even"><td>查找效率</td><td>低</td><td>高</td><td>高</td></tr><tr class="odd"><td>插入删除效率</td><td>低</td><td>中等</td><td>高</td></tr></tbody></table><p>普通二叉搜索树插入、删除、查询的时间复杂度与树的高度相关，因此在最坏情况下，时间复杂度为O(n)，而且容易退化成链表，查找效率低。</p><p>AVL树是一种高度平衡的二叉搜索树，其左右子树的高度差不超过1。因此，它能够在logn的平均时间内完成插入、删除、查询操作，但是在维护平衡的过程中，需要频繁地进行旋转操作，导致插入删除效率较低。</p><p>红黑树是一种近似平衡的二叉搜索树，它在保持高度平衡的同时，又能够保持较高的插入删除效率。红黑树通过节点着色和旋转操作来维护平衡。红黑树在维护平衡的过程中，能够进行较少的节点旋转操作，因此插入删除效率较高，并且查询效率也较高。</p><p>综上所述，红黑树具有较高的综合性能，是一种广泛应用的数据结构。</p><h2 id="b-树">3.5 B 树</h2><p>ai 问题列表</p><p>请用中文回答：B-树历史</p><p>请用中文回答：100万的数据使用 avl 树来存储，树高是多少?</p><p>请用中文回答：100万的数据，如果存储到B-树(最小度数是500)，那么树高大约是多少?</p><p>请用中文回答：B-树的特性有哪些？</p><h3 id="概述-9">概述</h3><h4 id="历史-3">历史</h4><blockquote><p>B树（B-Tree）结构是一种高效存储和查询数据的方法，它的历史可以追溯到1970年代早期。B树的发明人RudolfBayer和Edward M.McCreight分别发表了一篇论文介绍了B树。这篇论文是1972年发表于《ACMTransactions on Database Systems》中的，题目为"Organization andMaintenance of Large Ordered Indexes"。</p><p>这篇论文提出了一种能够高效地维护大型有序索引的方法，这种方法的主要思想是将每个节点扩展成多个子节点，以减少查找所需的次数。B树结构非常适合应用于磁盘等大型存储器的高效操作，被广泛应用于关系数据库和文件系统中。</p><p>B树结构有很多变种和升级版，例如B+树，B*树和SB树等。这些变种和升级版本都基于B树的核心思想，通过调整B树的参数和结构，提高了B树在不同场景下的性能表现。</p><p>总的来说，B树结构是一个非常重要的数据结构，为高效存储和查询大量数据提供了可靠的方法。它的历史可以追溯到上个世纪70年代，而且在今天仍然被广泛应用于各种场景。</p></blockquote><h4 id="b-的含义">B 的含义</h4><blockquote><p>B-树的名称是由其发明者RudolfBayer提出的。Bayer和McCreight从未解释B代表什么，人们提出了许多可能的解释，比如Boeing、balanced、between、broad、bushy和Bayer等。但McCreight表示，越是思考B-trees中的B代表什么，就越能更好地理解B-trees</p></blockquote><h4 id="特性-1">特性</h4><p>一棵 B-树具有以下性质</p><p>特性1：每个节点 x 具有</p><ul><li>属性 n，表示节点 x 中 key 的个数</li><li>属性 leaf，表示节点是否是叶子节点</li><li>节点 key 可以有多个，以升序存储</li></ul><p>特性2：每个非叶子节点中的孩子数是 n + 1、叶子节点没有孩子</p><p>特性3：最小度数t（节点的孩子数称为度）和节点中键数量的关系如下：</p><table><thead><tr class="header"><th>最小度数t</th><th>键数量范围</th></tr></thead><tbody><tr class="odd"><td>2</td><td>1 ~ 3</td></tr><tr class="even"><td>3</td><td>2 ~ 5</td></tr><tr class="odd"><td>4</td><td>3 ~ 7</td></tr><tr class="even"><td>...</td><td>...</td></tr><tr class="odd"><td>n</td><td>(n-1) ~ (2n-1)</td></tr></tbody></table><p>其中，当节点中键数量达到其最大值时，即 3、5、7 ... 2n-1，需要分裂</p><p>特性4：叶子节点的深度都相同</p><blockquote><p>问：</p><p>B-树为什么有最小度数的限制？</p><p>答：</p><p>B树中有最小度数的限制是为了保证B树的平衡特性。</p><p>在B树中，每个节点都可以有多个子节点，这使得B树可以存储大量的键值，但也带来了一些问题。如果节点的子节点数量太少，那么就可能导致B树的高度过高，从而降低了B树的效率。此外，如果节点的子节点数量太多，那么就可能导致节点的搜索、插入和删除操作变得复杂和低效。</p><p>最小度数的限制通过限制节点的子节点数量，来平衡这些问题。在B树中，每个节点的子节点数量都必须在一定的范围内，即t到2t之间（其中t为最小度数）</p></blockquote><h4 id="b-树与-2-3-树2-3-4-树的关系">B-树与 2-3 树、2-3-4 树的关系</h4><p>可以这样总结它们之间的关系：</p><ol type="1"><li>2-3树是最小度数为2的B树，其中每个节点可以包含2个或3个子节点。</li><li>2-3-4树是最小度数为2的B树的一种特殊情况，其中每个节点可以包含2个、3个或4个子节点。</li><li>B树是一种更加一般化的平衡树，可以适应不同的应用场景，其节点可以包含任意数量的键值，节点的度数取决于最小度数t的设定。</li></ol><h3 id="实现-3">实现</h3><h4 id="定义节点-1">定义节点</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">leaf</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> keyNumber;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="type">int</span>[] keys;</span><br><span class="line">    Node[] children;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> t)</span> {</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">        <span class="built_in">this</span>.keys = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * t - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">2</span> * t];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(Arrays.copyOfRange(keys, <span class="number">0</span>, keyNumber));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>leaf 表示是否为叶子节点</li><li>keyNumber 为 keys 中有效 key 数目</li><li>t 为最小度数，它决定了节点中key 的最小、最大数目，分别是 t-1 和2t-1</li><li>keys 存储此节点的 key</li><li>children 存储此节点的 child</li><li>toString 只是为了方便调试和测试，非必须</li></ul><blockquote><p>实际 keys 应当改为 entries 以便同时保存 key 和value，刚开始简化实现</p></blockquote><h4 id="多路查找">多路查找</h4><p>为上面节点类添加 get 方法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Node <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; keyNumber &amp;&amp; keys[i] &lt; key) {</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (i &lt; keyNumber &amp;&amp; keys[i] == key) {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (leaf) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> children[i].get(key);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="插入-key-和-child">插入 key 和 child</h4><p>为上面节点类添加 insertKey 和 insertChild 方法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">insertKey</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> index)</span> {</span><br><span class="line">    System.arraycopy(keys, index, keys, index + <span class="number">1</span>, keyNumber - index);</span><br><span class="line">    keys[index] = key;</span><br><span class="line">    keyNumber++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insertChild</span><span class="params">(Node child, <span class="type">int</span> index)</span> {</span><br><span class="line">    System.arraycopy(children, index, children, index + <span class="number">1</span>, keyNumber - index);</span><br><span class="line">    children[index] = child;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>作用是向 keys 数组或 children 数组指定 index 处插入新数据，注意</p><ul><li>由于使用了静态数组，并且不会在新增或删除时改变它的大小，因此需要额外的keyNumber 来指定数组内有效 key 的数目<ul><li>插入时 keyNumber++</li><li>删除时减少 keyNumber 的值即可</li></ul></li><li>children 不会单独维护数目，它比 keys 多一个</li><li>如果这两个方法同时调用，注意它们的先后顺序，insertChild后调用，因为它计算复制元素个数时用到了 keyNumber</li></ul><h4 id="定义树">定义树</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BTree</span> {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> t;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> MIN_KEY_NUMBER;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> MAX_KEY_NUMBER;</span><br><span class="line">    Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BTree</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BTree</span><span class="params">(<span class="type">int</span> t)</span> {</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">        MIN_KEY_NUMBER = t - <span class="number">1</span>;</span><br><span class="line">        MAX_KEY_NUMBER = <span class="number">2</span> * t - <span class="number">1</span>;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>(t);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="插入">插入</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">    doPut(<span class="literal">null</span>, <span class="number">0</span>, root, key);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doPut</span><span class="params">(Node parent, <span class="type">int</span> index, Node node, <span class="type">int</span> key)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; node.keyNumber &amp;&amp; node.keys[i] &lt; key) {</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (i &lt; node.keyNumber &amp;&amp; node.keys[i] == key) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (node.leaf) {</span><br><span class="line">        node.insertKey(key, i);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        doPut(node, i, node.children[i], key);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (isFull(node)) {</span><br><span class="line">        split(parent, index, node);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>首先查找本节点中的插入位置 i，如果没有空位（key被找到），应该走更新的逻辑，目前什么没做</li><li>接下来分两种情况<ul><li>如果节点是叶子节点，可以直接插入了</li><li>如果节点是非叶子节点，需要继续在 children[i] 处继续递归插入</li></ul></li><li>无论哪种情况，插入完成后都可能超过节点 keys数目限制，此时应当执行节点分裂<ul><li>参数中的 parent 和 index都是给分裂方法用的，代表当前节点父节点，和分裂节点是第几个孩子</li></ul></li></ul><p>判断依据为：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">(Node node)</span> {</span><br><span class="line">    <span class="keyword">return</span> node.keyNumber == MAX_KEY_NUMBER;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="分裂">分裂</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">split</span><span class="params">(Node parent, <span class="type">int</span> index , Node left)</span> {</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">null</span>) {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newRoot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="built_in">this</span>.t);</span><br><span class="line">        newRoot.leaf = <span class="literal">false</span>;</span><br><span class="line">        newRoot.insertChild(root, <span class="number">0</span>);</span><br><span class="line">        root = newRoot;</span><br><span class="line">        parent = newRoot;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">Node</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="built_in">this</span>.t);</span><br><span class="line">    right.leaf = left.leaf;</span><br><span class="line">    right.keyNumber = t - <span class="number">1</span>;</span><br><span class="line">    System.arraycopy(left.keys, t, right.keys, <span class="number">0</span>, t - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!left.leaf) {</span><br><span class="line">        System.arraycopy(left.children, t, right.children, <span class="number">0</span>, t);</span><br><span class="line">    }</span><br><span class="line">    left.keyNumber = t - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left.keys[t - <span class="number">1</span>];</span><br><span class="line">    parent.insertKey(mid, index);</span><br><span class="line">    parent.insertChild(right, index + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>分两种情况：</p><ul><li>如果 parent == null表示要分裂的是根节点，此时需要创建新根，原来的根节点作为新根的 0孩子</li><li>否则<ul><li>创建 right 节点（分裂后大于当前 left 节点的），把 t 以后的 key 和child 都拷贝过去</li><li>t-1 处的 key 插入到 parent 的 index 处，index 指 left作为孩子时的索引</li><li>right 节点作为 parent 的孩子插入到 index + 1 处</li></ul></li></ul><h4 id="删除-2">删除</h4><p>case 1：当前节点是叶子节点，没找到</p><p>case 2：当前节点是叶子节点，找到了</p><p>case 3：当前节点是非叶子节点，没找到</p><p>case 4：当前节点是非叶子节点，找到了</p><p>case 5：删除后 key 数目 &lt; 下限（不平衡）</p><p>case 6：根节点</p><h4 id="完整代码-1">完整代码</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.algorithm.btree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;B-树&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings("all")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BTree</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">        <span class="type">int</span>[] keys; <span class="comment">// 关键字</span></span><br><span class="line">        Node[] children; <span class="comment">// 孩子</span></span><br><span class="line">        <span class="type">int</span> keyNumber; <span class="comment">// 有效关键字数目</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">leaf</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 是否是叶子节点</span></span><br><span class="line">        <span class="type">int</span> t; <span class="comment">// 最小度数 (最小孩子数)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> t)</span> { <span class="comment">// t&gt;=2</span></span><br><span class="line">            <span class="built_in">this</span>.t = t;</span><br><span class="line">            <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">2</span> * t];</span><br><span class="line">            <span class="built_in">this</span>.keys = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span> * t - <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span>[] keys)</span> {</span><br><span class="line">            <span class="built_in">this</span>.keys = keys;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> Arrays.toString(Arrays.copyOfRange(keys, <span class="number">0</span>, keyNumber));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多路查找</span></span><br><span class="line">        Node <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; keyNumber) {</span><br><span class="line">                <span class="keyword">if</span> (keys[i] == key) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (keys[i] &gt; key) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 执行到此时 keys[i]&gt;key 或 i==keyNumber</span></span><br><span class="line">            <span class="keyword">if</span> (leaf) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 非叶子情况</span></span><br><span class="line">            <span class="keyword">return</span> children[i].get(key);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向 keys 指定索引处插入 key</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">insertKey</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> index)</span> {</span><br><span class="line">            System.arraycopy(keys, index, keys, index + <span class="number">1</span>, keyNumber - index);</span><br><span class="line">            keys[index] = key;</span><br><span class="line">            keyNumber++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向 children 指定索引处插入 child</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">insertChild</span><span class="params">(Node child, <span class="type">int</span> index)</span> {</span><br><span class="line">            System.arraycopy(children, index, children, index + <span class="number">1</span>, keyNumber - index);</span><br><span class="line">            children[index] = child;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">removeKey</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> keys[index];</span><br><span class="line">            System.arraycopy(keys, index + <span class="number">1</span>, keys, index, --keyNumber - index);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">removeLeftmostKey</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> removeKey(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">removeRightmostKey</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> removeKey(keyNumber - <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node <span class="title function_">removeChild</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> children[index];</span><br><span class="line">            System.arraycopy(children, index + <span class="number">1</span>, children, index, keyNumber - index);</span><br><span class="line">            children[keyNumber] = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node <span class="title function_">removeLeftmostChild</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> removeChild(<span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node <span class="title function_">removeRightmostChild</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> removeChild(keyNumber);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">moveToLeft</span><span class="params">(Node left)</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> left.keyNumber;</span><br><span class="line">            <span class="keyword">if</span> (!leaf) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= keyNumber; i++) {</span><br><span class="line">                    left.children[start + i] = children[i];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; keyNumber; i++) {</span><br><span class="line">                left.keys[left.keyNumber++] = keys[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node <span class="title function_">leftSibling</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">            <span class="keyword">return</span> index &gt; <span class="number">0</span> ? children[index - <span class="number">1</span>] : <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node <span class="title function_">rightSibling</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">            <span class="keyword">return</span> index == keyNumber ? <span class="literal">null</span> : children[index + <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Node root;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t; <span class="comment">// 树中节点最小度数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> MIN_KEY_NUMBER; <span class="comment">// 最小key数目</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> MAX_KEY_NUMBER; <span class="comment">// 最大key数目</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BTree</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BTree</span><span class="params">(<span class="type">int</span> t)</span> {</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>(t);</span><br><span class="line">        MAX_KEY_NUMBER = <span class="number">2</span> * t - <span class="number">1</span>;</span><br><span class="line">        MIN_KEY_NUMBER = t - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 是否存在</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="keyword">return</span> root.get(key) != <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 新增</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        doPut(root, key, <span class="literal">null</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doPut</span><span class="params">(Node node, <span class="type">int</span> key, Node parent, <span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; node.keyNumber) {</span><br><span class="line">            <span class="keyword">if</span> (node.keys[i] == key) {</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 更新</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.keys[i] &gt; key) {</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 找到了插入位置，即为此时的 i</span></span><br><span class="line">            }</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.leaf) {</span><br><span class="line">            node.insertKey(key, i);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            doPut(node.children[i], key, node, i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.keyNumber == MAX_KEY_NUMBER) {</span><br><span class="line">            split(node, parent, index);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h3&gt;分裂方法&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left   要分裂的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent 分裂节点的父节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index  分裂节点是第几个孩子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(Node left, Node parent, <span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="comment">// 分裂的是根节点</span></span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newRoot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(t);</span><br><span class="line">            newRoot.leaf = <span class="literal">false</span>;</span><br><span class="line">            newRoot.insertChild(left, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">this</span>.root = newRoot;</span><br><span class="line">            parent = newRoot;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 1. 创建 right 节点，把 left 中 t 之后的 key 和 child 移动过去</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(t);</span><br><span class="line">        right.leaf = left.leaf;</span><br><span class="line">        System.arraycopy(left.keys, t, right.keys, <span class="number">0</span>, t - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 分裂节点是非叶子的情况</span></span><br><span class="line">        <span class="keyword">if</span> (!left.leaf) {</span><br><span class="line">            System.arraycopy(left.children, t, right.children, <span class="number">0</span>, t);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> t; i &lt;= left.keyNumber; i++) {</span><br><span class="line">                left.children[i] = <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        right.keyNumber = t - <span class="number">1</span>;</span><br><span class="line">        left.keyNumber = t - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 2. 中间的 key （t-1 处）插入到父节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left.keys[t - <span class="number">1</span>];</span><br><span class="line">        parent.insertKey(mid, index);</span><br><span class="line">        <span class="comment">// 3. right 节点作为父节点的孩子</span></span><br><span class="line">        parent.insertChild(right, index + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 删除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        doRemove(root, key, <span class="literal">null</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doRemove</span><span class="params">(Node node, <span class="type">int</span> key, Node parent, <span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; node.keyNumber) {</span><br><span class="line">            <span class="keyword">if</span> (node.keys[i] &gt;= key) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.leaf) {</span><br><span class="line">            <span class="keyword">if</span> (notFound(node, key, i)) { <span class="comment">// case 1</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            node.removeKey(i);  <span class="comment">// case 2</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (notFound(node, key, i)) { <span class="comment">// case 3</span></span><br><span class="line">                doRemove(node.children[i], key, node, i);</span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// case 4</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.children[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">while</span> (!s.leaf) {</span><br><span class="line">                    s = s.children[<span class="number">0</span>];</span><br><span class="line">                }</span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> s.keys[<span class="number">0</span>];</span><br><span class="line">                node.keys[i] = k;</span><br><span class="line">                doRemove(node.children[i + <span class="number">1</span>], k, node, i + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.keyNumber &lt; MIN_KEY_NUMBER) { <span class="comment">// case 5</span></span><br><span class="line">            balance(node, parent, index);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">notFound</span><span class="params">(Node node, <span class="type">int</span> key, <span class="type">int</span> i)</span> {</span><br><span class="line">        <span class="keyword">return</span> i &gt;= node.keyNumber || (i &lt; node.keyNumber &amp;&amp; node.keys[i] != key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">balance</span><span class="params">(Node node, Node parent, <span class="type">int</span> i)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node == root) {</span><br><span class="line">            <span class="keyword">if</span> (root.keyNumber == <span class="number">0</span> &amp;&amp; root.children[<span class="number">0</span>] != <span class="literal">null</span>) {</span><br><span class="line">                root = root.children[<span class="number">0</span>];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">leftSibling</span> <span class="operator">=</span> parent.leftSibling(i);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">rightSibling</span> <span class="operator">=</span> parent.rightSibling(i);</span><br><span class="line">        <span class="keyword">if</span> (leftSibling != <span class="literal">null</span> &amp;&amp; leftSibling.keyNumber &gt; MIN_KEY_NUMBER) {</span><br><span class="line">            rightRotate(node, leftSibling, parent, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (rightSibling != <span class="literal">null</span> &amp;&amp; rightSibling.keyNumber &gt; MIN_KEY_NUMBER) {</span><br><span class="line">            leftRotate(node, rightSibling, parent, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (leftSibling != <span class="literal">null</span>) {</span><br><span class="line">            mergeToLeft(leftSibling, parent, i - <span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            mergeToLeft(node, parent, i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeToLeft</span><span class="params">(Node left, Node parent, <span class="type">int</span> i)</span> {</span><br><span class="line">        <span class="type">Node</span> <span class="variable">right</span> <span class="operator">=</span> parent.removeChild(i + <span class="number">1</span>);</span><br><span class="line">        left.insertKey(parent.removeKey(i), left.keyNumber);</span><br><span class="line">        right.moveToLeft(left);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rightRotate</span><span class="params">(Node node, Node leftSibling, Node parent, <span class="type">int</span> i)</span> {</span><br><span class="line">        node.insertKey(parent.keys[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!leftSibling.leaf) {</span><br><span class="line">            node.insertChild(leftSibling.removeRightmostChild(), <span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line">        parent.keys[i - <span class="number">1</span>] = leftSibling.removeRightmostKey();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">leftRotate</span><span class="params">(Node node, Node rightSibling, Node parent, <span class="type">int</span> i)</span> {</span><br><span class="line">        node.insertKey(parent.keys[i], node.keyNumber);</span><br><span class="line">        <span class="keyword">if</span> (!rightSibling.leaf) {</span><br><span class="line">            node.insertChild(rightSibling.removeLeftmostChild(), node.keyNumber + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        parent.keys[i] = rightSibling.removeLeftmostKey();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="哈希表">3.6 哈希表</h2><h3 id="第一版">第一版</h3><p>未考虑 hash 码的生成，假定该 hash 码由我们提供</p><p></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashTable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> {</span><br><span class="line">        <span class="type">int</span> hash; <span class="comment">// 哈希码</span></span><br><span class="line">        Object key; <span class="comment">// 键</span></span><br><span class="line">        Object value; <span class="comment">// 值</span></span><br><span class="line">        Entry next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Entry</span><span class="params">(<span class="type">int</span> hash, Object key, Object value)</span> {</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Entry[] table = <span class="keyword">new</span> <span class="title class_">Entry</span>[<span class="number">16</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="type">float</span> <span class="variable">loadFactor</span> <span class="operator">=</span> <span class="number">0.75f</span>; <span class="comment">// 12 阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> (<span class="type">int</span>) (loadFactor * table.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 求模运算替换为位运算</span></span><br><span class="line"><span class="comment">        - 前提：数组长度是 2 的 n 次方</span></span><br><span class="line"><span class="comment">        - hash % 数组长度 等价于 hash &amp; (数组长度-1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 hash 码获取 value</span></span><br><span class="line">    Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> hash, Object key)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> hash &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (table[idx] == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">p</span> <span class="operator">=</span> table[idx];</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (p.key.equals(key)) {</span><br><span class="line">                <span class="keyword">return</span> p.value;</span><br><span class="line">            }</span><br><span class="line">            p = p.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 hash 表存入新 key value，如果 key 重复，则更新 value</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> hash, Object key, Object value)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> hash &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (table[idx] == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 1. idx 处有空位, 直接新增</span></span><br><span class="line">            table[idx] = <span class="keyword">new</span> <span class="title class_">Entry</span>(hash, key, value);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 2. idx 处无空位, 沿链表查找 有重复key更新，否则新增</span></span><br><span class="line">            <span class="type">Entry</span> <span class="variable">p</span> <span class="operator">=</span> table[idx];</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                <span class="keyword">if</span> (p.key.equals(key)) {</span><br><span class="line">                    p.value = value; <span class="comment">// 更新</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (p.next == <span class="literal">null</span>) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                p = p.next;</span><br><span class="line">            }</span><br><span class="line">            p.next = <span class="keyword">new</span> <span class="title class_">Entry</span>(hash, key, value); <span class="comment">// 新增</span></span><br><span class="line">        }</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; threshold) {</span><br><span class="line">            resize();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> {</span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[table.length &lt;&lt; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; table.length; i++) {</span><br><span class="line">            <span class="type">Entry</span> <span class="variable">p</span> <span class="operator">=</span> table[i]; <span class="comment">// 拿到每个链表头</span></span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                拆分链表，移动到新数组，拆分规律</span></span><br><span class="line"><span class="comment">                * 一个链表最多拆成两个</span></span><br><span class="line"><span class="comment">                * hash &amp; table.length == 0 的一组</span></span><br><span class="line"><span class="comment">                * hash &amp; table.length != 0 的一组</span></span><br><span class="line"><span class="comment">                                          p</span></span><br><span class="line"><span class="comment">                0-&gt;8-&gt;16-&gt;24-&gt;32-&gt;40-&gt;48-&gt;null</span></span><br><span class="line"><span class="comment">                            a</span></span><br><span class="line"><span class="comment">                0-&gt;16-&gt;32-&gt;48-&gt;null</span></span><br><span class="line"><span class="comment">                        b</span></span><br><span class="line"><span class="comment">                8-&gt;24-&gt;40-&gt;null</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">                <span class="type">Entry</span> <span class="variable">a</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">Entry</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">Entry</span> <span class="variable">aHead</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">Entry</span> <span class="variable">bHead</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">                    <span class="keyword">if</span> ((p.hash &amp; table.length) == <span class="number">0</span>) {</span><br><span class="line">                        <span class="keyword">if</span> (a != <span class="literal">null</span>) {</span><br><span class="line">                            a.next = p;</span><br><span class="line">                        } <span class="keyword">else</span> {</span><br><span class="line">                            aHead = p;</span><br><span class="line">                        }</span><br><span class="line">                        a = p; <span class="comment">// 分配到a</span></span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        <span class="keyword">if</span> (b != <span class="literal">null</span>) {</span><br><span class="line">                            b.next = p;</span><br><span class="line">                        } <span class="keyword">else</span> {</span><br><span class="line">                            bHead = p;</span><br><span class="line">                        }</span><br><span class="line">                        b = p; <span class="comment">// 分配到b</span></span><br><span class="line">                    }</span><br><span class="line">                    p = p.next;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 规律： a 链表保持索引位置不变，b 链表索引位置+table.length</span></span><br><span class="line">                <span class="keyword">if</span> (a != <span class="literal">null</span>) {</span><br><span class="line">                    a.next = <span class="literal">null</span>;</span><br><span class="line">                    newTable[i] = aHead;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (b != <span class="literal">null</span>) {</span><br><span class="line">                    b.next = <span class="literal">null</span>;</span><br><span class="line">                    newTable[i + table.length] = bHead;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (<span class="type">int</span>) (loadFactor * table.length);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 hash 码删除，返回删除的 value</span></span><br><span class="line">    Object <span class="title function_">remove</span><span class="params">(<span class="type">int</span> hash, Object key)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> hash &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (table[idx] == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">p</span> <span class="operator">=</span> table[idx];</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (p.key.equals(key)) {</span><br><span class="line">                <span class="comment">// 找到了, 删除</span></span><br><span class="line">                <span class="keyword">if</span> (prev == <span class="literal">null</span>) { <span class="comment">// 链表头</span></span><br><span class="line">                    table[idx] = p.next;</span><br><span class="line">                } <span class="keyword">else</span> { <span class="comment">// 非链表头</span></span><br><span class="line">                    prev.next = p.next;</span><br><span class="line">                }</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">return</span> p.value;</span><br><span class="line">            }</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="生成-hashcode">生成 hashCode</h3><figure><img src="../../../../images/StrJava/image-20230424083655435.png" alt="image-20230424083655435"><figcaption aria-hidden="true">image-20230424083655435</figcaption></figure><p>hash算法是将任意对象，分配一个<strong>编号</strong>的过程，其中编号是一个有限范围内的数字（如int 范围内）</p><figure><img src="../../../../images/StrJava/image-20230424090603325.png" alt="image-20230424090603325"><figcaption aria-hidden="true">image-20230424090603325</figcaption></figure><p><strong>Object.hashCode</strong></p><ul><li>Object 的 hashCode 方法默认是生成随机数作为 hash值（会缓存在对象头当中）</li><li>缺点是包含相同<strong>值</strong>的不同对象，他们的 hashCode不一样，不能够用 hash值来反映对象的<strong>值</strong>特征，因此诸多子类都会重写 hashCode方法</li></ul><p><strong>String.hashCode</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">"bac"</span>;                     </span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"abc"</span>);         </span><br><span class="line"></span><br><span class="line">    System.out.println(s1.hashCode());</span><br><span class="line">    System.out.println(s2.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原则：值相同的字符串生成相同的 hash 码, 尽量让值不同的字符串生成不同的 hash 码</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对于 abc  a * 100 + b * 10 + c</span></span><br><span class="line"><span class="comment">    对于 bac  b * 100 + a * 10 + c</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s1.length(); i++) {</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s1.charAt(i);</span><br><span class="line">        System.out.println((<span class="type">int</span>) c);</span><br><span class="line">        <span class="comment">// (a*10 + b)*10 + c  ==&gt;  a*100 + b*10 + c  2^5</span></span><br><span class="line">        hash = (hash &lt;&lt; <span class="number">5</span>) - hash + c;     </span><br><span class="line">    }</span><br><span class="line">    System.out.println(hash);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>经验表明如果每次乘的是较大质数，可以有更好地降低 hash冲突，因此改【乘 10】为【乘 31】</li><li>【乘 31】可以等价为【乘 32 - hash】，进一步可以转为更高效地【左移5位- hash】</li></ul><p><strong>检查 hash 表的分散性</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[table.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; table.length; i++) {</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">p</span> <span class="operator">=</span> table[i];</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            sum[i]++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    System.out.println(Arrays.toString(sum));</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, Long&gt; result = Arrays.stream(sum).boxed()</span><br><span class="line">        .collect(Collectors.groupingBy(s -&gt; s, Collectors.counting()));</span><br><span class="line">    System.out.println(result);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 测试 Object.hashCode</span></span><br><span class="line">    <span class="type">HashTable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashTable</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200000</span>; i++) {</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        table.put(obj, obj);</span><br><span class="line">    }</span><br><span class="line">    table.print();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试 String.hashCode</span></span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">HashTable</span>();</span><br><span class="line">    List&lt;String&gt; strings = Files.readAllLines(Path.of(<span class="string">"words"</span>));</span><br><span class="line">    <span class="keyword">for</span> (String string : strings) {</span><br><span class="line">        table.put(string, string);</span><br><span class="line">    }</span><br><span class="line">    table.print();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>MurmurHash</strong></p><figure><img src="../../../../images/StrJava/image-20230425084247888.png" alt="image-20230425084247888"><figcaption aria-hidden="true">image-20230425084247888</figcaption></figure><h3 id="思考">思考</h3><ol type="1"><li>我们的代码里使用了尾插法，如果改成头插法呢？</li><li>JDK 的 HashMap 中采用了将对象 hashCode高低位相互异或的方式减少冲突，怎么理解</li><li>我们的 HashTable 中表格容量是 2 的 n次方，很多优化都是基于这个前提，能否不用 2 的 n 次方作为表格容量？</li><li>JDK 的 HashMap 在链表长度过长会转换成红黑树，对此你怎么看</li></ol><h3 id="习题-10">习题</h3><h4 id="e01.-两数之和-leetcode-1">E01. 两数之和-Leetcode 1</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E01Leetcode1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) {</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(k)) {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]{i, map.get(k)};</span><br><span class="line">            }</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 不会执行</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>注意：题目明确说明<strong>只会存在一个有效答案</strong>，因此不会执行到最后的return null</li></ul><h4 id="e02.-无重复字符的最长字串-leetcode-3">E02.无重复字符的最长字串-Leetcode 3</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> {</span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>; end &lt; s.length(); end++) {</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(end);</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(ch)) { <span class="comment">// 重复时调整 begin</span></span><br><span class="line">            begin = Math.max(begin, map.get(ch) + <span class="number">1</span>);</span><br><span class="line">            map.put(ch, end);</span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">// 不重复</span></span><br><span class="line">            map.put(ch, end);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(s.substring(begin, end + <span class="number">1</span>));</span><br><span class="line">        maxLength = Math.max(maxLength, end - begin + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>begin 调整时的解释，遇到重复的 begin 应该向右调整，例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">abca</span><br></pre></td></tr></tbody></table></figure><ul><li>遇到重复的 a，这时 begin 应该调整到上个重复字符 a 索引加 1 处，即map.get('a') + 1 = 1，</li></ul><p>但还有一种情况需要考虑，就是连续遇到两次重复，例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">abba</span><br></pre></td></tr></tbody></table></figure><ul><li>遇到重复的 b，这时 begin 应该调整到上个重复字符 b 索引加 1 处，即map.get('b') + 1 = 2</li><li>不过接下来，又遇到了重复的 a，此时若还执行 map.get('a') + 1 = 1，则begin 相当于向左退了，不对</li><li>应该是 Math.max(2, map.get('a') + 1)，即 begin应该是两个重复字符索引中更靠右者</li></ul><p>题目中说明 s由英文字母、数字、符号和空格组成，因此它的范围是有限的（在 0 ~127之内），可以用数组来替代 HashMap 优化，如下</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> {</span><br><span class="line">    <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">    Arrays.fill(map, -<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>; end &lt; s.length(); end++) {</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(end);</span><br><span class="line">        <span class="keyword">if</span> (map[ch] != -<span class="number">1</span>) { <span class="comment">// 重复时调整 begin</span></span><br><span class="line">            begin = Math.max(begin, map[ch] + <span class="number">1</span>);</span><br><span class="line">            map[ch] = end;</span><br><span class="line">        } <span class="keyword">else</span> { <span class="comment">// 不重复</span></span><br><span class="line">            map[ch] = end;</span><br><span class="line">        }</span><br><span class="line">        System.out.println(s.substring(begin, end + <span class="number">1</span>));</span><br><span class="line">        maxLength = Math.max(maxLength, end - begin + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e03.-字母异位词分组-leetcode-49">E03. 字母异位词分组-Leetcode49</h4><p>解法1</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> {</span><br><span class="line">    HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) {</span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">        List&lt;String&gt; strings = map.computeIfAbsent(key, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        strings.add(str);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解法2</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ArrayKey</span> {</span><br><span class="line">    <span class="type">int</span>[] key = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayKey</span><span class="params">(String str)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) {</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">            key[ch - <span class="string">'a'</span>]++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayKey</span> <span class="variable">arrayKey</span> <span class="operator">=</span> (ArrayKey) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(key, arrayKey.key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> Arrays.hashCode(key);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> {</span><br><span class="line">    HashMap&lt;ArrayKey, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) {</span><br><span class="line">        List&lt;String&gt; strings = map.computeIfAbsent(<span class="keyword">new</span> <span class="title class_">ArrayKey</span>(str), k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        strings.add(str);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e04.-判断有没有重复元素-leetcode-217">E04.判断有没有重复元素-Leetcode 217</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> { <span class="comment">// 5ms</span></span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> key : nums) {</span><br><span class="line">        <span class="keyword">if</span> (!set.add(key)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e05.-找出出现一次的数字-leetcode-136">E05.找出出现一次的数字-Leetcode 136</h4><p>解法1：用 HashSet</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) {</span><br><span class="line">        <span class="keyword">if</span> (!set.add(num)) {</span><br><span class="line">            set.remove(num);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> set.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">0</span>])[<span class="number">0</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解法2：用 xor</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) {</span><br><span class="line">        num = num ^ nums[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e06.-判断字母异位词-leetcode-242">E06. 判断字母异位词-Leetcode242</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> { <span class="comment">// 1ms</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.equals(getKey(s), getKey(t));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] getKey(String s) {</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : chars) {</span><br><span class="line">        array[ch - <span class="number">97</span>]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>其中用 s.toCharArray() 性能明显高于用 s.charAt() 一个个获取字符</li></ul><h4 id="e07.-第一个不重复字符-leetcode-387">E07.第一个不重复字符-Leetcode 387</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> {</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : chars) {</span><br><span class="line">        array[ch-<span class="number">97</span>]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) {</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> chars[i];</span><br><span class="line">        <span class="keyword">if</span> (array[ch - <span class="number">97</span>] == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e08.-出现次数最多的单词-leetcode-819">E08.出现次数最多的单词-Leetcode 819</h4><p>简洁解法 14 ms</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">mostCommonWord</span><span class="params">(String paragraph, String[] banned)</span> {</span><br><span class="line">    Set&lt;String&gt; banSet = Set.of(banned);</span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">String[] split = paragraph.toLowerCase().split(<span class="string">"[^A-Za-z]+"</span>);</span><br><span class="line">    <span class="keyword">for</span> (String key : split) {</span><br><span class="line">        <span class="keyword">if</span>(banSet.contains(key)) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        map.compute(key, (k, v) -&gt; v == <span class="literal">null</span> ? <span class="number">1</span> : v + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">Optional&lt;Map.Entry&lt;String, Integer&gt;&gt; optional = map.entrySet().stream().max(Map.Entry.comparingByValue());</span><br><span class="line">    <span class="keyword">return</span> optional.map(Map.Entry::getKey).orElse(<span class="literal">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>后两行避免 lambda，12 ms</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">mostCommonWord</span><span class="params">(String paragraph, String[] banned)</span> {</span><br><span class="line">    Set&lt;String&gt; banSet = Set.of(banned);</span><br><span class="line">    String[] split = paragraph.toLowerCase().split(<span class="string">"[^A-Za-z]+"</span>);</span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String key : split) {</span><br><span class="line">        <span class="keyword">if</span>(banSet.contains(key)) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        map.compute(key, (k, v) -&gt; v == <span class="literal">null</span> ? <span class="number">1</span> : v + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">maxKey</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; e : map.entrySet()) {</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">        <span class="keyword">if</span> (value &gt; max) {</span><br><span class="line">            max = value;</span><br><span class="line">            maxKey = e.getKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxKey;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>避免正则匹配 5ms</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">mostCommonWord</span><span class="params">(String paragraph, String[] banned)</span> {</span><br><span class="line">    Set&lt;String&gt; banSet = Set.of(banned);</span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[] chars = paragraph.toLowerCase().toCharArray();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : chars) {</span><br><span class="line">        <span class="keyword">if</span> (ch &gt;= <span class="string">'a'</span> &amp;&amp; ch &lt;= <span class="string">'z'</span>) {</span><br><span class="line">            sb.append(ch);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            put(banSet, map, sb);</span><br><span class="line">            sb = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    put(banSet, map, sb);</span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">maxKey</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; e : map.entrySet()) {</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">        <span class="keyword">if</span> (value &gt; max) {</span><br><span class="line">            max = value;</span><br><span class="line">            maxKey = e.getKey();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxKey;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Set&lt;String&gt; banSet, HashMap&lt;String, Integer&gt; map, StringBuilder sb)</span> {</span><br><span class="line">    <span class="keyword">if</span> (sb.length() &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        <span class="keyword">if</span>(!banSet.contains(key)) {</span><br><span class="line">            map.compute(key, (k, v) -&gt; v == <span class="literal">null</span> ? <span class="number">1</span> : v + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>sb 避免每次新建 4ms</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">sb.setLength(<span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure><h4 id="e09.-根据前序与中序遍历结果构造二叉树-leetcode105-improved">E09.根据前序与中序遍历结果构造二叉树-Leetcode105 Improved</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E09Leetcode105Improved</span> {</span><br><span class="line">    <span class="comment">//  用 hashmap 改善查找性能，其中 key 是 inOrder 值， value 是 inOrder 索引</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preOrder, <span class="type">int</span>[] inOrder)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inOrder.length; i++) {</span><br><span class="line">            map.put(inOrder[i], i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> helper(preOrder, <span class="number">0</span>, <span class="number">0</span>, inOrder.length - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// preBegin 决定了每次在 preOrder 中找到根元素</span></span><br><span class="line">    <span class="comment">// inBegin 和 inEnd 可以用来获取区间内元素个数，结束递归等</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">helper</span><span class="params">(<span class="type">int</span>[] preOrder, <span class="type">int</span> preBegin, <span class="type">int</span> inBegin, <span class="type">int</span> inEnd)</span> {</span><br><span class="line">        <span class="keyword">if</span> (inBegin &gt; inEnd) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootValue</span> <span class="operator">=</span> preOrder[preBegin];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootValue);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> map.get(rootValue);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> i - inBegin;</span><br><span class="line">        System.out.println(<span class="string">"元素："</span> + rootValue + <span class="string">" left["</span> + (preBegin + <span class="number">1</span>) + <span class="string">"] inOrder 索引范围["</span> + inBegin + <span class="string">"~"</span> + (i - <span class="number">1</span>) + <span class="string">"]"</span>);</span><br><span class="line">        System.out.println(<span class="string">"元素："</span> + rootValue + <span class="string">" right["</span> + (preBegin + <span class="number">1</span> + leftSize) + <span class="string">"] inOrder 索引范围["</span> + (i + <span class="number">1</span>) + <span class="string">"~"</span> + inEnd + <span class="string">"]"</span>);</span><br><span class="line">        root.left = helper(preOrder, preBegin + <span class="number">1</span>, inBegin, i - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(preOrder, preBegin + <span class="number">1</span> + leftSize, i + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] preOrder = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>};</span><br><span class="line">        <span class="type">int</span>[] inOrder = {<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>};</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        例如：</span></span><br><span class="line"><span class="comment">        根据根节点[1] 到中序遍历数组中一分为2，首次递归</span></span><br><span class="line"><span class="comment">            [1] 2  4  3  6  7  前</span></span><br><span class="line"><span class="comment">            0   1  2  3  4  5  前索引</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            4  2  [1] 6  3  7  中</span></span><br><span class="line"><span class="comment">            0  1  2   3  4  5  中索引</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            确定 preOrder 中 left 和 right 的递归起始索引，当然也要确定 inOrder 对应的两个索引位置</span></span><br><span class="line"><span class="comment">                left    right</span></span><br><span class="line"><span class="comment">            1   [2]  4  [3]  6  7  前</span></span><br><span class="line"><span class="comment">            0   1    2  3    4  5  前索引</span></span><br><span class="line"><span class="comment">            left  inOrder 索引范围： 0~1</span></span><br><span class="line"><span class="comment">            right inOrder 索引范围： 3~5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E09Leetcode105Improved</span>().buildTree(preOrder, inOrder);</span><br><span class="line">        System.out.println(root);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e10.-根据中序与后序遍历结果构造二叉树-leetcode106-improved">E10.根据中序与后序遍历结果构造二叉树-Leetcode106 Improved</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E10Leetcode106Improved</span> {</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inOrder, <span class="type">int</span>[] postOrder)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inOrder.length; i++) {</span><br><span class="line">            map.put(inOrder[i], i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> helper(postOrder, postOrder.length - <span class="number">1</span>, <span class="number">0</span>, inOrder.length - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        inOrder = {4,2,1,6,3,7}</span></span><br><span class="line"><span class="comment">        postOrder = {4,2,6,7,3,1}</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">helper</span><span class="params">(<span class="type">int</span>[] postOrder, <span class="type">int</span> postEnd, <span class="type">int</span> inBegin, <span class="type">int</span> inEnd)</span> {</span><br><span class="line">        <span class="keyword">if</span> (inBegin &gt; inEnd) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootValue</span> <span class="operator">=</span> postOrder[postEnd];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootValue);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> map.get(rootValue);</span><br><span class="line"><span class="comment">//        int leftSize = i - inBegin;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightSize</span> <span class="operator">=</span> inEnd - i;</span><br><span class="line">        System.out.println(<span class="string">"元素："</span> + rootValue + <span class="string">" left["</span> + (postEnd - <span class="number">1</span> - rightSize) + <span class="string">"] inOrder 索引范围["</span> + inBegin + <span class="string">"~"</span> + (i - <span class="number">1</span>) + <span class="string">"]"</span>);</span><br><span class="line">        System.out.println(<span class="string">"元素："</span> + rootValue + <span class="string">" right["</span> + (postEnd - <span class="number">1</span>) + <span class="string">"] inOrder 索引范围["</span> + (i + <span class="number">1</span>) + <span class="string">"~"</span> + inEnd + <span class="string">"]"</span>);</span><br><span class="line">        root.left = helper(postOrder, postEnd - <span class="number">1</span> - rightSize, inBegin, i - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(postOrder, postEnd - <span class="number">1</span>, i + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] postOrder = {<span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>};</span><br><span class="line">        <span class="type">int</span>[] inOrder = {<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>};</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E10Leetcode106Improved</span>().buildTree(inOrder, postOrder);</span><br><span class="line">        System.out.println(root);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="排序算法">3.7 排序算法</h2><h3 id="概述-10">概述</h3><h4 id="比较排序算法">比较排序算法</h4><table><colgroup><col style="width: 3%"><col style="width: 9%"><col style="width: 9%"><col style="width: 9%"><col style="width: 6%"><col style="width: 3%"><col style="width: 3%"><col style="width: 55%"></colgroup><thead><tr class="header"><th style="text-align: center;">算法</th><th style="text-align: center;">最好</th><th style="text-align: center;">最坏</th><th style="text-align: center;">平均</th><th style="text-align: center;">空间</th><th style="text-align: center;">稳定</th><th style="text-align: center;">思想</th><th style="text-align: center;">注意事项</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">冒泡</td><td style="text-align: center;">O(n)</td><td style="text-align: center;">O(<span class="math inline">\(n^2\)</span>)</td><td style="text-align: center;">O(<span class="math inline">\(n^2\)</span>)</td><td style="text-align: center;">O(1)</td><td style="text-align: center;">Y</td><td style="text-align: center;">比较</td><td style="text-align: center;">最好情况需要额外判断</td></tr><tr class="even"><td style="text-align: center;">选择</td><td style="text-align: center;">O(<span class="math inline">\(n^2\)</span>)</td><td style="text-align: center;">O(<span class="math inline">\(n^2\)</span>)</td><td style="text-align: center;">O(<span class="math inline">\(n^2\)</span>)</td><td style="text-align: center;">O(1)</td><td style="text-align: center;">N</td><td style="text-align: center;">比较</td><td style="text-align: center;">交换次数一般少于冒泡</td></tr><tr class="odd"><td style="text-align: center;">堆</td><td style="text-align: center;">O(<span class="math inline">\(nlogn\)</span>)</td><td style="text-align: center;">O(<span class="math inline">\(nlogn\)</span>)</td><td style="text-align: center;">O(<span class="math inline">\(nlogn\)</span>)</td><td style="text-align: center;">O(1)</td><td style="text-align: center;">N</td><td style="text-align: center;">选择</td><td style="text-align: center;">堆排序的辅助性较强，理解前先理解堆的数据结构</td></tr><tr class="even"><td style="text-align: center;">插入</td><td style="text-align: center;">O(n)</td><td style="text-align: center;">O(<span class="math inline">\(n^2\)</span>)</td><td style="text-align: center;">O(<span class="math inline">\(n^2\)</span>)</td><td style="text-align: center;">O(1)</td><td style="text-align: center;">Y</td><td style="text-align: center;">比较</td><td style="text-align: center;">插入排序对于近乎有序的数据处理速度比较快，复杂度有所下降，可以提前结束</td></tr><tr class="odd"><td style="text-align: center;">希尔</td><td style="text-align: center;">O(nlogn)</td><td style="text-align: center;">O(<span class="math inline">\(n^2\)</span>)</td><td style="text-align: center;">O(<span class="math inline">\(nlogn\)</span>)</td><td style="text-align: center;">O(1)</td><td style="text-align: center;">N</td><td style="text-align: center;">插入</td><td style="text-align: center;">gap序列的构造有多种方式，不同方式处理的数据复杂度可能不同</td></tr><tr class="even"><td style="text-align: center;">归并</td><td style="text-align: center;">O(<span class="math inline">\(nlogn\)</span>)</td><td style="text-align: center;">O(<span class="math inline">\(nlogn\)</span>)</td><td style="text-align: center;">O(<span class="math inline">\(nlogn\)</span>)</td><td style="text-align: center;">O(n)</td><td style="text-align: center;">Y</td><td style="text-align: center;">分治</td><td style="text-align: center;">需要额外的O(n)的存储空间</td></tr><tr class="odd"><td style="text-align: center;">快速</td><td style="text-align: center;">O(<span class="math inline">\(nlogn\)</span>)</td><td style="text-align: center;">O(<span class="math inline">\(n^2\)</span>)</td><td style="text-align: center;">O(<span class="math inline">\(nlogn\)</span>)</td><td style="text-align: center;">O(logn)</td><td style="text-align: center;">N</td><td style="text-align: center;">分治</td><td style="text-align: center;">快排可能存在最坏情况，需要把枢轴值选取得尽量随机化来缓解最坏情况下的时间复杂度</td></tr></tbody></table><h4 id="非比较排序算法">非比较排序算法</h4><table><thead><tr class="header"><th>非比较排序算法</th><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr class="odd"><td>计数排序</td><td>O(n+k)</td><td>O(n+k)</td><td>稳定</td></tr><tr class="even"><td>桶排序</td><td>O(n+k)</td><td>O(n+k)</td><td>稳定</td></tr><tr class="odd"><td>基数排序</td><td>O(d*(n+k))</td><td>O(n+k)</td><td>稳定</td></tr></tbody></table><p>其中</p><ul><li>n 是数组长度</li><li>k 是桶长度</li><li>d 是基数位数</li></ul><h4 id="稳定-vs-不稳定">稳定 vs 不稳定</h4><figure><img src="../../../../images/StrJava/stability_playing_cards.svg.png" alt="stability_playing_cards.svg"><figcaption aria-hidden="true">stability_playing_cards.svg</figcaption></figure><h4 id="java-中的排序">Java 中的排序</h4><p>Arrays.sort</p><p>JDK 7~13 中的排序实现</p><table><colgroup><col style="width: 32%"><col style="width: 46%"><col style="width: 21%"></colgroup><thead><tr class="header"><th>排序目标</th><th>条件</th><th>采用算法</th></tr></thead><tbody><tr class="odd"><td>int[] long[] float[] double[]</td><td>size &lt; 47</td><td>混合插入排序 (pair)</td></tr><tr class="even"><td></td><td>size &lt; 286</td><td>双基准点快排</td></tr><tr class="odd"><td></td><td>有序度低</td><td>双基准点快排</td></tr><tr class="even"><td></td><td>有序度高</td><td>归并排序</td></tr><tr class="odd"><td>byte[]</td><td>size &lt;= 29</td><td>插入排序</td></tr><tr class="even"><td></td><td>size &gt; 29</td><td>计数排序</td></tr><tr class="odd"><td>char[] short[]</td><td>size &lt; 47</td><td>插入排序</td></tr><tr class="even"><td></td><td>size &lt; 286</td><td>双基准点快排</td></tr><tr class="odd"><td></td><td>有序度低</td><td>双基准点快排</td></tr><tr class="even"><td></td><td>有序度高</td><td>归并排序</td></tr><tr class="odd"><td></td><td>size &gt; 3200</td><td>计数排序</td></tr><tr class="even"><td>Object[]</td><td>-Djava.util.Arrays.useLegacyMergeSort=true</td><td>传统归并排序</td></tr><tr class="odd"><td></td><td></td><td>TimSort</td></tr></tbody></table><p>JDK 14~20 中的排序实现</p><table><colgroup><col style="width: 31%"><col style="width: 48%"><col style="width: 19%"></colgroup><thead><tr class="header"><th>排序目标</th><th>条件</th><th>采用算法</th></tr></thead><tbody><tr class="odd"><td>int[] long[] float[] double[]</td><td>size &lt; 44 并位于最左侧</td><td>插入排序</td></tr><tr class="even"><td></td><td>size &lt; 65 并不是最左侧</td><td>混合插入排序 (pin)</td></tr><tr class="odd"><td></td><td>有序度低</td><td>双基准点快排</td></tr><tr class="even"><td></td><td>递归次数超过 384</td><td>堆排序</td></tr><tr class="odd"><td></td><td>对于整个数组或非最左侧 size &gt; 4096，有序度高</td><td>归并排序</td></tr><tr class="even"><td>byte[]</td><td>size &lt;= 64</td><td>插入排序</td></tr><tr class="odd"><td></td><td>size &gt; 64</td><td>计数排序</td></tr><tr class="even"><td>char[] short[]</td><td>size &lt; 44</td><td>插入排序</td></tr><tr class="odd"><td></td><td>再大</td><td>双基准点快排</td></tr><tr class="even"><td></td><td>递归次数超过 384</td><td>计数排序</td></tr><tr class="odd"><td></td><td>size &gt; 1750</td><td>计数排序</td></tr><tr class="even"><td>Object[]</td><td>-Djava.util.Arrays.useLegacyMergeSort=true</td><td>传统归并排序</td></tr><tr class="odd"><td></td><td></td><td>TimSort</td></tr></tbody></table><ul><li>其中 TimSort 是用归并+二分插入排序的混合排序算法</li><li>值得注意的是从 JDK 8 开始支持 Arrays.parallelSort 并行排序</li><li>根据最新的提交记录来看 JDK 21 可能会引入基数排序等优化</li></ul><h4 id="外部排序">外部排序</h4><h3 id="冒泡排序">1) 冒泡排序</h3><p>要点</p><ul><li>每轮冒泡不断地比较<strong>相邻</strong>的两个元素，如果它们是逆序的，则交换它们的位置</li><li>下一轮冒泡，可以调整未排序的右边界，减少不必要比较</li></ul><p>以数组 3、2、1 的冒泡排序为例，第一轮冒泡</p><figure><img src="../../../../images/StrJava/image-20230504153631958.png" alt="image-20230504153631958"><figcaption aria-hidden="true">image-20230504153631958</figcaption></figure><p>第二轮冒泡</p><figure><img src="../../../../images/StrJava/image-20230504154044402.png" alt="image-20230504154044402"><figcaption aria-hidden="true">image-20230504154044402</figcaption></figure><p>未排序区域内就剩一个元素，结束</p><figure><img src="../../../../images/StrJava/image-20230504154213239.png" alt="image-20230504154213239"><figcaption aria-hidden="true">image-20230504154213239</figcaption></figure><p>优化手段：每次循环时，若能确定<strong>更合适的</strong>右边界，则可以减少冒泡轮数</p><p>以数组 3、2、1、4、5 为例，第一轮结束后记录的 x，即为右边界</p><figure><img src="../../../../images/StrJava/image-20230504161136854.png" alt="image-20230504161136854"><figcaption aria-hidden="true">image-20230504161136854</figcaption></figure><p>非递归版代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> a.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; j; i++) {</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">                    a[i] = a[i + <span class="number">1</span>];</span><br><span class="line">                    a[i + <span class="number">1</span>] = t;</span><br><span class="line">                    x = i;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            j = x;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] a = {<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>};</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        bubble(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="选择排序">2) 选择排序</h3><p>要点</p><ul><li>每一轮选择，找出最大（最小）的元素，并把它交换到合适的位置</li></ul><p>以下面的数组选择最大值为例</p><figure><img src="../../../../images/StrJava/image-20230507112728513.png" alt="image-20230507112728513"><figcaption aria-hidden="true">image-20230507112728513</figcaption></figure><p>非递归实现</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">        <span class="comment">// 1. 选择轮数 a.length - 1</span></span><br><span class="line">        <span class="comment">// 2. 交换的索引位置(right) 初始 a.length - 1, 每次递减</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> a.length - <span class="number">1</span>; right &gt; <span class="number">0</span> ; right--) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> right;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right; i++) {</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; a[max]) {</span><br><span class="line">                    max = i;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(max != right) {</span><br><span class="line">                swap(a, max, right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] a = {<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>};</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="堆排序">3) 堆排序</h3><p>要点：</p><ul><li>建立大顶堆</li><li>每次将堆顶元素（最大值）交换到末尾，调整堆顶元素，让它重新符合大顶堆特性</li></ul><p>建堆</p><figure><img src="../../../../images/StrJava/image-20230508080820117.png" alt="image-20230508080820117"><figcaption aria-hidden="true">image-20230508080820117</figcaption></figure><p>交换，下潜调整</p><figure><img src="../../../../images/StrJava/image-20230508080912944.png" alt="image-20230508080912944"><figcaption aria-hidden="true">image-20230508080912944</figcaption></figure><figure><img src="../../../../images/StrJava/image-20230508080959301.png" alt="image-20230508080959301"><figcaption aria-hidden="true">image-20230508080959301</figcaption></figure><figure><img src="../../../../images/StrJava/image-20230508081052055.png" alt="image-20230508081052055"><figcaption aria-hidden="true">image-20230508081052055</figcaption></figure><figure><img src="../../../../images/StrJava/image-20230508081220301.png" alt="image-20230508081220301"><figcaption aria-hidden="true">image-20230508081220301</figcaption></figure><figure><img src="../../../../images/StrJava/image-20230508081315265.png" alt="image-20230508081315265"><figcaption aria-hidden="true">image-20230508081315265</figcaption></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">        heapify(a, a.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> a.length - <span class="number">1</span>; right &gt; <span class="number">0</span>; right--) {</span><br><span class="line">            swap(a, <span class="number">0</span>, right);</span><br><span class="line">            down(a, <span class="number">0</span>, right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建堆 O(n)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> size)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            down(array, i, size);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下潜</span></span><br><span class="line">    <span class="comment">// leetcode 上数组排序题目用堆排序求解，非递归实现比递归实现大约快 6ms</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> parent, <span class="type">int</span> size)</span> {</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> parent;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; size &amp;&amp; array[left] &gt; array[max]) {</span><br><span class="line">                max = left;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp; array[right] &gt; array[max]) {</span><br><span class="line">                max = right;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (max == parent) { <span class="comment">// 没找到更大的孩子</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            swap(array, max, parent);</span><br><span class="line">            parent = max;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] a = {<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="插入排序">4) 插入排序</h3><p>要点</p><ul><li><em>将数组分为两部分</em> <em>[0 .. low-1] [low .. a.length-1]</em><ul><li><em>左边</em> <em>[0 .. low-1]</em> <em>是已排序部分</em></li><li><em>右边</em> <em>[low .. a.length-1]</em><em>是未排序部分</em></li></ul></li><li><em>每次从未排序区域取出</em> <em>low</em> <em>位置的元素</em>,<em>插入到已排序区域</em></li></ul><p>例</p><figure><img src="../../../../images/StrJava/image-20230513150750673.png" alt="image-20230513150750673"><figcaption aria-hidden="true">image-20230513150750673</figcaption></figure><figure><img src="../../../../images/StrJava/image-20230513150907333.png" alt="image-20230513150907333"><figcaption aria-hidden="true">image-20230513150907333</figcaption></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertionSort</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">1</span>; low &lt; a.length; low++) {</span><br><span class="line">            <span class="comment">// 将 low 位置的元素插入至 [0..low-1] 的已排序区域</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[low];</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low - <span class="number">1</span>; <span class="comment">// 已排序区域指针</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; t &lt; a[i]) { <span class="comment">// 没有找到插入位置</span></span><br><span class="line">                a[i + <span class="number">1</span>] = a[i]; <span class="comment">// 空出插入位置</span></span><br><span class="line">                i--;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到插入位置</span></span><br><span class="line">            <span class="keyword">if</span> (i != low - <span class="number">1</span>) {</span><br><span class="line">                a[i + <span class="number">1</span>] = t;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] a = {<span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>};</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="希尔排序">5) 希尔排序</h3><p>要点</p><ul><li>简单的说，就是分组实现插入，每组元素间隙称为 gap</li><li>每轮排序后 gap 逐渐变小，直至 gap 为 1 完成排序</li><li>对插入排序的优化，让元素更快速地交换到最终位置</li></ul><p>下图演示了 gap = 4，gap = 2，gap = 1 的三轮排序前后比较</p><figure><img src="../../../../images/StrJava/image-20230508182439075.png" alt="image-20230508182439075"><figcaption aria-hidden="true">image-20230508182439075</figcaption></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> a.length&gt;&gt;<span class="number">1</span>; gap &gt;<span class="number">0</span> ; gap=gap&gt;&gt;<span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> gap; low &lt; a.length; low ++) {</span><br><span class="line">                <span class="comment">// 将 low 位置的元素插入至 [0..low-1] 的已排序区域</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[low];</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low - gap; <span class="comment">// 已排序区域指针</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; t &lt; a[i]) { <span class="comment">// 没有找到插入位置</span></span><br><span class="line">                    a[i + gap] = a[i]; <span class="comment">// 空出插入位置</span></span><br><span class="line">                    i -= gap;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 找到插入位置</span></span><br><span class="line">                <span class="keyword">if</span> (i != low - gap) {</span><br><span class="line">                    a[i + gap] = t;</span><br><span class="line">                }</span><br><span class="line">            }            </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] a = {<span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>};</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        sort(a);</span><br><span class="line">System.out.println(Arrays.toString(a));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="归并排序">6) 归并排序</h3><h4 id="递归实现-1">递归实现</h4><p>要点</p><ul><li>分 - 每次从中间切一刀，处理的数据少一半</li><li>治 - 当数据仅剩一个时可以认为有序</li><li>合 - 两个有序的结果，可以进行合并排序（参见数组练习 E01.合并有序数组）</li></ul><figure><img src="../../../../images/StrJava/image-20230513143854887.png" alt="image-20230513143854887"><figcaption aria-hidden="true">image-20230513143854887</figcaption></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSortTopDown</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        a1 原始数组</span></span><br><span class="line"><span class="comment">        i~iEnd 第一个有序范围</span></span><br><span class="line"><span class="comment">        j~jEnd 第二个有序范围</span></span><br><span class="line"><span class="comment">        a2 临时数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span> i, <span class="type">int</span> iEnd, <span class="type">int</span> j, <span class="type">int</span> jEnd, <span class="type">int</span>[] a2)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= iEnd &amp;&amp; j &lt;= jEnd) {</span><br><span class="line">            <span class="keyword">if</span> (a1[i] &lt; a1[j]) {</span><br><span class="line">                a2[k] = a1[i];</span><br><span class="line">                i++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                a2[k] = a1[j];</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">            k++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (i &gt; iEnd) {</span><br><span class="line">            System.arraycopy(a1, j, a2, k, jEnd - j + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (j &gt; jEnd) {</span><br><span class="line">            System.arraycopy(a1, i, a2, k, iEnd - i + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a1)</span> {</span><br><span class="line">        <span class="type">int</span>[] a2 = <span class="keyword">new</span> <span class="title class_">int</span>[a1.length];</span><br><span class="line">        split(a1, <span class="number">0</span>, a1.length - <span class="number">1</span>, a2);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] a2)</span> {</span><br><span class="line">        <span class="type">int</span>[] array = Arrays.copyOfRange(a1, left, right + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//        System.out.println(Arrays.toString(array));</span></span><br><span class="line">        <span class="comment">// 2. 治</span></span><br><span class="line">        <span class="keyword">if</span> (left == right) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 1. 分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        split(a1, left, m, a2);                 <span class="comment">// left = 0 m = 0  9</span></span><br><span class="line">        split(a1, m + <span class="number">1</span>, right, a2);       <span class="comment">// m+1 = 1 right = 1  3</span></span><br><span class="line">        <span class="comment">// 3. 合</span></span><br><span class="line">        merge(a1, left, m, m + <span class="number">1</span>, right, a2);</span><br><span class="line">        System.arraycopy(a2, left, a1, left, right - left + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] a = {<span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>};</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="时间复杂度">时间复杂度</h4><ul><li><p>两个长度为 m 和 n 的链表合并，时间复杂度是 m + n</p></li><li><p>归并，时间复杂度：<span class="math inline">\(f(n) = 2f(n/2) + n,f(1)=c\)</span>，等价解 <span class="math inline">\(f(n) = nlog_2{n} +cn\)</span></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">             8</span><br><span class="line">          /     \</span><br><span class="line">         4       4</span><br><span class="line">        / \     / \</span><br><span class="line">       2   2   2   2</span><br><span class="line">      ||   ||  ||  ||</span><br><span class="line">      11   11  11  11    </span><br><span class="line">      </span><br><span class="line">f(8) = 2f(4) + 8</span><br><span class="line">f(4) = 2f(2) + 4</span><br><span class="line">f(2) = 2f(1) + 2</span><br><span class="line">f(1) = 1</span><br><span class="line"></span><br><span class="line">f(8) = 8 + 24</span><br><span class="line">f(4) = 4 + 8</span><br><span class="line">f(2) = 2 + 2</span><br><span class="line">f(1) = 1</span><br></pre></td></tr></tbody></table></figure><ul><li>当 n = 16 时，结果 80</li><li>当 n = 64 时，结果 448</li></ul></li><li><p>若逐一合并，时间复杂度：<span class="math inline">\(f(n)=\sum\limits_{n=0}^{n-1}n+1\)</span>，等价解<span class="math inline">\(f(n)=\frac{1}{2}(n^2+n)\)</span></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1|0 =&gt; 1</span><br><span class="line">1|1 =&gt; 2</span><br><span class="line">1|2 =&gt; 3</span><br><span class="line">1|3 =&gt; 4</span><br><span class="line">1|4 =&gt; 5</span><br><span class="line">1|5 =&gt; 6</span><br><span class="line">1|6 =&gt; 7</span><br><span class="line">1|7 =&gt; 8</span><br><span class="line"></span><br><span class="line">36</span><br></pre></td></tr></tbody></table></figure><ul><li>当 n = 16 时，结果 136</li><li>当 n = 64 时，结果 2080</li></ul></li></ul><h4 id="非递归实现-1">非递归实现</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSortBottomUp</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        a1 原始数组</span></span><br><span class="line"><span class="comment">        i~iEnd 第一个有序范围</span></span><br><span class="line"><span class="comment">        j~jEnd 第二个有序范围</span></span><br><span class="line"><span class="comment">        a2 临时数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span> i, <span class="type">int</span> iEnd, <span class="type">int</span> j, <span class="type">int</span> jEnd, <span class="type">int</span>[] a2)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= iEnd &amp;&amp; j &lt;= jEnd) {</span><br><span class="line">            <span class="keyword">if</span> (a1[i] &lt; a1[j]) {</span><br><span class="line">                a2[k] = a1[i];</span><br><span class="line">                i++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                a2[k] = a1[j];</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">            k++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (i &gt; iEnd) {</span><br><span class="line">            System.arraycopy(a1, j, a2, k, jEnd - j + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (j &gt; jEnd) {</span><br><span class="line">            System.arraycopy(a1, i, a2, k, iEnd - i + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a1)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a1.length;</span><br><span class="line">        <span class="type">int</span>[] a2 = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">1</span>; width &lt; n; width *= <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * width) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> Integer.min(i + width - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Integer.min(i + <span class="number">2</span> * width - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">                System.out.println(i + <span class="string">" "</span> + m + <span class="string">" "</span> + j);</span><br><span class="line">                merge(a1, i, m, m + <span class="number">1</span>, j, a2);</span><br><span class="line">            }</span><br><span class="line">            System.arraycopy(a2, <span class="number">0</span>, a1, <span class="number">0</span>, n);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] a = {<span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>};</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="归并插入">7) 归并+插入</h3><ul><li>小数据量且有序度高时，插入排序效果高</li><li>大数据量用归并效果好</li><li>可以结合二者</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeInsertionSort</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertion</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> left + <span class="number">1</span>; low &lt;= right; low++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[low];</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= left &amp;&amp; t &lt; a[i]) {</span><br><span class="line">                a[i + <span class="number">1</span>] = a[i];</span><br><span class="line">                i--;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (i != low - <span class="number">1</span>) {</span><br><span class="line">                a[i + <span class="number">1</span>] = t;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        a1 原始数组</span></span><br><span class="line"><span class="comment">        i~iEnd 第一个有序范围</span></span><br><span class="line"><span class="comment">        j~jEnd 第二个有序范围</span></span><br><span class="line"><span class="comment">        a2 临时数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span> i, <span class="type">int</span> iEnd, <span class="type">int</span> j, <span class="type">int</span> jEnd, <span class="type">int</span>[] a2)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= iEnd &amp;&amp; j &lt;= jEnd) {</span><br><span class="line">            <span class="keyword">if</span> (a1[i] &lt; a1[j]) {</span><br><span class="line">                a2[k] = a1[i];</span><br><span class="line">                i++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                a2[k] = a1[j];</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">            k++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (i &gt; iEnd) {</span><br><span class="line">            System.arraycopy(a1, j, a2, k, jEnd - j + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (j &gt; jEnd) {</span><br><span class="line">            System.arraycopy(a1, i, a2, k, iEnd - i + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a1)</span> {</span><br><span class="line">        <span class="type">int</span>[] a2 = <span class="keyword">new</span> <span class="title class_">int</span>[a1.length];</span><br><span class="line">        split(a1, <span class="number">0</span>, a1.length - <span class="number">1</span>, a2);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] a2)</span> {</span><br><span class="line"><span class="comment">//        int[] array = Arrays.copyOfRange(a1, left, right + 1);</span></span><br><span class="line"><span class="comment">//        System.out.println(Arrays.toString(array));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 治</span></span><br><span class="line">        <span class="keyword">if</span> (right == left) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (right - left &lt;= <span class="number">32</span>) {</span><br><span class="line">            insertion(a1, left, right);</span><br><span class="line">            System.out.println(<span class="string">"insert..."</span> + left + <span class="string">" "</span> + right +<span class="string">" "</span>+Arrays.toString(a1));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 1. 分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        split(a1, left, m, a2);                 <span class="comment">// left = 0 m = 0  9</span></span><br><span class="line">        split(a1, m + <span class="number">1</span>, right, a2);       <span class="comment">// m+1 = 1 right = 1  3</span></span><br><span class="line">        System.out.println(left + <span class="string">" "</span> + right + <span class="string">" "</span>+Arrays.toString(a1));</span><br><span class="line">        <span class="comment">// 3. 合</span></span><br><span class="line">        merge(a1, left, m, m + <span class="number">1</span>, right, a2);</span><br><span class="line">        System.arraycopy(a2, left, a1, left, right - left + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] a = {<span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>};</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="快速排序">8) 快速排序</h3><p>单边循环（lomuto分区）要点</p><ul><li>选择最右侧元素作为基准点</li><li>j 找比基准点小的，i 找比基准点大的，一旦找到，二者进行交换<ul><li>交换时机：j 找到小的，且与 i 不相等</li><li>i 找到 &gt;= 基准点元素后，不应自增</li></ul></li><li>最后基准点与 i 交换，i 即为基准点最终索引</li></ul><p>例：</p><p>i 和 j 都从左边出发向右查找，i找到比基准点4大的5，j找到比基准点小的2，停下来交换</p><figure><img src="../../../../images/StrJava/image-20230513145045085.png" alt="image-20230513145045085"><figcaption aria-hidden="true">image-20230513145045085</figcaption></figure><p>i 找到了比基准点大的5，j 找到比基准点小的3，停下来交换</p><figure><img src="../../../../images/StrJava/image-20230513145259217.png" alt="image-20230513145259217"><figcaption aria-hidden="true">image-20230513145259217</figcaption></figure><p>j 到达right 处结束，right 与 i 交换，一轮分区结束</p><figure><img src="../../../../images/StrJava/image-20230513145454772.png" alt="image-20230513145454772"><figcaption aria-hidden="true">image-20230513145454772</figcaption></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSortLomuto</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">        quick(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a, left, right); <span class="comment">// p代表基准点元素索引</span></span><br><span class="line">        quick(a, left, p - <span class="number">1</span>);</span><br><span class="line">        quick(a, p + <span class="number">1</span>, right);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> a[right]; <span class="comment">// 基准点元素值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; right) {</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; pv) { <span class="comment">// j 找到比基准点小的了, 没找到大的</span></span><br><span class="line">                <span class="keyword">if</span> (i != j) {</span><br><span class="line">                    swap(a, i, j);</span><br><span class="line">                }</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        swap(a, i, right);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] a = {<span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>};</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>双边循环要点</p><ul><li>选择最左侧元素作为基准点</li><li>j 找比基准点小的，i 找比基准点大的，一旦找到，二者进行交换<ul><li>i 从左向右</li><li>j 从右向左</li></ul></li><li>最后基准点与 i 交换，i 即为基准点最终索引</li></ul><p>例：</p><p>i 找到比基准点大的5停下来，j找到比基准点小的1停下来（包含等于），二者交换</p><figure><img src="../../../../images/StrJava/image-20230513145918612.png" alt="image-20230513145918612"><figcaption aria-hidden="true">image-20230513145918612</figcaption></figure><p>i 找到8，j 找到3，二者交换，i 找到7，j 找到2，二者交换</p><figure><img src="../../../../images/StrJava/image-20230513150158220.png" alt="image-20230513150158220"><figcaption aria-hidden="true">image-20230513150158220</figcaption></figure><p>i == j，退出循环，基准点与 i 交换</p><figure><img src="../../../../images/StrJava/image-20230513150351115.png" alt="image-20230513150351115"><figcaption aria-hidden="true">image-20230513150351115</figcaption></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSortHoare</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">        quick(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a, left, right);</span><br><span class="line">        quick(a, left, p - <span class="number">1</span>);</span><br><span class="line">        quick(a, p + <span class="number">1</span>, right);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> a[left];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) {</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt; pv) {</span><br><span class="line">                j--;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; pv &gt;= a[i]) {</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            swap(a, i, j);</span><br><span class="line">        }</span><br><span class="line">        swap(a, left, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] a = {<span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>};</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="随机基准点">随机基准点</h4><p>使用随机数作为基准点，避免万一最大值或最小值作为基准点导致的分区不均衡</p><p>例</p><figure><img src="../../../../images/StrJava/image-20230513152038090.png" alt="image-20230513152038090"><figcaption aria-hidden="true">image-20230513152038090</figcaption></figure><p>改进代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(right - left + <span class="number">1</span>) + left;</span><br><span class="line">swap(a, idx, left);</span><br></pre></td></tr></tbody></table></figure><h4 id="处理重复值">处理重复值</h4><p>如果重复值较多，则原来算法中的分区效果也不好，如下图中左侧所示，需要想办法改为右侧的分区效果</p><figure><img src="../../../../images/StrJava/image-20230513151851103.png" alt="image-20230513151851103"><figcaption aria-hidden="true">image-20230513151851103</figcaption></figure><p>改进代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSortHandleDuplicate</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">        quick(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a, left, right);</span><br><span class="line">        quick(a, left, p - <span class="number">1</span>);</span><br><span class="line">        quick(a, p + <span class="number">1</span>, right);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        循环内</span></span><br><span class="line"><span class="comment">            i 从 left + 1 开始，从左向右找大的或相等的</span></span><br><span class="line"><span class="comment">            j 从 right 开始，从右向左找小的或相等的</span></span><br><span class="line"><span class="comment">            交换，i++ j--</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        循环外 j 和 基准点交换，j 即为分区位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(right - left + <span class="number">1</span>) + left;</span><br><span class="line">        swap(a, left, idx);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> a[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) {</span><br><span class="line">            <span class="comment">// i 从左向右找大的或者相等的</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; a[i] &lt; pv) {</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// j 从右向左找小的或者相等的</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; a[j] &gt; pv) {</span><br><span class="line">                j--;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= j) {</span><br><span class="line">                swap(a, i, j);</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        swap(a, j, left);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="comment">//        int[] a = {4, 2, 1, 3, 2, 4}; // 最外层循环 = 要加</span></span><br><span class="line"><span class="comment">//        int[] a = {2, 1, 3, 2}; // 内层循环 = 要加</span></span><br><span class="line">        <span class="type">int</span>[] a = {<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>}; <span class="comment">// 内层if要加</span></span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>核心思想是<ul><li>改进前，i 只找大于的，j会找小于等于的。一个不找等于、一个找等于，势必导致等于的值分布不平衡</li><li>改进后，二者都会找等于的交换，等于的值会平衡分布在基准点两边</li></ul></li><li>细节：<ul><li>因为一开始 i 就可能等于j，因此外层循环需要加等于条件保证至少进入一次，让 j 能减到正确位置</li><li>内层 while 循环中 i &lt;= j 的 = 也不能去掉，因为 i == j时也要做一次与基准点的判断，好让 i 及 j 正确</li><li>i == j 时，也要做一次 i++ 和 j-- 使下次循环二者不等才能退出</li><li>因为最后退出循环时 i 会大于 j，因此最终与基准点交换的是 j</li></ul></li><li>内层两个 while 循环的先后顺序不再重要</li></ul><h3 id="计数排序">9) 计数排序</h3><p>方法1（简化后的计数排序）</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : a) {</span><br><span class="line">        <span class="keyword">if</span> (i &gt; max) {</span><br><span class="line">            max = i;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; min) {</span><br><span class="line">            min = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span>[] counting = <span class="keyword">new</span> <span class="title class_">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : a) {</span><br><span class="line">        counting[i - min]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; counting.length; i++) {</span><br><span class="line">        <span class="keyword">while</span> (counting[i] &gt; <span class="number">0</span>) {</span><br><span class="line">            a[k] = i + min;</span><br><span class="line">            counting[i]--;</span><br><span class="line">            k++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>针对 byte []，因为数据范围已知，省去了求最大、最小值的过程，java 中对char[]、short[]、byte[] 的排序都可能采用 counting 排序</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">byte</span>[] a)</span> {</span><br><span class="line">    <span class="type">int</span>[] counting = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : a) {</span><br><span class="line">        counting[i &amp; <span class="number">0xFF</span>]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> a.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">128</span> + <span class="number">256</span>; k &gt;= <span class="number">0</span>; ) {            </span><br><span class="line">        <span class="keyword">while</span> (counting[--i &amp; <span class="number">0xFF</span>] ==<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> i &amp; <span class="number">0xFF</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> counting[i &amp; <span class="number">0xFF</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; c; j++) {</span><br><span class="line">            a[k] = (<span class="type">byte</span>) v;</span><br><span class="line">            k--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>稳定计数排序</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort2</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : a) {</span><br><span class="line">        <span class="keyword">if</span> (i &gt; max) {</span><br><span class="line">            max = i;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; min) {</span><br><span class="line">            min = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span>[] counting = <span class="keyword">new</span> <span class="title class_">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : a) {</span><br><span class="line">        counting[i - min]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; counting.length; i++) {</span><br><span class="line">        counting[i] = counting[i] + counting[i - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[a.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> a[i] - min;</span><br><span class="line">        counting[j]--;</span><br><span class="line">        b[counting[j]] = a[i];</span><br><span class="line">    }</span><br><span class="line">    System.arraycopy(b, <span class="number">0</span>, a, <span class="number">0</span>, a.length);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="桶排序">10) 桶排序</h3><p>初步实现</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSort</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] ages = {<span class="number">20</span>, <span class="number">18</span>, <span class="number">66</span>, <span class="number">25</span>, <span class="number">67</span>, <span class="number">30</span>}; <span class="comment">// 假设人类年龄 1~99 那么分为10个桶</span></span><br><span class="line">        System.out.println(Arrays.toString(ages));</span><br><span class="line">        sort(ages);</span><br><span class="line">        System.out.println(Arrays.toString(ages));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">        DynamicArray[] buckets = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buckets.length; i++) {</span><br><span class="line">            buckets[i] = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : a) {</span><br><span class="line">            <span class="type">DynamicArray</span> <span class="variable">bucket</span> <span class="operator">=</span> buckets[v / <span class="number">10</span>];</span><br><span class="line">            bucket.addLast(v);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (DynamicArray bucket : buckets) {</span><br><span class="line">            System.out.println(Arrays.toString(bucket.array()));</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (DynamicArray bucket : buckets) {</span><br><span class="line">            <span class="type">int</span>[] array = bucket.array();</span><br><span class="line">            InsertionSort.sort(array);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : array) {</span><br><span class="line">                a[k++] = v;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通用</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSortGeneric</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] ages = {<span class="number">20</span>, <span class="number">10</span>, <span class="number">28</span>, <span class="number">66</span>, <span class="number">25</span>, <span class="number">31</span>, <span class="number">67</span>, <span class="number">30</span>, <span class="number">70</span>}; <span class="comment">// 假设人类年龄 1~99</span></span><br><span class="line">        System.out.println(Arrays.toString(ages));</span><br><span class="line">        sort(ages, <span class="number">20</span>);</span><br><span class="line">        System.out.println(Arrays.toString(ages));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> range)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; max) {</span><br><span class="line">                max = a[i];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; min) {</span><br><span class="line">                min = a[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 1. 准备桶</span></span><br><span class="line">        DynamicArray[] buckets = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>[(max - min) / range + <span class="number">1</span>];</span><br><span class="line">        System.out.println(buckets.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buckets.length; i++) {</span><br><span class="line">            buckets[i] = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 2. 放入年龄数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> age : a) {</span><br><span class="line">            buckets[(age - min) / range].addLast(age);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (DynamicArray bucket : buckets) {</span><br><span class="line">            <span class="comment">// 3. 排序桶内元素</span></span><br><span class="line">            <span class="type">int</span>[] array = bucket.array();</span><br><span class="line">            InsertionSort.sort(array);</span><br><span class="line">            System.out.println(Arrays.toString(array));</span><br><span class="line">            <span class="comment">// 4. 把每个桶排序好的内容，依次放入原始数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : array) {</span><br><span class="line">                a[k++] = v;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="基数排序">11) 基数排序</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(String[] a, <span class="type">int</span> length)</span> {</span><br><span class="line">        ArrayList&lt;String&gt;[] buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buckets.length; i++) {</span><br><span class="line">            buckets[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) {</span><br><span class="line">            <span class="keyword">for</span> (String s : a) {</span><br><span class="line">                buckets[s.charAt(i)].add(s);</span><br><span class="line">            }</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (ArrayList&lt;String&gt; bucket : buckets) {</span><br><span class="line">                <span class="keyword">for</span> (String s : bucket) {</span><br><span class="line">                    a[k++] = s;</span><br><span class="line">                }</span><br><span class="line">                bucket.clear();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">/*String[] phoneNumbers = new String[10];</span></span><br><span class="line"><span class="comment">        phoneNumbers[0] = "13812345678";</span></span><br><span class="line"><span class="comment">        phoneNumbers[1] = "13912345678";</span></span><br><span class="line"><span class="comment">        phoneNumbers[2] = "13612345678";</span></span><br><span class="line"><span class="comment">        phoneNumbers[3] = "13712345678";</span></span><br><span class="line"><span class="comment">        phoneNumbers[4] = "13512345678";</span></span><br><span class="line"><span class="comment">        phoneNumbers[5] = "13412345678";</span></span><br><span class="line"><span class="comment">        phoneNumbers[6] = "15012345678";</span></span><br><span class="line"><span class="comment">        phoneNumbers[7] = "15112345678";</span></span><br><span class="line"><span class="comment">        phoneNumbers[8] = "15212345678";</span></span><br><span class="line"><span class="comment">        phoneNumbers[9] = "15712345678";*/</span></span><br><span class="line"></span><br><span class="line">        String[] phoneNumbers = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">        phoneNumbers[<span class="number">0</span>] = <span class="string">"138"</span>;</span><br><span class="line">        phoneNumbers[<span class="number">1</span>] = <span class="string">"139"</span>;</span><br><span class="line">        phoneNumbers[<span class="number">2</span>] = <span class="string">"136"</span>;</span><br><span class="line">        phoneNumbers[<span class="number">3</span>] = <span class="string">"137"</span>;</span><br><span class="line">        phoneNumbers[<span class="number">4</span>] = <span class="string">"135"</span>;</span><br><span class="line">        phoneNumbers[<span class="number">5</span>] = <span class="string">"134"</span>;</span><br><span class="line">        phoneNumbers[<span class="number">6</span>] = <span class="string">"150"</span>;</span><br><span class="line">        phoneNumbers[<span class="number">7</span>] = <span class="string">"151"</span>;</span><br><span class="line">        phoneNumbers[<span class="number">8</span>] = <span class="string">"152"</span>;</span><br><span class="line">        phoneNumbers[<span class="number">9</span>] = <span class="string">"157"</span>;</span><br><span class="line">        RadixSort.radixSort(phoneNumbers, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (String phoneNumber : phoneNumbers) {</span><br><span class="line">            System.out.println(phoneNumber);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>基数排序是稳定排序，因此先排个位、再排十位，十位的排序不会打乱个位取值相等的元素顺序</p><h3 id="习题-11">习题</h3><h4 id="e01.-根据另一个数组次序排序-leetcode-1122">E01.根据另一个数组次序排序-Leetcode 1122</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    前提</span></span><br><span class="line"><span class="comment">    1. 元素值均 &gt;= 0</span></span><br><span class="line"><span class="comment">    2. arr2 内元素唯一，且长度 &lt;= 1000</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E01Leetcode1122</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] relativeSortArray(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2) {</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1001</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr1) {</span><br><span class="line">            count[i]++;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr2) {</span><br><span class="line">            <span class="keyword">while</span> (count[i] &gt; <span class="number">0</span>) {</span><br><span class="line">                result[k++] = i;</span><br><span class="line">                count[i]--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count.length; i++) {</span><br><span class="line">            <span class="keyword">while</span> (count[i] &gt; <span class="number">0</span>) {</span><br><span class="line">                result[k++] = i;</span><br><span class="line">                count[i]--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e02.-按出现频率排序-leetcode-1636">E02. 按出现频率排序-Leetcode1636</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E02Leetcode1636</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] frequencySort(<span class="type">int</span>[] nums) {</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">201</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) {</span><br><span class="line">            count[i + <span class="number">100</span>]++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(nums).boxed().sorted((a, b) -&gt; {</span><br><span class="line">            <span class="type">int</span> <span class="variable">fa</span> <span class="operator">=</span> count[a + <span class="number">100</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">fb</span> <span class="operator">=</span> count[b + <span class="number">100</span>];</span><br><span class="line">            <span class="keyword">if</span> (fa == fb) {</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(b, a);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> fa - fb;</span><br><span class="line">            }</span><br><span class="line">        }).mapToInt(Integer::intValue).toArray();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="e03.-最大间距-leetcode-164">E03. 最大间距-Leetcode 164</h4><p>解法1：桶排序 - 超过<strong>内存</strong>限制</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E03Leetcode164_1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumGap</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        sort(nums, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            ret = Math.max(ret, nums[i] - nums[i - <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> range)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; max) {</span><br><span class="line">                max = a[i];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; min) {</span><br><span class="line">                min = a[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 1. 准备桶</span></span><br><span class="line">        DynamicArray[] buckets = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>[(max - min) / range + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buckets.length; i++) {</span><br><span class="line">            buckets[i] = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 2. 放入数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> age : a) {</span><br><span class="line">            buckets[(age - min) / range].addLast(age);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (DynamicArray bucket : buckets) {</span><br><span class="line">            <span class="comment">// 3. 排序桶内元素</span></span><br><span class="line">            <span class="type">int</span>[] array = bucket.array();</span><br><span class="line">            InsertionSort.sort(array);</span><br><span class="line">            <span class="comment">// 4. 把每个桶排序好的内容，依次放入原始数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : array) {</span><br><span class="line">                a[k++] = v;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] nums = {<span class="number">13</span>, <span class="number">26</span>, <span class="number">16</span>, <span class="number">11</span>};</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E03Leetcode164_1</span>().maximumGap(nums);</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解法2：基数排序</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E03Leetcode164</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumGap</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">                </span><br><span class="line">        <span class="comment">// 计算最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) {</span><br><span class="line">            max = Math.max(a[i], max);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备10个桶</span></span><br><span class="line">        ArrayList&lt;Integer&gt;[] buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buckets.length; i++) {</span><br><span class="line">            buckets[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没超过最大值</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (max &gt;= exp) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : a) {</span><br><span class="line">                buckets[(j / (<span class="type">int</span>) exp) % <span class="number">10</span>].add(j);</span><br><span class="line">            }</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (ArrayList&lt;Integer&gt; bucket : buckets) {</span><br><span class="line">                <span class="keyword">for</span> (Integer i : bucket) {</span><br><span class="line">                    a[k++] = i;</span><br><span class="line">                }</span><br><span class="line">                bucket.clear();</span><br><span class="line">            }</span><br><span class="line">            exp *= <span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求最大间距</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) {</span><br><span class="line">            r = Math.max(r, a[i] - a[i - <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] nums = {<span class="number">3</span>, <span class="number">6</span>, <span class="number">16</span>, <span class="number">1</span>};</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E03Leetcode164</span>().maximumGap(nums);</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解法3：桶排序 - 合理化桶个数</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E03Leetcode164_3</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumGap</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="comment">// 1. 处理特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 2. 桶排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">1</span>; i1 &lt; nums.length; i1++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i1] &gt; max) {</span><br><span class="line">                max = nums[i1];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (nums[i1] &lt; min) {</span><br><span class="line">                min = nums[i1];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 2.1 准备桶</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            计算桶个数                   期望桶个数</span></span><br><span class="line"><span class="comment">            (max - min) / range + 1 = nums.length</span></span><br><span class="line"><span class="comment">            (max - min) / (nums.length - 1) = range</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">range</span> <span class="operator">=</span> Math.max((max - min) / (nums.length - <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">        DynamicArray[] buckets = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>[(max - min) / range + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">0</span>; i1 &lt; buckets.length; i1++) {</span><br><span class="line">            buckets[i1] = <span class="keyword">new</span> <span class="title class_">DynamicArray</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 2.2 放入数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> age : nums) {</span><br><span class="line">            buckets[(age - min) / range].addLast(age);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (DynamicArray bucket : buckets) {</span><br><span class="line">            <span class="comment">// 2.3 排序桶内元素</span></span><br><span class="line">            <span class="type">int</span>[] array = bucket.array();</span><br><span class="line">            InsertionSort.sort(array);</span><br><span class="line">            System.out.println(Arrays.toString(array));</span><br><span class="line">            <span class="comment">// 2.4 把每个桶排序好的内容，依次放入原始数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : array) {</span><br><span class="line">                nums[k++] = v;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 3. 寻找最大差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) {</span><br><span class="line">            r = Math.max(r, nums[i] - nums[i - <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="comment">//        int[] nums = {1, 10000000};</span></span><br><span class="line"><span class="comment">//        int[] nums = {9, 1, 3, 5};</span></span><br><span class="line"><span class="comment">//        int[] nums = {1, 1, 1, 1};</span></span><br><span class="line"><span class="comment">//        int[] nums = {1, 1, 1, 1, 1, 5, 5, 5, 5, 5};</span></span><br><span class="line">        <span class="type">int</span>[] nums = {<span class="number">15252</span>, <span class="number">16764</span>, <span class="number">27963</span>, <span class="number">7817</span>, <span class="number">26155</span>, <span class="number">20757</span>, <span class="number">3478</span>, <span class="number">22602</span>, <span class="number">20404</span>, <span class="number">6739</span>, <span class="number">16790</span>, <span class="number">10588</span>, <span class="number">16521</span>, <span class="number">6644</span>, <span class="number">20880</span>, <span class="number">15632</span>, <span class="number">27078</span>, <span class="number">25463</span>, <span class="number">20124</span>, <span class="number">15728</span>, <span class="number">30042</span>, <span class="number">16604</span>, <span class="number">17223</span>, <span class="number">4388</span>, <span class="number">23646</span>, <span class="number">32683</span>, <span class="number">23688</span>, <span class="number">12439</span>, <span class="number">30630</span>, <span class="number">3895</span>, <span class="number">7926</span>, <span class="number">22101</span>, <span class="number">32406</span>, <span class="number">21540</span>, <span class="number">31799</span>, <span class="number">3768</span>, <span class="number">26679</span>, <span class="number">21799</span>, <span class="number">23740</span>};</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E03Leetcode164_3</span>().maximumGap(nums);</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解法4：在解法3的基础上，只保留桶内最大最小值</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E03Leetcode164_4</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumGap</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="comment">// 1. 处理特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 2. 桶排序</span></span><br><span class="line">        <span class="comment">// 桶个数 (max - min) / range + 1  期望桶个数 nums.length + 1</span></span><br><span class="line">        <span class="comment">// range = (max - min) / nums.length</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; max) {</span><br><span class="line">                max = nums[i];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; min) {</span><br><span class="line">                min = nums[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (max == min) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">range</span> <span class="operator">=</span> Math.max(<span class="number">1</span>, (max - min) / nums.length);</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> (max - min) / range + <span class="number">1</span>;</span><br><span class="line">        Pair[] buckets = <span class="keyword">new</span> <span class="title class_">Pair</span>[size];</span><br><span class="line">        <span class="comment">// 2. 放入数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> (i - min) / range;</span><br><span class="line">            <span class="keyword">if</span> (buckets[idx] == <span class="literal">null</span>) {</span><br><span class="line">                buckets[idx] = <span class="keyword">new</span> <span class="title class_">Pair</span>();</span><br><span class="line">            }</span><br><span class="line">            buckets[idx].add(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(buckets));</span><br><span class="line">        <span class="comment">// 3. 寻找最大差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastMax</span> <span class="operator">=</span> buckets[<span class="number">0</span>].max;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; buckets.length; i++) {</span><br><span class="line">            <span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> buckets[i];</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">null</span>) {</span><br><span class="line">                r = Math.max(r, pair.min - lastMax);</span><br><span class="line">                lastMax = pair.max;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Pair</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">1000_000_000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> v)</span> {</span><br><span class="line">            max = Math.max(max, v);</span><br><span class="line">            min = Math.min(min, v);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"["</span> + min + <span class="string">","</span> + max + <span class="string">"]"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] nums = {<span class="number">9</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>};</span><br><span class="line"><span class="comment">//        int[] nums = {1, 10000000};</span></span><br><span class="line"><span class="comment">//        int[] nums = {1, 1, 1, 1};</span></span><br><span class="line"><span class="comment">//        int[] nums = {1, 1, 1, 1, 1, 5, 5, 5, 5, 5};</span></span><br><span class="line"><span class="comment">//        int[] nums = {15252, 16764, 27963, 7817, 26155, 20757, 3478, 22602, 20404, 6739, 16790, 10588, 16521, 6644, 20880, 15632, 27078, 25463, 20124, 15728, 30042, 16604, 17223, 4388, 23646, 32683, 23688, 12439, 30630, 3895, 7926, 22101, 32406, 21540, 31799, 3768, 26679, 21799, 23740};</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">E03Leetcode164_4</span>().maximumGap(nums);</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="排序数组-leetcode-912">排序数组-Leetcode 912</h4><h4 id="排序链表-leetcode-148">排序链表-Leetcode 148</h4><h4 id="其它题目-2">其它题目</h4><table><thead><tr class="header"><th>题目编号</th><th>题目标题</th><th>排序算法类型</th></tr></thead><tbody><tr class="odd"><td>1122</td><td>数组的相对排序</td><td>计数排序</td></tr><tr class="even"><td>1636</td><td>按照频率将数组升序排序</td><td>计数排序</td></tr><tr class="odd"><td>164</td><td>最大间距</td><td>基数排序、桶排序</td></tr><tr class="even"><td>315</td><td>计算右侧小于当前元素的个数</td><td>基数排序</td></tr><tr class="odd"><td>347</td><td>前 K 个高频元素</td><td>桶排序</td></tr></tbody></table><table><thead><tr class="header"><th>题目编号</th><th>题目标题</th><th>排序算法类型</th></tr></thead><tbody><tr class="odd"><td>75</td><td>颜色分类</td><td>三向切分快速排序</td></tr><tr class="even"><td>215</td><td>数组中的第K个最大元素</td><td>堆排序</td></tr><tr class="odd"><td>493</td><td>翻转对</td><td>归并排序</td></tr><tr class="even"><td>493</td><td>翻转对</td><td>树状数组</td></tr><tr class="odd"><td>524</td><td>通过删除字母匹配到字典里最长单词</td><td>循环排序</td></tr><tr class="even"><td>977</td><td>有序数组的平方</td><td>双指针法</td></tr></tbody></table><h1 id="四.-高级数据结构与算法设计">四. 高级数据结构与算法设计</h1><h2 id="图">4.1 图</h2><h3 id="概念">1) 概念</h3><p>图是由顶点（vertex）和边（edge）组成的数据结构，例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A---&gt;B</span><br><span class="line">    A---&gt;C</span><br><span class="line">    B---&gt;D</span><br><span class="line">    C---&gt;D</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>该图有四个顶点：A、B、C、D 以及四条有向边，有向图中，边是单向的</p><h4 id="有向-vs-无向">有向 vs 无向</h4><p>如果是无向图，那么边是双向的，下面是一个无向图的例子</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A---B</span><br><span class="line">    A---C</span><br><span class="line">    B---D</span><br><span class="line">    C---D</span><br></pre></td></tr></tbody></table></figure><h4 id="度">度</h4><p><strong>度</strong>是指与该顶点相邻的边的数量</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A((A))---B((B))</span><br><span class="line">    A---C((C))</span><br><span class="line">    B---D((D))</span><br><span class="line">    C---D</span><br><span class="line">    D---E((E))</span><br><span class="line">    D---F((F))</span><br><span class="line">    E---F</span><br><span class="line">    A &amp; B &amp; C &amp; D &amp; E &amp; F</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>例如上图中</p><ul><li>A、B、C、E、F 这几个顶点度数为 2</li><li>D 顶点度数为 4</li></ul><p>有向图中，细分为<strong>入度</strong>和<strong>出度</strong>，参见下图</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A((A))--&gt;B((B))</span><br><span class="line">    A--&gt;C((C))</span><br><span class="line">    B--&gt;D((D))</span><br><span class="line">    C--&gt;D</span><br><span class="line">    D--&gt;E((E))</span><br><span class="line">    D--&gt;F((F))</span><br><span class="line">    E--&gt;F</span><br><span class="line">    A &amp; B &amp; C &amp; D &amp; E &amp; F</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>A (2 out / 0 in)</li><li>B、C、E (1 out / 1 in)</li><li>D (2 out / 2 in)</li><li>F (0 out / 2 in)</li></ul><h4 id="权">权</h4><p>边可以有权重，代表从源顶点到目标顶点的距离、费用、时间或其他度量。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    BJ((北京))</span><br><span class="line">    WH((武汉))</span><br><span class="line">    GZ((广州))</span><br><span class="line">    SH((上海))</span><br><span class="line">    BJ---800km--&gt;WH</span><br><span class="line">    BJ---1900km--&gt;GZ</span><br><span class="line">    BJ---1200km--&gt;SH</span><br><span class="line">    WH---1050km--&gt;GZ</span><br><span class="line">    WH---700km--&gt;SH</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="路径">路径</h4><p>路径被定义为从一个顶点到另一个顶点的一系列连续边，例如上图中【北京】到【上海】有多条路径</p><ul><li>北京 - 上海</li><li>北京 - 武汉 - 上海</li></ul><p>路径长度</p><ul><li>不考虑权重，长度就是边的数量</li><li>考虑权重，一般就是权重累加</li></ul><h4 id="环">环</h4><p>在有向图中，从一个顶点开始，可以通过若干条有向边返回到该顶点，那么就形成了一个环</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">  A((A))</span><br><span class="line">  B((B))</span><br><span class="line">  C((C))</span><br><span class="line">  D((D))</span><br><span class="line">  E((E))</span><br><span class="line"></span><br><span class="line">  A---&gt;B</span><br><span class="line">  B---&gt;C</span><br><span class="line">  C---&gt;D</span><br><span class="line">  D---&gt;E</span><br><span class="line">  E---&gt;A</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="图的连通性">图的连通性</h4><p>如果两个顶点之间存在路径，则这两个顶点是连通的，所有顶点都连通，则该图被称之为连通图，若子图连通，则称为连通分量</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A --- B</span><br><span class="line">    A --- C</span><br><span class="line">    C --- D</span><br><span class="line">    D --- E</span><br><span class="line">    B --- E</span><br><span class="line">    F --- G</span><br><span class="line">    G --- H</span><br><span class="line">    H --- F</span><br><span class="line">    I --- J</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="图的表示">2) 图的表示</h3><p>比如说，下面的图</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A---B</span><br><span class="line">    A---C</span><br><span class="line">    B---D</span><br><span class="line">    C---D</span><br></pre></td></tr></tbody></table></figure><p>用<strong>邻接矩阵</strong>可以表示为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">  A B C D</span><br><span class="line">A 0 1 1 0</span><br><span class="line">B 1 0 0 1 </span><br><span class="line">C 1 0 0 1</span><br><span class="line">D 0 1 1 0</span><br></pre></td></tr></tbody></table></figure><p>用<strong>邻接表</strong>可以表示为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">A -&gt; B -&gt; C</span><br><span class="line">B -&gt; A -&gt; D</span><br><span class="line">C -&gt; A -&gt; D</span><br><span class="line">D -&gt; B -&gt; C</span><br></pre></td></tr></tbody></table></figure><p>有向图的例子</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A---&gt;B</span><br><span class="line">    A---&gt;C</span><br><span class="line">    B---&gt;D</span><br><span class="line">    C---&gt;D</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">  A B C D</span><br><span class="line">A 0 1 1 0</span><br><span class="line">B 0 0 0 1</span><br><span class="line">C 0 0 0 1</span><br><span class="line">D 0 0 0 0</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">A - B - C</span><br><span class="line">B - D</span><br><span class="line">C - D</span><br><span class="line">D - empty</span><br></pre></td></tr></tbody></table></figure><h3 id="java-表示">3) Java 表示</h3><p>顶点</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vertex</span> {</span><br><span class="line">    String name;</span><br><span class="line">    List&lt;Edge&gt; edges;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拓扑排序相关</span></span><br><span class="line">    <span class="type">int</span> inDegree;</span><br><span class="line">    <span class="type">int</span> status; <span class="comment">// 状态 0-未访问 1-访问中 2-访问过，用在拓扑排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dfs, bfs 相关</span></span><br><span class="line">    <span class="type">boolean</span> visited;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求解最短距离相关</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dist</span> <span class="operator">=</span> INF;</span><br><span class="line">    <span class="type">Vertex</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>边</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Edge</span> {</span><br><span class="line"></span><br><span class="line">    Vertex linked;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(Vertex linked)</span> {</span><br><span class="line">        <span class="built_in">this</span>(linked, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(Vertex linked, <span class="type">int</span> weight)</span> {</span><br><span class="line">        <span class="built_in">this</span>.linked = linked;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="dfs">4) DFS</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dfs</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v1"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v2"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v3"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v4"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v5"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v6"</span>);</span><br><span class="line"></span><br><span class="line">        v1.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v3), <span class="keyword">new</span> <span class="title class_">Edge</span>(v2), <span class="keyword">new</span> <span class="title class_">Edge</span>(v6));</span><br><span class="line">        v2.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4));</span><br><span class="line">        v3.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4), <span class="keyword">new</span> <span class="title class_">Edge</span>(v6));</span><br><span class="line">        v4.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v5));</span><br><span class="line">        v5.edges = List.of();</span><br><span class="line">        v6.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v5));</span><br><span class="line"></span><br><span class="line">        dfs1(v1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs2</span><span class="params">(Vertex v)</span> {</span><br><span class="line">        LinkedList&lt;Vertex&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(v);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">            <span class="type">Vertex</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            pop.visited = <span class="literal">true</span>;</span><br><span class="line">            System.out.println(pop.name);</span><br><span class="line">            <span class="keyword">for</span> (Edge edge : pop.edges) {</span><br><span class="line">                <span class="keyword">if</span> (!edge.linked.visited) {</span><br><span class="line">                    stack.push(edge.linked);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs1</span><span class="params">(Vertex v)</span> {</span><br><span class="line">        v.visited = <span class="literal">true</span>;</span><br><span class="line">        System.out.println(v.name);</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : v.edges) {</span><br><span class="line">            <span class="keyword">if</span> (!edge.linked.visited) {</span><br><span class="line">                dfs(edge.linked);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="bfs">5) BFS</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bfs</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v1"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v2"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v3"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v4"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v5"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v6"</span>);</span><br><span class="line"></span><br><span class="line">        v1.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v3), <span class="keyword">new</span> <span class="title class_">Edge</span>(v2), <span class="keyword">new</span> <span class="title class_">Edge</span>(v6));</span><br><span class="line">        v2.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4));</span><br><span class="line">        v3.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4), <span class="keyword">new</span> <span class="title class_">Edge</span>(v6));</span><br><span class="line">        v4.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v5));</span><br><span class="line">        v5.edges = List.of();</span><br><span class="line">        v6.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v5));</span><br><span class="line"></span><br><span class="line">        bfs(v1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(Vertex v)</span> {</span><br><span class="line">        LinkedList&lt;Vertex&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        v.visited = <span class="literal">true</span>;</span><br><span class="line">        queue.offer(v);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            <span class="type">Vertex</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.println(poll.name);</span><br><span class="line">            <span class="keyword">for</span> (Edge edge : poll.edges) {</span><br><span class="line">                <span class="keyword">if</span> (!edge.linked.visited) {</span><br><span class="line">                    edge.linked.visited = <span class="literal">true</span>;</span><br><span class="line">                    queue.offer(edge.linked);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="拓扑排序">6) 拓扑排序</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">HTML[网页基础] --&gt; WEB</span><br><span class="line">    SE[Java 基础] --&gt; WEB[Java Web] </span><br><span class="line">    DB[数据库] --&gt; Spring</span><br><span class="line">    WEB --&gt; Spring[Spring框架]</span><br><span class="line">    Spring --&gt; Micro[微服务框架]</span><br><span class="line">    Micro --&gt; Project[实战项目]</span><br></pre></td></tr></tbody></table></figure><h4 id="kahn">Kahn</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopologicalSort</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"网页基础"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"Java基础"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"JavaWeb"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"Spring框架"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"微服务框架"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"数据库"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"实战项目"</span>);</span><br><span class="line"></span><br><span class="line">        v1.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v3)); <span class="comment">// +1</span></span><br><span class="line">        v2.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v3)); <span class="comment">// +1</span></span><br><span class="line">        v3.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4));</span><br><span class="line">        v6.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4));</span><br><span class="line">        v4.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v5));</span><br><span class="line">        v5.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v7));</span><br><span class="line">        v7.edges = List.of();</span><br><span class="line"></span><br><span class="line">        List&lt;Vertex&gt; graph = List.of(v1, v2, v3, v4, v5, v6, v7);</span><br><span class="line">        <span class="comment">// 1. 统计每个顶点的入度</span></span><br><span class="line">        <span class="keyword">for</span> (Vertex v : graph) {</span><br><span class="line">            <span class="keyword">for</span> (Edge edge : v.edges) {</span><br><span class="line">                edge.linked.inDegree++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">/*for (Vertex vertex : graph) {</span></span><br><span class="line"><span class="comment">            System.out.println(vertex.name + " " + vertex.inDegree);</span></span><br><span class="line"><span class="comment">        }*/</span></span><br><span class="line">        <span class="comment">// 2. 将入度为0的顶点加入队列</span></span><br><span class="line">        LinkedList&lt;Vertex&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Vertex v : graph) {</span><br><span class="line">            <span class="keyword">if</span> (v.inDegree == <span class="number">0</span>) {</span><br><span class="line">                queue.offer(v);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 3. 队列中不断移除顶点，每移除一个顶点，把它相邻顶点入度减1，若减到0则入队</span></span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            <span class="type">Vertex</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"><span class="comment">//            System.out.println(poll.name);</span></span><br><span class="line">            result.add(poll.name);</span><br><span class="line">            <span class="keyword">for</span> (Edge edge : poll.edges) {</span><br><span class="line">                edge.linked.inDegree--;</span><br><span class="line">                <span class="keyword">if</span> (edge.linked.inDegree == <span class="number">0</span>) {</span><br><span class="line">                    queue.offer(edge.linked);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (result.size() != graph.size()) {</span><br><span class="line">            System.out.println(<span class="string">"出现环"</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">for</span> (String key : result) {</span><br><span class="line">                System.out.println(key);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="dfs-1">DFS</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopologicalSortDFS</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"网页基础"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"Java基础"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"JavaWeb"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"Spring框架"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"微服务框架"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"数据库"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"实战项目"</span>);</span><br><span class="line"></span><br><span class="line">        v1.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v3));</span><br><span class="line">        v2.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v3));</span><br><span class="line">        v3.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4));</span><br><span class="line">        v6.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4));</span><br><span class="line">        v4.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v5));</span><br><span class="line">        v5.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v7));</span><br><span class="line">        v7.edges = List.of();</span><br><span class="line"></span><br><span class="line">        List&lt;Vertex&gt; graph = List.of(v1, v2, v3, v4, v5, v6, v7);</span><br><span class="line">        LinkedList&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Vertex v : graph) {</span><br><span class="line">            <span class="keyword">if</span>(v.status==<span class="number">0</span>) {</span><br><span class="line">                dfs(v, result);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Vertex v, LinkedList&lt;String&gt; result)</span> {</span><br><span class="line">        <span class="keyword">if</span> (v.status == <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (v.status == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"发现环"</span>);</span><br><span class="line">        }</span><br><span class="line">        v.status = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : v.edges) {</span><br><span class="line">            dfs(edge.linked, result);</span><br><span class="line">        }</span><br><span class="line">        v.status = <span class="number">2</span>;</span><br><span class="line">        result.push(v.name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="最短路径">7) 最短路径</h3><h4 id="dijkstra">Dijkstra</h4><figure><img src="../../../../images/StrJava/330px-Edsger_Wybe_Dijkstra.jpg" alt="330px-Edsger_Wybe_Dijkstra"><figcaption aria-hidden="true">330px-Edsger_Wybe_Dijkstra</figcaption></figure><p><strong>Edsger Wybe Dijkstra</strong></p><blockquote><p>艾兹格·维布·迪克斯特拉（Edsger Wybe Dijkstra，/ˈdaɪkstrə/DYKE-strə；荷兰语：[ˈɛtsxər ˈʋibə ˈdɛikstra]1930年5月11日-2002年8月6日）是一位荷兰计算机科学家、程序员、软件工程师、系统科学家和科学散文家。他因对开发结构化编程语言做出的基础贡献而获得了1972年的图灵奖，并担任德克萨斯大学奥斯汀分校的斯伦贝谢百年计算机科学主席，任职时间从1984年到2000年。在他于2002年去世前不久，他因其在程序计算的自稳定性方面的工作而获得了ACMPODC分布式计算有影响力论文奖。为了纪念他，该年度奖项在接下来的一年更名为迪克斯特拉奖。</p><p>迪克斯特拉在计算机科学领域的贡献</p><ol type="1"><li>最短路径算法，也称为迪克斯特拉算法，现代计算机科学本科课程中广泛教授</li><li>Shunting yard算法</li><li>THE OS 操作系统</li><li>银行家算法</li><li>用于协调多个处理器和程序的信号量构造</li><li>在分布式计算领域提出概念：自稳定性</li></ol></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    1--7--&gt;2</span><br><span class="line">    1--9---&gt;3</span><br><span class="line">    1--14---&gt;6</span><br><span class="line">    6--9---&gt;5</span><br><span class="line">    3--2---&gt;6</span><br><span class="line">    2--15---&gt;4</span><br><span class="line">    3--11---&gt;4</span><br><span class="line">    4--6---&gt;5</span><br></pre></td></tr></tbody></table></figure><p>算法描述：</p><ol type="1"><li>将所有顶点标记为未访问。创建一个未访问顶点的集合。</li><li>为每个顶点分配一个临时距离值<ul><li>对于我们的初始顶点，将其设置为零</li><li>对于所有其他顶点，将其设置为无穷大。</li></ul></li><li>每次选择最小临时距离的未访问顶点，作为新的当前顶点</li><li>对于当前顶点，遍历其所有未访问的邻居，并更新它们的临时距离为更小<ul><li>例如，1-&gt;6 的距离是 14，而1-&gt;3-&gt;6的距离是11。这时将距离更新为 11</li><li>否则，将保留上次距离值</li></ul></li><li>当前顶点的邻居处理完成后，把它从未访问集合中删除</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dijkstra</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v1"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v2"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v3"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v4"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v5"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v6"</span>);</span><br><span class="line"></span><br><span class="line">        v1.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v3, <span class="number">9</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v2, <span class="number">7</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v6, <span class="number">14</span>));</span><br><span class="line">        v2.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4, <span class="number">15</span>));</span><br><span class="line">        v3.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4, <span class="number">11</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v6, <span class="number">2</span>));</span><br><span class="line">        v4.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v5, <span class="number">6</span>));</span><br><span class="line">        v5.edges = List.of();</span><br><span class="line">        v6.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v5, <span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">        List&lt;Vertex&gt; graph = List.of(v1, v2, v3, v4, v5, v6);</span><br><span class="line"></span><br><span class="line">        dijkstra(graph, v1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dijkstra</span><span class="params">(List&lt;Vertex&gt; graph, Vertex source)</span> {</span><br><span class="line">        ArrayList&lt;Vertex&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(graph);</span><br><span class="line">        source.dist = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!list.isEmpty()) {</span><br><span class="line">            <span class="comment">// 3. 选取当前顶点</span></span><br><span class="line">            <span class="type">Vertex</span> <span class="variable">curr</span> <span class="operator">=</span> chooseMinDistVertex(list);</span><br><span class="line">            <span class="comment">// 4. 更新当前顶点邻居距离</span></span><br><span class="line">            updateNeighboursDist(curr, list);</span><br><span class="line">            <span class="comment">// 5. 移除当前顶点</span></span><br><span class="line">            list.remove(curr);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Vertex v : graph) {</span><br><span class="line">            System.out.println(v.name + <span class="string">" "</span> + v.dist);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateNeighboursDist</span><span class="params">(Vertex curr, ArrayList&lt;Vertex&gt; list)</span> {</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : curr.edges) {</span><br><span class="line">            <span class="type">Vertex</span> <span class="variable">n</span> <span class="operator">=</span> edge.linked;</span><br><span class="line">            <span class="keyword">if</span> (list.contains(n)) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">dist</span> <span class="operator">=</span> curr.dist + edge.weight;</span><br><span class="line">                <span class="keyword">if</span> (dist &lt; n.dist) {</span><br><span class="line">                    n.dist = dist;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vertex <span class="title function_">chooseMinDistVertex</span><span class="params">(ArrayList&lt;Vertex&gt; list)</span> {</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">min</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; list.size(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (list.get(i).dist &lt; min.dist) {</span><br><span class="line">                min = list.get(i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>改进 - 优先级队列</p><ol type="1"><li>创建一个优先级队列，放入所有顶点（队列大小会达到边的数量）</li><li>为每个顶点分配一个临时距离值<ul><li>对于我们的初始顶点，将其设置为零</li><li>对于所有其他顶点，将其设置为无穷大。</li></ul></li><li>每次选择最小临时距离的未访问顶点，作为新的当前顶点</li><li>对于当前顶点，遍历其所有未访问的邻居，并更新它们的临时距离为更小，若距离更新需加入队列<ul><li>例如，1-&gt;6 的距离是 14，而1-&gt;3-&gt;6的距离是11。这时将距离更新为 11</li><li>否则，将保留上次距离值</li></ul></li><li>当前顶点的邻居处理完成后，把它从队列中删除</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DijkstraPriorityQueue</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v1"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v2"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v3"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v4"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v5"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v6"</span>);</span><br><span class="line"></span><br><span class="line">        v1.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v3, <span class="number">9</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v2, <span class="number">7</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v6, <span class="number">14</span>));</span><br><span class="line">        v2.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4, <span class="number">15</span>));</span><br><span class="line">        v3.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4, <span class="number">11</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v6, <span class="number">2</span>));</span><br><span class="line">        v4.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v5, <span class="number">6</span>));</span><br><span class="line">        v5.edges = List.of();</span><br><span class="line">        v6.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v5, <span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">        List&lt;Vertex&gt; graph = List.of(v1, v2, v3, v4, v5, v6);</span><br><span class="line"></span><br><span class="line">        dijkstra(graph, v1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dijkstra</span><span class="params">(List&lt;Vertex&gt; graph, Vertex source)</span> {</span><br><span class="line">        PriorityQueue&lt;Vertex&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(v -&gt; v.dist));</span><br><span class="line">        source.dist = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Vertex v : graph) {</span><br><span class="line">            queue.offer(v);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            System.out.println(queue);</span><br><span class="line">            <span class="comment">// 3. 选取当前顶点</span></span><br><span class="line">            <span class="type">Vertex</span> <span class="variable">curr</span> <span class="operator">=</span> queue.peek();</span><br><span class="line">            <span class="comment">// 4. 更新当前顶点邻居距离</span></span><br><span class="line">            <span class="keyword">if</span>(!curr.visited) {</span><br><span class="line">                updateNeighboursDist(curr, queue);</span><br><span class="line">                curr.visited = <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 5. 移除当前顶点</span></span><br><span class="line">            queue.poll();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Vertex v : graph) {</span><br><span class="line">            System.out.println(v.name + <span class="string">" "</span> + v.dist + <span class="string">" "</span> + (v.prev != <span class="literal">null</span> ? v.prev.name : <span class="string">"null"</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateNeighboursDist</span><span class="params">(Vertex curr, PriorityQueue&lt;Vertex&gt; queue)</span> {</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : curr.edges) {</span><br><span class="line">            <span class="type">Vertex</span> <span class="variable">n</span> <span class="operator">=</span> edge.linked;</span><br><span class="line">            <span class="keyword">if</span> (!n.visited) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">dist</span> <span class="operator">=</span> curr.dist + edge.weight;</span><br><span class="line">                <span class="keyword">if</span> (dist &lt; n.dist) {</span><br><span class="line">                    n.dist = dist;</span><br><span class="line">                    n.prev = curr;</span><br><span class="line">                    queue.offer(n);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>问题</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">v1 --2--&gt; v2</span><br><span class="line">v1 --1--&gt; v3</span><br><span class="line">v2 --"-2"--&gt; v3</span><br><span class="line">v3 --1--&gt; v4</span><br></pre></td></tr></tbody></table></figure><p>按照 Dijkstra 算法，得出</p><ul><li>v1 -&gt; v2 最短距离2</li><li>v1 -&gt; v3 最短距离1</li><li>v1 -&gt; v4 最短距离2</li></ul><p>事实应当是</p><ul><li>v1 -&gt; v2 最短距离2</li><li>v1 -&gt; v3 最短距离0</li><li>v1 -&gt; v4 最短距离1</li></ul><h4 id="bellman-ford">Bellman-Ford</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BellmanFord</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 正常情况</span></span><br><span class="line">        <span class="comment">/*Vertex v1 = new Vertex("v1");</span></span><br><span class="line"><span class="comment">        Vertex v2 = new Vertex("v2");</span></span><br><span class="line"><span class="comment">        Vertex v3 = new Vertex("v3");</span></span><br><span class="line"><span class="comment">        Vertex v4 = new Vertex("v4");</span></span><br><span class="line"><span class="comment">        Vertex v5 = new Vertex("v5");</span></span><br><span class="line"><span class="comment">        Vertex v6 = new Vertex("v6");</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        v1.edges = List.of(new Edge(v3, 9), new Edge(v2, 7), new Edge(v6, 14));</span></span><br><span class="line"><span class="comment">        v2.edges = List.of(new Edge(v4, 15));</span></span><br><span class="line"><span class="comment">        v3.edges = List.of(new Edge(v4, 11), new Edge(v6, 2));</span></span><br><span class="line"><span class="comment">        v4.edges = List.of(new Edge(v5, 6));</span></span><br><span class="line"><span class="comment">        v5.edges = List.of();</span></span><br><span class="line"><span class="comment">        v6.edges = List.of(new Edge(v5, 9));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        List&lt;Vertex&gt; graph = List.of(v4, v5, v6, v1, v2, v3);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 负边情况</span></span><br><span class="line">        <span class="comment">/*Vertex v1 = new Vertex("v1");</span></span><br><span class="line"><span class="comment">        Vertex v2 = new Vertex("v2");</span></span><br><span class="line"><span class="comment">        Vertex v3 = new Vertex("v3");</span></span><br><span class="line"><span class="comment">        Vertex v4 = new Vertex("v4");</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        v1.edges = List.of(new Edge(v2, 2), new Edge(v3, 1));</span></span><br><span class="line"><span class="comment">        v2.edges = List.of(new Edge(v3, -2));</span></span><br><span class="line"><span class="comment">        v3.edges = List.of(new Edge(v4, 1));</span></span><br><span class="line"><span class="comment">        v4.edges = List.of();</span></span><br><span class="line"><span class="comment">        List&lt;Vertex&gt; graph = List.of(v1, v2, v3, v4);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 负环情况</span></span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v1"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v2"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v3"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v4"</span>);</span><br><span class="line"></span><br><span class="line">        v1.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v2, <span class="number">2</span>));</span><br><span class="line">        v2.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v3, -<span class="number">4</span>));</span><br><span class="line">        v3.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4, <span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v1, <span class="number">1</span>));</span><br><span class="line">        v4.edges = List.of();</span><br><span class="line">        List&lt;Vertex&gt; graph = List.of(v1, v2, v3, v4);</span><br><span class="line"></span><br><span class="line">        bellmanFord(graph, v1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bellmanFord</span><span class="params">(List&lt;Vertex&gt; graph, Vertex source)</span> {</span><br><span class="line">        source.dist = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> graph.size();</span><br><span class="line">        <span class="comment">// 1. 进行 顶点个数 - 1 轮处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="comment">// 2. 遍历所有的边</span></span><br><span class="line">            <span class="keyword">for</span> (Vertex s : graph) {</span><br><span class="line">                <span class="keyword">for</span> (Edge edge : s.edges) {</span><br><span class="line">                    <span class="comment">// 3. 处理每一条边</span></span><br><span class="line">                    <span class="type">Vertex</span> <span class="variable">e</span> <span class="operator">=</span> edge.linked;</span><br><span class="line">                    <span class="keyword">if</span> (s.dist != Integer.MAX_VALUE &amp;&amp; s.dist + edge.weight &lt; e.dist) {</span><br><span class="line">                        e.dist = s.dist + edge.weight;</span><br><span class="line">                        e.prev = s;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (Vertex v : graph) {</span><br><span class="line">            System.out.println(v + <span class="string">" "</span> + (v.prev != <span class="literal">null</span> ? v.prev.name : <span class="string">"null"</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>负环</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">v1 --2--&gt; v2</span><br><span class="line">v2 --"-4"--&gt; v3</span><br><span class="line">v3 --1--&gt; v4</span><br><span class="line">v3 --1--&gt; v1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>如果在【顶点-1】轮处理完成后，还能继续找到更短距离，表示发现了负环</p><h4 id="floyd-warshall">Floyd-Warshall</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">v1 --"-2"--&gt; v3</span><br><span class="line">v2 --"4"--&gt; v1</span><br><span class="line">v2 --"3"--&gt; v3</span><br><span class="line">v3 --2--&gt; v4</span><br><span class="line">v4 --"-1"--&gt; v2</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FloydWarshall</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v1"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v2"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v3"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v4"</span>);</span><br><span class="line"></span><br><span class="line">        v1.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v3, -<span class="number">2</span>));</span><br><span class="line">        v2.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v1, <span class="number">4</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v3, <span class="number">3</span>));</span><br><span class="line">        v3.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4, <span class="number">2</span>));</span><br><span class="line">        v4.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v2, -<span class="number">1</span>));</span><br><span class="line">        List&lt;Vertex&gt; graph = List.of(v1, v2, v3, v4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                直接连通</span></span><br><span class="line"><span class="comment">                v1  v2  v3  v4</span></span><br><span class="line"><span class="comment">            v1  0   ∞   -2  ∞</span></span><br><span class="line"><span class="comment">            v2  4   0   3   ∞</span></span><br><span class="line"><span class="comment">            v3  ∞   ∞   0   2</span></span><br><span class="line"><span class="comment">            v4  ∞   -1  ∞   0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                k=0 借助v1到达其它顶点</span></span><br><span class="line"><span class="comment">                v1  v2  v3  v4</span></span><br><span class="line"><span class="comment">            v1  0   ∞   -2  ∞</span></span><br><span class="line"><span class="comment">            v2  4   0   2   ∞</span></span><br><span class="line"><span class="comment">            v3  ∞   ∞   0   2</span></span><br><span class="line"><span class="comment">            v4  ∞   -1  ∞   0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                k=1 借助v2到达其它顶点</span></span><br><span class="line"><span class="comment">                v1  v2  v3  v4</span></span><br><span class="line"><span class="comment">            v1  0   ∞   -2  ∞</span></span><br><span class="line"><span class="comment">            v2  4   0   2   ∞</span></span><br><span class="line"><span class="comment">            v3  ∞   ∞   0   2</span></span><br><span class="line"><span class="comment">            v4  3   -1  1   0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                k=2 借助v3到达其它顶点</span></span><br><span class="line"><span class="comment">                v1  v2  v3  v4</span></span><br><span class="line"><span class="comment">            v1  0   ∞   -2  0</span></span><br><span class="line"><span class="comment">            v2  4   0   2   4</span></span><br><span class="line"><span class="comment">            v3  ∞   ∞   0   2</span></span><br><span class="line"><span class="comment">            v4  3   -1  1   0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                k=3 借助v4到达其它顶点</span></span><br><span class="line"><span class="comment">                v1  v2  v3  v4</span></span><br><span class="line"><span class="comment">            v1  0   -1   -2  0</span></span><br><span class="line"><span class="comment">            v2  4   0   2   4</span></span><br><span class="line"><span class="comment">            v3  5   1   0   2</span></span><br><span class="line"><span class="comment">            v4  3   -1  1   0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        floydWarshall(graph);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">floydWarshall</span><span class="params">(List&lt;Vertex&gt; graph)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> graph.size();</span><br><span class="line">        <span class="type">int</span>[][] dist = <span class="keyword">new</span> <span class="title class_">int</span>[size][size];</span><br><span class="line">        Vertex[][] prev = <span class="keyword">new</span> <span class="title class_">Vertex</span>[size][size];</span><br><span class="line">        <span class="comment">// 1）初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            <span class="type">Vertex</span> <span class="variable">v</span> <span class="operator">=</span> graph.get(i); <span class="comment">// v1 (v3)</span></span><br><span class="line">            Map&lt;Vertex, Integer&gt; map = v.edges.stream().collect(Collectors.toMap(e -&gt; e.linked, e -&gt; e.weight));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; size; j++) {</span><br><span class="line">                <span class="type">Vertex</span> <span class="variable">u</span> <span class="operator">=</span> graph.get(j); <span class="comment">// v3</span></span><br><span class="line">                <span class="keyword">if</span> (v == u) {</span><br><span class="line">                    dist[i][j] = <span class="number">0</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dist[i][j] = map.getOrDefault(u, Integer.MAX_VALUE);</span><br><span class="line">                    prev[i][j] = map.get(u) != <span class="literal">null</span> ? v : <span class="literal">null</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        print(prev);</span><br><span class="line">        <span class="comment">// 2）看能否借路到达其它顶点</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            v2-&gt;v1          v1-&gt;v?</span></span><br><span class="line"><span class="comment">            dist[1][0]   +   dist[0][0]</span></span><br><span class="line"><span class="comment">            dist[1][0]   +   dist[0][1]</span></span><br><span class="line"><span class="comment">            dist[1][0]   +   dist[0][2]</span></span><br><span class="line"><span class="comment">            dist[1][0]   +   dist[0][3]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; size; k++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; size; j++) {</span><br><span class="line"><span class="comment">//                    dist[i][k]   +   dist[k][j] // i行的顶点，借助k顶点，到达j列顶点</span></span><br><span class="line"><span class="comment">//                    dist[i][j]                  // i行顶点，直接到达j列顶点</span></span><br><span class="line">                    <span class="keyword">if</span> (dist[i][k] != Integer.MAX_VALUE &amp;&amp;</span><br><span class="line">                            dist[k][j] != Integer.MAX_VALUE &amp;&amp;</span><br><span class="line">                            dist[i][k] + dist[k][j] &lt; dist[i][j]) {</span><br><span class="line">                        dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">                        prev[i][j] = prev[k][j];</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"><span class="comment">//            print(dist);</span></span><br><span class="line">        }</span><br><span class="line">        print(prev);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">path</span><span class="params">(Vertex[][] prev, List&lt;Vertex&gt; graph, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        LinkedList&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        System.out.print(<span class="string">"["</span> + graph.get(i).name + <span class="string">","</span> + graph.get(j).name + <span class="string">"] "</span>);</span><br><span class="line">        stack.push(graph.get(j).name);</span><br><span class="line">        <span class="keyword">while</span> (i != j) {</span><br><span class="line">            <span class="type">Vertex</span> <span class="variable">p</span> <span class="operator">=</span> prev[i][j];</span><br><span class="line">            stack.push(p.name);</span><br><span class="line">            j = graph.indexOf(p);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(stack);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[][] dist)</span> {</span><br><span class="line">        System.out.println(<span class="string">"-------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : dist) {</span><br><span class="line">            System.out.println(Arrays.stream(row).boxed()</span><br><span class="line">                    .map(x -&gt; x == Integer.MAX_VALUE ? <span class="string">"∞"</span> : String.valueOf(x))</span><br><span class="line">                    .map(s -&gt; String.format(<span class="string">"%2s"</span>, s))</span><br><span class="line">                    .collect(Collectors.joining(<span class="string">","</span>, <span class="string">"["</span>, <span class="string">"]"</span>)));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Vertex[][] prev)</span> {</span><br><span class="line">        System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Vertex[] row : prev) {</span><br><span class="line">            System.out.println(Arrays.stream(row).map(v -&gt; v == <span class="literal">null</span> ? <span class="string">"null"</span> : v.name)</span><br><span class="line">                    .map(s -&gt; String.format(<span class="string">"%5s"</span>, s))</span><br><span class="line">                    .collect(Collectors.joining(<span class="string">","</span>, <span class="string">"["</span>, <span class="string">"]"</span>)));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>负环</strong></p><p>如果在 3 层循环结束后，在 dist 数组的对角线处（i==j处）发现了负数，表示出现了负环</p><h3 id="最小生成树">8) 最小生成树</h3><h4 id="prim">Prim</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Prim</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v1"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v2"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v3"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v4"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v5"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v6"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v7"</span>);</span><br><span class="line"></span><br><span class="line">        v1.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v2, <span class="number">2</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v3, <span class="number">4</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v4, <span class="number">1</span>));</span><br><span class="line">        v2.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v1, <span class="number">2</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v4, <span class="number">3</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v5, <span class="number">10</span>));</span><br><span class="line">        v3.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v1, <span class="number">4</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v4, <span class="number">2</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v6, <span class="number">5</span>));</span><br><span class="line">        v4.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v1, <span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v2, <span class="number">3</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v3, <span class="number">2</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(v5, <span class="number">7</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v6, <span class="number">8</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v7, <span class="number">4</span>));</span><br><span class="line">        v5.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v2, <span class="number">10</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v4, <span class="number">7</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v7, <span class="number">6</span>));</span><br><span class="line">        v6.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v3, <span class="number">5</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v4, <span class="number">8</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v7, <span class="number">1</span>));</span><br><span class="line">        v7.edges = List.of(<span class="keyword">new</span> <span class="title class_">Edge</span>(v4, <span class="number">4</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v5, <span class="number">6</span>), <span class="keyword">new</span> <span class="title class_">Edge</span>(v6, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        List&lt;Vertex&gt; graph = List.of(v1, v2, v3, v4, v5, v6, v7);</span><br><span class="line"></span><br><span class="line">        prim(graph, v1);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prim</span><span class="params">(List&lt;Vertex&gt; graph, Vertex source)</span> {</span><br><span class="line">        ArrayList&lt;Vertex&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(graph);</span><br><span class="line">        source.dist = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!list.isEmpty()) {</span><br><span class="line">            <span class="type">Vertex</span> <span class="variable">min</span> <span class="operator">=</span> chooseMinDistVertex(list);</span><br><span class="line">            updateNeighboursDist(min);</span><br><span class="line">            list.remove(min);</span><br><span class="line">            min.visited = <span class="literal">true</span>;</span><br><span class="line">            System.out.println(<span class="string">"---------------"</span>);</span><br><span class="line">            <span class="keyword">for</span> (Vertex v : graph) {</span><br><span class="line">                System.out.println(v);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateNeighboursDist</span><span class="params">(Vertex curr)</span> {</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : curr.edges) {</span><br><span class="line">            <span class="type">Vertex</span> <span class="variable">n</span> <span class="operator">=</span> edge.linked;</span><br><span class="line">            <span class="keyword">if</span> (!n.visited) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">dist</span> <span class="operator">=</span> edge.weight;</span><br><span class="line">                <span class="keyword">if</span> (dist &lt; n.dist) {</span><br><span class="line">                    n.dist = dist;</span><br><span class="line">                    n.prev = curr;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vertex <span class="title function_">chooseMinDistVertex</span><span class="params">(ArrayList&lt;Vertex&gt; list)</span> {</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">min</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; list.size(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (list.get(i).dist &lt; min.dist) {</span><br><span class="line">                min = list.get(i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="kruskal">Kruskal</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kruskal</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Edge</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Edge&gt; {</span><br><span class="line">        List&lt;Vertex&gt; vertices;</span><br><span class="line">        <span class="type">int</span> start;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(List&lt;Vertex&gt; vertices, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> weight)</span> {</span><br><span class="line">            <span class="built_in">this</span>.vertices = vertices;</span><br><span class="line">            <span class="built_in">this</span>.start = start;</span><br><span class="line">            <span class="built_in">this</span>.end = end;</span><br><span class="line">            <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> weight)</span> {</span><br><span class="line">            <span class="built_in">this</span>.start = start;</span><br><span class="line">            <span class="built_in">this</span>.end = end;</span><br><span class="line">            <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Edge o)</span> {</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.weight, o.weight);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> vertices.get(start).name + <span class="string">"&lt;-&gt;"</span> + vertices.get(end).name + <span class="string">"("</span> + weight + <span class="string">")"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v1"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v2"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v3"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v4"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v5"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v6"</span>);</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">v7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vertex</span>(<span class="string">"v7"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Vertex&gt; vertices = List.of(v1, v2, v3, v4, v5, v6, v7);</span><br><span class="line">        PriorityQueue&lt;Edge&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(List.of(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(vertices,<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(vertices,<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(vertices,<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(vertices,<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(vertices,<span class="number">1</span>, <span class="number">4</span>, <span class="number">10</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(vertices,<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(vertices,<span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(vertices,<span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(vertices,<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(vertices,<span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(vertices,<span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(vertices,<span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>)</span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">        kruskal(vertices.size(), queue);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">kruskal</span><span class="params">(<span class="type">int</span> size, PriorityQueue&lt;Edge&gt; queue)</span> {</span><br><span class="line">        List&lt;Edge&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">DisjointSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DisjointSet</span>(size);</span><br><span class="line">        <span class="keyword">while</span> (result.size() &lt; size - <span class="number">1</span>) {</span><br><span class="line">            <span class="type">Edge</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> set.find(poll.start);</span><br><span class="line">            <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> set.find(poll.end);</span><br><span class="line">            <span class="keyword">if</span> (s != e) {</span><br><span class="line">                result.add(poll);</span><br><span class="line">                set.union(s, e);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Edge edge : result) {</span><br><span class="line">            System.out.println(edge);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="不相交集合并查集合">9) 不相交集合（并查集合）</h3><h4 id="基础">基础</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DisjointSet</span> {</span><br><span class="line">    <span class="type">int</span>[] s;</span><br><span class="line">    <span class="comment">// 索引对应顶点</span></span><br><span class="line">    <span class="comment">// 元素是用来表示与之有关系的顶点</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        索引  0  1  2  3  4  5  6</span></span><br><span class="line"><span class="comment">        元素 [0, 1, 2, 3, 4, 5, 6] 表示一开始顶点直接没有联系（只与自己有联系）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DisjointSet</span><span class="params">(<span class="type">int</span> size)</span> {</span><br><span class="line">        s = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            s[i] = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find 是找到老大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        <span class="keyword">if</span> (x == s[x]) {</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> find(s[x]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// union 是让两个集合“相交”，即选出新老大，x、y 是原老大索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> {</span><br><span class="line">        s[y] = x;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(s);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="路径压缩">路径压缩</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> { <span class="comment">// x = 2</span></span><br><span class="line">    <span class="keyword">if</span> (x == s[x]) {</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s[x] = find(s[x]); <span class="comment">// 0    s[2]=0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="union-by-size">Union By Size</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DisjointSetUnionBySize</span> {</span><br><span class="line">    <span class="type">int</span>[] s;</span><br><span class="line">    <span class="type">int</span>[] size;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DisjointSetUnionBySize</span><span class="params">(<span class="type">int</span> size)</span> {</span><br><span class="line">        s = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            s[i] = i;</span><br><span class="line">            <span class="built_in">this</span>.size[i] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find 是找到老大 - 优化：路径压缩</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> { <span class="comment">// x = 2</span></span><br><span class="line">        <span class="keyword">if</span> (x == s[x]) {</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s[x] = find(s[x]); <span class="comment">// 0    s[2]=0</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// union 是让两个集合“相交”，即选出新老大，x、y 是原老大索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> {</span><br><span class="line"><span class="comment">//        s[y] = x;</span></span><br><span class="line">        <span class="keyword">if</span> (size[x] &lt; size[y]) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> x;</span><br><span class="line">            x = y;</span><br><span class="line">            y = t;</span><br><span class="line">        }</span><br><span class="line">        s[y] = x;</span><br><span class="line">        size[x] = size[x] + size[y];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"内容："</span>+Arrays.toString(s) + <span class="string">"\n大小："</span> + Arrays.toString(size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">DisjointSetUnionBySize</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DisjointSetUnionBySize</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        set.union(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        set.union(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        set.union(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="图-相关题目">图-相关题目</h3><table><thead><tr class="header"><th>题目编号</th><th>题目标题</th><th>算法思想</th></tr></thead><tbody><tr class="odd"><td>547</td><td>省份数量</td><td>DFS、BFS、并查集</td></tr><tr class="even"><td>797</td><td>所有可能路径</td><td>DFS、BFS</td></tr><tr class="odd"><td>1584</td><td>连接所有点的最小费用</td><td>最小生成树</td></tr><tr class="even"><td>743</td><td>网络延迟时间</td><td>单源最短路径</td></tr><tr class="odd"><td>787</td><td>K 站中转内最便宜的航班</td><td>单源最短路径</td></tr><tr class="even"><td>207</td><td>课程表</td><td>拓扑排序</td></tr><tr class="odd"><td>210</td><td>课程表 II</td><td>拓扑排序</td></tr></tbody></table><h2 id="greedy-algorithm">4.2 Greedy Algorithm</h2><h3 id="贪心例子">1) 贪心例子</h3><p>称之为贪心算法或贪婪算法，核心思想是</p><ol type="1"><li>将寻找最优解的问题分为若干个步骤</li><li>每一步骤都采用贪心原则，选取当前最优解</li><li>因为没有考虑所有可能，局部最优的堆叠<strong>不一定</strong>让最终解最优</li></ol><p>贪心算法是一种在每一步选择中都采取在当前状态下最好或最优(即最有利)的选择，从而希望导致结果是最好或最优的算法。这种算法通常用于求解优化问题，如最小生成树、背包问题等。</p><p>贪心算法的应用：</p><ol type="1"><li>背包问题：给定一组物品和一个背包，每个物品有一定的重量和价值，要求在不超过背包容量的情况下，尽可能多地装入物品。</li><li>活动选择问题：在一个活动集合中，每次只能参加一个活动，问如何安排时间以最大化所有活动的收益。</li><li>编辑距离问题：给定两个字符串，求它们之间的最小编辑距离(即将一个字符串转换为另一个字符串所需的最少操作次数)。</li><li>网络流问题：给定一张有向图和一些起点和终点，求最大流量。</li><li>找零问题：给定一定数量的硬币和需要找零的金额，求使用最少的硬币数。</li></ol><p>常见问题及解答：</p><ol type="1"><li>贪心算法一定会找到最优解吗？答：不一定。贪心算法只保证在每一步选择中都是最优的，但并不能保证整个问题的最优解。例如，背包问题中的贪心算法可能会导致最后一个物品没有被装入背包。</li><li>如何判断一个问题是否适合用贪心算法解决？答：一个问题如果可以用递归的方式分解成若干个子问题，且每个子问题都有明确的最优解(即局部最优),那么这个问题就可以用贪心算法解决。</li><li>贪心算法的时间复杂度是多少？答：贪心算法的时间复杂度取决于问题的规模和具体实现。一般来说，对于规模较小的问题，贪心算法的时间复杂度可以达到O(nlogn)或O(n<sup>2);对于规模较大的问题，可能需要O(n</sup>3)或更高。</li></ol><p>几个贪心的例子</p><h4 id="dijkstra-1">Dijkstra</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">while</span> (!list.isEmpty()) {</span><br><span class="line">    <span class="comment">// 选取当前【距离最小】的顶点</span></span><br><span class="line">    <span class="type">Vertex</span> <span class="variable">curr</span> <span class="operator">=</span> chooseMinDistVertex(list);</span><br><span class="line">    <span class="comment">// 更新当前顶点邻居距离</span></span><br><span class="line">    updateNeighboursDist(curr);</span><br><span class="line">    <span class="comment">// 移除当前顶点</span></span><br><span class="line">    list.remove(curr);</span><br><span class="line">    <span class="comment">// 标记当前顶点已经处理过</span></span><br><span class="line">    curr.visited = <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>没找到最短路径的例子：负边存在时，可能得不到正确解</li><li>问题出在贪心的原则会认为本次已经找到了该顶点的最短路径，下次不会再处理它（curr.visited= true）</li><li>与之对比，Bellman-Ford并没有考虑局部距离最小的顶点，而是每次都处理所有边，所以不会出错，当然效率不如Dijkstra</li></ul><h4 id="prim-1">Prim</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">while</span> (!list.isEmpty()) {</span><br><span class="line">    <span class="comment">// 选取当前【距离最小】的顶点</span></span><br><span class="line">    <span class="type">Vertex</span> <span class="variable">curr</span> <span class="operator">=</span> chooseMinDistVertex(list);</span><br><span class="line">    <span class="comment">// 更新当前顶点邻居距离</span></span><br><span class="line">    updateNeighboursDist(curr);</span><br><span class="line">    <span class="comment">// 移除当前顶点</span></span><br><span class="line">    list.remove(curr);</span><br><span class="line">    <span class="comment">// 标记当前顶点已经处理过</span></span><br><span class="line">    curr.visited = <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="kruskal-1">Kruskal</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">while</span> (list.size() &lt; size - <span class="number">1</span>) {</span><br><span class="line">    <span class="comment">// 选取当前【距离最短】的边</span></span><br><span class="line">    <span class="type">Edge</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">    <span class="comment">// 判断两个集合是否相交</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> set.find(poll.start);</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> set.find(poll.end);</span><br><span class="line">    <span class="keyword">if</span> (i != j) { <span class="comment">// 未相交</span></span><br><span class="line">        list.add(poll);</span><br><span class="line">        set.union(i, j); <span class="comment">// 相交</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其它贪心的例子</p><ul><li>选择排序、堆排序</li><li>拓扑排序</li><li>并查集合中的 union by size 和 union by height</li><li>哈夫曼编码</li><li>钱币找零，英文搜索关键字<ul><li>change-making problem</li><li>find Minimum number of Coins</li></ul></li><li>任务编排</li><li>求复杂问题的近似解</li></ul><h3 id="零钱兑换问题">2) 零钱兑换问题</h3><h4 id="有几个解零钱兑换-iileetcode-518">有几个解（零钱兑换 II）Leetcode518</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leetcode518</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> {</span><br><span class="line">        <span class="keyword">return</span> rec(<span class="number">0</span>, coins, amount, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), <span class="literal">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求凑成剩余金额的解的个数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index     当前硬币索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coins     硬币面值数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> remainder 剩余金额</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stack     -</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> first     -</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rec</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span>[] coins, <span class="type">int</span> remainder, LinkedList&lt;Integer&gt; stack, <span class="type">boolean</span> first)</span> {</span><br><span class="line">        <span class="keyword">if</span>(!first) {</span><br><span class="line">            stack.push(coins[index]);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 情况1：剩余金额 &lt; 0 - 无解</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (remainder &lt; <span class="number">0</span>) {</span><br><span class="line">            print(<span class="string">"无解："</span>, stack);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 情况2：剩余金额 == 0 - 有解</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (remainder == <span class="number">0</span>) {</span><br><span class="line">            print(<span class="string">"有解："</span>, stack);</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 情况3：剩余金额 &gt; 0 - 继续递归</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; coins.length; i++) {</span><br><span class="line">                count += rec(i, coins, remainder - coins[i], stack, <span class="literal">false</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty()) {</span><br><span class="line">            stack.pop();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String prompt, LinkedList&lt;Integer&gt; stack)</span> {</span><br><span class="line">        ArrayList&lt;Integer&gt; print = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ListIterator&lt;Integer&gt; iterator = stack.listIterator(stack.size());</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasPrevious()) {</span><br><span class="line">            print.add(iterator.previous());</span><br><span class="line">        }</span><br><span class="line">        System.out.println(prompt + print);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Leetcode518</span> <span class="variable">leetcode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leetcode518</span>();</span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{1, 5, 10, 25}, 41);</span></span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{25, 10, 5, 1}, 41);</span></span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{5, 2, 1}, 5);</span></span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{1, 2, 5}, 5);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> leetcode.change(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">15</span>, <span class="number">10</span>, <span class="number">1</span>}, <span class="number">21</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="最优解零钱兑换--穷举法-leetcode-322">最优解（零钱兑换）- 穷举法Leetcode 322</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leetcode322</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 需要的最少硬币数  2 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> {</span><br><span class="line">        rec(<span class="number">0</span>, coins, amount, <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(-<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// count 代表某一组合 钱币的总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rec</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span>[] coins, <span class="type">int</span> remainder, AtomicInteger count, LinkedList&lt;Integer&gt; stack, <span class="type">boolean</span> first)</span> {</span><br><span class="line">        <span class="keyword">if</span> (!first) {</span><br><span class="line">            stack.push(coins[index]);</span><br><span class="line">        }</span><br><span class="line">        count.incrementAndGet(); <span class="comment">// count++</span></span><br><span class="line">        <span class="keyword">if</span> (remainder == <span class="number">0</span>) {</span><br><span class="line">            System.out.println(stack);</span><br><span class="line">            <span class="keyword">if</span> (min == -<span class="number">1</span>) {</span><br><span class="line">                min = count.get();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                min = Integer.min(min, count.get());</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (remainder &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; coins.length; i++) {</span><br><span class="line">                rec(i, coins, remainder - coins[i], count, stack, <span class="literal">false</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        count.decrementAndGet(); <span class="comment">// count--</span></span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty()) {</span><br><span class="line">            stack.pop();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Leetcode322</span> <span class="variable">leetcode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leetcode322</span>();</span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{5, 2, 1}, 5);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> leetcode.coinChange(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">25</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>}, <span class="number">41</span>);</span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{2}, 3);</span></span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{15, 10, 1}, 21);</span></span><br><span class="line">        System.out.println(count);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="最优解零钱兑换--贪心法-leetcode-322">最优解（零钱兑换）- 贪心法Leetcode 322</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leetcode322</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> amount;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> coin : coins) {</span><br><span class="line">            <span class="keyword">while</span> (remainder - coin &gt; <span class="number">0</span>) {</span><br><span class="line">                remainder -= coin;</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (remainder - coin == <span class="number">0</span>) {</span><br><span class="line">                remainder = <span class="number">0</span>;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (remainder &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Leetcode322</span> <span class="variable">leetcode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leetcode322</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> leetcode.coinChange(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>}, <span class="number">5</span>);</span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{25, 10, 5, 1}, 41);</span></span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{2}, 3);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 问题1 没有回头，导致找到更差的解</span></span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{15, 10, 1}, 21);  </span></span><br><span class="line">        <span class="comment">// 问题2 没有回头，导致无解</span></span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{15, 10}, 20);  </span></span><br><span class="line">        System.out.println(count);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="huffman-编码问题">3) Huffman 编码问题</h3><h4 id="问题引入">问题引入</h4><p>什么是编码？</p><p>简单说就是建立【字符】到【数字】的对应关系，如下面大家熟知的 ASC II编码表，例如，可以查表得知字符【a】对应的数字是十六进制数【0x61】</p><table><colgroup><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"><col style="width: 5%"></colgroup><thead><tr class="header"><th>\</th><th>00</th><th>01</th><th>02</th><th>03</th><th>04</th><th>05</th><th>06</th><th>07</th><th>08</th><th>09</th><th>0a</th><th>0b</th><th>0c</th><th>0d</th><th>0e</th><th>0f</th></tr></thead><tbody><tr class="odd"><td>0000</td><td>00</td><td>01</td><td>02</td><td>03</td><td>04</td><td>05</td><td>06</td><td>07</td><td>08</td><td>09</td><td>0a</td><td>0b</td><td>0c</td><td>0d</td><td>0e</td><td>0f</td></tr><tr class="even"><td>0010</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td><td>17</td><td>18</td><td>19</td><td>1a</td><td>1b</td><td>1c</td><td>1d</td><td>1e</td><td>1f</td></tr><tr class="odd"><td>0020</td><td>20</td><td>!</td><td>"</td><td>#</td><td>$</td><td>%</td><td>&amp;</td><td>'</td><td>(</td><td>)</td><td>*</td><td>+</td><td>,</td><td>-</td><td>.</td><td>/</td></tr><tr class="even"><td>0030</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>:</td><td>;</td><td>&lt;</td><td>=</td><td>&gt;</td><td>?</td></tr><tr class="odd"><td>0040</td><td>@</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td><td>G</td><td>H</td><td>I</td><td>J</td><td>K</td><td>L</td><td>M</td><td>N</td><td>O</td></tr><tr class="even"><td>0050</td><td>P</td><td>Q</td><td>R</td><td>S</td><td>T</td><td>U</td><td>V</td><td>W</td><td>X</td><td>Y</td><td>Z</td><td>[</td><td>\</td><td>]</td><td>^</td><td>_</td></tr><tr class="odd"><td>0060</td><td>`</td><td>a</td><td>b</td><td>c</td><td>d</td><td>e</td><td>f</td><td>g</td><td>h</td><td>i</td><td>j</td><td>k</td><td>l</td><td>m</td><td>n</td><td>o</td></tr><tr class="even"><td>0070</td><td>p</td><td>q</td><td>r</td><td>s</td><td>t</td><td>u</td><td>v</td><td>w</td><td>x</td><td>y</td><td>z</td><td>{</td><td>|</td><td>}</td><td>~</td><td>7f</td></tr></tbody></table><blockquote><p>注：一些直接以十六进制数字标识的是那些不可打印字符</p></blockquote><p>传输时的编码</p><ul><li>java 中每个 char 对应的数字会占用固定长度 2 个字节</li><li>如果在传输中仍采用上述规则，传递 abbccccccc 这 10 个字符<ul><li>实际的字节为0061006200620063006300630063006300630063（16进制表示）</li><li>总共 20 个字节，不经济</li></ul></li></ul><p>现在希望找到一种最节省字节的传输方式，怎么办？</p><p>假设传输的字符中只包含 a，b，c 这 3个字符，有同学重新设计一张二进制编码表，见下图</p><ul><li>0 表示 a</li><li>1 表示 b</li><li>10 表示 c</li></ul><p>现在还是传递 abbccccccc 这 10 个字符</p><ul><li>实际的字节为 01110101010101010 （二进制表示）</li><li>总共需要 17 bits，也就是 2 个字节多一点，行不行？</li></ul><p>不行，因为解码会出现问题，因为 10 会被错误的解码成 ba，而不是 c</p><ul><li>解码后结果为 abbbababababababa，是错误的</li></ul><p>怎么解决？必须保证编码后的二进制数字，要能区分它们的前缀（prefix-free）</p><p>用满二叉树结构编码，可以确保前缀不重复</p><figure><img src="../../../../images/StrJava/image-20230616094945068.png" alt="image-20230616094945068"><figcaption aria-hidden="true">image-20230616094945068</figcaption></figure><ul><li>向左走 0，向右走 1</li><li>走到叶子字符，累计起来的 0 和 1 就是该字符的二进制编码</li></ul><p>再来试一遍</p><ul><li>a 的编码 0</li><li>b 的编码 10</li><li>c 的编码 11</li></ul><p>现在还是传递 abbccccccc 这 10 个字符</p><ul><li>实际的字节为 0101011111111111111（二进制表示）</li><li>总共需要 19 bits，也是 2个字节多一点，并且解码没有问题了，行不行？</li></ul><p>这回解码没问题了，但并非最少字节，因为 c 的出现频率高（7 次）a的出现频率低（1 次），因此出现频率高的字符编码成短数字更经济</p><p>考察下面的树</p><figure><img src="../../../../images/StrJava/image-20230616095129461.png" alt="image-20230616095129461"><figcaption aria-hidden="true">image-20230616095129461</figcaption></figure><ul><li>00 表示 a</li><li>01 表示 b</li><li>1 表示 c</li></ul><p>现在还是传递 abbccccccc 这 10 个字符</p><ul><li>实际的字节为 000101 1111111 （二进制表示）</li><li>总共需要 13 bits，这棵树就称之为 Huffman 树</li><li>根据 Huffman 树对字符和数字进行编解码，就是 Huffman 编解码</li></ul><h4 id="huffman-树">Huffman 树</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanTree</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Huffman 树的构建过程</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1. 将统计了出现频率的字符，放入优先级队列</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2. 每次出队两个频次最低的元素，给它俩找个爹</span></span><br><span class="line"><span class="comment">        3. 把爹重新放入队列，重复 2~3</span></span><br><span class="line"><span class="comment">        4. 当队列只剩一个元素时，Huffman 树构建完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">        Character ch; <span class="comment">// 字符</span></span><br><span class="line">        <span class="type">int</span> freq;     <span class="comment">// 频次</span></span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        String code;  <span class="comment">// 编码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Character ch)</span> {</span><br><span class="line">            <span class="built_in">this</span>.ch = ch;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> freq, Node left, Node right)</span> {</span><br><span class="line">            <span class="built_in">this</span>.freq = freq;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">freq</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> freq;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">isLeaf</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> left == <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Node{"</span> +</span><br><span class="line">                    <span class="string">"ch="</span> + ch +</span><br><span class="line">                    <span class="string">", freq="</span> + freq +</span><br><span class="line">                    <span class="string">'}'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    String str;</span><br><span class="line">    Map&lt;Character, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HuffmanTree</span><span class="params">(String str)</span> {</span><br><span class="line">        <span class="built_in">this</span>.str = str;</span><br><span class="line">        <span class="comment">// 功能1：统计频率</span></span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : chars) {</span><br><span class="line">            <span class="comment">/*if (!map.containsKey(c)) {</span></span><br><span class="line"><span class="comment">                map.put(c, new Node(c));</span></span><br><span class="line"><span class="comment">            }</span></span><br><span class="line"><span class="comment">            Node node = map.get(c);</span></span><br><span class="line"><span class="comment">            node.freq++;*/</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.computeIfAbsent(c, Node::<span class="keyword">new</span>);</span><br><span class="line">            node.freq++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 功能2: 构造树</span></span><br><span class="line">        PriorityQueue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(Node::freq));</span><br><span class="line">        queue.addAll(map.values());</span><br><span class="line">        <span class="keyword">while</span> (queue.size() &gt;= <span class="number">2</span>) {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">y</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">freq</span> <span class="operator">=</span> x.freq + y.freq;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="title class_">Node</span>(freq, x, y));</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="comment">// 功能3：计算每个字符的编码, 功能4：字符串编码后占用 bits</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> dfs(root, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>());</span><br><span class="line">        <span class="keyword">for</span> (Node node : map.values()) {</span><br><span class="line">            System.out.println(node + <span class="string">" "</span> + node.code);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"总共会占用 bits:"</span> + sum);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(Node node, StringBuilder code)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.isLeaf()) {</span><br><span class="line">            node.code = code.toString();</span><br><span class="line">            sum = node.freq * code.length();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            sum += dfs(node.left, code.append(<span class="string">"0"</span>));</span><br><span class="line">            sum += dfs(node.right, code.append(<span class="string">"1"</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (code.length() &gt; <span class="number">0</span>) {</span><br><span class="line">            code.deleteCharAt(code.length() - <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HuffmanTree</span>(<span class="string">"abbccccccc"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong><em>注意</em></strong></p><ul><li>Node::new 是一个 Function，根据 key（即字符）生成 Node 对象</li><li>对应的是 public Node(Character ch) 有参构造</li></ul></blockquote><h4 id="huffman-编解码">Huffman 编解码</h4><p>补充两个方法，注意为了简单期间用了编解码都用字符串演示，实际应该按bits 编解码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanTree</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : chars) {</span><br><span class="line">            sb.append(map.get(c).code);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decode</span><span class="params">(String str)</span> {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            从根节点，寻找数字对应的字符</span></span><br><span class="line"><span class="comment">                数字是 0 向左走</span></span><br><span class="line"><span class="comment">                数字是 1 向右走</span></span><br><span class="line"><span class="comment">                如果没走到头，每走一步数字的索引 i++</span></span><br><span class="line"><span class="comment">            走到头就可以找到解码字符，再将 node 重置为根节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; chars.length) {</span><br><span class="line">            <span class="keyword">if</span> (!node.isLeaf()) { <span class="comment">// 非叶子</span></span><br><span class="line">                <span class="keyword">if</span>(chars[i] == <span class="string">'0'</span>) { <span class="comment">// 向左走</span></span><br><span class="line">                    node = node.left;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span>(chars[i] == <span class="string">'1'</span>) { <span class="comment">// 向右走</span></span><br><span class="line">                    node = node.right;</span><br><span class="line">                }</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.isLeaf()) {</span><br><span class="line">                sb.append(node.ch);</span><br><span class="line">                node = root;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings("all")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">HuffmanTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HuffmanTree</span>(<span class="string">"abbccccccc"</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">encoded</span> <span class="operator">=</span> tree.encode();</span><br><span class="line">        System.out.println(encoded);</span><br><span class="line">        System.out.println(tree.decode(encoded));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong><em>注意</em></strong></p><ul><li>循环中非叶子节点 i 要自增，但叶子节点 i 暂不自增</li><li>第一个非叶子的 if 判断结束后，仍需要第二个叶子的 if判断，因为在第一个 if 内 node 发生了变化</li></ul></blockquote><h4 id="相关题目">相关题目</h4><table><thead><tr class="header"><th>题目编号</th><th>题目标题</th><th>算法思路</th></tr></thead><tbody><tr class="odd"><td>1167（Plus 题目）</td><td>连接棒材的最低费用</td><td>Huffman 树、贪心</td></tr></tbody></table><p>参考解答</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;连接棒材的最低费用&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;为了装修新房，你需要加工一些长度为正整数的棒材。如果要将长度分别为 X 和 Y 的两根棒材连接在一起，你需要支付 X + Y 的费用。 返回讲所有棒材连成一根所需要的最低费用。&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leetcode1167</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        举例 棒材为 [1,8,3,5]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        如果以如下顺序连接(非最优)</span></span><br><span class="line"><span class="comment">        - 1+8=9</span></span><br><span class="line"><span class="comment">        - 9+3=12</span></span><br><span class="line"><span class="comment">        - 12+5=17</span></span><br><span class="line"><span class="comment">        总费用为 9+12+17=38</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        如果以如下顺序连接(最优)</span></span><br><span class="line"><span class="comment">        - 1+3=4</span></span><br><span class="line"><span class="comment">        - 4+5=9</span></span><br><span class="line"><span class="comment">        - 8+9=17</span></span><br><span class="line"><span class="comment">        总费用为 4+9+17=30</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">connectSticks</span><span class="params">(<span class="type">int</span>[] sticks)</span> {</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> stick : sticks) {</span><br><span class="line">            queue.offer(stick);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() &gt;= <span class="number">2</span>) {</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> x + y;</span><br><span class="line">            sum += c;</span><br><span class="line">            queue.offer(c);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Leetcode1167</span> <span class="variable">leetcode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leetcode1167</span>();</span><br><span class="line">        System.out.println(leetcode.connectSticks(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>})); <span class="comment">// 30</span></span><br><span class="line">        System.out.println(leetcode.connectSticks(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>})); <span class="comment">// 14</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="活动选择问题">4) 活动选择问题</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActivitySelectionProblem</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        要在一个会议室举办 n 个活动</span></span><br><span class="line"><span class="comment">        - 每个活动有它们各自的起始和结束时间</span></span><br><span class="line"><span class="comment">        - 找出在时间上互不冲突的活动组合，能够最充分利用会议室（举办的活动次数最多）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        例1</span></span><br><span class="line"><span class="comment">            0   1   2   3   4   5   6   7   8   9</span></span><br><span class="line"><span class="comment">                |-------)</span></span><br><span class="line"><span class="comment">                    |-------)</span></span><br><span class="line"><span class="comment">                        |-------)</span></span><br><span class="line"><span class="comment">        例2</span></span><br><span class="line"><span class="comment">            0   1   2   3   4   5   6   7   8   9</span></span><br><span class="line"><span class="comment">                |---)</span></span><br><span class="line"><span class="comment">                        |---)</span></span><br><span class="line"><span class="comment">            |-----------------------)</span></span><br><span class="line"><span class="comment">                                |-------)</span></span><br><span class="line"><span class="comment">                                            |---)</span></span><br><span class="line"><span class="comment">                                |---------------)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        几种贪心策略</span></span><br><span class="line"><span class="comment">        1. 优先选择持续时间最短的活动</span></span><br><span class="line"><span class="comment">            0   1   2   3   4   5   6   7   8   9</span></span><br><span class="line"><span class="comment">                |---------------)</span></span><br><span class="line"><span class="comment">                            |-------)</span></span><br><span class="line"><span class="comment">                                |---------------)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2. 优先选择冲突最少的活动</span></span><br><span class="line"><span class="comment">            0   1   2   3   4   5   6   7   8   9</span></span><br><span class="line"><span class="comment">            |-------)                                       3</span></span><br><span class="line"><span class="comment">                |-------)                                   4</span></span><br><span class="line"><span class="comment">                |-------)                                   4</span></span><br><span class="line"><span class="comment">                |-------)                                   4</span></span><br><span class="line"><span class="comment">                    |-------)                               4</span></span><br><span class="line"><span class="comment">                        |-------)                           2</span></span><br><span class="line"><span class="comment">                            |-----------)                   4</span></span><br><span class="line"><span class="comment">                                    |-------)               4</span></span><br><span class="line"><span class="comment">                                    |-------)               4</span></span><br><span class="line"><span class="comment">                                    |-------)               4</span></span><br><span class="line"><span class="comment">                                        |-------)           3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3. 优先选择最先开始的活动</span></span><br><span class="line"><span class="comment">            0   1   2   3   4   5   6   7   8   9</span></span><br><span class="line"><span class="comment">            |-----------------------------------)</span></span><br><span class="line"><span class="comment">                |---)</span></span><br><span class="line"><span class="comment">                    |---)</span></span><br><span class="line"><span class="comment">                        |---)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        4. 优先选择最后结束的活动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Activity</span> {</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="type">int</span> start;</span><br><span class="line">        <span class="type">int</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Activity</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> start, <span class="type">int</span> finish)</span> {</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">            <span class="built_in">this</span>.start = start;</span><br><span class="line">            <span class="built_in">this</span>.finish = finish;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Activity("</span> + index + <span class="string">")"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Activity[] activities = <span class="keyword">new</span> <span class="title class_">Activity</span>[]{</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Activity</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Activity</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Activity</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">        };</span><br><span class="line"><span class="comment">//        Activity[] activities = new Activity[]{</span></span><br><span class="line"><span class="comment">//                new Activity(0, 1, 2),</span></span><br><span class="line"><span class="comment">//                new Activity(1, 3, 4),</span></span><br><span class="line"><span class="comment">//                new Activity(2, 0, 6),</span></span><br><span class="line"><span class="comment">//                new Activity(3, 5, 7),</span></span><br><span class="line"><span class="comment">//                new Activity(4, 8, 9),</span></span><br><span class="line"><span class="comment">//                new Activity(5, 5, 9)</span></span><br><span class="line"><span class="comment">//        };</span></span><br><span class="line">        select(activities, activities.length);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">(Activity[] activities, <span class="type">int</span> n)</span> {</span><br><span class="line">        List&lt;Activity&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        result.add(activities[i]);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; n; j++) {</span><br><span class="line">            <span class="keyword">if</span> (activities[j].start &gt;= activities[i].finish) {</span><br><span class="line">                result.add(activities[j]);</span><br><span class="line">                i = j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="无重叠区间-leetcode-435">无重叠区间-Leetcode 435</h4><table><thead><tr class="header"><th>题目编号</th><th>题目标题</th><th>算法思路</th></tr></thead><tbody><tr class="odd"><td>435</td><td>无重叠区间</td><td>贪心</td></tr></tbody></table><p>参考解答</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 下面代码为 Leetcode 435 题解</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> {</span><br><span class="line">    Arrays.sort(intervals, Comparator.comparingInt(a -&gt; a[<span class="number">1</span>]));</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; intervals.length; j++) {</span><br><span class="line">        <span class="keyword">if</span> (intervals[j][<span class="number">0</span>] &gt;= intervals[i][<span class="number">1</span>]) {</span><br><span class="line">            i = j;</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> intervals.length - count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>找到不重叠的最多的活动数（count），即活动选择问题原始需求</li><li>在此基础上，活动总数 - count，就是题目要的排除数量</li></ul><h3 id="分数背包问题">5) 分数背包问题</h3><h4 id="贪心法">贪心法</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FractionalKnapsackProblem</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. n个物品都是液体，有重量和价值</span></span><br><span class="line"><span class="comment">    2. 现在你要取走 10升 的液体</span></span><br><span class="line"><span class="comment">    3. 每次可以不拿，全拿，或拿一部分，问最高价值是多少</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        编号 重量(升) 价值</span></span><br><span class="line"><span class="comment">        0   4       24      水</span></span><br><span class="line"><span class="comment">        1   8       160     牛奶       选中 7/8</span></span><br><span class="line"><span class="comment">        2   2       4000    五粮液     选中</span></span><br><span class="line"><span class="comment">        3   6       108     可乐</span></span><br><span class="line"><span class="comment">        4   1       4000    茅台       选中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        8140</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        简化起见，给出的数据都是【价值/重量】能够整除，避免计算结果中出现小数，增加心算难度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Item</span> {</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Item</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> weight, <span class="type">int</span> value)</span> {</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">            <span class="built_in">this</span>.weight = weight;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">unitPrice</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> value / weight;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Item("</span> + index + <span class="string">")"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Item[] items = <span class="keyword">new</span> <span class="title class_">Item</span>[]{</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">0</span>, <span class="number">4</span>, <span class="number">24</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">1</span>, <span class="number">8</span>, <span class="number">160</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="number">4000</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">3</span>, <span class="number">6</span>, <span class="number">108</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">4000</span>),</span><br><span class="line">        };</span><br><span class="line">        select(items, <span class="number">10</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">(Item[] items, <span class="type">int</span> total)</span> {</span><br><span class="line">        Arrays.sort(items, Comparator.comparingInt(Item::unitPrice).reversed());</span><br><span class="line">        <span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> total;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Item item : items) {</span><br><span class="line">            <span class="keyword">if</span> (remainder - item.weight &gt; <span class="number">0</span>) {</span><br><span class="line">                max += item.value;</span><br><span class="line">                remainder -= item.weight;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                max += remainder * item.unitPrice();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"最高价值为："</span> + max);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="背包问题">6) 0-1 背包问题</h3><h4 id="贪心法-1">贪心法</h4><p>可能得不到最优解</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KnapsackProblem</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. n个物品都是固体，有重量和价值</span></span><br><span class="line"><span class="comment">    2. 现在你要取走不超过 10克 的物品</span></span><br><span class="line"><span class="comment">    3. 每次可以不拿或全拿，问最高价值是多少</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        编号 重量(g)  价值(元)</span></span><br><span class="line"><span class="comment">        0   1       1_000_000      钻戒一枚</span></span><br><span class="line"><span class="comment">        1   4       1600           黄金一块</span></span><br><span class="line"><span class="comment">        2   8       2400           红宝石戒指一枚</span></span><br><span class="line"><span class="comment">        3   5       30             白银一块</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Item</span> {</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Item</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> weight, <span class="type">int</span> value)</span> {</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">            <span class="built_in">this</span>.weight = weight;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">unitValue</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> value / weight;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Item("</span> + index + <span class="string">")"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Item[] items = <span class="keyword">new</span> <span class="title class_">Item</span>[]{</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1_000_000</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1600</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">2</span>, <span class="number">8</span>, <span class="number">2400</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">30</span>)</span><br><span class="line">        };</span><br><span class="line">        select(items, <span class="number">10</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">(Item[] items, <span class="type">int</span> total)</span> {</span><br><span class="line">        Arrays.sort(items, Comparator.comparingInt(Item::unitValue).reversed());</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 最大价值</span></span><br><span class="line">        <span class="keyword">for</span> (Item item : items) {</span><br><span class="line">            System.out.println(item);</span><br><span class="line">            <span class="keyword">if</span> (total &gt;= item.weight) { <span class="comment">// 可以拿完</span></span><br><span class="line">                total -= item.weight;</span><br><span class="line">                max += item.value;</span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 拿不完</span></span><br><span class="line"><span class="comment">//                max += total * item.unitValue();</span></span><br><span class="line"><span class="comment">//                break;</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"最大价值是:"</span> + max);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="贪心算法的局限">贪心算法的局限</h3><table><thead><tr class="header"><th>问题名称</th><th>是否能用贪心得到最优解</th><th>替换解法</th></tr></thead><tbody><tr class="odd"><td>Dijkstra(不存在负边)</td><td>✔️</td><td></td></tr><tr class="even"><td>Dijkstra(存在负边)</td><td>❌</td><td>Bellman-Ford</td></tr><tr class="odd"><td>Prim</td><td>✔️</td><td></td></tr><tr class="even"><td>Kruskal</td><td>✔️</td><td></td></tr><tr class="odd"><td>零钱兑换</td><td>❌</td><td>动态规划</td></tr><tr class="even"><td>Huffman 树</td><td>✔️</td><td></td></tr><tr class="odd"><td>活动选择问题</td><td>✔️</td><td></td></tr><tr class="even"><td>分数背包问题</td><td>✔️</td><td></td></tr><tr class="odd"><td>0-1 背包问题</td><td>❌</td><td>动态规划</td></tr></tbody></table><h3 id="set-cover-problem">7) Set cover problem</h3><p>集合覆盖问题</p><h2 id="dynamic-programming">4.3 Dynamic-Programming</h2><h3 id="fibonacci">1) Fibonacci</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fibonacci</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(fibonacci(<span class="number">13</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> dp[n];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) {</span><br><span class="line">            dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="降维">降维</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fibonacci</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(fibonacci(<span class="number">13</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> {        </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> b + a;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="最短路径---bellman-ford">2) 最短路径 - Bellman-Ford</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BellmanFord</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Edge</span> {</span><br><span class="line">        <span class="type">int</span> from;</span><br><span class="line">        <span class="type">int</span> to;</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> weight)</span> {</span><br><span class="line">            <span class="built_in">this</span>.from = from;</span><br><span class="line">            <span class="built_in">this</span>.to = to;</span><br><span class="line">            <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">            f(v) 用来表示从起点出发，到达 v 这个顶点的最短距离</span></span><br><span class="line"><span class="comment">            初始时</span></span><br><span class="line"><span class="comment">            f(v) = 0   当 v==起点 时</span></span><br><span class="line"><span class="comment">            f(v) = ∞   当 v!=起点 时</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            之后</span></span><br><span class="line"><span class="comment">            新           旧     所有from</span></span><br><span class="line"><span class="comment">            f(to) = min(f(to), f(from) + from.weight)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            from 从哪来</span></span><br><span class="line"><span class="comment">            to   到哪去</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            f(v4) = min( ∞, f(v3) + 11 ) = 20</span></span><br><span class="line"><span class="comment">            f(v4) = min( 20, f(v2) + 15 ) = 20</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            v1  v2  v3  v4  v5  v6</span></span><br><span class="line"><span class="comment">            0   ∞   ∞   ∞   ∞   ∞</span></span><br><span class="line"><span class="comment">            0   7   9   ∞   ∞   14  第一轮</span></span><br><span class="line"><span class="comment">            0   7   9   20  23  11  第二轮</span></span><br><span class="line"><span class="comment">            0   7   9   20  20  11  第三轮</span></span><br><span class="line"><span class="comment">            0   7   9   20  20  11  第四轮</span></span><br><span class="line"><span class="comment">            0   7   9   20  20  11  第五轮</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        List&lt;Edge&gt; edges = List.of(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">6</span>, <span class="number">5</span>, <span class="number">9</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">1</span>, <span class="number">6</span>, <span class="number">14</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">11</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">15</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">7</span>]; <span class="comment">// 一维数组用来缓存结果</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; dp.length; i++) {</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">        }</span><br><span class="line">        print(dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="keyword">for</span> (Edge e : edges) {</span><br><span class="line">                <span class="keyword">if</span>(dp[e.from] != Integer.MAX_VALUE) {</span><br><span class="line">                    dp[e.to] = Integer.min(dp[e.to], dp[e.from] + e.weight);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        print(dp);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[] dp)</span> {</span><br><span class="line">        System.out.println(Arrays.stream(dp)</span><br><span class="line">                .mapToObj(i -&gt; i == Integer.MAX_VALUE ? <span class="string">"∞"</span> : String.valueOf(i))</span><br><span class="line">                .collect(Collectors.joining(<span class="string">","</span>, <span class="string">"["</span>, <span class="string">"]"</span>)));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="不同路径-leetcode-62">3) 不同路径-Leetcode 62</h3><p>机器人要从左上角走到右下角，每次只能<strong>向右</strong>或<strong>向下</strong>，问一共有多少条不同路径？</p><p><img src="../../../../images/StrJava/robot_maze2.png"></p><p>分析，先考虑较为简单的情况</p><p><img src="../../../../images/StrJava/robot_maze.png"></p><p>可能路径有三种情况：</p><ul><li>👉 👇 👇</li><li>👇 👇👉</li><li>👇👉👇</li></ul><p>分析：设坐标为，共有 m 行 n 列</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">(0,0)(0,1)</span><br><span class="line">(1,0)(1,1)</span><br><span class="line">(2,0)(2,1)</span><br></pre></td></tr></tbody></table></figure><p>如果终点是 (0,1) 那么只有一种走法</p><p>如果终点是 (1,0) 那么也只有一种走法</p><p>如果终点是 (1,1)呢，它的走法是从它的上方走下来，或者从它的左边走过来，因此走法 = (0,1) +(1,0) = 2种</p><p>如果终点是 (2,0) 那么也只有一种走法</p><p>如果终点是 (2,1)呢，它的走法是从它的上方走下来，或者从它的左边走过来，因此走法 = (1,1) +(2,0) = 3种</p><p>总结规律发现：</p><ol type="1"><li>终点是 (0,1) (0,2) (0,3) ... (0,n) 走法只有1种</li><li>终点是 (1,0) (2,0) (3,0) ... (m,0) 走法也只有1种</li><li>除了上面两种情况以外，(i,j) 处的走法等于(i-1,j) + (i,j-1)的走法之和，即为递推公式</li></ol><p>画表格</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">0111111</span><br><span class="line">1234567</span><br><span class="line">13610152128</span><br></pre></td></tr></tbody></table></figure><p>题解</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UniquePaths</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UniquePaths</span>().uniquePaths(<span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) {</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="降维-1">降维</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UniquePaths</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UniquePaths</span>().uniquePaths(<span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) {</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) {</span><br><span class="line">                dp[j] = dp[j] + dp[j - <span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>类似于不规则的杨辉三角</p><h3 id="背包问题-1">4) 0-1 背包问题</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KnapsackProblem</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. n个物品都是固体，有重量和价值</span></span><br><span class="line"><span class="comment">        2. 现在你要取走不超过 10克 的物品</span></span><br><span class="line"><span class="comment">        3. 每次可以不拿或全拿，问最高价值是多少</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            编号 重量(g)  价值(元)                        简称</span></span><br><span class="line"><span class="comment">            1   4       1600           黄金一块   400    A</span></span><br><span class="line"><span class="comment">            2   8       2400           红宝石一粒 300    R</span></span><br><span class="line"><span class="comment">            3   5       30             白银一块         S</span></span><br><span class="line"><span class="comment">            0   1       1_000_000      钻石一粒          D</span></span><br><span class="line"><span class="comment">        1_001_630</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1_002_400</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1   2   3   4   5   6   7   8   9   10</span></span><br><span class="line"><span class="comment">                    a</span></span><br><span class="line"><span class="comment">                    a               r</span></span><br><span class="line"><span class="comment">                    a               r</span></span><br><span class="line"><span class="comment">        d               da          da  dr  dr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Item</span> {</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Item</span><span class="params">(<span class="type">int</span> index, String name, <span class="type">int</span> weight, <span class="type">int</span> value)</span> {</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.weight = weight;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Item("</span> + name + <span class="string">")"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Item[] items = <span class="keyword">new</span> <span class="title class_">Item</span>[]{</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">1</span>, <span class="string">"黄金"</span>, <span class="number">4</span>, <span class="number">1600</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">2</span>, <span class="string">"宝石"</span>, <span class="number">8</span>, <span class="number">2400</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">3</span>, <span class="string">"白银"</span>, <span class="number">5</span>, <span class="number">30</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">4</span>, <span class="string">"钻石"</span>, <span class="number">1</span>, <span class="number">10_000</span>),</span><br><span class="line">        };</span><br><span class="line">        System.out.println(select(items, <span class="number">10</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">(Item[] items, <span class="type">int</span> total)</span> {</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[items.length][total + <span class="number">1</span>];</span><br><span class="line">        print(dp);</span><br><span class="line">        <span class="type">Item</span> <span class="variable">item0</span> <span class="operator">=</span> items[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; total + <span class="number">1</span>; j++) {</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= item0.weight) {</span><br><span class="line">                dp[<span class="number">0</span>][j] = item0.value;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        print(dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length; i++) {</span><br><span class="line">            <span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> items[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; total + <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="comment">// x: 上一次同容量背包的最大价值</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= item.weight) {</span><br><span class="line">                    <span class="comment">// j-item.weight: 当前背包容量-这次物品重量=剩余背包空间</span></span><br><span class="line">                    <span class="comment">// y: 剩余背包空间能装下的最大价值 + 这次物品价值</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j - item.weight] + item.value;</span><br><span class="line">                    dp[i][j] = Integer.max(x, y);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = x;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            print(dp);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>][total];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[][] dp)</span> {</span><br><span class="line">        System.out.println(<span class="string">"   "</span> + <span class="string">"-"</span>.repeat(<span class="number">63</span>));</span><br><span class="line">        Object[] array = IntStream.range(<span class="number">0</span>, dp[<span class="number">0</span>].length + <span class="number">1</span>).boxed().toArray();</span><br><span class="line">        System.out.printf((<span class="string">"%5d "</span>.repeat(dp[<span class="number">0</span>].length)) + <span class="string">"%n"</span>, array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] d : dp) {</span><br><span class="line">            array = Arrays.stream(d).boxed().toArray();</span><br><span class="line">            System.out.printf((<span class="string">"%5d "</span>.repeat(d.length)) + <span class="string">"%n"</span>, array);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="降维-2">降维</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">(Item[] items, <span class="type">int</span> total)</span> {</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[total + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (Item item : items) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> total; j &gt; <span class="number">0</span>; j--) {</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= item.weight) { <span class="comment">// 装得下</span></span><br><span class="line">                dp[j] = Integer.max(dp[j], item.value + dp[j - item.weight]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(Arrays.toString(dp));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[total];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意：内层循环需要倒序，否则 dp[j - item.weight]的结果会被提前覆盖</p><h3 id="完全背包问题">5) 完全背包问题</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KnapsackProblemComplete</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Item</span> {</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Item</span><span class="params">(<span class="type">int</span> index, String name, <span class="type">int</span> weight, <span class="type">int</span> value)</span> {</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.weight = weight;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Item("</span> + name + <span class="string">")"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Item[] items = <span class="keyword">new</span> <span class="title class_">Item</span>[]{</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">1</span>, <span class="string">"青铜"</span>, <span class="number">2</span>, <span class="number">3</span>),    <span class="comment">// c</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">2</span>, <span class="string">"白银"</span>, <span class="number">3</span>, <span class="number">4</span>),    <span class="comment">// s</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">3</span>, <span class="string">"黄金"</span>, <span class="number">4</span>, <span class="number">7</span>),    <span class="comment">// a</span></span><br><span class="line">        };</span><br><span class="line">        System.out.println(select(items, <span class="number">6</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">            0   1   2   3   4   5   6</span></span><br><span class="line"><span class="comment">        1   0   0   c   c   cc  cc  ccc</span></span><br><span class="line"><span class="comment">        2   0   0   c   s   cc  cs  ccc</span></span><br><span class="line"><span class="comment">        3   0   0   c   s   a   a   ac</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">(Item[] items, <span class="type">int</span> total)</span> {</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[items.length][total + <span class="number">1</span>];</span><br><span class="line">        <span class="type">Item</span> <span class="variable">item0</span> <span class="operator">=</span> items[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; total + <span class="number">1</span>; j++) {</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= item0.weight) {</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - item0.weight] + item0.value;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        print(dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; items.length; i++) {</span><br><span class="line">            <span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> items[i];            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; total + <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="comment">// x: 上一次同容量背包的最大价值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= item.weight) {</span><br><span class="line">                    <span class="comment">// j-item.weight: 当前背包容量-这次物品重量=剩余背包空间</span></span><br><span class="line">                    <span class="comment">// y: 剩余背包空间能装下的最大价值 + 这次物品价值</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> dp[i][j - item.weight] + item.value;</span><br><span class="line">                    dp[i][j] = Integer.max(x, y);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = x;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            print(dp);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>][total];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[][] dp)</span> {</span><br><span class="line">        System.out.println(<span class="string">"   "</span> + <span class="string">"-"</span>.repeat(<span class="number">63</span>));</span><br><span class="line">        Object[] array = IntStream.range(<span class="number">0</span>, dp[<span class="number">0</span>].length + <span class="number">1</span>).boxed().toArray();</span><br><span class="line">        System.out.printf((<span class="string">"%5d "</span>.repeat(dp[<span class="number">0</span>].length)) + <span class="string">"%n"</span>, array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] d : dp) {</span><br><span class="line">            array = Arrays.stream(d).boxed().toArray();</span><br><span class="line">            System.out.printf((<span class="string">"%5d "</span>.repeat(d.length)) + <span class="string">"%n"</span>, array);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="降维-3">降维</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">(Item[] items, <span class="type">int</span> total)</span> {</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[total + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (Item item : items) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; total + <span class="number">1</span>; j++) {</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= item.weight) {</span><br><span class="line">                dp[j] = Integer.max(dp[j], dp[j - item.weight] + item.value);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(Arrays.toString(dp));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[total];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="零钱兑换问题-leetcode322">6) 零钱兑换问题-Leetcode322</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChangeMakingProblemLeetcode322</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> amount + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[coins.length][amount + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; amount + <span class="number">1</span>; j++) {</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= coins[<span class="number">0</span>]) {</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span> + dp[<span class="number">0</span>][j - coins[<span class="number">0</span>]];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                dp[<span class="number">0</span>][j] = max;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; coins.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; amount + <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= coins[i]) {</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], <span class="number">1</span> + dp[i][j - coins[i]]);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            print(dp);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> dp[coins.length - <span class="number">1</span>][amount];</span><br><span class="line">        <span class="keyword">return</span> r &gt; amount ? -<span class="number">1</span> : r;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ChangeMakingProblemLeetcode322</span> <span class="variable">leetcode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChangeMakingProblemLeetcode322</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> leetcode.coinChange(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>}, <span class="number">5</span>);</span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{25, 10, 5, 1}, 41);</span></span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{2}, 3);</span></span><br><span class="line"><span class="comment">//        int count = leetcode.coinChange(new int[]{15, 10, 1}, 21);</span></span><br><span class="line">        System.out.println(count);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[][] dp)</span> {</span><br><span class="line">        System.out.println(<span class="string">"-"</span>.repeat(<span class="number">18</span>));</span><br><span class="line">        Object[] array = IntStream.range(<span class="number">0</span>, dp[<span class="number">0</span>].length + <span class="number">1</span>).boxed().toArray();</span><br><span class="line">        System.out.printf((<span class="string">"%2d "</span>.repeat(dp[<span class="number">0</span>].length)) + <span class="string">"%n"</span>, array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] d : dp) {</span><br><span class="line">            array = Arrays.stream(d).boxed().toArray();</span><br><span class="line">            System.out.printf((<span class="string">"%2d "</span>.repeat(d.length)) + <span class="string">"%n"</span>, array);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="降维-4">降维</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> {</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> coin : coins) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coin; j &lt; amount + <span class="number">1</span>; j++) {</span><br><span class="line">            dp[j] = Math.min(dp[j], <span class="number">1</span> + dp[j - coin]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> dp[amount];</span><br><span class="line">    <span class="keyword">return</span> r &gt; amount ? -<span class="number">1</span> : r;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="零钱兑换-ii-leetcode-518">零钱兑换 II-Leetcode 518</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChangeMakingProblemLeetcode518</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     面值    0        1        2        3        4        5</span></span><br><span class="line"><span class="comment">       1    1        1        1        1        1        1</span></span><br><span class="line"><span class="comment">       2    1        1        2        2        3        3</span></span><br><span class="line"><span class="comment">       5    1        1        2        2        3        4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     面值    0        1        2        3</span></span><br><span class="line"><span class="comment">            1        0        0        0</span></span><br><span class="line"><span class="comment">       2    1        0        1        0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> {</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> coin : coins) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coin; j &lt; amount + <span class="number">1</span>; j++) {</span><br><span class="line">                dp[j] = dp[j] + dp[j - coin];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ChangeMakingProblemLeetcode518</span> <span class="variable">leetcode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChangeMakingProblemLeetcode518</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> leetcode.change(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>}, <span class="number">5</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="钢条切割问题">7) 钢条切割问题</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CutRodProblem</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1 5 8 9</span></span><br><span class="line"><span class="comment">            0   1   2   3   4</span></span><br><span class="line"><span class="comment">        1       1   11  111 1111</span></span><br><span class="line"><span class="comment">                (1) (2) (3) (4)</span></span><br><span class="line"><span class="comment">        2           11  111 1111</span></span><br><span class="line"><span class="comment">                    2   21  211</span></span><br><span class="line"><span class="comment">                            22</span></span><br><span class="line"><span class="comment">                (1) (5) (6) (10)</span></span><br><span class="line"><span class="comment">        3       1   11  111 1111</span></span><br><span class="line"><span class="comment">                    2   21  211</span></span><br><span class="line"><span class="comment">                        3   22</span></span><br><span class="line"><span class="comment">                            31</span></span><br><span class="line"><span class="comment">                (1) (5) (8) (10)</span></span><br><span class="line"><span class="comment">        4       1   11  111 1111</span></span><br><span class="line"><span class="comment">                    2   21  211</span></span><br><span class="line"><span class="comment">                        3   22</span></span><br><span class="line"><span class="comment">                            31</span></span><br><span class="line"><span class="comment">                            4</span></span><br><span class="line"><span class="comment">                (1) (5) (8) (10)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">cut</span><span class="params">(<span class="type">int</span>[] values, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[values.length][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; values.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> values[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= i) {</span><br><span class="line">                    dp[i][j] = Integer.max(dp[i - <span class="number">1</span>][j], v + dp[i][j - i]);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            print(dp);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[values.length - <span class="number">1</span>][n];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(cut(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>}, <span class="number">4</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="降维-5">降维</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">cut</span><span class="params">(<span class="type">int</span>[] values, <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; values.length; i++) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> values[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n + <span class="number">1</span>; j++) {</span><br><span class="line">            dp[j] = Integer.max(dp[j], v + dp[j - i]);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(Arrays.toString(dp));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>本质上是完全背包问题，把钢条总长度看作背包容量，切分后的钢条看作物品。只是</p><ul><li><p>此时的背包容量=物品数量，例如，钢条总长度为4，可以看作有四种物品：</p><ul><li><p>长度1的钢条</p></li><li><p>长度2的钢条</p></li><li><p>长度3的钢条</p></li><li><p>长度4的钢条</p></li></ul></li><li><p>另外，这个场景下，总能装满背包</p></li></ul><h4 id="类似题目-leetcode-343-整数拆分">类似题目 Leetcode-343整数拆分</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leetcode343</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         0   1   2   3   4</span></span><br><span class="line"><span class="comment">     1   1   1   11  111 1111</span></span><br><span class="line"><span class="comment">     2   1   1   11  111 1111</span></span><br><span class="line"><span class="comment">                 2   21  211</span></span><br><span class="line"><span class="comment">                         22</span></span><br><span class="line"><span class="comment">             (1) (2) (2) (4)</span></span><br><span class="line"><span class="comment">     3   1   1   11  111 1111</span></span><br><span class="line"><span class="comment">                 2   21  211</span></span><br><span class="line"><span class="comment">                     3   22</span></span><br><span class="line"><span class="comment">                         31</span></span><br><span class="line"><span class="comment">             (1) (2) (3) (4)</span></span><br><span class="line"><span class="comment">     4   1   1   11  111 1111</span></span><br><span class="line"><span class="comment">                 2   21  211</span></span><br><span class="line"><span class="comment">                     3   22</span></span><br><span class="line"><span class="comment">                         31</span></span><br><span class="line"><span class="comment">                         4</span></span><br><span class="line"><span class="comment">             (1) (2) (3) (4)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= i) {</span><br><span class="line">                    dp[j] = Integer.max(dp[j], i * dp[j - i]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Arrays.toString(dp));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak2</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= i) {</span><br><span class="line">                    dp[i][j] = Integer.max(dp[i - <span class="number">1</span>][j], i * dp[i][j - i]);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            print(dp);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][n];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Leetcode343</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leetcode343</span>();</span><br><span class="line">        System.out.println(code.integerBreak(<span class="number">4</span>));</span><br><span class="line">        System.out.println(code.integerBreak(<span class="number">10</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="最长公共子串">8) 最长公共子串</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LCSubstring</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lcs</span><span class="params">(String a, String b)</span> {</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[b.length()][a.length()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length(); j++) {</span><br><span class="line">                <span class="keyword">if</span> (a.charAt(j) == b.charAt(i)) {</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) {</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    }</span><br><span class="line">                    max = Integer.max(dp[i][j], max);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        print(dp, a, b);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[][] dp, String a, String b)</span> {</span><br><span class="line">        System.out.println(<span class="string">"-"</span>.repeat(<span class="number">23</span>));</span><br><span class="line">        Object[] array = a.chars().mapToObj(i -&gt; String.valueOf((<span class="type">char</span>) i)).toArray();</span><br><span class="line">        System.out.printf(<span class="string">"  "</span>+<span class="string">"%2s "</span>.repeat(a.length()) + <span class="string">"%n"</span>, array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length(); i++) {</span><br><span class="line">            <span class="type">int</span>[] d = dp[i];</span><br><span class="line">            array = Arrays.stream(d).boxed().toArray();</span><br><span class="line">            System.out.printf(b.charAt(i) + <span class="string">" "</span> + <span class="string">"%2d "</span>.repeat(d.length) + <span class="string">"%n"</span>, array);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">            i   t   h   e   i   m   a</span></span><br><span class="line"><span class="comment">         t  0   1   0   0   0   0   0</span></span><br><span class="line"><span class="comment">         h  0   0   2   0   0   0   0</span></span><br><span class="line"><span class="comment">         e  0   0   0   3   0   0   0</span></span><br><span class="line"><span class="comment">         n  0   0   0   0   0   0   0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(lcs(<span class="string">"itheima"</span>, <span class="string">"then"</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="类似题目-leetcode-718-最长重复子数组">类似题目 Leetcode-718最长重复子数组</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leetcode718</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) {</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) {</span><br><span class="line">                    dp[j] = dp[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    max = Integer.max(max, dp[j]);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength1</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) {</span><br><span class="line">                <span class="keyword">if</span> (nums1[i] == nums2[j]) {</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) {</span><br><span class="line">                        dp[j] = <span class="number">1</span>;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        dp[j] = dp[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    }</span><br><span class="line">                    max = Integer.max(max, dp[j]);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength2</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> {</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length][nums2.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums2.length; j++) {</span><br><span class="line">                <span class="keyword">if</span> (nums1[i] == nums2[j]) {</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) {</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    }</span><br><span class="line">                    max = Integer.max(max, dp[i][j]);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Leetcode718</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leetcode718</span>();</span><br><span class="line">        System.out.println(code.findLength(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>}, <span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>}));</span><br><span class="line">        System.out.println(code.findLength(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>}, <span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>}));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="最长公共子序列">9) 最长公共子序列</h3><h4 id="最长公共子序列-leetcode-1143">最长公共子序列-Leetcode 1143</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LCSubsequence</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> text1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> text2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> text1.charAt(i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="type">char</span> <span class="variable">b</span> <span class="operator">=</span> text2.charAt(j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (a == b) {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = Integer.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        print(dp, text2, text1);</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[][] dp, String a, String b)</span> {</span><br><span class="line">        System.out.println(<span class="string">"-"</span>.repeat(<span class="number">23</span>));</span><br><span class="line">        Object[] array = a.chars().mapToObj(i -&gt; String.valueOf((<span class="type">char</span>) i)).toArray();</span><br><span class="line">        System.out.printf(<span class="string">"     "</span> + <span class="string">"%2s "</span>.repeat(a.length()) + <span class="string">"%n"</span>, array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length(); i++) {</span><br><span class="line">            <span class="type">int</span>[] d = dp[i + <span class="number">1</span>];</span><br><span class="line">            array = Arrays.stream(d).boxed().toArray();</span><br><span class="line">            System.out.printf(b.charAt(i) + <span class="string">" "</span> + <span class="string">"%2d "</span>.repeat(d.length) + <span class="string">"%n"</span>, array);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">LCSubsequence</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LCSubsequence</span>();</span><br><span class="line">        System.out.println(code.longestCommonSubsequence(<span class="string">"abcde"</span>, <span class="string">"ace"</span>));</span><br><span class="line">        System.out.println(code.longestCommonSubsequence(<span class="string">"ba"</span>, <span class="string">"yby"</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="两个字符串的删除操作-leetcode-583">两个字符串的删除操作-Leetcode583</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leetcode538</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Leetcode538</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leetcode538</span>();</span><br><span class="line">        System.out.println(code.minDistance(<span class="string">"leetcode"</span>, <span class="string">"etco"</span>));  <span class="comment">// 4</span></span><br><span class="line">        System.out.println(code.minDistance(<span class="string">"eat"</span>, <span class="string">"sea"</span>));   <span class="comment">// 2</span></span><br><span class="line">        System.out.println(code.minDistance(<span class="string">"park"</span>, <span class="string">"spake"</span>));   <span class="comment">// 3</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> word1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word2.length();</span><br><span class="line">        <span class="type">char</span>[] chars1 = word1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] chars2 = word2.toCharArray();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> chars1[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> chars2[j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x == y) {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = Integer.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> m + n - dp[m][n] - dp[m][n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="最长上升子序列-leetcode-300">10) 最长上升子序列-Leetcode300</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leetcode300</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    1       2       3       4</span></span><br><span class="line"><span class="comment">            1       3       6       4       9</span></span><br><span class="line"><span class="comment">            1       13      16      14      19</span></span><br><span class="line"><span class="comment">                            136     134     139</span></span><br><span class="line"><span class="comment">                                            169</span></span><br><span class="line"><span class="comment">                                            1369</span></span><br><span class="line"><span class="comment">                                            149</span></span><br><span class="line"><span class="comment">                                            1349</span></span><br><span class="line"><span class="comment">           (1)    (2)      (3)     (3)      (4)</span></span><br><span class="line"><span class="comment">                                            4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) {</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) { <span class="comment">// 满足了升序条件</span></span><br><span class="line">                    <span class="comment">// 用之前递增子序列的最大长度 + 1 更新当前长度</span></span><br><span class="line">                    dp[i] = Integer.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Arrays.toString(dp));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(dp).max().getAsInt();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Leetcode300</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leetcode300</span>();</span><br><span class="line">        System.out.println(code.lengthOfLIS(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>}));</span><br><span class="line"><span class="comment">//        System.out.println(code.lengthOfLIS(new int[]{10, 9, 2, 5, 3, 7, 101, 18}));</span></span><br><span class="line"><span class="comment">//        System.out.println(code.lengthOfLIS(new int[]{1, 3, 6, 7, 9, 4, 10, 5, 6}));</span></span><br><span class="line">        <span class="comment">//                                            1 3 6 7 9 10  = 6</span></span><br><span class="line">        <span class="comment">//                                            1 3 4 5 6     = 5</span></span><br><span class="line"><span class="comment">//        System.out.println(code.lengthOfLIS(new int[]{0, 1, 0, 3, 2, 3}));</span></span><br><span class="line"><span class="comment">//        System.out.println(code.lengthOfLIS(new int[]{7, 7, 7, 7, 7, 7, 7}));</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="catalan-数">11) Catalan 数</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Catalan</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(catalan(<span class="number">6</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">catalan</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) {</span><br><span class="line">                System.out.print(<span class="string">"("</span> + j + <span class="string">" "</span> + (i - <span class="number">1</span> - j) + <span class="string">")\t"</span>);</span><br><span class="line">                dp[i] += dp[j] * dp[i - <span class="number">1</span> - j];</span><br><span class="line">            }</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(Arrays.toString(dp));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="leetcode-96-不同的二叉搜索树">Leetcode-96 不同的二叉搜索树</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt; n + <span class="number">1</span>; j++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; j; i++) { </span><br><span class="line">                dp[j] += dp[i] * dp[j - <span class="number">1</span> - i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="leetcode-22-括号生成">Leetcode-22 括号生成</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leetcode22</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        ArrayList&lt;String&gt;[] dp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(List.of(<span class="string">""</span>));</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(List.of(<span class="string">"()"</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt; n + <span class="number">1</span>; j++) {</span><br><span class="line">            dp[j] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; j; i++) { <span class="comment">// 第j个卡特兰数的拆分</span></span><br><span class="line">                System.out.printf(<span class="string">"(%d,%d)\t"</span>, i, j - <span class="number">1</span> - i);</span><br><span class="line"><span class="comment">//                dp[j] += dp[i] * dp[j - 1 - i];</span></span><br><span class="line"><span class="comment">//                dp[j].add("(" + dp[i] + ")" + dp[j - 1 - i]);</span></span><br><span class="line">                <span class="keyword">for</span> (String k1 : dp[i]) {</span><br><span class="line">                    <span class="keyword">for</span> (String k2 : dp[j - <span class="number">1</span> - i]) {</span><br><span class="line">                        dp[j].add(<span class="string">"("</span> + k1 + <span class="string">")"</span> + k2);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            System.out.println(dp[j]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Leetcode22</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leetcode22</span>();</span><br><span class="line">        System.out.println(code.generateParenthesis(<span class="number">4</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="买票找零问题">买票找零问题</h4><p>售票处售卖球票，每张票 50 元。有2n人前来买票</p><ul><li>其中一半人手持 50 元钞票</li><li>另一半人手持 100 元钞票</li></ul><p>若售票处开始没有任何零钱，问：有多少种排队方式，能够让售票顺畅进行。</p><p>思路：</p><ul><li>把手持 50 元钞票的人视为左括号</li><li>把手持 100 元钞票的人视为右括号</li><li>左右括号合法配对，即先出现左括号，再出现右括号，就可以让售票顺畅执行</li></ul><p>可以看到，问题又变成了求解 n 的卡特兰数</p><h4 id="其它问题">其它问题</h4><table><thead><tr class="header"><th>题号</th><th>标题</th></tr></thead><tbody><tr class="odd"><td>Leetcode 331</td><td>验证二叉树的前序序列化</td></tr><tr class="even"><td>Leetcode 894</td><td>所有可能的满二叉树</td></tr><tr class="odd"><td></td><td></td></tr></tbody></table><h3 id="打家劫舍-leetcode-198">12) 打家劫舍-Leetcode 198</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseRobberLeetcode198</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        房子价值</span></span><br><span class="line"><span class="comment">              0   1   2   3   4</span></span><br><span class="line"><span class="comment">              2   7   9   3   1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              0   1   2   3   4</span></span><br><span class="line"><span class="comment">              0   0   0   0   0</span></span><br><span class="line"><span class="comment">              2   7   11  10  12</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              0   1   2   3</span></span><br><span class="line"><span class="comment">              2   1   1   2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              0   1   2   3</span></span><br><span class="line"><span class="comment">              2   2   3   4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Integer.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; len; i++) {</span><br><span class="line">            dp[i] = Integer.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">HouseRobberLeetcode198</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseRobberLeetcode198</span>();</span><br><span class="line">        System.out.println(code.rob(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>}));</span><br><span class="line">        System.out.println(code.rob(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>}));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="travelling-salesman-problem">13) Travelling salesmanproblem</h3><p>旅行商问题</p><figure><img src="../../../../images/StrJava/image-20230731213127478.png" alt="image-20230731213127478"><figcaption aria-hidden="true">image-20230731213127478</figcaption></figure><p>java 代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TravellingSalesmanProblem</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">            0   1   2   3</span></span><br><span class="line"><span class="comment">        0   0   1   2   3</span></span><br><span class="line"><span class="comment">        1   1   0   6   4</span></span><br><span class="line"><span class="comment">        2   2   6   0   5</span></span><br><span class="line"><span class="comment">        3   3   4   5   0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        d(0,{1,2,3}) =&gt; c01+d(1,{2,3}) =&gt; c12+d(2,{3}) =&gt; c23+d(3,{})</span></span><br><span class="line"><span class="comment">                                          c13+d(3,{2}) =&gt; c32+d(2,{})</span></span><br><span class="line"><span class="comment">                        c02+d(2,{1,3}) =&gt; c21+d(1,{3}) =&gt; c13+d(3,{})</span></span><br><span class="line"><span class="comment">                                          c23+d(3,{1}) =&gt; c31+d(1,{})</span></span><br><span class="line"><span class="comment">                        c03+d(3,{1,2}) =&gt; c31+d(1,{2}) =&gt; c12+d(2,{})</span></span><br><span class="line"><span class="comment">                                          c32+d(2,{1}) =&gt; c21+d(1,{})</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        d(0,{1}) =&gt; c01+d(1,{}) 0-&gt;1-&gt;0</span></span><br><span class="line"><span class="comment">        d(1,{1})</span></span><br><span class="line"><span class="comment">        d(2,{1}) =&gt; c21+d(1,{}) 2-&gt;1-&gt;0</span></span><br><span class="line"><span class="comment">        d(3,{1}) =&gt; c31+d(1,{}) 3-&gt;1-&gt;0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        d(0,{2}) =&gt; c02+d(2,{}) 0-&gt;2-&gt;0</span></span><br><span class="line"><span class="comment">        d(1,{2}) =&gt; c12+d(2,{}) 1-&gt;2-&gt;0</span></span><br><span class="line"><span class="comment">        d(2,{2})</span></span><br><span class="line"><span class="comment">        d(3,{2}) =&gt; c32+d(2,{}) 3-&gt;2-&gt;0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        d(0,{1,2}) =&gt; c01+d(1,{2}) =&gt; 0-&gt;1-&gt;2-&gt;0</span></span><br><span class="line"><span class="comment">                      c02+d(2,{1}) =&gt; 0-&gt;2-&gt;1-&gt;0</span></span><br><span class="line"><span class="comment">        d(3,{1,2}) =&gt; c31+d(1,{2}) =&gt; 3-&gt;1-&gt;2-&gt;0</span></span><br><span class="line"><span class="comment">                      c32+d(2,{1}) =&gt; 3-&gt;2-&gt;1-&gt;0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        d(0,{3}) =&gt; c03+d(3,{}) 0-&gt;3-&gt;0</span></span><br><span class="line"><span class="comment">        d(1,{3}) =&gt; c13+d(3,{}) 1-&gt;3-&gt;0</span></span><br><span class="line"><span class="comment">        d(2,{3}) =&gt; c23+d(3,{}) 2-&gt;3-&gt;0</span></span><br><span class="line"><span class="comment">        d(3,{3})</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        d(0,{1,3}) =&gt; c01+d(1,{3}) =&gt; 0-&gt;1-&gt;3-&gt;0</span></span><br><span class="line"><span class="comment">                      c03+d(3,{1}) =&gt; 0-&gt;3-&gt;1-&gt;0</span></span><br><span class="line"><span class="comment">        d(2,{1,3}) =&gt; c21+d(1,{3}) =&gt; 2-&gt;1-&gt;3-&gt;0</span></span><br><span class="line"><span class="comment">                      c23+d(3,{1}) =&gt; 2-&gt;3-&gt;1-&gt;0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        d(0,{2,3}) =&gt; c02+d(2,{3}) =&gt; 0-&gt;2-&gt;3-&gt;0</span></span><br><span class="line"><span class="comment">                      c03+d(3,{2}) =&gt; 0-&gt;3-&gt;2-&gt;0</span></span><br><span class="line"><span class="comment">        d(1,{2,3}) =&gt; c12+d(2,{3}) =&gt; 1-&gt;2-&gt;3-&gt;0</span></span><br><span class="line"><span class="comment">                      c13+d(3,{2}) =&gt; 1-&gt;3-&gt;2-&gt;0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        d(0,{1,2,3}) =&gt; c01+d(1,{2,3})  11+1</span></span><br><span class="line"><span class="comment">                        c02+d(2,{1,3})  10+2</span></span><br><span class="line"><span class="comment">                        c03+d(3,{1,2})  12+3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            0       1       2       12      3       13      23      123</span></span><br><span class="line"><span class="comment">            0       1       2       3       4       5       6       7</span></span><br><span class="line"><span class="comment">       0    0       2       4       9       6       8       10      12</span></span><br><span class="line"><span class="comment">       1    1       _       8       _       7       _       11      _</span></span><br><span class="line"><span class="comment">       2    2       7       _       _       8       10      _       _</span></span><br><span class="line"><span class="comment">       3    3       5       7       12      _       _       _       _</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[][] graph = {</span><br><span class="line">                {<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>},</span><br><span class="line">                {<span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">4</span>},</span><br><span class="line">                {<span class="number">2</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">5</span>},</span><br><span class="line">                {<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>},</span><br><span class="line">        };</span><br><span class="line"><span class="comment">//        System.out.println(tsp(graph));</span></span><br><span class="line">        System.out.println(<span class="number">6</span> &gt;&gt; (<span class="number">0</span>-<span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">tsp1</span><span class="params">(<span class="type">int</span>[][] graph)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> graph.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span> &lt;&lt; n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : dp) {</span><br><span class="line">            Arrays.fill(row, Integer.MAX_VALUE / <span class="number">2</span>);</span><br><span class="line">        }</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">1</span>; mask &lt; <span class="number">1</span> &lt;&lt; n; mask++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">                <span class="keyword">if</span> ((mask &amp; <span class="number">1</span> &lt;&lt; i) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; <span class="number">1</span> &lt;&lt; j) != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    dp[mask | <span class="number">1</span> &lt;&lt; j][j] = Math.min(dp[mask | <span class="number">1</span> &lt;&lt; j][j], dp[mask][i] + graph[i][j]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            print(dp);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            res = Math.min(res, dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][i] + graph[i][<span class="number">0</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        110 是否包含 0 = 0 &amp; 1 = 0</span></span><br><span class="line"><span class="comment">        110 是否包含 1 = 110 &amp; 1 = 0</span></span><br><span class="line"><span class="comment">        110 是否包含 2 = 11 &amp; 1 = 1</span></span><br><span class="line"><span class="comment">        110 是否包含 3 = 1 &amp; 1 = 1</span></span><br><span class="line"><span class="comment">        110 是否包含 4 = 0 &amp; 1 = 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(<span class="type">int</span> set, <span class="type">int</span> city)</span> {</span><br><span class="line">        <span class="keyword">return</span> (set &gt;&gt; (city - <span class="number">1</span>) &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        110     110</span></span><br><span class="line"><span class="comment">       ^100    ^010</span></span><br><span class="line"><span class="comment">       ----    ----</span></span><br><span class="line"><span class="comment">         10     100</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">exclude</span><span class="params">(<span class="type">int</span> set, <span class="type">int</span> city)</span> {</span><br><span class="line">        <span class="keyword">return</span> set ^ (<span class="number">1</span> &lt;&lt; (city - <span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">tsp</span><span class="params">(<span class="type">int</span>[][] g)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> g.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = g[i][<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; j++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">                dp[i][j] = Integer.MAX_VALUE / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (contains(j, i)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt; n; k++) {</span><br><span class="line">                    <span class="keyword">if</span> (contains(j, k)) {</span><br><span class="line"><span class="comment">//                    System.out.println("(" + k + "," + (j ^ (1 &lt;&lt; (k - 1))) + ")");</span></span><br><span class="line">                        dp[i][j] = Math.min(dp[i][j], g[i][k] + dp[k][exclude(j, k)]);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            print(dp);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][m - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[][] dist)</span> {</span><br><span class="line">        System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : dist) {</span><br><span class="line">            System.out.println(Arrays.stream(row).boxed()</span><br><span class="line">                    .map(x -&gt; x &gt;= Integer.MAX_VALUE / <span class="number">2</span> ? <span class="string">"∞"</span> : String.valueOf(x))</span><br><span class="line">                    .map(s -&gt; String.format(<span class="string">"%2s"</span>, s))</span><br><span class="line">                    .collect(Collectors.joining(<span class="string">","</span>, <span class="string">"["</span>, <span class="string">"]"</span>)));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="其它题目-3">其它题目</h3><table><thead><tr class="header"><th>题号</th><th>标题</th></tr></thead><tbody><tr class="odd"><td>无</td><td>集合覆盖问题</td></tr><tr class="even"><td>无</td><td>扔鸡蛋问题</td></tr><tr class="odd"><td>Leetcode 72</td><td>编辑距离</td></tr><tr class="even"><td>Leetcode 121</td><td>买股票的最佳时机</td></tr></tbody></table><h4 id="组合总和-iv-leetcode-377">组合总和 IV-Leetcode 377</h4><p>不要被题目名字误导了，本题类似于零钱兑换518题，区别在于零钱兑换求的是组合数，本题求的是排列数</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CombinationLeetcode377</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="keyword">return</span> change(nums, target);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">            0       1       2       3       4 总金额</span></span><br><span class="line"><span class="comment">        1           1       11      111     1111</span></span><br><span class="line"><span class="comment">        2           1       11      111     1111</span></span><br><span class="line"><span class="comment">                            2       12      112</span></span><br><span class="line"><span class="comment">                                    21      121</span></span><br><span class="line"><span class="comment">                                            22</span></span><br><span class="line"><span class="comment">                                            211</span></span><br><span class="line"><span class="comment">        3           1       11      111     1111</span></span><br><span class="line"><span class="comment">                            2       12      112</span></span><br><span class="line"><span class="comment">                                    21      121</span></span><br><span class="line"><span class="comment">                                    3       13</span></span><br><span class="line"><span class="comment">                                            211</span></span><br><span class="line"><span class="comment">                                            22</span></span><br><span class="line"><span class="comment">                                            31</span></span><br><span class="line"><span class="comment">        面值</span></span><br><span class="line"><span class="comment">        dp[j] = dp[j-1] + dp[j-2] + dp[j-3]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> {</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; amount + <span class="number">1</span>; j++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> coin : coins) {</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= coin) {</span><br><span class="line">                    dp[j] += dp[j - coin];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Arrays.toString(dp));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(combinationSum4(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}, <span class="number">4</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="divide-and-conquer">4.4 Divide and Conquer</h2><h3 id="概述-11">1) 概述</h3><p>分治思想</p><ul><li>将大问题划分为两个到多个子问题</li><li>子问题可以继续拆分成更小的子问题，直到能够简单求解</li><li>如有必要，将子问题的解进行合并，得到原始问题的解</li></ul><p>之前学过的一些经典分而治之的例子</p><ul><li>二分查找</li><li>快速排序</li><li>归并排序</li><li>合并K个排序链表 - LeetCode 23</li></ul><h4 id="二分查找-1">二分查找</h4><figure><img src="../../../../images/StrJava/image-20230802100240290.png" alt="image-20230802100240290"><figcaption aria-hidden="true">image-20230802100240290</figcaption></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> {</span><br><span class="line">    <span class="keyword">return</span> recursion(a, target, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">recursion</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">    <span class="keyword">if</span> (i &gt; j) {</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; a[m]) {</span><br><span class="line">        <span class="keyword">return</span> recursion(a, target, i, m - <span class="number">1</span>);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) {</span><br><span class="line">        <span class="keyword">return</span> recursion(a, target, m + <span class="number">1</span>, j);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>减而治之，每次搜索范围内元素减少一半</p><h4 id="快速排序-1">快速排序</h4><figure><img src="../../../../images/StrJava/image-20230802100332341.png" alt="image-20230802100332341"><figcaption aria-hidden="true">image-20230802100332341</figcaption></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span> {</span><br><span class="line">    quick(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a, left, right);</span><br><span class="line">    quick(a, left, p - <span class="number">1</span>);</span><br><span class="line">    quick(a, p + <span class="number">1</span>, right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>分而治之，这次分区基准点，在划分后两个区域分别进行下次分区</p><h4 id="归并排序-1">归并排序</h4><figure><img src="../../../../images/StrJava/image-20230513143854887.png" alt="image-20230513143854887"><figcaption aria-hidden="true">image-20230513143854887</figcaption></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a1)</span> {</span><br><span class="line">    <span class="type">int</span>[] a2 = <span class="keyword">new</span> <span class="title class_">int</span>[a1.length];</span><br><span class="line">    split(a1, <span class="number">0</span>, a1.length - <span class="number">1</span>, a2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] a2)</span> {</span><br><span class="line">    <span class="type">int</span>[] array = Arrays.copyOfRange(a1, left, right + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 2. 治</span></span><br><span class="line">    <span class="keyword">if</span> (left == right) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 1. 分</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    split(a1, left, m, a2);                 </span><br><span class="line">    split(a1, m + <span class="number">1</span>, right, a2);       </span><br><span class="line">    <span class="comment">// 3. 合</span></span><br><span class="line">    merge(a1, left, m, m + <span class="number">1</span>, right, a2);</span><br><span class="line">    System.arraycopy(a2, left, a1, left, right - left + <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>分而治之，分到区间内只有一个元素，合并区间</p><h4 id="合并k个排序链表---leetcode-23">合并K个排序链表 - LeetCode23</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> {</span><br><span class="line">    <span class="keyword">if</span> (lists.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> split(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">split</span><span class="params">(ListNode[] lists, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">    System.out.println(i + <span class="string">" "</span> + j);</span><br><span class="line">    <span class="keyword">if</span> (j == i) {</span><br><span class="line">        <span class="keyword">return</span> lists[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(</span><br><span class="line">        split(lists, i, m),</span><br><span class="line">        split(lists, m + <span class="number">1</span>, j)</span><br><span class="line">    );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>分而治之，分到区间内只有一个链表，合并区间</p><h4 id="对比动态规划">对比动态规划</h4><ul><li>都需要拆分子问题</li><li>动态规划的子问题有重叠、因此需要记录之前子问题解，避免重复运算</li><li>分而治之的子问题无重叠</li></ul><h3 id="快速选择算法">2) 快速选择算法</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Utils</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a, left, right);</span><br><span class="line">        <span class="keyword">if</span> (p == index) {</span><br><span class="line">            <span class="keyword">return</span> a[p];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (p &lt; index) {</span><br><span class="line">            <span class="keyword">return</span> quick(a, p + <span class="number">1</span>, right, index);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> quick(a, left, p - <span class="number">1</span>, index);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(right - left + <span class="number">1</span>) + left;</span><br><span class="line">        swap(a, left, idx);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> a[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) {</span><br><span class="line">            <span class="comment">// i 从左向右找大的或者相等的</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; a[i] &lt; pv) {</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// j 从右向左找小的或者相等的</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; a[j] &gt; pv) {</span><br><span class="line">                j--;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= j) {</span><br><span class="line">                swap(a, i, j);</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        swap(a, j, left);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="数组中第k个最大元素-leetcode-215">数组中第k个最大元素-Leetcode215</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindKthLargestLeetcode215</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        目标 index = 4</span></span><br><span class="line"><span class="comment">            3   2   1   5   6   4</span></span><br><span class="line"><span class="comment">        =&gt;  3   2   1   4   5   6   (3)</span></span><br><span class="line"><span class="comment">        =&gt;  3   2   1   4   5   6   (5)</span></span><br><span class="line"><span class="comment">        =&gt;  3   2   1   4   5   6   (4)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> k)</span> {</span><br><span class="line">        <span class="keyword">return</span> Utils.quick(a, <span class="number">0</span>, a.length - <span class="number">1</span>, a.length - k);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 应为5</span></span><br><span class="line">        <span class="type">FindKthLargestLeetcode215</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FindKthLargestLeetcode215</span>();</span><br><span class="line">        System.out.println(code.findKthLargest(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>}, <span class="number">2</span>));</span><br><span class="line">        <span class="comment">// 应为4</span></span><br><span class="line">        System.out.println(code.findKthLargest(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>}, <span class="number">4</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="数组中位数">数组中位数</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindMedian</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        偶数个</span></span><br><span class="line"><span class="comment">            3   1   5   4</span></span><br><span class="line"><span class="comment">        奇数个</span></span><br><span class="line"><span class="comment">            4   5   1</span></span><br><span class="line"><span class="comment">            4   5   1   6   3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="keyword">if</span> (nums.length % <span class="number">2</span> != <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> findIndex(nums, nums.length / <span class="number">2</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            System.out.println((nums.length / <span class="number">2</span> - <span class="number">1</span>) + <span class="string">","</span> + (nums.length / <span class="number">2</span>));</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> findIndex(nums, nums.length / <span class="number">2</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> findIndex(nums, nums.length / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> (a + b) / <span class="number">2.0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(findMedian(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>}));</span><br><span class="line">        System.out.println(findMedian(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>}));</span><br><span class="line">        System.out.println(findMedian(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>}));</span><br><span class="line">        System.out.println(findMedian(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>}));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findIndex</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="keyword">return</span> Utils.quick(a, <span class="number">0</span>, a.length - <span class="number">1</span>, index);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="快速幂-leetcode-50">3) 快速幂-Leetcode 50</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickPowLeetcode50</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                  2^10</span></span><br><span class="line"><span class="comment">              /         \</span></span><br><span class="line"><span class="comment">            2^5         2^5</span></span><br><span class="line"><span class="comment">           /  \        /  \</span></span><br><span class="line"><span class="comment">        2 2^2 2^2    2 2^2 2^2</span></span><br><span class="line"><span class="comment">         / \  / \     / \  / \</span></span><br><span class="line"><span class="comment">        2  2  2  2   2  2  2  2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                  256          n=1 x=65536 mul=1024</span></span><br><span class="line"><span class="comment">              /         \</span></span><br><span class="line"><span class="comment">            16          16          n=2 x=256 mul=4</span></span><br><span class="line"><span class="comment">           /  \        /  \</span></span><br><span class="line"><span class="comment">        2 4    4    2  4    4       n=5  x=16 mul=4</span></span><br><span class="line"><span class="comment">         / \  / \     / \  / \</span></span><br><span class="line"><span class="comment">        2  2  2  2   2  2  2  2     n=10  x=4  mul=1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">double</span> <span class="variable">mul</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">N</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) {</span><br><span class="line">            N = -N;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> ((N &amp; <span class="number">1</span>) == <span class="number">1</span>) {</span><br><span class="line">                mul *= x;</span><br><span class="line">            }</span><br><span class="line">            x =  x * x;</span><br><span class="line">            N = N &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> ? mul : <span class="number">1</span> / mul;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">myPow1</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">long</span> <span class="variable">N</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">if</span> (N &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span> / rec(x, -N);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> rec(x, n);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">rec</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> n)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> rec(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> x * y * y;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> y * y;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(myPow(<span class="number">2</span>, <span class="number">10</span>));  <span class="comment">// 1024.0</span></span><br><span class="line">        System.out.println(myPow(<span class="number">2.1</span>, <span class="number">3</span>)); <span class="comment">// 9.261</span></span><br><span class="line">        System.out.println(myPow(<span class="number">2</span>, -<span class="number">2</span>)); <span class="comment">// 0.25</span></span><br><span class="line">        System.out.println(myPow(<span class="number">2</span>, <span class="number">0</span>)); <span class="comment">// 1.0</span></span><br><span class="line">        System.out.println(myPow(<span class="number">2</span>, -<span class="number">2147483648</span>)); <span class="comment">// 1.0</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="平方根整数部分-leetcode-69">4) 平方根整数部分-Leetcode 69</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqrtLeetcode69</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (x / m &gt;= m) {</span><br><span class="line">                r = m;</span><br><span class="line">                i = m+<span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                j = m-<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(mySqrt(<span class="number">1</span>));</span><br><span class="line">        System.out.println(mySqrt(<span class="number">2</span>));</span><br><span class="line">        System.out.println(mySqrt(<span class="number">4</span>));</span><br><span class="line">        System.out.println(mySqrt(<span class="number">8</span>));</span><br><span class="line">        System.out.println(mySqrt(<span class="number">9</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>while(i &lt;= j)含义是在此区间内，只要有数字还未尝试，就不算结束</li><li>r 的作用是保留最近一次当 <span class="math inline">\(m^2 &lt;=x\)</span> 的 m 的值</li><li>使用除法而非乘法，避免大数相乘越界</li></ul><h3 id="至少k个重复字符的最长子串-leetcode-395">5)至少k个重复字符的最长子串-Leetcode 395</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongestSubstringLeetcode395</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestSubstring</span><span class="params">(String s, <span class="type">int</span> k)</span> {</span><br><span class="line">        <span class="comment">// 子串落选情况</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; k) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>]; <span class="comment">// 索引对应字符 值用来存储该字符出现了几次</span></span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : chars) { <span class="comment">// 'a' -&gt; 0  'b' -&gt; 1 ....</span></span><br><span class="line">            counts[c - <span class="string">'a'</span>]++;</span><br><span class="line">        }</span><br><span class="line">        System.out.println(Arrays.toString(counts));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) {</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> chars[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> counts[c - <span class="string">'a'</span>]; <span class="comment">// i字符出现次数</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; count &lt; k) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(j &lt; s.length() &amp;&amp; counts[chars[j] - <span class="string">'a'</span>] &lt; k) {</span><br><span class="line">                    j++;</span><br><span class="line">                }</span><br><span class="line">                System.out.println(s.substring(<span class="number">0</span>, i) + <span class="string">"\t"</span> + s.substring(j));</span><br><span class="line">                <span class="keyword">return</span> Integer.max(</span><br><span class="line">                        longestSubstring(s.substring(<span class="number">0</span>, i), k),</span><br><span class="line">                        longestSubstring(s.substring(j), k)</span><br><span class="line">                );</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 子串入选情况</span></span><br><span class="line">        <span class="keyword">return</span> s.length();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//                                         i j</span></span><br><span class="line">        System.out.println(longestSubstring(<span class="string">"aaaccbbb"</span>, <span class="number">3</span>)); <span class="comment">// ababb</span></span><br><span class="line">        System.out.println(longestSubstring(<span class="string">"dddxaabaaabaacciiiiefbff"</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">//        System.out.println(longestSubstring("ababbc", 3)); // ababb</span></span><br><span class="line"><span class="comment">//        System.out.println(longestSubstring("ababbc", 2)); // ababb</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            ddd aabaaabaa iiii fbff</span></span><br><span class="line"><span class="comment">                aa aaa aa      f ff</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            统计字符串中每个字符的出现次数，移除哪些出现次数 &lt; k 的字符</span></span><br><span class="line"><span class="comment">            剩余的子串，递归做此处理，直至</span></span><br><span class="line"><span class="comment">                 - 整个子串长度 &lt; k (排除)</span></span><br><span class="line"><span class="comment">                 - 子串中没有出现次数 &lt; k 的字符</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="backtracking-algorithm">4.5 Backtracking Algorithm</h2><h3 id="入门例子">1) 入门例子</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Backtracking</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        rec(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rec</span><span class="params">(<span class="type">int</span> n, LinkedList&lt;String&gt; list)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"before:"</span> + list);</span><br><span class="line">        list.push(<span class="string">"a"</span>);</span><br><span class="line">        rec(n + <span class="number">1</span>, list);</span><br><span class="line">        list.pop();</span><br><span class="line">        System.out.println(<span class="string">"after:"</span> + list);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="全排列-leetcode-46">2) 全排列-Leetcode 46</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PermuteLeetcode46</span> {</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; r = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        rec(nums, visited, stack, r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rec</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] visited, LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; r)</span> {</span><br><span class="line">        <span class="keyword">if</span> (stack.size() == nums.length) {</span><br><span class="line">            r.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span>(visited[i]){</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            stack.push(nums[i]);</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            rec(nums, visited, stack, r);</span><br><span class="line">            stack.pop();</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; permute = permute(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>});</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; s : permute) {</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="全排列ii-leetcode-47">3) 全排列II-Leetcode 47</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PermuteLeetcode47</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(nums, <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length], <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] visited, LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result)</span> {</span><br><span class="line">        <span class="keyword">if</span> (stack.size() == nums.length) {</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !visited[i-<span class="number">1</span>]) { <span class="comment">// 找出重复数字</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) {</span><br><span class="line">                stack.push(nums[i]);</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">                dfs(nums, visited, stack, result);</span><br><span class="line">                visited[i] = <span class="literal">false</span>;</span><br><span class="line">                stack.pop();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] nums = {<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>};        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; permute = permuteUnique(nums);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : permute) {</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>排好序，这样重复的数字会相邻</li><li>定好规则：必须 1 固定之后才能固定 1'，即 1 的 visited = true才能继续处理 1'</li><li>在遍历时，遇到了 <code>nums[i] == nums[i - 1]</code>（即 1 和 1‘这种情况），进一步检查 i-1 位置的数字有没有visited，没有，则不处理（剪枝）</li></ul><h3 id="组合-leetcode-77">4) 组合-Leetcode 77</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CombinationLeetcode77</span> {</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(n, k, <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> start, LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result)</span> {</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) {</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">            System.out.println(stack);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"><span class="comment">//      if (k &gt; n - start + 1) { return; }</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n; i++) {</span><br><span class="line"><span class="comment">//            System.out.printf("k-1=%d n=%d i=%d %n", k - 1, n, i);</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; n - i + <span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            stack.push(i);</span><br><span class="line">            dfs(n, k - <span class="number">1</span>, i + <span class="number">1</span>, stack, result);</span><br><span class="line">            stack.pop();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = combinationSum(<span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//        for (List&lt;Integer&gt; list : lists) {</span></span><br><span class="line"><span class="comment">//            System.out.println(list);</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line">        System.out.println(count);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>k 代表剩余要组合的个数</li><li><code>n - i + 1</code> 代表剩余可用数字</li><li>剪枝条件是：剩余可用数字要大于剩余组合数</li><li>为啥放在外面不行？即这行代码：<code>if (k &gt; n - start + 1) { return; }</code><ul><li>因为它只考虑了 start 一种情况，而实际在循环内要处理的是start，start+1 ... n 这多种情况</li></ul></li></ul><p>似乎 ArrayList 作为 stack 性能高一些，见下面代码，但是这道题在leetcode 上执行时间不稳定，相同代码都会有较大时间差异（15ms vs 9ms）</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> {        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || n &lt; k) <span class="keyword">return</span> result;</span><br><span class="line">        dfs(n, k, <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> start, ArrayList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result)</span> {</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) {</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (k-<span class="number">1</span> &gt; n - i) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            stack.add(i);</span><br><span class="line">            dfs(n, k - <span class="number">1</span>, i + <span class="number">1</span>, stack, result);</span><br><span class="line">            stack.remove(stack.size()-<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="组合总和-leetcode-39">5) 组合总和-Leetcode 39</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CombinationLeetcode39</span> {</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(target, <span class="number">0</span>,candidates, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> start, <span class="type">int</span>[] candidates, LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result)</span> {</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) {</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> candidates[i];</span><br><span class="line">            <span class="keyword">if</span> (target &lt; candidate) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            stack.push(candidate);</span><br><span class="line">            dfs(target - candidate, i, candidates, stack, result);</span><br><span class="line">            stack.pop();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = combinationSum(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>}, <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : lists) {</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>与之前的零钱兑换问题其实是一样的，只是</p><ul><li>本题求的是：所有组合的具体信息</li><li>零钱兑换问题求的是：所有组合中数字最少的、所有组合个数...</li></ul><h3 id="组合总和-ii-leetcode-40">6) 组合总和 II-Leetcode 40</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CombinationLeetcode40</span> {</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> {</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(target, <span class="number">0</span>, candidates, <span class="keyword">new</span> <span class="title class_">boolean</span>[candidates.length], <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> start, <span class="type">int</span>[] candidates, <span class="type">boolean</span>[] visited, LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result)</span> {</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) {</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> candidates[i];</span><br><span class="line">            <span class="keyword">if</span> (target &lt; candidate) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidate == candidates[i - <span class="number">1</span>] &amp;&amp; !visited[i - <span class="number">1</span>]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            stack.push(candidate);</span><br><span class="line">            dfs(target - candidate, i + <span class="number">1</span>, candidates, visited, stack, result);</span><br><span class="line">            stack.pop();</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] candidates = {<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>};        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = combinationSum2(candidates, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : lists) {</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="组合总和-iii-leetcode-216">7) 组合总和 III-Leetcode 216</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CombinationLeetcode216</span> {</span><br><span class="line">    <span class="comment">// 此 target 代表数字组合后的和</span></span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> target)</span> {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">1</span>, target, k, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> target, <span class="type">int</span> k,</span></span><br><span class="line"><span class="params">                    LinkedList&lt;Integer&gt; stack,</span></span><br><span class="line"><span class="params">                    List&lt;List&lt;Integer&gt;&gt; result)</span> {</span><br><span class="line"><span class="comment">//        System.out.println(stack);</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> &amp;&amp; stack.size() == k) {</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= <span class="number">9</span>; i++) {</span><br><span class="line">            <span class="comment">//  还差几个数字          剩余可用数字</span></span><br><span class="line">            <span class="comment">/*if (k - stack.size() &gt; 9 - i + 1) {</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            }*/</span></span><br><span class="line">            <span class="keyword">if</span>(target &lt; i){</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(stack.size() == k) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            stack.push(i);</span><br><span class="line">            dfs(i + <span class="number">1</span>, target - i, k, stack, result);</span><br><span class="line">            stack.pop();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="comment">//        List&lt;List&lt;Integer&gt;&gt; lists = combinationSum3(3, 7);</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = combinationSum3(<span class="number">2</span>, <span class="number">18</span>); <span class="comment">// 9 8</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : lists) {</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这道题更类似于 77 题，区别在于</p><ol type="1"><li>77 题的数字范围 n 更大 [1,20]，而本题数字范围限制为 [1,9]</li><li>本题不仅仅找到组合，还要让组合之和等于 target（类似于 39 题）</li></ol><p>剪枝优化</p><ol type="1"><li>如果剩余的和 target 还没 i 大，这时减完 i是负数，肯定无法满足要求，因此有剪枝条件：<ul><li><code>target &lt; i</code></li></ul></li><li>如果组合的数字个数已经到达了上限 k，还没有凑够target，也没必要继续递归，因此有：<ul><li><code>stack.size() == k</code></li></ul></li></ol><h3 id="n-皇后-leetcode-51">8) N 皇后 Leetcode 51</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NQueenLeetcode51</span> {</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[][] table = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            Arrays.fill(table[i], <span class="string">'.'</span>);</span><br><span class="line">        }</span><br><span class="line">        dfs(<span class="number">0</span>, n, table, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n, <span class="type">char</span>[][] table, List&lt;List&lt;String&gt;&gt; result)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i == n) {</span><br><span class="line">            ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span>[] chars : table) {</span><br><span class="line">                list.add(String.valueOf(chars));</span><br><span class="line">            }</span><br><span class="line">            result.add(list);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">            <span class="keyword">if</span> (notValid(table, i, j)) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            table[i][j] = <span class="string">'Q'</span>;</span><br><span class="line">            dfs(i + <span class="number">1</span>, n, table, result);</span><br><span class="line">            table[i][j] = <span class="string">'.'</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        .   .   .   .</span></span><br><span class="line"><span class="comment">        .   .   .   .</span></span><br><span class="line"><span class="comment">        .   ?   .   .</span></span><br><span class="line"><span class="comment">        .   .   .   .</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">notValid</span><span class="params">(<span class="type">char</span>[][] table, <span class="type">int</span> row, <span class="type">int</span> col)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> table.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (table[i][col] == <span class="string">'Q'</span>) { <span class="comment">// 上</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) {</span><br><span class="line">            <span class="keyword">if</span> (table[i][j] == <span class="string">'Q'</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) {</span><br><span class="line">            <span class="keyword">if</span> (table[i][j] == <span class="string">'Q'</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; table : solveNQueens(<span class="number">8</span>)) {</span><br><span class="line">            <span class="keyword">for</span> (String row : table) {</span><br><span class="line">                System.out.println(row);</span><br><span class="line">            }</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(<span class="string">"--------------------- "</span> + count);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NQueenLeetcode51</span> {</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[][] table = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="type">boolean</span>[] va = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="type">boolean</span>[] vb = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2</span> * n - <span class="number">1</span>];</span><br><span class="line">        <span class="type">boolean</span>[] vc = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2</span> * n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            Arrays.fill(table[i], <span class="string">'.'</span>);</span><br><span class="line">        }</span><br><span class="line">        dfs(<span class="number">0</span>, n, table, result, va, vb, vc);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n, <span class="type">char</span>[][] table, List&lt;List&lt;String&gt;&gt; result, <span class="type">boolean</span>[] va, <span class="type">boolean</span>[] vb, <span class="type">boolean</span>[] vc)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i == n) {</span><br><span class="line">            ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span>[] chars : table) {</span><br><span class="line">                list.add(String.valueOf(chars));</span><br><span class="line">            }</span><br><span class="line">            result.add(list);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">            <span class="keyword">if</span> (va[j] || vb[i + j] || vc[i - j + n - <span class="number">1</span>]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            va[j] = <span class="literal">true</span>;</span><br><span class="line">            vb[i + j] = <span class="literal">true</span>;</span><br><span class="line">            vc[i - j + n - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            table[i][j] = <span class="string">'Q'</span>;</span><br><span class="line">            dfs(i + <span class="number">1</span>, n, table, result, va, vb, vc);</span><br><span class="line">            table[i][j] = <span class="string">'.'</span>;</span><br><span class="line">            va[j] = <span class="literal">false</span>;</span><br><span class="line">            vb[i + j] = <span class="literal">false</span>;</span><br><span class="line">            vc[i - j + n - <span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; table : solveNQueens(<span class="number">4</span>)) {</span><br><span class="line">            <span class="keyword">for</span> (String row : table) {</span><br><span class="line">                System.out.println(row);</span><br><span class="line">            }</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(<span class="string">"--------------------- "</span> + count);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="解数独-leetcode37">9) 解数独-Leetcode37</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SudokuLeetcode37</span> {</span><br><span class="line">    <span class="keyword">record</span> <span class="title class_">Pair</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] table)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">        <span class="type">boolean</span>[][] va = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="type">boolean</span>[][] vb = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="type">boolean</span>[][][] vc = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">3</span>][<span class="number">3</span>][n];</span><br><span class="line">        List&lt;Pair&gt; blanks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (table[i][j] != <span class="string">'.'</span>) {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> table[i][j] - <span class="string">'0'</span> - <span class="number">1</span>;</span><br><span class="line">                    va[i][x] = <span class="literal">true</span>;</span><br><span class="line">                    vb[j][x] = <span class="literal">true</span>;</span><br><span class="line">                    vc[i / <span class="number">3</span>][j / <span class="number">3</span>][x] = <span class="literal">true</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    blanks.add(<span class="keyword">new</span> <span class="title class_">Pair</span>(i, j));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        dfs(<span class="number">0</span>, blanks, table, va, vb, vc);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> p, List&lt;Pair&gt; blanks, <span class="type">char</span>[][] table, <span class="type">boolean</span>[][] va, <span class="type">boolean</span>[][] vb, <span class="type">boolean</span>[][][] vc)</span> {</span><br><span class="line">        <span class="keyword">if</span> (p == blanks.size()) {</span><br><span class="line">            print(table);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> table.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0</span>; d &lt; n; d++) {</span><br><span class="line">            <span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> blanks.get(p);</span><br><span class="line">            <span class="keyword">if</span> (va[pair.i][d] || vb[pair.j][d] || vc[pair.i / <span class="number">3</span>][pair.j / <span class="number">3</span>][d]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> (<span class="type">char</span>) (d + <span class="string">'0'</span> + <span class="number">1</span>);</span><br><span class="line">            table[pair.i][pair.j] = ch;</span><br><span class="line">            va[pair.i][d] = <span class="literal">true</span>;</span><br><span class="line">            vb[pair.j][d] = <span class="literal">true</span>;</span><br><span class="line">            vc[pair.i / <span class="number">3</span>][pair.j / <span class="number">3</span>][d] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">dfs</span> <span class="operator">=</span> dfs(p + <span class="number">1</span>, blanks, table, va, vb, vc);</span><br><span class="line">            <span class="keyword">if</span> (dfs) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            table[pair.i][pair.j] = <span class="string">'.'</span>;</span><br><span class="line">            va[pair.i][d] = <span class="literal">false</span>;</span><br><span class="line">            vb[pair.j][d] = <span class="literal">false</span>;</span><br><span class="line">            vc[pair.i / <span class="number">3</span>][pair.j / <span class="number">3</span>][d] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">char</span>[][] table = {</span><br><span class="line">                {<span class="string">'5'</span>, <span class="string">'3'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'7'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>},</span><br><span class="line">                {<span class="string">'6'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'1'</span>, <span class="string">'9'</span>, <span class="string">'5'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>},</span><br><span class="line">                {<span class="string">'.'</span>, <span class="string">'9'</span>, <span class="string">'8'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'6'</span>, <span class="string">'.'</span>},</span><br><span class="line">                {<span class="string">'8'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'6'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'3'</span>},</span><br><span class="line">                {<span class="string">'4'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'8'</span>, <span class="string">'.'</span>, <span class="string">'3'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'1'</span>},</span><br><span class="line">                {<span class="string">'7'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'2'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'6'</span>},</span><br><span class="line">                {<span class="string">'.'</span>, <span class="string">'6'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'2'</span>, <span class="string">'8'</span>, <span class="string">'.'</span>},</span><br><span class="line">                {<span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'4'</span>, <span class="string">'1'</span>, <span class="string">'9'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'5'</span>},</span><br><span class="line">                {<span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'8'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'7'</span>, <span class="string">'9'</span>}</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        solveSudoku(table);</span><br><span class="line"></span><br><span class="line">        print(table);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">char</span>[][] solved = {</span><br><span class="line">            {<span class="string">'5'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>},</span><br><span class="line">            {<span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'2'</span>, <span class="string">'1'</span>, <span class="string">'9'</span>, <span class="string">'5'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'8'</span>},</span><br><span class="line">            {<span class="string">'1'</span>, <span class="string">'9'</span>, <span class="string">'8'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'2'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>},</span><br><span class="line">            {<span class="string">'8'</span>, <span class="string">'5'</span>, <span class="string">'9'</span>, <span class="string">'7'</span>, <span class="string">'6'</span>, <span class="string">'1'</span>, <span class="string">'4'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>},</span><br><span class="line">            {<span class="string">'4'</span>, <span class="string">'2'</span>, <span class="string">'6'</span>, <span class="string">'8'</span>, <span class="string">'5'</span>, <span class="string">'3'</span>, <span class="string">'7'</span>, <span class="string">'9'</span>, <span class="string">'1'</span>},</span><br><span class="line">            {<span class="string">'7'</span>, <span class="string">'1'</span>, <span class="string">'3'</span>, <span class="string">'9'</span>, <span class="string">'2'</span>, <span class="string">'4'</span>, <span class="string">'8'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>},</span><br><span class="line">            {<span class="string">'9'</span>, <span class="string">'6'</span>, <span class="string">'1'</span>, <span class="string">'5'</span>, <span class="string">'3'</span>, <span class="string">'7'</span>, <span class="string">'2'</span>, <span class="string">'8'</span>, <span class="string">'4'</span>},</span><br><span class="line">            {<span class="string">'2'</span>, <span class="string">'8'</span>, <span class="string">'7'</span>, <span class="string">'4'</span>, <span class="string">'1'</span>, <span class="string">'9'</span>, <span class="string">'6'</span>, <span class="string">'3'</span>, <span class="string">'5'</span>},</span><br><span class="line">            {<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'2'</span>, <span class="string">'8'</span>, <span class="string">'6'</span>, <span class="string">'1'</span>, <span class="string">'7'</span>, <span class="string">'9'</span>}</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span>[][] table)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] chars : table) {</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(chars));</span><br><span class="line">        }</span><br><span class="line">        System.out.println(Arrays.deepEquals(table, solved));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SudokuLeetcode37</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] table)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">        <span class="type">boolean</span>[][] va = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="type">boolean</span>[][] vb = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="type">boolean</span>[][][] vc = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">3</span>][<span class="number">3</span>][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (table[i][j] != <span class="string">'.'</span>) {</span><br><span class="line">                    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> table[i][j] - <span class="string">'0'</span> - <span class="number">1</span>;</span><br><span class="line">                    va[i][x] = <span class="literal">true</span>;</span><br><span class="line">                    vb[j][x] = <span class="literal">true</span>;</span><br><span class="line">                    vc[i / <span class="number">3</span>][j / <span class="number">3</span>][x] = <span class="literal">true</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        dfs(table, va, vb, vc, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] table, <span class="type">boolean</span>[][] va, <span class="type">boolean</span>[][] vb, <span class="type">boolean</span>[][][] vc, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="keyword">while</span> (table[i][j] != <span class="string">'.'</span>) {</span><br><span class="line">            <span class="keyword">if</span> (++j &gt;= <span class="number">9</span>) {</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">9</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> table.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0</span>; d &lt; n; d++) {</span><br><span class="line">            <span class="keyword">if</span> (va[i][d] || vb[j][d] || vc[i / <span class="number">3</span>][j / <span class="number">3</span>][d]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> (<span class="type">char</span>) (d + <span class="string">'0'</span> + <span class="number">1</span>);</span><br><span class="line">            table[i][j] = ch;</span><br><span class="line">            va[i][d] = <span class="literal">true</span>;</span><br><span class="line">            vb[j][d] = <span class="literal">true</span>;</span><br><span class="line">            vc[i / <span class="number">3</span>][j / <span class="number">3</span>][d] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">dfs</span> <span class="operator">=</span> dfs(table, va, vb, vc, i, j);</span><br><span class="line">            <span class="keyword">if</span> (dfs) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            table[i][j] = <span class="string">'.'</span>;</span><br><span class="line">            va[i][d] = <span class="literal">false</span>;</span><br><span class="line">            vb[j][d] = <span class="literal">false</span>;</span><br><span class="line">            vc[i / <span class="number">3</span>][j / <span class="number">3</span>][d] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">char</span>[][] table = {</span><br><span class="line">                {<span class="string">'5'</span>, <span class="string">'3'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'7'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>},</span><br><span class="line">                {<span class="string">'6'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'1'</span>, <span class="string">'9'</span>, <span class="string">'5'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>},</span><br><span class="line">                {<span class="string">'.'</span>, <span class="string">'9'</span>, <span class="string">'8'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'6'</span>, <span class="string">'.'</span>},</span><br><span class="line">                {<span class="string">'8'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'6'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'3'</span>},</span><br><span class="line">                {<span class="string">'4'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'8'</span>, <span class="string">'.'</span>, <span class="string">'3'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'1'</span>},</span><br><span class="line">                {<span class="string">'7'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'2'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'6'</span>},</span><br><span class="line">                {<span class="string">'.'</span>, <span class="string">'6'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'2'</span>, <span class="string">'8'</span>, <span class="string">'.'</span>},</span><br><span class="line">                {<span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'4'</span>, <span class="string">'1'</span>, <span class="string">'9'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'5'</span>},</span><br><span class="line">                {<span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'8'</span>, <span class="string">'.'</span>, <span class="string">'.'</span>, <span class="string">'7'</span>, <span class="string">'9'</span>}</span><br><span class="line">        };</span><br><span class="line">        solveSudoku(table);</span><br><span class="line"></span><br><span class="line">        print(table);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">char</span>[][] solved = {</span><br><span class="line">            {<span class="string">'5'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>},</span><br><span class="line">            {<span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'2'</span>, <span class="string">'1'</span>, <span class="string">'9'</span>, <span class="string">'5'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'8'</span>},</span><br><span class="line">            {<span class="string">'1'</span>, <span class="string">'9'</span>, <span class="string">'8'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'2'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>},</span><br><span class="line">            {<span class="string">'8'</span>, <span class="string">'5'</span>, <span class="string">'9'</span>, <span class="string">'7'</span>, <span class="string">'6'</span>, <span class="string">'1'</span>, <span class="string">'4'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>},</span><br><span class="line">            {<span class="string">'4'</span>, <span class="string">'2'</span>, <span class="string">'6'</span>, <span class="string">'8'</span>, <span class="string">'5'</span>, <span class="string">'3'</span>, <span class="string">'7'</span>, <span class="string">'9'</span>, <span class="string">'1'</span>},</span><br><span class="line">            {<span class="string">'7'</span>, <span class="string">'1'</span>, <span class="string">'3'</span>, <span class="string">'9'</span>, <span class="string">'2'</span>, <span class="string">'4'</span>, <span class="string">'8'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>},</span><br><span class="line">            {<span class="string">'9'</span>, <span class="string">'6'</span>, <span class="string">'1'</span>, <span class="string">'5'</span>, <span class="string">'3'</span>, <span class="string">'7'</span>, <span class="string">'2'</span>, <span class="string">'8'</span>, <span class="string">'4'</span>},</span><br><span class="line">            {<span class="string">'2'</span>, <span class="string">'8'</span>, <span class="string">'7'</span>, <span class="string">'4'</span>, <span class="string">'1'</span>, <span class="string">'9'</span>, <span class="string">'6'</span>, <span class="string">'3'</span>, <span class="string">'5'</span>},</span><br><span class="line">            {<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'2'</span>, <span class="string">'8'</span>, <span class="string">'6'</span>, <span class="string">'1'</span>, <span class="string">'7'</span>, <span class="string">'9'</span>}</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span>[][] table)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] chars : table) {</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(chars));</span><br><span class="line">        }</span><br><span class="line">        System.out.println(Arrays.deepEquals(table, solved));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="其它题目-4">其它题目</h3><table><colgroup><col style="width: 11%"><col style="width: 33%"><col style="width: 54%"></colgroup><thead><tr class="header"><th>题号</th><th>标题</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>Leetcode 1219</td><td>黄金矿工</td><td></td></tr><tr class="even"><td>无</td><td>马踏棋盘（The Knight’s tour problem）</td><td></td></tr><tr class="odd"><td>无</td><td>Rat in a Maze</td><td>与 Leetcode 62不同路径区别在于，该题问的是有多少种走法，而本题只是找到其中一种走法实现</td></tr></tbody></table><h2 id="leetcode-双指针">4.6 Leetcode 双指针</h2><p>下面是的题目都会涉及双指针，除此外，还有</p><ul><li>Leetcode3 最长不重复子串，在 hash 表部分讲过了</li><li>快排中</li><li>二分中</li><li>...</li></ul><h3 id="移动零-leetcode-283">移动零-Leetcode 283</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoveZeroesLeetcode283</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; nums.length) {</span><br><span class="line">            <span class="keyword">if</span> (nums[j] != <span class="number">0</span>) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = t;</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] nums = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">12</span>};</span><br><span class="line">        moveZeroes(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="两数之和-ii-leetcode-167">两数之和 II-Leetcode 167</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SumLeetcode167</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(Arrays.toString(twoSum(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>}, <span class="number">9</span>)));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) {</span><br><span class="line">        <span class="keyword">return</span> twoSum(numbers, <span class="number">0</span>, numbers.length - <span class="number">1</span>, target);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] &lt; target) {</span><br><span class="line">                i++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] &gt; target) {</span><br><span class="line">                j--;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]{i + <span class="number">1</span>, j + <span class="number">1</span>};</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>与 Leetcode 1 的两数之和区别在于，本题的数组是升序排好的</p><h3 id="三数之和-leetcode-15">三数之和-Leetcode 15</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SumLeetcode15</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">3</span>, <span class="number">0</span>, nums.length - <span class="number">1</span>, <span class="number">0</span>, nums,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> target, <span class="type">int</span>[] nums,</span></span><br><span class="line"><span class="params">                    LinkedList&lt;Integer&gt; stack,</span></span><br><span class="line"><span class="params">                    List&lt;List&lt;Integer&gt;&gt; result)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) {</span><br><span class="line">            <span class="comment">// 套用两数之和求解</span></span><br><span class="line">            twoSum(i, j, nums, target, stack, result);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i; k &lt; j - (n - <span class="number">2</span>); k++) {</span><br><span class="line">            <span class="comment">// 检查重复</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; i &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 固定一个数字，再尝试 n-1 数字之和</span></span><br><span class="line">            stack.push(nums[k]);</span><br><span class="line">            dfs(n - <span class="number">1</span>, k + <span class="number">1</span>, j, target - nums[k], nums, stack, result);</span><br><span class="line">            stack.pop();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] numbers, <span class="type">int</span> target,</span></span><br><span class="line"><span class="params">                              LinkedList&lt;Integer&gt; stack,</span></span><br><span class="line"><span class="params">                              List&lt;List&lt;Integer&gt;&gt; result)</span> {</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers[i] + numbers[j];</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target) {</span><br><span class="line">                i++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) {</span><br><span class="line">                j--;</span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 找到解</span></span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack);</span><br><span class="line">                list.add(numbers[i]);</span><br><span class="line">                list.add(numbers[j]);</span><br><span class="line">                result.add(list);</span><br><span class="line">                <span class="comment">// 继续查找其它的解</span></span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; numbers[i] == numbers[i - <span class="number">1</span>]) {</span><br><span class="line">                    i++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; numbers[j] == numbers[j + <span class="number">1</span>]) {</span><br><span class="line">                    j--;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">int</span>[] candidates = {-<span class="number">4</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>};</span><br><span class="line">        System.out.println(<span class="string">"数据量:"</span> + candidates.length);</span><br><span class="line">        System.out.println(threeSum(candidates));</span><br><span class="line">        System.out.println(<span class="string">"耗费时间:"</span> + (System.currentTimeMillis() - start));</span><br><span class="line">        System.out.println(<span class="string">"递归次数:"</span> + count);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>本题与之前的两数之和（Leetcode 1 和 Leetcode 167）相比，区别在于<ul><li>两数之和里明确说了，只有一个答案，而本题要找出所有答案</li><li>本题要考虑去重</li></ul></li><li>本题类似于 组合总和 II（Leetcode 40） 区别在于<ul><li>40 题要求列出任意数之和等于 target的所有组合，而本题要求三数之和等于 target 的所有组合</li><li>40 题使用回溯的办法时间复杂度是 <span class="math inline">\(O(2^n *n)\)</span>，而本题的三数限制了递归次数仅有一次，并且每次递归终点是求两数之和时间复杂度为<span class="math inline">\(O(n)\)</span>，因此总时间复杂度为 <span class="math inline">\(O(n^2)\)</span></li></ul></li><li>小优化：固定数字时，应该预留三个数字做三数之和，预览两个数字做两数之和，因此有k &lt; j - (n - 2)</li></ul><h3 id="四数之和-leetcode-18">四数之和-Leetcode 18</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SumLeetcode18</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">4</span>, <span class="number">0</span>, nums.length - <span class="number">1</span>, target, nums,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> target, <span class="type">int</span>[] nums,</span></span><br><span class="line"><span class="params">                    LinkedList&lt;Integer&gt; stack,</span></span><br><span class="line"><span class="params">                    List&lt;List&lt;Integer&gt;&gt; result)</span> {</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) {</span><br><span class="line">            <span class="comment">// 套用两数之和求解</span></span><br><span class="line">            twoSum(i, j, nums, target, stack, result);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i; k &lt; j - (n - <span class="number">2</span>); k++) { <span class="comment">// 四数之和 i &lt;j-2  三数之和 i &lt;j-1</span></span><br><span class="line">            <span class="comment">// 检查重复</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; i &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 固定一个数字，再尝试 n-1 数字之和</span></span><br><span class="line">            stack.push(nums[k]);</span><br><span class="line">            dfs(n - <span class="number">1</span>, k + <span class="number">1</span>, j, target - nums[k], nums, stack, result);</span><br><span class="line">            stack.pop();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] numbers, <span class="type">int</span> target,</span></span><br><span class="line"><span class="params">                              LinkedList&lt;Integer&gt; stack,</span></span><br><span class="line"><span class="params">                              List&lt;List&lt;Integer&gt;&gt; result)</span> {</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers[i] + numbers[j];</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target) {</span><br><span class="line">                i++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) {</span><br><span class="line">                j--;</span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 找到解</span></span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack);</span><br><span class="line">                list.add(numbers[i]);</span><br><span class="line">                list.add(numbers[j]);</span><br><span class="line">                result.add(list);</span><br><span class="line">                <span class="comment">// 继续查找其它的解</span></span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; numbers[i] == numbers[i - <span class="number">1</span>]) {</span><br><span class="line">                    i++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; numbers[j] == numbers[j + <span class="number">1</span>]) {</span><br><span class="line">                    j--;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(fourSum(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">2</span>, <span class="number">2</span>}, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//        System.out.println(fourSum(new int[]{2, 2, 2, 2, 2}, 8));</span></span><br><span class="line"><span class="comment">//        System.out.println(fourSum(new int[]{1000000000,1000000000,1000000000,1000000000}, -294967296));</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="盛最多水的容器-leetcode-11">盛最多水的容器-Leetcode 11</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MostWaterLeetcode11</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.min(height[i], height[j]);</span><br><span class="line">            max = Integer.max(max, (j - i) * min);</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; height[i] &lt;= min) {</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; height[j] &lt;= min) {</span><br><span class="line">                j--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(maxArea(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>})); <span class="comment">// 49</span></span><br><span class="line">        System.out.println(maxArea(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">2</span>,<span class="number">1</span>})); <span class="comment">// 1</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="反转字符数组-leetcode-344">反转字符数组-Leetcode 344</h3><p>双指针</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReverseStringLeetcode344</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">char</span>[] array = <span class="string">"abcde"</span>.toCharArray();</span><br><span class="line">        reverseString(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> {</span><br><span class="line">        recursion(s, <span class="number">0</span>, s.length - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recursion</span><span class="params">(<span class="type">char</span>[] array, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        swap(array, i, j);</span><br><span class="line">        recursion(array, ++i, --j);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] array, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = c;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>第一次交换的是 array[0] 和 array[4]</li><li>第二次交换的是 array[1] 和 array[3]</li><li>第三次 i = j = 2，开始返回</li><li>如果 array.length 是偶数，则会在 i &gt; j 时返回</li></ul><h2 id="leetcode-单调队列和栈">4.7 Leetcode 单调队列和栈</h2><h3 id="单调递减队列">单调递减队列</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonotonicStack</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;T&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T t)</span> {</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().compareTo(t) &lt; <span class="number">0</span>) {</span><br><span class="line">            stack.pop();</span><br><span class="line">        }</span><br><span class="line">        stack.push(t);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        stack.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">peek</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> stack.toString();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        MonotonicStack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">MonotonicStack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : <span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>}) {</span><br><span class="line">            stack.push(i);</span><br><span class="line">            System.out.println(stack);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="最大滑动窗口-leetcode-239">最大滑动窗口-Leetcode 239</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlidingWindowMaximumLeetcode239</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) {</span><br><span class="line">        MonotonicQueue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">MonotonicQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] output = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - (k - <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k &amp;&amp; nums[i - k] == q.peek()) {</span><br><span class="line">                q.poll();</span><br><span class="line">            }</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            q.offer(num);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) {</span><br><span class="line">                output[i - (k - <span class="number">1</span>)] = q.peek();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(Arrays.toString(maxSlidingWindow(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>}, <span class="number">3</span>))); <span class="comment">//[3, 3, 5, 5, 6, 7]</span></span><br><span class="line">        System.out.println(Arrays.toString(maxSlidingWindow(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>}, <span class="number">2</span>))); <span class="comment">// [7, 4]</span></span><br><span class="line">        System.out.println(Arrays.toString(maxSlidingWindow(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">5</span>}, <span class="number">3</span>))); <span class="comment">// [3, 3, 2, 5]</span></span><br><span class="line">        System.out.println(Arrays.toString(maxSlidingWindow(<span class="keyword">new</span> <span class="title class_">int</span>[]{-<span class="number">7</span>, -<span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">0</span>}, <span class="number">4</span>))); <span class="comment">// [7, 7, 7, 7, 7]</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果每移动一次窗口，就在 k 个数里找最大值，时间复杂度约为 <span class="math inline">\(O(n*k)\)</span></li><li>利用了单调队列后，每个元素都最多<strong>入队</strong>、<strong>出队</strong>一次，找最大值就在队头找，时间复杂度为<span class="math inline">\(O(n)\)</span></li></ul><h3 id="单调递减栈">单调递减栈</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonotonicStack</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ValueAndIndex</span> {</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ValueAndIndex</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> i)</span> {</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.i = i;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line"><span class="comment">//            return "[%d]%d".formatted(index, value);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"%d"</span>.formatted(value);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;ValueAndIndex&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> i, TriConsumer onPop)</span> {</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().value &lt; value) {</span><br><span class="line">            <span class="type">ValueAndIndex</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="type">ValueAndIndex</span> <span class="variable">peek</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (peek != <span class="literal">null</span>) {</span><br><span class="line">                onPop.accept(pop.value, peek.value, peek.i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        stack.push(<span class="keyword">new</span> <span class="title class_">ValueAndIndex</span>(value, i));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> stack.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="接雨水-leetcode-42">接雨水-Leetcode 42</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrappingRainWaterLeetcode42</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(trap(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>})); <span class="comment">// 6</span></span><br><span class="line">        System.out.println(trap(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>})); <span class="comment">// 9</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">record</span> <span class="title class_">Data</span><span class="params">(<span class="type">int</span> height, <span class="type">int</span> i)</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] heights)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;Data&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; heights.length; i++) {</span><br><span class="line">            <span class="type">Data</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>(heights[i], i);</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().height &lt; heights[i]) {</span><br><span class="line">                <span class="type">Data</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">Data</span> <span class="variable">left</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">                <span class="keyword">if</span> (left != <span class="literal">null</span>) {</span><br><span class="line">                    sum += (Integer.min(left.height, right.height) - pop.height) * (right.i - left.i - <span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            stack.push(right);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>维护一个单调栈</li><li>当加入新柱子（right）时，如果发现要弹出之前的柱子，表示遇到了凹陷的地方<ul><li>此时栈里没有更左边的柱子，表示拦不住雨水</li><li>栈里有左边柱子（left）就可以计算雨水容量：<span class="math inline">\((right.i -left.i-1)*Min(right.height,left.height)-pop.height\)</span></li></ul></li></ul><h2 id="leetcode-字符串">4.8 Leetcode 字符串</h2><h3 id="indexof-leetcode-28">indexOf-Leetcode 28</h3><p>native string matching</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrStrLeetcode28</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> {</span><br><span class="line">        <span class="type">char</span>[] text = haystack.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] pattern = needle.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> text.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> pattern.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - m; i++) {</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; j++) {</span><br><span class="line">                <span class="keyword">if</span> (pattern[j] != text[i + j]) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (j == m) {</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(strStr(<span class="string">"aaacaaab"</span>, <span class="string">"aaab"</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>kmp string matching</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrStrLeetcode28KMP</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> {</span><br><span class="line">        <span class="type">char</span>[] text = haystack.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] pattern = needle.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> text.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> pattern.length;</span><br><span class="line">        <span class="type">int</span>[] lps = lps(pattern);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((n - i) &gt;= (m - j)) {</span><br><span class="line">            <span class="keyword">if</span> (text[i] == pattern[j]) { <span class="comment">// 匹配成功</span></span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (j != <span class="number">0</span>) { <span class="comment">// 匹配失败</span></span><br><span class="line">                j = lsp[j - <span class="number">1</span>];</span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 匹配失败 j == 0</span></span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (j == m) { <span class="comment">// 找到解</span></span><br><span class="line">                <span class="keyword">return</span> i - j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] lps(<span class="type">char</span>[] pattern) {</span><br><span class="line">        <span class="type">int</span>[] lps = <span class="keyword">new</span> <span class="title class_">int</span>[pattern.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 后缀</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 前缀 同时也是数量</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; pattern.length) {</span><br><span class="line">            <span class="keyword">if</span> (pattern[i] == pattern[j]) {</span><br><span class="line">                j++;</span><br><span class="line">                lps[i] = j;</span><br><span class="line">                i++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (j != <span class="number">0</span>) {</span><br><span class="line">                j = lps[j - <span class="number">1</span>];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> lps;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(strStr(<span class="string">"aaaaaaab"</span>, <span class="string">"aaab"</span>));</span><br><span class="line"><span class="comment">//        System.out.println(Arrays.toString(prefix("aaab".toCharArray())));</span></span><br><span class="line">        System.out.println(Arrays.toString(lsp(<span class="string">"ababaca"</span>.toCharArray())));</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>很多文章里<a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a>，把 lps 数组的向后平移一位，lps 用-1 填充，这个平移后的数组称为 next<ul><li>这样可以用 -1 代替 j == 0 的判断</li><li>并可以在 j &gt; 0 向前移动时，做少量优化（不用 next数组也能做同样优化）</li></ul></li><li>其它字符串匹配算法有：BM 算法、sunday 算法、Horspool 算法等</li></ul><h3 id="最长公共前缀-leetcode-14">最长公共前缀-Leetcode 14</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LCPLeetcode14</span> {</span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strings)</span> {</span><br><span class="line">        <span class="type">char</span>[] first = strings[<span class="number">0</span>].toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; first.length; i++) {</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> first[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; strings.length; j++) {</span><br><span class="line">                <span class="keyword">if</span> (i == strings[j].length() || ch != strings[j].charAt(i)) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(first, <span class="number">0</span>, i);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> strings[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(longestCommonPrefix(<span class="keyword">new</span> <span class="title class_">String</span>[]{<span class="string">"flower"</span>, <span class="string">"flow"</span>, <span class="string">"flight"</span>})); <span class="comment">// fl</span></span><br><span class="line">        System.out.println(longestCommonPrefix(<span class="keyword">new</span> <span class="title class_">String</span>[]{<span class="string">"dog"</span>,<span class="string">"racecar"</span>,<span class="string">"car"</span>})); <span class="comment">//</span></span><br><span class="line">        System.out.println(longestCommonPrefix(<span class="keyword">new</span> <span class="title class_">String</span>[]{<span class="string">"ab"</span>,<span class="string">"a"</span>})); <span class="comment">// a</span></span><br><span class="line">        System.out.println(longestCommonPrefix(<span class="keyword">new</span> <span class="title class_">String</span>[]{<span class="string">"dog"</span>,<span class="string">"dogaa"</span>,<span class="string">"dogbb"</span>})); <span class="comment">// dog</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="最长回文子串-leetcode-5">最长回文子串-Leetcode 5</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongestPalindromeLeetcode5</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(longestPalindrome(<span class="string">"babad"</span>));  <span class="comment">// bab</span></span><br><span class="line">        System.out.println(longestPalindrome(<span class="string">"cbbd"</span>)); <span class="comment">// bb</span></span><br><span class="line">        System.out.println(longestPalindrome(<span class="string">"a"</span>)); <span class="comment">// a</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">record</span> <span class="title class_">Result</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> length)</span> {</span><br><span class="line">        <span class="keyword">static</span> Result <span class="title function_">max</span><span class="params">(Result r1, Result r2, Result r3)</span> {</span><br><span class="line">            <span class="type">Result</span> <span class="variable">m</span> <span class="operator">=</span> r1;</span><br><span class="line">            <span class="keyword">if</span> (r2.length &gt; m.length) {</span><br><span class="line">                m = r2;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (r3.length &gt; m.length) {</span><br><span class="line">                m = r3;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="type">Result</span> <span class="variable">max</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="type">Result</span> <span class="variable">r1</span> <span class="operator">=</span> extend(chars, i, i);</span><br><span class="line">            <span class="type">Result</span> <span class="variable">r2</span> <span class="operator">=</span> extend(chars, i, i + <span class="number">1</span>);</span><br><span class="line">            max = Result.max(max, r1, r2);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars, max.i, max.length);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Result <span class="title function_">extend</span><span class="params">(<span class="type">char</span>[] chars, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> chars.length;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; len &amp;&amp; chars[i] == chars[j]) {</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(i, j - i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>还有时间复杂度更低的算法：Manacher</li></ul><h3 id="最小覆盖子串-leetcode-76">最小覆盖子串-Leetcode 76</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinWindowLeetcode76_2</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(minWindow(<span class="string">"ADOBECODEBANC"</span>, <span class="string">"ABC"</span>)); <span class="comment">// BANC</span></span><br><span class="line">        System.out.println(minWindow(<span class="string">"aaabbbbbcdd"</span>, <span class="string">"abcdd"</span>)); <span class="comment">// abbbbbcdd</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">record</span> <span class="title class_">Answer</span><span class="params">(<span class="type">int</span> count, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> {</span><br><span class="line">        <span class="type">char</span>[] source = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] target = t.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] targetCountMap = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="type">int</span>[] windowCountMap = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : target) {</span><br><span class="line">            targetCountMap[ch]++;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">Answer</span> <span class="variable">answer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Answer</span>(Integer.MAX_VALUE, i, j);</span><br><span class="line">        <span class="type">int</span> <span class="variable">passCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> count : targetCountMap) {</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">                passCount++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">pass</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; source.length) {</span><br><span class="line">            <span class="type">char</span> <span class="variable">right</span> <span class="operator">=</span> source[j];</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ++windowCountMap[right];</span><br><span class="line">            <span class="keyword">if</span> (c == targetCountMap[right]) {</span><br><span class="line">                pass++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span> (pass == passCount &amp;&amp; i &lt;= j) {</span><br><span class="line">                <span class="keyword">if</span> (j - i &lt; answer.count) {</span><br><span class="line">                    answer = <span class="keyword">new</span> <span class="title class_">Answer</span>(j - i, i, j);</span><br><span class="line">                }</span><br><span class="line">                <span class="type">char</span> <span class="variable">left</span> <span class="operator">=</span> source[i];</span><br><span class="line">                windowCountMap[left]--;</span><br><span class="line">                <span class="keyword">if</span> (windowCountMap[left] &lt; targetCountMap[left]) {</span><br><span class="line">                    pass--;</span><br><span class="line">                }</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer.count != Integer.MAX_VALUE ? s.substring(answer.i, answer.j + <span class="number">1</span>) : <span class="string">""</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="leetcode-设计">4.9 Leetcode 设计</h2><h3 id="lru-缓存-leetcode-146">LRU 缓存-Leetcode 146</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCacheLeetcode146</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> {</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">            Node prev;</span><br><span class="line">            Node next;</span><br><span class="line">            <span class="type">int</span> key;</span><br><span class="line">            <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> {</span><br><span class="line">                <span class="built_in">this</span>.key = key;</span><br><span class="line">                <span class="built_in">this</span>.value = value;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DoublyLinkedList</span> {</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Node head;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Node tail;</span><br><span class="line"></span><br><span class="line">            DoublyLinkedList() {</span><br><span class="line">                head = tail = <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">                head.next = tail;</span><br><span class="line">                tail.prev = head;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(Node newFirst)</span> {</span><br><span class="line">                <span class="type">Node</span> <span class="variable">oldFirst</span> <span class="operator">=</span> head.next;</span><br><span class="line">                newFirst.prev = head;</span><br><span class="line">                newFirst.next = oldFirst;</span><br><span class="line">                head.next = newFirst;</span><br><span class="line">                oldFirst.prev = newFirst;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Node node)</span> {</span><br><span class="line">                <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> node.prev;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">                prev.next = next;</span><br><span class="line">                next.prev = prev;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Node <span class="title function_">removeLast</span><span class="params">()</span> {</span><br><span class="line">                <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">                remove(last);</span><br><span class="line">                <span class="keyword">return</span> last;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Integer, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">DoublyLinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoublyLinkedList</span>();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">            <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            linkedList.remove(node);</span><br><span class="line">            linkedList.addFirst(node);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> {</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(key)) {</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">                node.value = value;</span><br><span class="line">                linkedList.remove(node);</span><br><span class="line">                linkedList.addFirst(node);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">                map.put(key, node);</span><br><span class="line">                linkedList.addFirst(node);</span><br><span class="line">                <span class="keyword">if</span> (map.size() &gt; capacity) {</span><br><span class="line">                    <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> linkedList.removeLast();</span><br><span class="line">                    map.remove(last.key);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">LRUCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LRUCache</span>(<span class="number">2</span>);</span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(cache.get(<span class="number">1</span>)); <span class="comment">// 1</span></span><br><span class="line">        cache.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(cache.get(<span class="number">2</span>)); <span class="comment">// -1</span></span><br><span class="line">        cache.put(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(cache.get(<span class="number">1</span>)); <span class="comment">// -1</span></span><br><span class="line">        System.out.println(cache.get(<span class="number">3</span>)); <span class="comment">// 3</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意：</p><ul><li>这里很重要的一点是，map 中存储 node，可以省去在双向链表中查找 node的时间，这样让使用最近访问的节点移动到链表头时达到 <span class="math inline">\(O(1)\)</span> 的需求</li><li>同时我们应当意识到，node的引用不能修改了（不方便修改，真要改得同时改链表）<ul><li>例如，不能在更新时用新的 node 对象替换，而应该在原有的 node 上修改value</li></ul></li></ul><h3 id="lfu-缓存-leetcode-460">LFU 缓存-Leetcode 460</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LFUCacheLeetcode460</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LFUCache</span> {</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">            Node prev;</span><br><span class="line">            Node next;</span><br><span class="line">            <span class="type">int</span> key;</span><br><span class="line">            <span class="type">int</span> value;</span><br><span class="line">            <span class="type">int</span> freq;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> {</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value, <span class="type">int</span> freq)</span> {</span><br><span class="line">                <span class="built_in">this</span>.key = key;</span><br><span class="line">                <span class="built_in">this</span>.value = value;</span><br><span class="line">                <span class="built_in">this</span>.freq = freq;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DoublyLinkedList</span> {</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Node head;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Node tail;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">DoublyLinkedList</span><span class="params">()</span> {</span><br><span class="line">                head = tail = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">                head.next = tail;</span><br><span class="line">                tail.prev = head;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Node node)</span> {</span><br><span class="line">                <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> node.prev;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">                prev.next = next;</span><br><span class="line">                next.prev = prev;</span><br><span class="line">                node.prev = node.next = <span class="literal">null</span>;</span><br><span class="line">                size--;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(Node newFirst)</span> {</span><br><span class="line">                <span class="type">Node</span> <span class="variable">oldFirst</span> <span class="operator">=</span> head.next;</span><br><span class="line">                newFirst.prev = head;</span><br><span class="line">                newFirst.next = oldFirst;</span><br><span class="line">                head.next = newFirst;</span><br><span class="line">                oldFirst.prev = newFirst;</span><br><span class="line">                size++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Node <span class="title function_">removeLast</span><span class="params">()</span> {</span><br><span class="line">                <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">                remove(last);</span><br><span class="line">                <span class="keyword">return</span> last;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Integer, DoublyLinkedList&gt; freqMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Integer, Node&gt; kvMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> minFreq;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LFUCache</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">            <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> kvMap.get(key);</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="type">DoublyLinkedList</span> <span class="variable">list</span> <span class="operator">=</span> freqMap.get(node.freq);</span><br><span class="line">            list.remove(node);</span><br><span class="line">            <span class="keyword">if</span> (node.freq == minFreq &amp;&amp; list.isEmpty()) {</span><br><span class="line">                minFreq++;</span><br><span class="line">            }</span><br><span class="line">            node.freq++;</span><br><span class="line">            freqMap.computeIfAbsent(node.freq, k -&gt; <span class="keyword">new</span> <span class="title class_">DoublyLinkedList</span>()).addFirst(node);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> {</span><br><span class="line">            <span class="keyword">if</span> (kvMap.containsKey(key)) {</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> kvMap.get(key);</span><br><span class="line">                <span class="type">DoublyLinkedList</span> <span class="variable">list</span> <span class="operator">=</span> freqMap.get(node.freq);</span><br><span class="line">                list.remove(node);</span><br><span class="line">                <span class="keyword">if</span> (node.freq == minFreq &amp;&amp; list.isEmpty()) {</span><br><span class="line">                    minFreq++;</span><br><span class="line">                }</span><br><span class="line">                node.freq++;</span><br><span class="line">                node.value = value;</span><br><span class="line">                freqMap.computeIfAbsent(node.freq, k -&gt; <span class="keyword">new</span> <span class="title class_">DoublyLinkedList</span>()).addFirst(node);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (kvMap.size() == capacity) {</span><br><span class="line">                    <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> freqMap.get(minFreq).removeLast();</span><br><span class="line">                    kvMap.remove(last.key);</span><br><span class="line">                }</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value, <span class="number">1</span>);</span><br><span class="line">                kvMap.put(key, node);</span><br><span class="line">                minFreq = <span class="number">1</span>;</span><br><span class="line">                freqMap.computeIfAbsent(node.freq, k -&gt; <span class="keyword">new</span> <span class="title class_">DoublyLinkedList</span>()).addFirst(node);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">LFUCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LFUCache</span>(<span class="number">2</span>);</span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(cache.get(<span class="number">1</span>)); <span class="comment">// 1 freq=2</span></span><br><span class="line">        cache.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(cache.get(<span class="number">2</span>)); <span class="comment">// -1</span></span><br><span class="line">        System.out.println(cache.get(<span class="number">3</span>)); <span class="comment">// 3 freq=2</span></span><br><span class="line">        cache.put(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(cache.get(<span class="number">1</span>)); <span class="comment">// -1</span></span><br><span class="line">        System.out.println(cache.get(<span class="number">3</span>)); <span class="comment">// 3  freq=3</span></span><br><span class="line">        System.out.println(cache.get(<span class="number">4</span>)); <span class="comment">// 4  freq=2</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="随机数">随机数</h3><h4 id="线性同余发生器">线性同余发生器</h4><p>公式 <span class="math inline">\(nextSeed = (seed * a + c) \modm\)</span></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRandom</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> m;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> seed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRandom</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> c, <span class="type">int</span> m, <span class="type">int</span> seed)</span> {</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">        <span class="built_in">this</span>.m = m;</span><br><span class="line">        <span class="built_in">this</span>.seed = seed;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">return</span> <span class="variable">seed</span> <span class="operator">=</span> (a * seed + c) % m;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">MyRandom</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRandom</span>(<span class="number">7</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(IntStream.generate(r1::nextInt).limit(<span class="number">30</span>).toArray()));</span><br><span class="line">        <span class="type">MyRandom</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRandom</span>(<span class="number">7</span>, <span class="number">0</span>, Integer.MAX_VALUE, <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(IntStream.generate(r2::nextInt).limit(<span class="number">30</span>).toArray()));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>32 位随机数生成器</li><li>乘法会超过 int 范围导致随机性被破坏</li></ul><h4 id="java-版-1">java 版</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRandom2</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0x5DEECE66DL</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0xBL</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1L</span> &lt;&lt; <span class="number">48</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> seed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRandom2</span><span class="params">(<span class="type">long</span> seed)</span> {</span><br><span class="line">        <span class="built_in">this</span>.seed = (seed ^ a) &amp; (m - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> {</span><br><span class="line">        seed = (a * seed + c) &amp; (m - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ((<span class="type">int</span>) (seed &gt;&gt;&gt; <span class="number">16</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">MyRandom2</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRandom2</span>(<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(IntStream.generate(r1::nextInt).limit(<span class="number">10</span>).toArray()));</span><br><span class="line">        System.out.println(Arrays.toString(IntStream.generate(r2::nextInt).limit(<span class="number">10</span>).toArray()));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>0x5DEECE66DL * 0x5DEECE66DL 不会超过 long 的范围</li><li>m 决定只取 48 位随机数</li><li>对于 nextInt，只取 48 位随机数的高 32 位</li></ul><h3 id="跳表-leetcode-1206">跳表-Leetcode 1206</h3><h4 id="randomlevel">randomLevel</h4><p>设计一个方法调用若干次，每次返回 <em>1~max</em> 的数字，从 1开始，返回数字的比例减半，例如 <em>max = 4</em>，让大概</p><ul><li>50% 的几率返回 1</li><li>25% 的几率返回 2</li><li>12.5% 的几率返回 3</li><li>12.5% 的几率返回 4</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    第一轮有 500 个(level 1) &gt;= 0.5 退出循环，剩下 500 个(level 2)</span></span><br><span class="line"><span class="comment">    第二轮有 250 个(level 2) &gt;= 0.5 退出循环，剩下 125 个(level 3)</span></span><br><span class="line"><span class="comment">    第三轮有 63 个(level 3) &gt;= 0.5 退出循环，剩下 62 个(level 4) 由于第二个条件退出循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">randomLevel</span><span class="params">(<span class="type">int</span> max)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (Math.random() &lt; <span class="number">0.5</span> &amp;&amp; level &lt; max) {</span><br><span class="line">        level++;</span><br><span class="line">    }    </span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="跳表">跳表</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SkipListLeetcode1206</span> {</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> Skiplist.randomLevel();</span><br><span class="line">            map.compute(level, (k, v) -&gt; v == <span class="literal">null</span> ? <span class="number">1</span> : v + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(map.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, e -&gt; String.format(<span class="string">"%d%%"</span>, e.getValue() * <span class="number">100</span> / <span class="number">1000</span>))));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Skiplist</span> {</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">randomLevel</span><span class="params">()</span> {</span><br><span class="line">            <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (Math.random() &lt; <span class="number">0.5</span> &amp;&amp; level &lt; MAX) {</span><br><span class="line">                level++;</span><br><span class="line">            }</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            第一轮有 500 个(level 1) &gt;= 0.5 退出循环，剩下 500 个(level 2)</span></span><br><span class="line"><span class="comment">            第二轮有 250 个(level 2) &gt;= 0.5 退出循环，剩下 125 个(level 3)</span></span><br><span class="line"><span class="comment">            第三轮有 63 个(level 3) &gt;= 0.5 退出循环，剩下 62 个(level 4) 由于第二个条件退出循环</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            <span class="keyword">return</span> level;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">            <span class="type">int</span> val;</span><br><span class="line">            Node[] next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">                <span class="built_in">this</span>.val = val;</span><br><span class="line">                <span class="built_in">this</span>.next = <span class="keyword">new</span> <span class="title class_">Node</span>[MAX];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Node[] find(<span class="type">int</span> val) {</span><br><span class="line">            Node[] path = <span class="keyword">new</span> <span class="title class_">Node</span>[MAX];</span><br><span class="line">            <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">lvl</span> <span class="operator">=</span> MAX - <span class="number">1</span>; lvl &gt;= <span class="number">0</span>; lvl--) {</span><br><span class="line">                <span class="keyword">while</span> (curr.next[lvl] != <span class="literal">null</span> &amp;&amp; curr.next[lvl].val &lt; val) {</span><br><span class="line">                    curr = curr.next[lvl];</span><br><span class="line">                }</span><br><span class="line">                path[lvl] = curr;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> path;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">            Node[] path = find(val);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> path[<span class="number">0</span>].next[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> node != <span class="literal">null</span> &amp;&amp; node.val == val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">            Node[] path = find(val);</span><br><span class="line">            <span class="type">int</span> <span class="variable">lv</span> <span class="operator">=</span> randomLevel();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lv; i++) {</span><br><span class="line">                node.next[i] = path[i].next[i];</span><br><span class="line">                path[i].next[i] = node;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">erase</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">            Node[] path = find(val);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> path[<span class="number">0</span>].next[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">null</span> || node.val != val) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX; i++) {</span><br><span class="line">                <span class="keyword">if</span> (path[i].next[i] != node) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                path[i].next[i] = node.next[i];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下楼梯规则</p><ul><li>若 next 指针为 null，或者 next 指向的节点值 &gt;= 目标，向下找</li><li>若 next 指针不为 null，且 next 指向的节点值 &lt; 目标，向右找</li></ul><p>节点的【高度】</p><ul><li>高度并不需要额外属性来记录，而是由之前节点 next ==本节点的个数来决定，或是本节点 next 数组长度</li><li>本实现选择了第一种方式来决定高度，本节点的 next 数组长度统一为MAX</li></ul><h3 id="最小栈-leetcode-155">最小栈-Leetcode 155</h3><p>解法1</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MinStack</span> {</span><br><span class="line">    LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; min = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> {</span><br><span class="line">        min.push(Integer.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">        stack.push(val);</span><br><span class="line">        min.push(Math.min(val, min.peek()));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        stack.pop();</span><br><span class="line">        min.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> min.peek();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解法2</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MinStack2</span> {</span><br><span class="line">    <span class="keyword">record</span> <span class="title class_">Data</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> min)</span> {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">final</span> LinkedList&lt;Data&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) {</span><br><span class="line">            stack.push(<span class="keyword">new</span> <span class="title class_">Data</span>(val, val));</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">Data</span> <span class="variable">peek</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            stack.push(<span class="keyword">new</span> <span class="title class_">Data</span>(val, Math.min(val, peek.min)));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        stack.pop();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> stack.peek().val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> stack.peek().min;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="tinyurl-的加密与解密-leetcode-535">TinyURL 的加密与解密-Leetcode535</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TinyURLLeetcode535</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">/*CodecSequence codec = new CodecSequence();</span></span><br><span class="line"><span class="comment">        String encoded = codec.encode("https://leetcode.cn/problems/1");</span></span><br><span class="line"><span class="comment">        System.out.println(encoded);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        encoded = codec.encode("https://leetcode.cn/problems/2");</span></span><br><span class="line"><span class="comment">        System.out.println(encoded);*/</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt;= 62; i++) {</span></span><br><span class="line"><span class="comment">//            System.out.println(i + "\t" + CodecSequence.toBase62(i));</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line"></span><br><span class="line">        System.out.println(CodecSequence.toBase62(<span class="number">237849728</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        要让【长】【短】网址一一对应</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            1. 用【随机数】作为短网址标识</span></span><br><span class="line"><span class="comment">            2. 用【hash码】作为短网址标识</span></span><br><span class="line"><span class="comment">            3. 用【递增数】作为短网址标识</span></span><br><span class="line"><span class="comment">                1) 多线程下可以使用吗？</span></span><br><span class="line"><span class="comment">                2) 分布式下可以使用吗？</span></span><br><span class="line"><span class="comment">                3) 4e9iAk 是怎么生成的？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                a-z 0-9 A-Z  62进制的数字</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        十进制 =&gt; 十六进制</span></span><br><span class="line"><span class="comment">        31       1f</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        31 % 16 = 15</span></span><br><span class="line"><span class="comment">        31 / 16 = 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1 % 16 = 1</span></span><br><span class="line"><span class="comment">        1 / 16 = 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        长网址： https://leetcode.cn/problems/encode-and-decode-tinyurl/description/</span></span><br><span class="line"><span class="comment">        对应的短网址： http://tinyurl.com/4e9iAk</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CodecSequence</span> {</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span>[] toBase62 = {</span><br><span class="line">                <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>, <span class="string">'H'</span>, <span class="string">'I'</span>, <span class="string">'J'</span>, <span class="string">'K'</span>, <span class="string">'L'</span>, <span class="string">'M'</span>,</span><br><span class="line">                <span class="string">'N'</span>, <span class="string">'O'</span>, <span class="string">'P'</span>, <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'S'</span>, <span class="string">'T'</span>, <span class="string">'U'</span>, <span class="string">'V'</span>, <span class="string">'W'</span>, <span class="string">'X'</span>, <span class="string">'Y'</span>, <span class="string">'Z'</span>,</span><br><span class="line">                <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>, <span class="string">'m'</span>,</span><br><span class="line">                <span class="string">'n'</span>, <span class="string">'o'</span>, <span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>, <span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>, <span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>,</span><br><span class="line">                <span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span></span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toBase62</span><span class="params">(<span class="type">int</span> number)</span> {</span><br><span class="line">            <span class="keyword">if</span> (number == <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">return</span> String.valueOf(toBase62[<span class="number">0</span>]);</span><br><span class="line">            }</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">while</span> (number &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> number % <span class="number">62</span>;</span><br><span class="line">                sb.append(toBase62[r]);</span><br><span class="line">                number = number / <span class="number">62</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; longToShort = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; shortToLong = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SHORT_PREFIX</span> <span class="operator">=</span> <span class="string">"http://tinyurl.com/"</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String longUrl)</span> {</span><br><span class="line">            <span class="type">String</span> <span class="variable">shortUrl</span> <span class="operator">=</span> longToShort.get(longUrl);</span><br><span class="line">            <span class="keyword">if</span> (shortUrl != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> shortUrl;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 生成短网址</span></span><br><span class="line">            shortUrl = SHORT_PREFIX + id;</span><br><span class="line">            longToShort.put(longUrl, shortUrl);</span><br><span class="line">            shortToLong.put(shortUrl, longUrl);</span><br><span class="line">            id++;</span><br><span class="line">            <span class="keyword">return</span> shortUrl;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">decode</span><span class="params">(String shortUrl)</span> {</span><br><span class="line">            <span class="keyword">return</span> shortToLong.get(shortUrl);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CodecHashCode</span> {</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; longToShort = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; shortToLong = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SHORT_PREFIX</span> <span class="operator">=</span> <span class="string">"http://tinyurl.com/"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String longUrl)</span> {</span><br><span class="line">            <span class="type">String</span> <span class="variable">shortUrl</span> <span class="operator">=</span> longToShort.get(longUrl);</span><br><span class="line">            <span class="keyword">if</span> (shortUrl != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> shortUrl;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 生成短网址</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> longUrl.hashCode(); <span class="comment">// int</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                shortUrl = SHORT_PREFIX + id;</span><br><span class="line">                <span class="keyword">if</span> (!shortToLong.containsKey(shortUrl)) {</span><br><span class="line">                    longToShort.put(longUrl, shortUrl);</span><br><span class="line">                    shortToLong.put(shortUrl, longUrl);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                id++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> shortUrl;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">decode</span><span class="params">(String shortUrl)</span> {</span><br><span class="line">            <span class="keyword">return</span> shortToLong.get(shortUrl);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CodecRandom</span> {</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; longToShort = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; shortToLong = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SHORT_PREFIX</span> <span class="operator">=</span> <span class="string">"http://tinyurl.com/"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String longUrl)</span> {</span><br><span class="line">            <span class="type">String</span> <span class="variable">shortUrl</span> <span class="operator">=</span> longToShort.get(longUrl);</span><br><span class="line">            <span class="keyword">if</span> (shortUrl != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> shortUrl;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 生成短网址</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt();<span class="comment">// 1</span></span><br><span class="line">                shortUrl = SHORT_PREFIX + id;</span><br><span class="line">                <span class="keyword">if</span> (!shortToLong.containsKey(shortUrl)) {</span><br><span class="line">                    longToShort.put(longUrl, shortUrl);</span><br><span class="line">                    shortToLong.put(shortUrl, longUrl);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> shortUrl;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">decode</span><span class="params">(String shortUrl)</span> {</span><br><span class="line">            <span class="keyword">return</span> shortToLong.get(shortUrl);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="设计-twitter-leetcode-355">设计 Twitter-Leetcode 355</h3><p>线性合并</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Twitter2</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Tweet</span> {</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        <span class="type">int</span> time;</span><br><span class="line">        Tweet next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Tweet</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> time, Tweet next)</span> {</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.time = time;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">time</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> time;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line">        Integer id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(Integer id)</span> {</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; followees = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Tweet</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tweet</span>(-<span class="number">1</span>, -<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, User&gt; userMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, User&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postTweet</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> tweetId)</span> {</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMap.computeIfAbsent(userId, User::<span class="keyword">new</span>);</span><br><span class="line">        user.head.next = <span class="keyword">new</span> <span class="title class_">Tweet</span>(tweetId, time++, user.head.next);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getNewsFeed</span><span class="params">(<span class="type">int</span> userId)</span> {</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMap.get(userId);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> List.of();</span><br><span class="line">        }</span><br><span class="line">        <span class="type">Tweet</span> <span class="variable">p1</span> <span class="operator">=</span> user.head.next;</span><br><span class="line">        <span class="keyword">for</span> (Integer id : user.followees) {</span><br><span class="line">            p1 = merge(p1, userMap.get(id).head.next);</span><br><span class="line">        }</span><br><span class="line">        LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; count &lt; <span class="number">10</span>) {</span><br><span class="line">            result.addLast(p1.id);</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Tweet <span class="title function_">merge</span><span class="params">(Tweet p1, Tweet p2)</span> {</span><br><span class="line">        <span class="type">Tweet</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tweet</span>(-<span class="number">1</span>, -<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">Tweet</span> <span class="variable">p0</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span> &amp;&amp; count &lt; <span class="number">10</span>) {</span><br><span class="line">            <span class="keyword">if</span> (p1.time &gt; p2.time) {</span><br><span class="line">                p0.next = <span class="keyword">new</span> <span class="title class_">Tweet</span>(p1.id, p1.time, <span class="literal">null</span>);</span><br><span class="line">                p0 = p0.next;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                p0.next = <span class="keyword">new</span> <span class="title class_">Tweet</span>(p2.id, p2.time, <span class="literal">null</span>);</span><br><span class="line">                p0 = p0.next;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            }</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; count &lt; <span class="number">10</span>) {</span><br><span class="line">            p0.next = <span class="keyword">new</span> <span class="title class_">Tweet</span>(p1.id, p1.time, <span class="literal">null</span>);</span><br><span class="line">            p0 = p0.next;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="literal">null</span> &amp;&amp; count &lt; <span class="number">10</span>) {</span><br><span class="line">            p0.next = <span class="keyword">new</span> <span class="title class_">Tweet</span>(p2.id, p2.time, <span class="literal">null</span>);</span><br><span class="line">            p0 = p0.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">follow</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> followeeId)</span> {</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMap.computeIfAbsent(userId, User::<span class="keyword">new</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">followee</span> <span class="operator">=</span> userMap.computeIfAbsent(followeeId, User::<span class="keyword">new</span>);</span><br><span class="line">        user.followees.add(followeeId);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unfollow</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> followeeId)</span> {</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMap.get(userId);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) {</span><br><span class="line">            user.followees.remove(followeeId);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>优先级队列合并</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwitterLeetcode355</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Twitter</span> {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Tweet</span> {</span><br><span class="line">            <span class="type">int</span> id;</span><br><span class="line">            <span class="type">int</span> time;</span><br><span class="line">            Tweet next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Tweet</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> time, Tweet next)</span> {</span><br><span class="line">                <span class="built_in">this</span>.id = id;</span><br><span class="line">                <span class="built_in">this</span>.time = time;</span><br><span class="line">                <span class="built_in">this</span>.next = next;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> id;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTime</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">return</span> time;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line">            <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id)</span> {</span><br><span class="line">                <span class="built_in">this</span>.id = id;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Set&lt;Integer&gt; followees = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            <span class="type">Tweet</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tweet</span>(-<span class="number">1</span>, -<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, User&gt; userMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> time;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布文章</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postTweet</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> tweetId)</span> {</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMap.computeIfAbsent(userId, User::<span class="keyword">new</span>);</span><br><span class="line">            user.head.next = <span class="keyword">new</span> <span class="title class_">Tweet</span>(tweetId, time++, user.head.next);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新增关注</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">follow</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> followeeId)</span> {</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMap.computeIfAbsent(userId, User::<span class="keyword">new</span>);</span><br><span class="line">            <span class="type">User</span> <span class="variable">followee</span> <span class="operator">=</span> userMap.computeIfAbsent(followeeId, User::<span class="keyword">new</span>);</span><br><span class="line">            user.followees.add(followee.id);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消关注</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unfollow</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> followeeId)</span> {</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMap.get(userId);</span><br><span class="line">            <span class="keyword">if</span> (user != <span class="literal">null</span>) {</span><br><span class="line">                user.followees.remove(followeeId);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取最新10篇文章（包括自己和关注用户）</span></span><br><span class="line">        <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getNewsFeed</span><span class="params">(<span class="type">int</span> userId)</span> {</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMap.get(userId);</span><br><span class="line">            <span class="keyword">if</span> (user == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> List.of();</span><br><span class="line">            }</span><br><span class="line">            PriorityQueue&lt;Tweet&gt; queue</span><br><span class="line">                    = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(Tweet::getTime).reversed());</span><br><span class="line">            <span class="keyword">if</span>(user.head.next != <span class="literal">null</span>) {</span><br><span class="line">                queue.offer(user.head.next);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (Integer id : user.followees) {</span><br><span class="line">                <span class="type">User</span> <span class="variable">followee</span> <span class="operator">=</span> userMap.get(id);</span><br><span class="line">                <span class="keyword">if</span>(followee.head.next != <span class="literal">null</span>) {</span><br><span class="line">                    queue.offer(followee.head.next);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; count &lt; <span class="number">10</span>) {</span><br><span class="line">                <span class="type">Tweet</span> <span class="variable">max</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                res.add(max.id);</span><br><span class="line">                <span class="keyword">if</span> (max.next != <span class="literal">null</span>) {</span><br><span class="line">                    queue.offer(max.next);</span><br><span class="line">                }</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="股票问题">4.10 股票问题</h2><h3 id="leetcode-121">Leetcode 121</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharesI</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; prices.length) {</span><br><span class="line">            <span class="keyword">if</span> (prices[j] - prices[i] &gt; <span class="number">0</span>) {</span><br><span class="line">                max = Math.max(max, prices[j] - prices[i]);</span><br><span class="line">                j++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                i = j;</span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(maxProfit(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">9</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">11</span>}));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="leetcode-122">Leetcode 122</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharesIILeetcode122</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; prices.length) {</span><br><span class="line">            <span class="keyword">if</span> (prices[j] - prices[i] &gt; <span class="number">0</span>) { <span class="comment">// 有利润</span></span><br><span class="line">                max += prices[j] - prices[i];</span><br><span class="line">            }</span><br><span class="line">            i = j;</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(maxProfit(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">9</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>})); <span class="comment">// 11</span></span><br><span class="line">        System.out.println(maxProfit(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>})); <span class="comment">// 7</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="leetcode-714">Leetcode 714</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharesLeetcode714</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        0       1           2           3           4       5</span></span><br><span class="line"><span class="comment">        1       3           2           8           4       9</span></span><br><span class="line"><span class="comment"> 买     -1     等-1 √       等-1 √       等-1 √      -1       等1 √</span></span><br><span class="line"><span class="comment">               买-3         买-2        买-8        买1 √     买-4</span></span><br><span class="line"><span class="comment"> 卖     0      等0  √        等0  √      等0          等5 √    等5</span></span><br><span class="line"><span class="comment">               卖0          卖-1         卖5 √        卖1     卖8 √</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">b1</span> <span class="operator">=</span> -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">s0</span> <span class="operator">=</span> Math.max(s1, b1 + prices[i] - fee);</span><br><span class="line">            <span class="type">int</span> <span class="variable">b0</span> <span class="operator">=</span> Math.max(b1, s1 - prices[i]);</span><br><span class="line">            s1 = s0;</span><br><span class="line">            b1 = b0;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(maxProfit(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>}, <span class="number">2</span>)); <span class="comment">// 8</span></span><br><span class="line">        System.out.println(maxProfit(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">18</span>, <span class="number">3</span>}, <span class="number">3</span>)); <span class="comment">// 16</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">        System.out.println(maxProfit(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">3</span>}, <span class="number">3</span>)); <span class="comment">// 6</span></span><br><span class="line">        System.out.println(maxProfit(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">3</span>}, <span class="number">3</span>)); <span class="comment">// 7</span></span><br><span class="line">        System.out.println(maxProfit(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>}, <span class="number">1</span>)); <span class="comment">// 4</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>降维</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> {</span><br><span class="line">    <span class="comment">// _buy _sell 代表上一次 buy sell 代表这一次</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">_buy</span> <span class="operator">=</span> -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">_sell</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">buy</span> <span class="operator">=</span> Math.max(_buy, _sell - prices[i]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sell</span> <span class="operator">=</span> Math.max(_sell, _buy + prices[i] - fee);</span><br><span class="line">        _buy = buy;</span><br><span class="line">        _sell = sell;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> _sell;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>结构优化（非性能）</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">buy</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sell</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> price : prices) {</span><br><span class="line">        buy = Math.max(buy, sell - price);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            若 max 是 上次 buy，那么显然用这次 buy 是一样的</span></span><br><span class="line"><span class="comment">            若 max 是 上次 sell - prices[i], 则</span></span><br><span class="line"><span class="comment">                Math.max(sell, sell - prices[i] + prices[i] - fee);</span></span><br><span class="line"><span class="comment">                ==&gt;</span></span><br><span class="line"><span class="comment">                Math.max(sell, sell - fee);</span></span><br><span class="line"><span class="comment">                显然后面的式子不可能比上次 sell 更大，此时新的 sell 只由上次 sell 决定，与 上次 buy 无关</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        sell = Math.max(sell, buy + price - fee);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sell;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol type="1"><li>在计算这次的 sell 时，用这次的 buy 代替上次buy（证明见上方注释）</li><li>设置 buy 的初始值为最小，可以让循环统一从 0 开始</li></ol><h3 id="leetcode-309">Leetcode 309</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharesLeetcode309</span> {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        0       1           2           3           4</span></span><br><span class="line"><span class="comment">        1       2           3           0           2</span></span><br><span class="line"><span class="comment"> 买     -1      -2          -3          1√          0</span></span><br><span class="line"><span class="comment"> 等             -1√         -1√         -1          1√</span></span><br><span class="line"><span class="comment"> 卖     0       1√          2√          -1          3√</span></span><br><span class="line"><span class="comment"> 等             0           1           2√          2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> {</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[] buy = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length];</span><br><span class="line">        <span class="type">int</span>[] sell = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length];</span><br><span class="line">        buy[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        sell[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        buy[<span class="number">1</span>] = Math.max(-prices[<span class="number">0</span>], -prices[<span class="number">1</span>]);</span><br><span class="line">        sell[<span class="number">1</span>] = Math.max(sell[<span class="number">0</span>], buy[<span class="number">0</span>] + prices[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; prices.length; i++) {</span><br><span class="line">            buy[i] = Math.max(buy[i - <span class="number">1</span>], sell[i - <span class="number">2</span>] - prices[i]);</span><br><span class="line">            sell[i] = Math.max(sell[i - <span class="number">1</span>], buy[i - <span class="number">1</span>] + prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sell[prices.length - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(maxProfit(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>})); <span class="comment">// 3</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>降维</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> {</span><br><span class="line">    <span class="keyword">if</span> (prices.length == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="variable">__sell</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">_sell</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">_buy</span> <span class="operator">=</span> -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">buy</span> <span class="operator">=</span> Math.max(_buy, __sell - prices[i]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sell</span> <span class="operator">=</span> Math.max(_sell, prices[i] + _buy);</span><br><span class="line">        _buy = buy;</span><br><span class="line">        __sell = _sell;</span><br><span class="line">        _sell = sell;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> _sell;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="leetcode-123">Leetcode 123</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharesIIILeetcode123</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">buy1</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sell1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">buy2</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sell2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price : prices) {</span><br><span class="line">            buy1 = Math.max(buy1, -price);</span><br><span class="line">            sell1 = Math.max(sell1, buy1 + price);</span><br><span class="line">            buy2 = Math.max(buy2, sell1 - price);</span><br><span class="line">            sell2 = Math.max(sell2, buy2 + price);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sell2;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(maxProfit(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>})); <span class="comment">// 6</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="leetcode-188">Leetcode 188</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharesLeetcode188</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; prices.length) {</span><br><span class="line">            <span class="keyword">if</span> (prices[j] - prices[i] &gt; <span class="number">0</span>) { <span class="comment">// 有利润</span></span><br><span class="line">                sum += prices[j] - prices[i];</span><br><span class="line">            }</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> {</span><br><span class="line">        <span class="keyword">if</span> (k &gt; prices.length / <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> maxProfit(prices);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[] buy = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span>[] sell = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        Arrays.fill(buy, Integer.MIN_VALUE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price : prices) {</span><br><span class="line">            buy[<span class="number">0</span>] = Math.max(buy[<span class="number">0</span>], -price);</span><br><span class="line">            sell[<span class="number">0</span>] = Math.max(sell[<span class="number">0</span>], buy[<span class="number">0</span>] + price);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; k; j++) {</span><br><span class="line">                buy[j] = Math.max(buy[j], sell[j - <span class="number">1</span>] - price);</span><br><span class="line">                sell[j] = Math.max(sell[j], buy[j] + price);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sell[k - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="comment">//        System.out.println(maxProfit(2, new int[]{3, 2, 6, 5, 0, 3})); // 7</span></span><br><span class="line">        System.out.println(maxProfit(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>})); <span class="comment">// 6</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>对于天数 n = 6，最多进行 3 次交易，如果此时 k &gt;3，意味着不限次交易</p></li><li><p>对于天数 n = 7，最多进行 3 次交易，如果此时 k &gt;3，意味着不限次交易</p></li></ul><h1 id="附录">附录</h1><h2 id="参考文章">参考文章</h2><p>注：以上内容来自网络资源，仅出于分享目的，若侵权请联系删除。</p><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="https://www.merriam-webster.com/dictionary/algorithm">"Definitionof ALGORITHM"</a>. <em>Merriam-Webster Online Dictionary</em>. <a href="https://web.archive.org/web/20200214074446/https://www.merriam-webster.com/dictionary/algorithm">Archived</a>from the original on February 14, 2020. Retrieved November 14, 2019.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p>Introduction to Algorithm 中文译作《算法导论》<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p>Introduction to Algorithm 中文译作《算法导论》<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p>主要参考文档https://en.wikipedia.org/wiki/Binary_search_algorithm<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn5"><p>图片及概念均摘自 Introduction to Algorithm4th，3.1节，3.2 节<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn6"><p>jdk 版本有关，64 位 jdk，按 8 字节对齐<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn7"><p>图片引用自 wikipedia linkedlist条目，https://en.wikipedia.org/wiki/Linked_list<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn8"><p>龟兔赛跑动画来自于 <a href="https://onestepcode.com/floyd-hare-tortoise-algorithm-demo/">Floyd'sHare and Tortoise Algorithm Demo - One Step! Code(onestepcode.com)</a><a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn9"><p>Josephus problem 主要参考https://en.wikipedia.org/wiki/Josephus_problem<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn10"><p>Fibonacci介绍：https://en.wikipedia.org/wiki/Fibonacci_number<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn11"><p><a href="https://zhuanlan.zhihu.com/p/165877869">几种计算Fibonacci数列算法的时间复杂度比较- 知乎 (zhihu.com)</a><a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn12"><p>几种斐波那契数列算法比较 <a href="https://www.nayuki.io/page/fast-fibonacci-algorithms">FastFibonacci algorithms (nayuki.io)</a><a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn13"><p>Fibonacci介绍：https://en.wikipedia.org/wiki/Fibonacci_number<a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn14"><p>汉诺塔图片资料均来自https://en.wikipedia.org/wiki/Tower_of_Hanoi<a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn15"><p>也称为 Pascal's trianglehttps://en.wikipedia.org/wiki/Pascal%27s_triangle<a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn16"><p>我知道的有 C++，Scala<a href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn17"><p>与主定理类似的还有 Akra–Bazzimethod，https://en.wikipedia.org/wiki/Akra%E2%80%93Bazzi_method<a href="#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn18"><p>KMP 算法中 next 数组的说明 <a href="https://www.cnblogs.com/tangzhengyue/p/4315393.html">KMP算法的Next数组详解- 唐小喵 - 博客园 (cnblogs.com)</a><a href="#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三节 三重积分</title>
      <link href="/2024/03/25/duo-yuan-wei-ji-fen-10-3-san-chong-ji-fen/"/>
      <url>/2024/03/25/duo-yuan-wei-ji-fen-10-3-san-chong-ji-fen/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/i3ucW1sjrjhc">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分10-3三重积分/123.jpg" alt="123.jpg"><figcaption aria-hidden="true">123.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分10-3三重积分/124.jpg" alt="124.jpg"><figcaption aria-hidden="true">124.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分10-3三重积分/125.jpg" alt="125.jpg"><figcaption aria-hidden="true">125.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分10-3三重积分/126.jpg" alt="126.jpg"><figcaption aria-hidden="true">126.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分10-3三重积分/127.jpg" alt="127.jpg"><figcaption aria-hidden="true">127.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分10-3三重积分/128.jpg" alt="128.jpg"><figcaption aria-hidden="true">128.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分10-3三重积分/129.jpg" alt="129.jpg"><figcaption aria-hidden="true">129.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分10-3三重积分/130.jpg" alt="130.jpg"><figcaption aria-hidden="true">130.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十章 重积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三重积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四节 重积分的应用</title>
      <link href="/2024/03/25/duo-yuan-wei-ji-fen-10-4-chong-ji-fen-de-ying-yong/"/>
      <url>/2024/03/25/duo-yuan-wei-ji-fen-10-4-chong-ji-fen-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iWMgk1sjtepc">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分10-4重积分的应用/131.jpg" alt="131.jpg"><figcaption aria-hidden="true">131.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分10-4重积分的应用/132.jpg" alt="132.jpg"><figcaption aria-hidden="true">132.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分10-4重积分的应用/133.jpg" alt="133.jpg"><figcaption aria-hidden="true">133.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分10-4重积分的应用/134.jpg" alt="134.jpg"><figcaption aria-hidden="true">134.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分10-4重积分的应用/135.jpg" alt="135.jpg"><figcaption aria-hidden="true">135.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分10-4重积分的应用/136.jpg" alt="136.jpg"><figcaption aria-hidden="true">136.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十章 重积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多重积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT Deep Learning Bootcamp_ Phillip Isola</title>
      <link href="/2024/03/24/mit-deep-learning-bootcamp-phillip-isola/"/>
      <url>/2024/03/24/mit-deep-learning-bootcamp-phillip-isola/</url>
      
        <content type="html"><![CDATA[<h1 id="deep-learning-bootcamp_-phillip-isola">Deep Learning Bootcamp_Phillip Isola</h1><p>MIT Deep Learning Bootcamp，上半场为PhillipIsola主讲，下半场为KaimingHe主讲。目前只大概校准了前30分钟的翻译，后面的翻译还在制作当中。</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=1952115963&amp;bvid=BV1LC41187hj&amp;cid=1481029257&amp;p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 深度学习简介 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 什么是深度学习 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六节 空间曲线及其方程</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-8-6-kong-jian-qu-xian-ji-qi-fang-cheng/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-8-6-kong-jian-qu-xian-ji-qi-fang-cheng/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/i8VrV1sim23a">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分8-6空间曲线及其方程/30.jpg" alt="30.jpg"><figcaption aria-hidden="true">30.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-6空间曲线及其方程/31.jpg" alt="31.jpg"><figcaption aria-hidden="true">31.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-6空间曲线及其方程/32.jpg" alt="32.jpg"><figcaption aria-hidden="true">32.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-6空间曲线及其方程/33.jpg" alt="33.jpg"><figcaption aria-hidden="true">33.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-6空间曲线及其方程/34.jpg" alt="34.jpg"><figcaption aria-hidden="true">34.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第八章 向量代数与空间解析几何 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 空间曲线方程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四节 空间直线及其方程</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-8-4-kong-jian-zhi-xian-ji-qi-fang-cheng/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-8-4-kong-jian-zhi-xian-ji-qi-fang-cheng/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/ii9JG1sikwxi">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分8-4空间直线及其方程/17.jpg" alt="17.jpg"><figcaption aria-hidden="true">17.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-4空间直线及其方程/18.jpg" alt="18.jpg"><figcaption aria-hidden="true">18.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-4空间直线及其方程/19.jpg" alt="19.jpg"><figcaption aria-hidden="true">19.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-4空间直线及其方程/20.jpg" alt="20.jpg"><figcaption aria-hidden="true">20.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-4空间直线及其方程/21.jpg" alt="21.jpg"><figcaption aria-hidden="true">21.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-4空间直线及其方程/22.jpg" alt="22.jpg"><figcaption aria-hidden="true">22.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第八章 向量代数与空间解析几何 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 空间直线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五节 曲面及其方程</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-8-5-qu-mian-ji-qi-fang-cheng/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-8-5-qu-mian-ji-qi-fang-cheng/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iHag01silrne">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分8-5曲面及其方程/23.jpg" alt="23.jpg"><figcaption aria-hidden="true">23.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-5曲面及其方程/24.jpg" alt="24.jpg"><figcaption aria-hidden="true">24.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-5曲面及其方程/25.jpg" alt="25.jpg"><figcaption aria-hidden="true">25.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-5曲面及其方程/26.jpg" alt="26.jpg"><figcaption aria-hidden="true">26.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-5曲面及其方程/27.jpg" alt="27.jpg"><figcaption aria-hidden="true">27.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-5曲面及其方程/28.jpg" alt="28.jpg"><figcaption aria-hidden="true">28.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-5曲面及其方程/29.jpg" alt="29.jpg"><figcaption aria-hidden="true">29.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第八章 向量代数与空间解析几何 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 曲面方程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二节 数量积 向量积 混合积</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-8-2-shu-liang-ji-xiang-liang-ji-hun-he-ji/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-8-2-shu-liang-ji-xiang-liang-ji-hun-he-ji/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iMNku1sifsmd">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分8-2数量积-向量积-混合积/8.jpg" alt="8.jpg"><figcaption aria-hidden="true">8.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-2数量积-向量积-混合积/9.jpg" alt="9.jpg"><figcaption aria-hidden="true">9.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-2数量积-向量积-混合积/10.jpg" alt="10.jpg"><figcaption aria-hidden="true">10.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-2数量积-向量积-混合积/11.jpg" alt="11.jpg"><figcaption aria-hidden="true">11.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-2数量积-向量积-混合积/12.jpg" alt="12.jpg"><figcaption aria-hidden="true">12.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第八章 向量代数与空间解析几何 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数量积 </tag>
            
            <tag> 向量积 </tag>
            
            <tag> 混合积 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三节 平面及其方程</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-8-3-ping-mian-ji-qi-fang-cheng/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-8-3-ping-mian-ji-qi-fang-cheng/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iTTwt1siju6d">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分8-3平面及其方程/13.jpg" alt="13.jpg"><figcaption aria-hidden="true">13.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-3平面及其方程/14.jpg" alt="14.jpg"><figcaption aria-hidden="true">14.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-3平面及其方程/15.jpg" alt="15.jpg"><figcaption aria-hidden="true">15.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分8-3平面及其方程/16.jpg" alt="16.jpg"><figcaption aria-hidden="true">16.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第八章 向量代数与空间解析几何 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 平面方程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三节 全微分</title>
      <link href="/2024/03/24/duo-yuan-han-shu-quan-wei-fen/"/>
      <url>/2024/03/24/duo-yuan-han-shu-quan-wei-fen/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/i3HEa1si7b1c">下载PDF点这里</a></p><figure><img src="../../../../images/多元函数全微分/52.jpg" alt="52.jpg"><figcaption aria-hidden="true">52.jpg</figcaption></figure><figure><img src="../../../../images/多元函数全微分/53.jpg" alt="53.jpg"><figcaption aria-hidden="true">53.jpg</figcaption></figure><figure><img src="../../../../images/多元函数全微分/54.jpg" alt="54.jpg"><figcaption aria-hidden="true">54.jpg</figcaption></figure><figure><img src="../../../../images/多元函数全微分/55.jpg" alt="55.jpg"><figcaption aria-hidden="true">55.jpg</figcaption></figure><figure><img src="../../../../images/多元函数全微分/56.jpg" alt="56.jpg"><figcaption aria-hidden="true">56.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第九章 多元函数微分法及其应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 全微分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一节 向量及其线性运算</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-8-1-xiang-liang-ji-qi-xian-xing-yun-suan/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-8-1-xiang-liang-ji-qi-xian-xing-yun-suan/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/ifa1T1siexkf">下载PDF点这里</a></p><figure><img src="../../../../images/8-1向量及其线性运算/4.jpg" alt="4.jpg"><figcaption aria-hidden="true">4.jpg</figcaption></figure><figure><img src="../../../../images/8-1向量及其线性运算/5.jpg" alt="5.jpg"><figcaption aria-hidden="true">5.jpg</figcaption></figure><figure><img src="../../../../images/8-1向量及其线性运算/6.jpg" alt="6.jpg"><figcaption aria-hidden="true">6.jpg</figcaption></figure><figure><img src="../../../../images/8-1向量及其线性运算/7.jpg" alt="7.jpg"><figcaption aria-hidden="true">7.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第八章 向量代数与空间解析几何 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 向量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六节 多元函数微分学的几何应用</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-duo-yuan-han-shu-wei-fen-xue-de-ji-he-ying-yong/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-duo-yuan-han-shu-wei-fen-xue-de-ji-he-ying-yong/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/ixMOv1si9tgh">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分多元函数微分学的几何应用/71.jpg" alt="71.jpg"><figcaption aria-hidden="true">71.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数微分学的几何应用/72.jpg" alt="72.jpg"><figcaption aria-hidden="true">72.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数微分学的几何应用/73.jpg" alt="73.jpg"><figcaption aria-hidden="true">73.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数微分学的几何应用/74.jpg" alt="74.jpg"><figcaption aria-hidden="true">74.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数微分学的几何应用/75.jpg" alt="75.jpg"><figcaption aria-hidden="true">75.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数微分学的几何应用/76.jpg" alt="76.jpg"><figcaption aria-hidden="true">76.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数微分学的几何应用/77.jpg" alt="77.jpg"><figcaption aria-hidden="true">77.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数微分学的几何应用/78.jpg" alt="78.jpg"><figcaption aria-hidden="true">78.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数微分学的几何应用/79.jpg" alt="79.jpg"><figcaption aria-hidden="true">79.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数微分学的几何应用/80.jpg" alt="80.jpg"><figcaption aria-hidden="true">80.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第九章 多元函数微分法及其应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多元函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四节 多元复合函数的求导法则</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-duo-yuan-fu-he-han-shu-de-qiu-dao-fa-ze/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-duo-yuan-fu-he-han-shu-de-qiu-dao-fa-ze/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/i5lYU1si86if">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分多元复合函数的求导法则/57.jpg" alt="57.jpg"><figcaption aria-hidden="true">57.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元复合函数的求导法则/58.jpg" alt="58.jpg"><figcaption aria-hidden="true">58.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元复合函数的求导法则/59.jpg" alt="59.jpg"><figcaption aria-hidden="true">59.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元复合函数的求导法则/60.jpg" alt="60.jpg"><figcaption aria-hidden="true">60.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元复合函数的求导法则/61.jpg" alt="61.jpg"><figcaption aria-hidden="true">61.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元复合函数的求导法则/62.jpg" alt="62.jpg"><figcaption aria-hidden="true">62.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元复合函数的求导法则/63.jpg" alt="63.jpg"><figcaption aria-hidden="true">63.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第九章 多元函数微分法及其应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复合函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八节 多元函数的极值及其求法</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-duo-yuan-han-shu-de-ji-zhi-ji-qi-qiu-fa/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-duo-yuan-han-shu-de-ji-zhi-ji-qi-qiu-fa/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/ieDhy1sibm9a">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分多元函数的极值及其求法/88.jpg" alt="88.jpg"><figcaption aria-hidden="true">88.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数的极值及其求法/89.jpg" alt="89.jpg"><figcaption aria-hidden="true">89.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数的极值及其求法/90.jpg" alt="90.jpg"><figcaption aria-hidden="true">90.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数的极值及其求法/91.jpg" alt="91.jpg"><figcaption aria-hidden="true">91.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数的极值及其求法/92.jpg" alt="92.jpg"><figcaption aria-hidden="true">92.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数的极值及其求法/93.jpg" alt="93.jpg"><figcaption aria-hidden="true">93.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分多元函数的极值及其求法/94.jpg" alt="94.jpg"><figcaption aria-hidden="true">94.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第九章 多元函数微分法及其应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多元函数的极值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七节 方向导数与梯度</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-fang-xiang-dao-shu-yu-ti-du/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-fang-xiang-dao-shu-yu-ti-du/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iAKOX1siaqaj">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分方向导数与梯度/81.jpg" alt="81.jpg"><figcaption aria-hidden="true">81.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分方向导数与梯度/82.jpg" alt="82.jpg"><figcaption aria-hidden="true">82.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分方向导数与梯度/83.jpg" alt="83.jpg"><figcaption aria-hidden="true">83.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分方向导数与梯度/84.jpg" alt="84.jpg"><figcaption aria-hidden="true">84.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分方向导数与梯度/85.jpg" alt="85.jpg"><figcaption aria-hidden="true">85.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分方向导数与梯度/86.jpg" alt="86.jpg"><figcaption aria-hidden="true">86.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分方向导数与梯度/87.jpg" alt="87.jpg"><figcaption aria-hidden="true">87.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第九章 多元函数微分法及其应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方向导数 </tag>
            
            <tag> 梯度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五节 隐函数的求导公式</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-yin-han-shu-de-qiu-dao-gong-shi/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-yin-han-shu-de-qiu-dao-gong-shi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/imvmj1si8o8d">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分隐函数的求导公式/64.jpg" alt="64.jpg"><figcaption aria-hidden="true">64.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分隐函数的求导公式/65.jpg" alt="65.jpg"><figcaption aria-hidden="true">65.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分隐函数的求导公式/66.jpg" alt="66.jpg"><figcaption aria-hidden="true">66.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分隐函数的求导公式/67.jpg" alt="67.jpg"><figcaption aria-hidden="true">67.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分隐函数的求导公式/68.jpg" alt="68.jpg"><figcaption aria-hidden="true">68.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分隐函数的求导公式/69.jpg" alt="69.jpg"><figcaption aria-hidden="true">69.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分隐函数的求导公式/70.jpg" alt="70.jpg"><figcaption aria-hidden="true">70.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第九章 多元函数微分法及其应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二节 二重积分的计算方法</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-er-chong-ji-fen-de-ji-suan-fang-fa/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-er-chong-ji-fen-de-ji-suan-fang-fa/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/inVBC1sgdp3c">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分二重积分的计算方法/109.jpg" alt="109.jpg"><figcaption aria-hidden="true">109.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/110.jpg" alt="110.jpg"><figcaption aria-hidden="true">110.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/111.jpg" alt="111.jpg"><figcaption aria-hidden="true">111.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/112.jpg" alt="112.jpg"><figcaption aria-hidden="true">112.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/113.jpg" alt="113.jpg"><figcaption aria-hidden="true">113.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/114.jpg" alt="114.jpg"><figcaption aria-hidden="true">114.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/115.jpg" alt="115.jpg"><figcaption aria-hidden="true">115.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/116.jpg" alt="116.jpg"><figcaption aria-hidden="true">116.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/117.jpg" alt="117.jpg"><figcaption aria-hidden="true">117.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/118.jpg" alt="118.jpg"><figcaption aria-hidden="true">118.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/119.jpg" alt="119.jpg"><figcaption aria-hidden="true">119.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/120.jpg" alt="120.jpg"><figcaption aria-hidden="true">120.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/121.jpg" alt="121.jpg"><figcaption aria-hidden="true">121.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的计算方法/122.jpg" alt="122.jpg"><figcaption aria-hidden="true">122.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十章 重积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二重积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一节 二重积分的概念与性质</title>
      <link href="/2024/03/24/duo-yuan-wei-ji-fen-er-chong-ji-fen-de-gai-nian-yu-xing-zhi/"/>
      <url>/2024/03/24/duo-yuan-wei-ji-fen-er-chong-ji-fen-de-gai-nian-yu-xing-zhi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iAUeM1sgbz3a">下载PDF点这里</a></p><figure><img src="../../../../images/多元微积分二重积分的概念与性质/p105.jpg" alt="p105.jpg"><figcaption aria-hidden="true">p105.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的概念与性质/p106.jpg" alt="p106.jpg"><figcaption aria-hidden="true">p106.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的概念与性质/p107.jpg" alt="p107.jpg"><figcaption aria-hidden="true">p107.jpg</figcaption></figure><figure><img src="../../../../images/多元微积分二重积分的概念与性质/p108.jpg" alt="p108.jpg"><figcaption aria-hidden="true">p108.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第十章 重积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二重积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>凸集和凸函数基础知识</title>
      <link href="/2024/03/20/zui-you-hua-fang-fa-tu-ji-he-tu-han-shu/"/>
      <url>/2024/03/20/zui-you-hua-fang-fa-tu-ji-he-tu-han-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="凸集和凸函数">凸集和凸函数</h1><p><strong>今天是春分，春分快乐~</strong></p><p>​ <span class="math inline">\(——\)</span>谁把春光，平分一半，最惜今朝。</p><h2 id="凸集">1. 凸集</h2><h3 id="凸集的定义">1.1 凸集的定义</h3><p>设集合 <span class="math inline">\(\boldsymbol{D} \subset\mathbb{R}^n\)</span> ，如果对于任意的 <span class="math inline">\(\boldsymbol{x}, \boldsymbol{y} \in\boldsymbol{D}\)</span> 与任意的 <span class="math inline">\(\alpha\in[0,1]\)</span>,有 <span class="math inline">\(\alpha\boldsymbol{x}+(1-\alpha) \boldsymbol{y} \in \boldsymbol{D}\)</span>，则称 <span class="math inline">\(\boldsymbol{D}\)</span> 是凸集（<span class="math inline">\(convex \quad set\)</span>）。</p><p>凸集的几何意义是：如果两个点属于此集合，则这两点连线上的任意一点均属于此集合。</p><hr><p>定义推广：<span class="math inline">\(\boldsymbol{D}\)</span>是凸集的充分必要条件是：</p><p>对任意<span class="math inline">\(\forall m \geqslant 2, \forall\boldsymbol{x}_1, \boldsymbol{x}_2, \cdots, \boldsymbol{x}_m \in\boldsymbol{D}, \forall \alpha_1, \alpha_2, \cdots, \alpha_m\)</span>，其中 <span class="math inline">\(\alpha_i \geqslant 0\)</span> <span class="math inline">\((i=1,2,\cdots,m)\)</span> 且 <span class="math inline">\(\sum_{i=1}^m \alpha_i = 1\)</span> ，均有： <span class="math display">\[\alpha_1 \boldsymbol{x}_1+\alpha_2 \boldsymbol{x}_2+\cdots+\alpha_m\boldsymbol{x}_m \in \boldsymbol{D}\]</span></p><h3 id="凸集的性质">1.2 凸集的性质</h3><p>设 <span class="math inline">\(\boldsymbol{D}_1, \boldsymbol{D}_2\subset \mathbb{R}^n\)</span> 是凸集， <span class="math inline">\(\alpha \in \mathbb{R}\)</span> ，则有：</p><ul><li><span class="math inline">\(\boldsymbol{D}_1 \cap\boldsymbol{D}_2=\left\{\boldsymbol{x} \mid \boldsymbol{x} \in\boldsymbol{D}_1, \boldsymbol{x} \in \boldsymbol{D}_2\right\}\)</span>是凸集。</li><li><span class="math inline">\(\alpha \boldsymbol{D}_1=\left\{\alpha\boldsymbol{x} \mid \boldsymbol{x} \in \boldsymbol{D}_1\right\}\)</span>是凸集。</li><li><span class="math inline">\(\boldsymbol{D}_1+\boldsymbol{D}_2=\left\{\boldsymbol{x}+\boldsymbol{y}\mid \boldsymbol{x} \in \boldsymbol{D}_1, \boldsymbol{y} \in\boldsymbol{D}_2\right\}\)</span> 是凸集。</li><li><span class="math inline">\(\boldsymbol{D}_1-\boldsymbol{D}_2=\left\{\boldsymbol{x}-\boldsymbol{y}\mid \boldsymbol{x} \in \boldsymbol{D}_1, \boldsymbol{y} \in\boldsymbol{D}_2\right\}\)</span> 是凸集。</li></ul><p>注意：这里要明确一点凸集的加减法和集合中的加减法完全是两件事情，比如说即使<span class="math inline">\(\boldsymbol{D}_1=\boldsymbol{D}_2\)</span>，那么 <span class="math inline">\(\boldsymbol{D}_1-\boldsymbol{D}_2\neq \varnothing\)</span> ，甚至结果的测度要比原来的 <span class="math inline">\(\boldsymbol{D}_1\)</span>更大。给出其中一个性质的证明有利于更好地理解凸集加减法的运算：</p><blockquote><p>证明：设 <span class="math inline">\(\boldsymbol{D}_1,\boldsymbol{D}_2 \subset \mathbb{R}^n\)</span> 是凸集，则 <span class="math inline">\(\boldsymbol{D}_1 +\boldsymbol{D}_2=\left\{\boldsymbol{x}+\boldsymbol{y} \mid\boldsymbol{x} \in \boldsymbol{D}_1, \boldsymbol{y} \in\boldsymbol{D}_2\right\}\)</span> 也是凸集。</p><p>不妨设：$_1 + _2 = $ ，任取 <span class="math inline">\(\boldsymbol{z}\in \boldsymbol{Z},\boldsymbol{z}'\in \boldsymbol{Z}\)</span> ，则有： <span class="math display">\[\boldsymbol{x} + \boldsymbol{y} = \boldsymbol{z},\boldsymbol{x}' +\boldsymbol{y}' = \boldsymbol{z}'\]</span> 其中 <span class="math inline">\(\boldsymbol{x},\boldsymbol{x}'\in \boldsymbol{D_1};\boldsymbol{y},\boldsymbol{y}' \in \boldsymbol{D_2}\)</span></p><p>所以对于任意 <span class="math inline">\(\alpha \in [0,1]\)</span>有：<span class="math inline">\(\alpha\boldsymbol{z} +(1-\alpha)\boldsymbol{z'} =\alpha(\boldsymbol{x}+\boldsymbol{y})+(1-\alpha)(\boldsymbol{x'}+\boldsymbol{y'})=\alpha\boldsymbol{x}+(1-\alpha)\boldsymbol{x'}+\alpha\boldsymbol{y}+(1-\alpha)\boldsymbol{y'}\)</span></p><p>而 <span class="math inline">\(\alpha\boldsymbol{x}+(1-\alpha)\boldsymbol{x'}\in\boldsymbol{D_1}\)</span> ， <span class="math inline">\(\alpha\boldsymbol{y}+(1-\alpha)\boldsymbol{y'}\in\boldsymbol{D_2}\)</span>。</p><p>所以：<span class="math inline">\(\alpha\boldsymbol{z}+(1-\alpha)\boldsymbol{z'}\in\boldsymbol{D_1} + \boldsymbol{D_2} = \boldsymbol{Z}\)</span> 。</p></blockquote><h3 id="内点边界闭包">1.3 内点、边界、闭包</h3><p>内点：给定 <span class="math inline">\(\boldsymbol{D} \subset\mathbb{R}^n, \boldsymbol{x} \in \mathbb{R}^n\)</span> 。若存在 <span class="math inline">\(\boldsymbol{x}\)</span> 的 <span class="math inline">\(\delta\)</span> 邻域 <span class="math inline">\(N_\delta(\boldsymbol{x})=\{\boldsymbol{y}\mid\|\boldsymbol{y}-\boldsymbol{x}\|&lt;\delta\} \subset\)</span> <span class="math inline">\(D\)</span> ，则称 <span class="math inline">\(x\)</span> 为 <span class="math inline">\(D\)</span> 的内点; 所有内点组合成的集合记为 <span class="math inline">\(i n t D\)</span> 。</p><p>边界：若 <span class="math inline">\(\boldsymbol{x}\)</span> 的任意<span class="math inline">\(\delta\)</span> 邻域 <span class="math inline">\(N_\delta(\boldsymbol{x}\)</span> )既包含 <span class="math inline">\(\boldsymbol{D}\)</span> 中的点, 又包含不属于 <span class="math inline">\(\boldsymbol{D}\)</span> 的点, 则称 <span class="math inline">\(x\)</span> 为 <span class="math inline">\(D\)</span> 的边界点; 所有边界点组成的集合记为<span class="math inline">\(\partial \boldsymbol{D}\)</span> 。</p><p>闭包：若对任意 <span class="math inline">\(\delta&gt;0\)</span> 均有<span class="math inline">\(N_\delta(\boldsymbol{x}) \cap \boldsymbol{D}\neq \varnothing\)</span>, 则称 <span class="math inline">\(\boldsymbol{x}\)</span> 属于集合的闭包, 记为 <span class="math inline">\(x \in c l D\)</span>​ 。</p><hr><p>根据以上定义可知，集合 <span class="math inline">\(\boldsymbol{D}\)</span> 的闭包 <span class="math inline">\(c \boldsymbol{D}=\boldsymbol{D} \cup \partial\boldsymbol{D}\)</span>, 它是包含集合 <span class="math inline">\(\boldsymbol{D}\)</span> 的最小的闭集。</p><h2 id="投影定理">2. 投影定理</h2><blockquote><p>设 <span class="math inline">\(\boldsymbol{D} \subset\mathbb{R}^n\)</span> 是非空闭凸集, <span class="math inline">\(\boldsymbol{y} \in \mathbb{R}^n\)</span> 且 <span class="math inline">\(\boldsymbol{y} \notin \boldsymbol{D}\)</span>, 则(1) 存在唯一的一点 <span class="math inline">\(\overline{\boldsymbol{x}}\in D\)</span>, 使得 <span class="math inline">\(\overline{\boldsymbol{x}} \in D\)</span> 是 <span class="math inline">\(\boldsymbol{y}\)</span> 到 <span class="math inline">\(D\)</span> 的距离最小的点（距离大于 0 ），即有 ：<span class="math display">\[\|\overline{\boldsymbol{x}}-\boldsymbol{y}\|=\min\{\|\boldsymbol{x}-\boldsymbol{y}\| \mid \boldsymbol{x} \in\boldsymbol{D}\}&gt;0\]</span> (2) <span class="math inline">\(\overline{\boldsymbol{x}} \in\boldsymbol{D}\)</span> 是 <span class="math inline">\(\boldsymbol{y}\)</span> 到 <span class="math inline">\(\boldsymbol{D}\)</span> 的距离最小的点的充要条件是<span class="math inline">\((\boldsymbol{x}-\overline{\boldsymbol{x}})^T(\overline{\boldsymbol{x}}-\boldsymbol{y})\geqslant\)</span> <span class="math inline">\(0, \forall \boldsymbol{x}\in \boldsymbol{D}\)</span></p></blockquote><h2 id="凸集的分离定理">3. 凸集的分离定理</h2><p>先回顾一下什么是超平面(Hyperplane)，超平面指的是比所处空间少一个维度的子空间。超平面<span class="math inline">\(H\)</span>的方程如下： <span class="math display">\[H=\left\{\boldsymbol{x} \in \mathbb{R}^n: \boldsymbol{u}^T\boldsymbol{x}=v\right\}\]</span> 也可以写成：在超平面<span class="math inline">\(H\)</span>内一点 <span class="math inline">\(\boldsymbol{a}\)</span> 和任一点 <span class="math inline">\(\boldsymbol{x}\)</span>。 <span class="math inline">\(\boldsymbol{u}\)</span> 为点 <span class="math inline">\(\boldsymbol{x}\)</span> 处的法向量，将满足 <span class="math inline">\(\boldsymbol{u^T}(\boldsymbol{x}-\boldsymbol{a})=0\)</span>​于是有： <span class="math display">\[H=\left\{\boldsymbol{x} \in \mathbb{R}^n\right. :\left.\boldsymbol{u^T}(\boldsymbol{x}-\boldsymbol{a})=0\right\}\]</span> 若 <span class="math inline">\(\boldsymbol{u}^T\boldsymbol{x}\geq v\)</span> 则表明点 <span class="math inline">\(\boldsymbol{x}\)</span> 在超平面<span class="math inline">\(H\)</span>的正面，若<span class="math inline">\(\boldsymbol{u}^T \boldsymbol{x}\leq v\)</span>则表明点 <span class="math inline">\(\boldsymbol{x}\)</span> 在超平面<span class="math inline">\(H\)</span> 的背面。</p><p>现在再给定两个集合 <span class="math inline">\(S_1\)</span> ，<span class="math inline">\(S_2\)</span>，</p><p>如果 <span class="math inline">\(\boldsymbol{u}^T\boldsymbol{x_1}\geq v\)</span> ，<span class="math inline">\(\forall\boldsymbol{x_1} \in S_1\)</span> ； <span class="math inline">\(\boldsymbol{u}^T \boldsymbol{x_1}\leq v\)</span>，<span class="math inline">\(\forall \boldsymbol{x_2} \in S_2\)</span>,则称 <span class="math inline">\(H\)</span> 分离 <span class="math inline">\(S_1\)</span> 和 <span class="math inline">\(S_2\)</span>。如下图所示：</p><figure><img src="../../../../images/最优化方法凸集和凸函数/p2.jpg" alt="p2.jpg"><figcaption aria-hidden="true">p2.jpg</figcaption></figure><p>图中超平面<span class="math inline">\(H\)</span>的式子为<span class="math inline">\(\boldsymbol{u}^T \boldsymbol{x_1}=v\)</span>，集合<span class="math inline">\(S_1\)</span>中的任意点代入方程后都在正面(或面上)，集合<span class="math inline">\(S_2\)</span>中的任意点代入方程后都在背面(或面上)，所以超平面<span class="math inline">\(H\)</span>分离开了集合<span class="math inline">\(S1\)</span>和<span class="math inline">\(S_2\)</span>。</p><h3 id="点和凸集的分离定理基本分离定理">3.1点和凸集的分离定理(基本分离定理)</h3><blockquote><p><code>定理</code>设 <span class="math inline">\(\boldsymbol{D}\subset \mathbb{R}^n\)</span> 是非空闭凸集, <span class="math inline">\(\boldsymbol{y} \in \mathbb{R}^n, \boldsymbol{y}\notin \boldsymbol{D}\)</span>, 则存在非零向量 <span class="math inline">\(\boldsymbol{\alpha} \in \mathbb{R}^n, \beta \in\mathbb{R}\)</span> 满足 <span class="math inline">\(\boldsymbol{\alpha}^{\boldsymbol{T}}\boldsymbol{x} \leqslant \beta&lt;\boldsymbol{\alpha}^{\boldsymbol{T}}\boldsymbol{y}, \forall \boldsymbol{x} \in \boldsymbol{D}\)</span></p></blockquote><p>这个定理表明如果在空间<span class="math inline">\(\mathbb{R}^n\)</span>内存在一个凸集<span class="math inline">\(\boldsymbol{D}\)</span>，凸集外有一点<span class="math inline">\(\boldsymbol{y}\)</span>，那么可以找到一个超平面<span class="math inline">\(\boldsymbol{\alpha}^{\boldsymbol{T}}\boldsymbol{x}=\beta\)</span> 将凸集<span class="math inline">\(\boldsymbol{D}\)</span>和点<span class="math inline">\(\boldsymbol{y}\)</span>分离开。</p><blockquote><p>证明思路:</p><p>利用投影定理，在凸集中找到距离点$ $ 最近的点 <span class="math inline">\(\overline{\boldsymbol{x}}\)</span>，然后做切平面(极限情况)，即可分离。</p></blockquote><blockquote><p><code>推论1</code>设 <span class="math inline">\(\boldsymbol{D}\subset \mathbb{R}^n\)</span> 是非空凸集, <span class="math inline">\(\boldsymbol{y} \in \partial\boldsymbol{D}\)</span>, 则存在非零向量 <span class="math inline">\(\boldsymbol{\alpha} \in \mathbb{R}^n\)</span> 满足<span class="math inline">\(\boldsymbol{\alpha}^T \boldsymbol{x}\leqslant \boldsymbol{\alpha}^T \boldsymbol{y}, \forall \boldsymbol{x}\in c l \boldsymbol{D}\)</span></p></blockquote><blockquote><p><code>推论2</code>设 <span class="math inline">\(\boldsymbol{D}\subset \mathbb{R}^n\)</span> 是非空凸集, <span class="math inline">\(\boldsymbol{y} \notin \boldsymbol{D}\)</span>,则存在非零向量 <span class="math inline">\(\boldsymbol{\alpha} \in\mathbb{R}^n\)</span> 满足 <span class="math inline">\(\boldsymbol{\alpha}^T x \leqslant\boldsymbol{\alpha}^T \boldsymbol{y}, \forall \boldsymbol{x}\in c l\boldsymbol{D}\)</span></p><p><span class="math inline">\(c l\)</span> 是闭包, <span class="math inline">\(\partial\)</span> 是边界。</p></blockquote><h3 id="支撑超平面定理">3.2 支撑超平面定理</h3><blockquote><p><code>定理</code>设 <span class="math inline">\(\boldsymbol{D}\subset \mathbb{R}^n\)</span> 是非空凸集, <span class="math inline">\(\overline{\boldsymbol{x}} \in \partial\boldsymbol{D}\)</span>, 则存在非零向量 <span class="math inline">\(\boldsymbol{\alpha} \in \mathbb{R}^n\)</span>,使得 <span class="math inline">\(\boldsymbol{\alpha}^T \boldsymbol{x}\leqslant \boldsymbol{\alpha}^T \overline{\boldsymbol{x}}, \forall\boldsymbol{x} \in c l \boldsymbol{D}\)</span>; 此时也称超平面 <span class="math inline">\(\boldsymbol{H}=\left\{\boldsymbol{x} \in\mathbb{R}^n \mid \boldsymbol{\alpha}^T(\boldsymbol{x}-\overline{\boldsymbol{x}})=0\right\}\)</span> 为集合<span class="math inline">\(\boldsymbol{D}\)</span> 在 <span class="math inline">\(\overline{\boldsymbol{x}}\)</span>处的支撑超平面。</p><p><span class="math inline">\(c l\)</span> 是闭包, <span class="math inline">\(\partial\)</span> 是边界。</p></blockquote><p>从其他角度理解支撑超平面：</p><figure><img src="../../../../images/最优化方法凸集和凸函数/p1.jpg" alt="p1.jpg"><figcaption aria-hidden="true">p1.jpg</figcaption></figure><p>下图为一个示意图：</p><figure><img src="../../../../images/最优化方法凸集和凸函数/p3.jpg" alt="p3.jpg"><figcaption aria-hidden="true">p3.jpg</figcaption></figure><h3 id="支撑分离定理边界点与凸集的分离">3.3支撑分离定理(边界点与凸集的分离)</h3><blockquote><p><code>定理</code> 若 <span class="math inline">\(S\)</span> 为 <span class="math inline">\(\mathbb{R}^n\)</span> 中的非空凸集(不需要为闭集)，令 <span class="math inline">\(\overline{\boldsymbol{x}}\in \partial S\)</span> ，则存在过点 <span class="math inline">\(\overline{\boldsymbol{x}}\)</span> 的 <span class="math inline">\(S\)</span> 的支撑超平面。</p></blockquote><h3 id="凸集和凸集的分离定理超平面分离定理">3.4凸集和凸集的分离定理(超平面分离定理)</h3><blockquote><p><code>定理</code>设 <span class="math inline">\(\boldsymbol{D}_1,\boldsymbol{D}_2 \subset \mathbb{R}^n\)</span> 是非空凸集，且 <span class="math inline">\(\boldsymbol{D}_1 \cap\boldsymbol{D}_2=\varnothing\)</span> 则存在非零向量 <span class="math inline">\(\boldsymbol{\alpha}\)</span> 使得： <span class="math display">\[\inf \left\{\boldsymbol{\alpha}^T \boldsymbol{x} \mid \boldsymbol{x} \in\boldsymbol{D}_1\right\} \geqslant \sup \left\{\boldsymbol{\alpha}^T\boldsymbol{x} \mid \boldsymbol{x} \in \boldsymbol{D}_2\right\}\]</span> <span class="math inline">\(inf\)</span>表示下确界(infimum)，<span class="math inline">\(sup\)</span>表示上确界(supremum)</p></blockquote><p>这个定理表明如果在空间<span class="math inline">\(\mathbb{R}^n\)</span>内存在两个没有交集的凸集<span class="math inline">\(\boldsymbol{D_1}\)</span>和<span class="math inline">\(\boldsymbol{D_2}\)</span>，那么可以找到一个平面将这两个凸集分隔开。</p><blockquote><p>证明思路：</p><p>由于凸集没有交集，所以<span class="math inline">\(\boldsymbol{D_1}-\boldsymbol{D_2}\)</span>一定不包含<span class="math inline">\(\boldsymbol{0}\)</span>这个点，根据这个特殊的点利用点和凸集的分离定理即可证明。</p><p>证明: 令 <span class="math inline">\(\boldsymbol{D}^{\prime}=\boldsymbol{D_2}-\boldsymbol{D_1}=\left\{\boldsymbol{z}\mid \boldsymbol{z}=\boldsymbol{x_2}-\boldsymbol{x_1}, \boldsymbol{x_1}\in \boldsymbol{D_1}, \boldsymbol{x_2} \in\boldsymbol{D_2}\right\}\)</span>,由于 <span class="math inline">\(\boldsymbol{D}_1, \boldsymbol{D}_2\)</span> 非空,所以 <span class="math inline">\(\boldsymbol{D}^{\prime}\)</span> 非空,由于 <span class="math inline">\(\boldsymbol{D}_1 \cap\boldsymbol{D}_2=\varnothing\)</span>, 所以 <span class="math inline">\(\boldsymbol{0} \notin\boldsymbol{D}^{\prime}\)</span>, <span class="math inline">\(\boldsymbol{0} \in \partial\boldsymbol{D'}\)</span>，根据点与凸集的分离定理的推论可知存在非零向量<span class="math inline">\(\boldsymbol{\alpha}\)</span>, 使得对每一个<span class="math inline">\(\boldsymbol{z} \in\boldsymbol{D}^{\prime}\)</span> 都有 <span class="math inline">\(\boldsymbol{\alpha}^T(\boldsymbol{z}-\boldsymbol{0})= \boldsymbol{\alpha}^T\boldsymbol{z}\leqslant 0\)</span>, 即 <span class="math display">\[\boldsymbol{\alpha}^T \boldsymbol{x}_1 \geqslant \boldsymbol{\alpha}^T\boldsymbol{x}_2, \forall \boldsymbol{x}_1 \in \boldsymbol{D}_1,\boldsymbol{x}_2 \in \boldsymbol{D}_2\]</span></p></blockquote><h2 id="凸函数">4.凸函数</h2><h3 id="凸函数的定义">4.1 凸函数的定义</h3><p>设 <span class="math inline">\(\boldsymbol{D} \subset\mathbb{R}^n\)</span> 是非空凸集, <span class="math inline">\(f(\boldsymbol{x})\)</span> 是定义在 <span class="math inline">\(\boldsymbol{D}\)</span> 上的函数, 如果对任 意的<span class="math inline">\(\boldsymbol{x}_1, \boldsymbol{x}_2 \in\boldsymbol{D}, \alpha \in(0,1)\)</span> 都有 <span class="math inline">\(f\left(\alpha \boldsymbol{x}_1+(1-\alpha)\boldsymbol{x}_2\right) \leqslant\)</span> <span class="math inline">\(\alpha f\left(\boldsymbol{x}_1\right)+(1-\alpha)f\left(\boldsymbol{x}_2\right)\)</span>, 则称 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\boldsymbol{D}\)</span> 上的凸函数(<span class="math inline">\(convex\quad function\)</span>)。</p><p>凸函数的定义和詹森 <span class="math inline">\((Jensen)\)</span>不等式是相同的。</p><blockquote><p>注意这个定义包含了两个条件。</p></blockquote><p>更进一步地，如果对任意的 <span class="math inline">\(\boldsymbol{x}_1, \boldsymbol{x}_2 \in\boldsymbol{D}, \alpha \in(0,1)\)</span> 都有 <span class="math inline">\(f\left(\alpha \boldsymbol{x}_1+(1-\alpha)\boldsymbol{x}_2\right)&lt;\)</span> <span class="math inline">\(\alphaf\left(\boldsymbol{x}_1\right)+(1-\alpha)f\left(\boldsymbol{x}_2\right)\)</span>, 则称 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\boldsymbol{D}\)</span> 上的严格凸函数(<span class="math inline">\(strictly\quad convex\quad function\)</span>)。</p><h3 id="凸函数的几何意义">4.2 凸函数的几何意义</h3><p>下图是一个凸函数：</p><figure><img src="../../../../images/最优化方法凸集和凸函数/p4.jpg" alt="p4.jpg"><figcaption aria-hidden="true">p4.jpg</figcaption></figure><blockquote><p>凸函数的几何意义在于，定义域中任意两点连线组成的线段都在这两点的函数曲线（面）上方。</p></blockquote><p>下列函数均为 <span class="math inline">\(\mathbb{R}^n\)</span>上的凸函数:</p><ul><li><p><span class="math inline">\(f(\boldsymbol{x})=\boldsymbol{c}^T\boldsymbol{x}\)</span></p></li><li><p><span class="math inline">\(f(\boldsymbol{x})=\|\boldsymbol{x}\|\)</span></p></li><li><p><span class="math inline">\(f(\boldsymbol{x})=\boldsymbol{x}^T\boldsymbol{A} \boldsymbol{x}\)</span>, 其中 <span class="math inline">\(\boldsymbol{A}\)</span> 为对称正定矩阵</p></li></ul><h3 id="凸函数的alpha水平集">4.3 凸函数的<span class="math inline">\(\alpha\)</span>水平集</h3><p><span class="math inline">\(f(\boldsymbol{x})\)</span> 是定义在 <span class="math inline">\(\boldsymbol{D} \subset \mathbb{R}^n\)</span>上的函数, <span class="math inline">\(\alpha \in \mathbb{R}\)</span>,集合 <span class="math inline">\(\boldsymbol{D}_\alpha=\{\boldsymbol{x}\mid f(\boldsymbol{x}) \leqslant\)</span> <span class="math inline">\(\alpha, \boldsymbol{x} \in\boldsymbol{D}\}\)</span> 称作 <span class="math inline">\(f\)</span>函数的 <span class="math inline">\(\alpha\)</span> 水平集(<span class="math inline">\(level\quad set\)</span>)。</p><p>实质上就是一个函数满足一定条件时的定义域上的一系列点的集合。</p><p>一个例子，如下图所示：</p><figure><img src="../../../../images/最优化方法凸集和凸函数/p5.jpg.png" alt="p5.jpg"><figcaption aria-hidden="true">p5.jpg</figcaption></figure><blockquote><p><code>性质</code>凸函数的任意 <span class="math inline">\(\alpha\)</span> 下水平集都是凸集。</p><p>注意：某个函数的下水平集都是凸集，但这个函数却不一定是凸函数 (如:<span class="math inline">\(f(x)=-e^x\)</span> )。</p></blockquote><h2 id="凸函数的判别定理">5. 凸函数的判别定理</h2><blockquote><p><code>判别定理1</code> 定义在 <span class="math inline">\(\mathbb{R}^n\)</span> 上的 <span class="math inline">\(f(\boldsymbol{x})\)</span>为凸函数的充要条件是对于任意 <span class="math inline">\(\boldsymbol{x},\boldsymbol{y} \in \mathbb{R}^n\)</span>, 一元函数 <span class="math inline">\(\phi(\alpha)=f(\boldsymbol{x}+\alpha\boldsymbol{y})\)</span> 是关于 <span class="math inline">\(\alpha\)</span>​ 的凸函数。</p></blockquote><blockquote><p><code>判别定理2</code>(一阶条件) 设 <span class="math inline">\(\boldsymbol{D} \subset \mathbb{R}^n\)</span>是非空开凸集, <span class="math inline">\(f: \boldsymbol{D} \subset\mathbb{R}^n \rightarrow \mathbb{R}\)</span>, 且 <span class="math inline">\(f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(\boldsymbol{D}\)</span> 上一阶连续可微,则 <span class="math inline">\(f(x)\)</span> 是 <span class="math inline">\(\boldsymbol{D}\)</span> 上的凸函数的充要条件是:<span class="math display">\[f(\boldsymbol{y}) \geqslant f(\boldsymbol{x})+\nablaf(\boldsymbol{x})^T(\boldsymbol{y}-\boldsymbol{x}), \forall\boldsymbol{x}, \boldsymbol{y} \in \boldsymbol{D}\]</span></p></blockquote><p>一阶条件的几何意义：<mark class="hl-label blue">凸函数永远位于其切线的上方</mark>  ,如下图所示：</p><figure><img src="../../../../images/最优化方法凸集和凸函数/p6.jpg" alt="p6.jpg"><figcaption aria-hidden="true">p6.jpg</figcaption></figure><p>事实上，<span class="math inline">\(f(\boldsymbol{y}) =f(\boldsymbol{x})+\nablaf(\boldsymbol{x})^T(\boldsymbol{y}-\boldsymbol{x})\)</span> 就是函数<span class="math inline">\(f\)</span> 在点 <span class="math inline">\(\boldsymbol{x}\)</span>处的一阶泰勒近似，那么上述条件就说明了对于凸函数而言，其任意位置处的一阶泰勒展开总是其本身的全局下界。而泰勒展开描述的是函数<span class="math inline">\(f\)</span>的局部性质，由此我们得到有关凸函数的一个重要性质：<strong>凸函数是一类可以由局部信息推导出全局信息的函数。</strong></p><p>一阶条件的引申：设 <span class="math inline">\(\boldsymbol{D} \subset\mathbb{R}^n\)</span> 是非空开凸集, <span class="math inline">\(f:\boldsymbol{D} \subset \mathbb{R}^n \rightarrow \mathbb{R}\)</span>, 且<span class="math inline">\(f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(\boldsymbol{D}\)</span> 上一阶连续可微, 则 <span class="math inline">\(f(x)\)</span> 是 <span class="math inline">\(\boldsymbol{D}\)</span>上的严格凸函数的充要条件是: <span class="math display">\[f(\boldsymbol{y})&gt;f(\boldsymbol{x})+\nablaf(\boldsymbol{x})^T(\boldsymbol{y}-\boldsymbol{x}), \forall\boldsymbol{x}, \boldsymbol{y} \in \boldsymbol{D} \text { 且 }\boldsymbol{x} \neq \boldsymbol{y}\]</span></p><blockquote><p><code>判别定理3</code> 设 <span class="math inline">\(\boldsymbol{D}\subset \mathbb{R}^n\)</span> 是非空开凸集, <span class="math inline">\(f: \boldsymbol{D} \subset \mathbb{R}^n \rightarrow\mathbb{R}\)</span>, 且 <span class="math inline">\(f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(\boldsymbol{D}\)</span> 上二阶连续可微,则 <span class="math inline">\(f(x)\)</span> 是 <span class="math inline">\(\boldsymbol{D}\)</span>上的凸函数的充要条件是:<span class="math inline">\(f(\boldsymbol{x})\)</span> 的<span class="math inline">\(Hesse\)</span>矩阵 <span class="math inline">\(\nabla^2 f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(\boldsymbol{D}\)</span> 上是半正定的。</p></blockquote><blockquote><p><code>判别定理4</code></p><p>设 <span class="math inline">\(\boldsymbol{D} \subset\mathbb{R}^n\)</span> 是非空开凸集, <span class="math inline">\(f:\boldsymbol{D} \subset \mathbb{R}^n \rightarrow \mathbb{R}\)</span>, 且<span class="math inline">\(f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(\boldsymbol{D}\)</span> 上二阶连续可微, 则：</p><ul><li><span class="math inline">\(f(\boldsymbol{x})\)</span> 的<span class="math inline">\(Hesse\)</span>矩阵 <span class="math inline">\(\nabla^2 f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(\boldsymbol{D}\)</span> 上正定 <span class="math inline">\(\Rightarrow f(\boldsymbol{x})\)</span> 是 <span class="math inline">\(\boldsymbol{D}\)</span> 上的严格凸函数;</li><li><span class="math inline">\(f(\boldsymbol{x})\)</span> 是 <span class="math inline">\(\boldsymbol{D}\)</span> 上的严格 凸函数 <span class="math inline">\(\Rightarrow f(\boldsymbol{x})\)</span> 的<span class="math inline">\(Hesse\)</span>矩阵 <span class="math inline">\(\nabla^2 f(\boldsymbol{x})\)</span> 在 <span class="math inline">\(\boldsymbol{D}\)</span>​ 上半正定。</li></ul><hr><p>几个反例：<span class="math inline">\(y=x^4, x \in \mathbb{R}, y=x^6,x \in \mathbb{R}\)</span> 。</p><p>导致充分严格凸函数与严格正定不构成互为充要条件的原因: 对于 <span class="math inline">\(\alpha&gt;0\)</span>, 如果当 <span class="math inline">\(\alpha \rightarrow 0\)</span> 时 <span class="math inline">\(o(\alpha)&gt;0\)</span> 且 <span class="math inline">\(o(\alpha) \rightarrow 0\)</span>, 则有 <span class="math display">\[\begin{aligned}&amp; f(\boldsymbol{x})+\frac{o(\alpha)}{\alpha}&lt;0, \forall\boldsymbol{x} \in \mathbb{R}^n \Rightarrow f(\boldsymbol{x})&lt;0,\forall \boldsymbol{x} \in \mathbb{R}^n \\&amp;f(\boldsymbol{x})+\frac{o(\alpha)}{\alpha}&gt;0, \forall \boldsymbol{x}\in \mathbb{R}^n \Rightarrow f(\boldsymbol{x}) \geqslant 0, \forall\boldsymbol{x} \in \mathbb{R}^n \\&amp;f(\boldsymbol{x})+\frac{o(\alpha)}{\alpha} \leqslant 0, \forall\boldsymbol{x} \in \mathbb{R}^n \Rightarrow f(\boldsymbol{x})&lt;0,\forall \boldsymbol{x} \in \mathbb{R}^n \\&amp;f(\boldsymbol{x})+\frac{o(\alpha)}{\alpha} \geqslant 0, \forall\boldsymbol{x} \in \mathbb{R}^n \Rightarrow f(\boldsymbol{x}) \geqslant0, \forall \boldsymbol{x} \in \mathbb{R}^n\end{aligned}\]</span></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 最优化方法 </category>
          
          <category> 凸集和凸函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最优化方法 </tag>
            
            <tag> 凸集 </tag>
            
            <tag> 凸函数 </tag>
            
            <tag> 投影定理 </tag>
            
            <tag> 支撑超平面 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带黑色帽子的人数</title>
      <link href="/2024/03/19/dai-hei-se-mao-zi-de-ren-shu/"/>
      <url>/2024/03/19/dai-hei-se-mao-zi-de-ren-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="戴黑色帽子的人数">戴黑色帽子的人数</h1><h2 id="题目">题目：</h2><p>有一群人去参加聚会，每个人头上被分得一顶帽子。帽子有白色也有黑色，但一定会有人分到黑色帽子。每个人都无法看到自己的帽子，但可以看到别人的。以熄灯为时机，每次熄灯，如果有人觉得自己是黑色帽子，就拍手。第一次熄灯没有人拍手，第二次也没有，直到第5次才有人拍手。问：戴黑色帽子的有几个人？</p><h2 id="解答">解答：</h2><p><strong>假设只有一个人带了黑帽子</strong>：</p><p>第1次关灯的时候会有两种情况：带白帽子的人会看到1顶黑帽子；这种情况下，由于每个人不知道自己帽子的颜色，所以所有带白色帽子的人都可以得到结论：黑帽子不是1顶就是2顶。带黑帽子的人会看到所有人都是白帽子。这时候，带黑帽子的人就知道，他戴的肯定是黑色的。因为，黑帽子至少有1顶，而自己看到全是白色帽子，所以只能他带的是黑色的，从而在第一次关灯的时候就可以报出帽子颜色为1。排除。</p><p><strong>假设有两个人带了黑帽子</strong>：</p><p>在第1次关灯时：带白帽子的人会看到2顶黑帽子；这种情况下，由于每个人不知道自己帽子的颜色，所以所有带白色帽子的人都可以得到结论：黑帽子不是2顶就是3顶。带黑帽子的人会看到其他人中只要一顶黑帽子，其余所有人都是白帽子。所以他得到结论：黑帽子不是1顶就是2顶。但是由于他不知道自己的帽子颜色，所以也无法报数。然后第一次关灯后，没人报数。这时候，带黑帽子的人就知道肯定有2顶黑帽子，除了可以看到的那1顶，自己的也是，否则第一次关灯的时候就会报数了。因此，第二次关灯的时候，就会进行报数。</p><p><strong>假设有三个人带了黑帽子</strong>：</p><p>第1次关灯时：带白帽子的人会看到3顶黑帽子；这种情况下，由于每个人不知道自己帽子的颜色，所以所有带白色帽子的人都可以得到结论：黑帽子不是3顶就是4顶。带黑帽子的人会看到其他人中只有2顶黑帽子，其余所有人都是白帽子。所以他得到结论：黑帽子不是2顶就是3顶。但是由于他不知道自己的帽子颜色，所以也无法报数。按照上边的逻辑。所有人都知道第一次关灯是不会有任何人报数的。第二次关灯后，没人报数。这时候，带黑帽子的人就知道肯定有3顶黑帽子，除了可以看到的那2顶，自己的也是，否则第二次关灯的时候就会报数了。因此，第三次关灯的时候，就会进行报数。</p><p><strong>归纳：假设有<span class="math inline">\(N\)</span>个人带了黑帽子</strong></p><p>第一次关灯时：带白帽子的人会看到<span class="math inline">\(N\)</span>顶黑帽子；这种情况下，由于每个人不知道自己帽子的颜色，所以所有带白色帽子的人都可以得到结论：黑帽子不是<span class="math inline">\(N\)</span>顶就是<span class="math inline">\((N+1)\)</span>顶。带黑帽子的人会看到其他人中只有<span class="math inline">\((N-1)\)</span>顶黑帽子，其余所有人都是白帽子。所以他得到结论：黑帽子不是<span class="math inline">\((N-1)\)</span>顶就是<span class="math inline">\(N\)</span>顶。但是由于他不知道自己的帽子颜色，所以也无法报数。同上，所有人都知道第一次关灯是不会有任何人报数的。第二次关灯后，也没人报数。一直到第<span class="math inline">\((N-1)\)</span>次关灯，这时候，带黑帽子的人就知道肯定有<span class="math inline">\(N\)</span>顶黑帽子，除了可以看到的那<span class="math inline">\((N-1)\)</span>顶，自己的也是，否则第<span class="math inline">\((N-1)\)</span>次关灯的时候就会报数了。因此，第<span class="math inline">\(N\)</span>次关灯的时候，就会进行报数。</p><h2 id="答案">答案</h2><p>​ 戴黑色帽子的有5个人。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 逻辑推理题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 逻辑推理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础知识回顾与拓展（一）</title>
      <link href="/2024/03/19/zui-you-hua-fang-fa-zhi-shi-hui-gu-yu-tuo-zhan/"/>
      <url>/2024/03/19/zui-you-hua-fang-fa-zhi-shi-hui-gu-yu-tuo-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="数学知识回顾与拓展一">数学知识回顾与拓展(一)</h1><h2 id="线性代数">1 线性代数</h2><h3 id="向量">1.1 向量</h3><p>在最优化方法的课程中，默认向量为列向量的形式。</p><p><span class="math inline">\(n\)</span>维列向量定义为包含<span class="math inline">\(n\)</span>个实数的数组，记作： <span class="math display">\[\boldsymbol{a}=\left[\begin{array}{c}a_1 \\ a_2 \\ \vdots \\a_n\end{array}\right]\]</span> <span class="math inline">\(a_i\)</span> 表示向量 <span class="math inline">\(\boldsymbol{a}\)</span> 的第 <span class="math inline">\(i\)</span> 个元素。定义 <span class="math inline">\(\mathbb{R}\)</span>为全体实数组成的集合，那么由实数组成的 <span class="math inline">\(n\)</span> 维列向量可表示为 <span class="math inline">\(\mathbb{R}^n\)</span>, 称为 <span class="math inline">\(n\)</span> 维实数向量空间。通常将 <span class="math inline">\(\mathbb{R}^n\)</span> 的元素(<span class="math inline">\(n\)</span>维向量)用小写粗体字母表示 (如 <span class="math inline">\(\boldsymbol{x}\)</span> )。向量 <span class="math inline">\(\boldsymbol{x} \in \mathbb{R}^n\)</span>中的元素记为 <span class="math inline">\(x_1, \cdots, x_n\)</span>。</p><p><span class="math inline">\(n\)</span> 维行向量记为 <span class="math inline">\(\left[a_1, a_2, \cdots, a_n\right]\)</span>, 向量<span class="math inline">\(\boldsymbol{a}\)</span> 的转置记为 <span class="math inline">\(\boldsymbol{a}^T\)</span> 。比如, 如果 <span class="math display">\[\boldsymbol{a}=\left[\begin{array}{c}a_1 \\a_2 \\\vdots \\a_n\end{array}\right]\]</span></p><p>那么 <span class="math display">\[\boldsymbol{a}^T=\left[a_1, a_2, \cdots, a_n\right]\]</span></p><p>相应的, 列向量<span class="math inline">\(\boldsymbol{a}\)</span>可以记为 <span class="math inline">\(\boldsymbol{a}=\left[a_1, a_2, \cdots,a_n\right]^T\)</span> 。</p><h3 id="线性相关">1.2 线性相关</h3><h4 id="线性相关与线性无关的定义">1.2.1 线性相关与线性无关的定义</h4><p>如果方程： <span class="math display">\[\alpha_1 \boldsymbol{a}_1+\alpha_2 \boldsymbol{a}_2+\cdots+\alpha_k\boldsymbol{a}_k=\mathbf{0}\]</span></p><p>只有在所有系数 <span class="math inline">\(\alpha_i(i=1, \cdots,k)\)</span> 都等于零的前提下等号成立, 那么称向量集 <span class="math inline">\(\left\{\boldsymbol{a}_1, \boldsymbol{a}_2, \cdots,\boldsymbol{a}_k\right\}\)</span>是线性无关的，否则称向量集是线性相关的。</p><blockquote><p>线性相关的一些结论</p></blockquote><blockquote><p>1.如果集合中只包括一个向量 <span class="math inline">\(\boldsymbol{0}\)</span>, 由于对于任意 <span class="math inline">\(\alpha \neq 0\)</span>, 都有 <span class="math inline">\(\alpha\mathbf{0}=\mathbf{0}\)</span>,因此，该集合是线性相关的。实际上，所有包含零向量的集合都是线性相关的，假设这个集合有<span class="math inline">\(n\)</span>个向量元素，令剩下的<span class="math inline">\((n-1)\)</span>个元素<span class="math inline">\(\alpha_1 \boldsymbol{a}_1+\alpha_2\boldsymbol{a}_2+\cdots+\alpha_{k-1}\boldsymbol{a}_{k-1}=\mathbf{0}\)</span> ，这些系数可以全部为<span class="math inline">\(0\)</span>，即： <span class="math inline">\(\alpha_i(i=1, \cdots, k-1)\)</span> 都为<span class="math inline">\(0\)</span>，剩下的零向量前的系数不为 <span class="math inline">\(0\)</span>即可，所以所有包含零向量的集合都是线性相关的。2.如果集合中只包括一个非零向量 ： <span class="math inline">\(\boldsymbol{a} \neq \mathbf{0}\)</span> , 只有<span class="math inline">\(\alpha=0\)</span>时, 才有 <span class="math inline">\(\alpha\boldsymbol{a}=\boldsymbol{0}\)</span>成立，因此，该集合是线性无关的。</p></blockquote><h4 id="线性组合">1.2.2 线性组合</h4><p>给定向量 <span class="math inline">\(\boldsymbol{a}\)</span>,如果存在标量 <span class="math inline">\(\alpha_1, \cdots,\alpha_k\)</span>, 使得 <span class="math display">\[\boldsymbol{a}=\alpha_1 \boldsymbol{a}_1+\alpha_2\boldsymbol{a}_2+\cdots+\alpha_k \boldsymbol{a}_k\]</span></p><p>那么称向量 <span class="math inline">\(\boldsymbol{a}\)</span>为向量<span class="math inline">\(\boldsymbol{a}_1, \boldsymbol{a}_2,\cdots, \boldsymbol{a}_k\)</span> 的线性组合。</p><blockquote><p><code>定理</code>向量集 <span class="math inline">\(\left\{\boldsymbol{a}_1, \boldsymbol{a}_2, \cdots,\boldsymbol{a}_k\right\}\)</span>是线性相关的，当且仅当集合中的一个向量可以表示为其他向量的线性组合。</p></blockquote><blockquote><p>证明：</p><p>必要性。如果 <span class="math inline">\(\left\{a_1, a_2, \cdots,a_k\right\}\)</span> 是线性相关的, 那么有 <span class="math display">\[\alpha_1 \boldsymbol{a}_1+\alpha_2 \boldsymbol{a}_2+\cdots+\alpha_k\boldsymbol{a}_k=\mathbf{0}\]</span></p><p>其中至少存在一个标量 <span class="math inline">\(\alpha_i \neq0\)</span>, 从而有 <span class="math display">\[\boldsymbol{a}_i=-\frac{\alpha_1}{\alpha_i}\boldsymbol{a}_1-\frac{\alpha_2}{\alpha_i}\boldsymbol{a}_2-\cdots-\frac{\alpha_k}{\alpha_i}\boldsymbol{a}_k\]</span> 充分性。不妨设向量 <span class="math inline">\(\boldsymbol{a_1}\)</span>可以被表示为其他向量的线性组合: <span class="math display">\[\boldsymbol{a}_1=\alpha_2 \boldsymbol{a}_2+\alpha_3\boldsymbol{a}_3+\cdots+\alpha_k \boldsymbol{a}_k\]</span></p><p>那么有 <span class="math display">\[(-1) \boldsymbol{a}_1+\alpha_2 \boldsymbol{a}_2+\cdots+\alpha_k\boldsymbol{a}_k=\mathbf{0}\]</span></p><p>因为第一个标量非零，所以向量集 <span class="math inline">\(\left\{\boldsymbol{a}_1, \boldsymbol{a}_2, \cdots,\boldsymbol{a}_k\right\}\)</span> 是线性相关的。</p><p>得证。</p></blockquote><h4 id="向量空间">1.2.3向量空间</h4><h5 id="子空间">1.2.3.1 子空间</h5><p>令 <span class="math inline">\(\mathcal{V}\)</span> 表示 <span class="math inline">\(\mathbb{R}^n\)</span> 的一个子集, 如果 <span class="math inline">\(\mathcal{V}\)</span>在向量加和运算及标量乘积运算下是封闭的，那么称 <span class="math inline">\(\mathcal{V}\)</span> 为 <span class="math inline">\(\mathbb{R}^n\)</span> 的一个子空间。</p><p>注：每个子空间都包含零向量。</p><p>假定 <span class="math inline">\(\boldsymbol{a}_1, \boldsymbol{a}_2,\cdots, \boldsymbol{a}_k\)</span> 是 <span class="math inline">\(\mathbb{R}^n\)</span> 中的任意向量,它们所有线性组合的集合称为 <span class="math inline">\(\boldsymbol{a}_1,\boldsymbol{a}_2, \cdots, \boldsymbol{a}_k\)</span> 张成的子空间。记为：<span class="math display">\[span\left[\boldsymbol{a}_1, \boldsymbol{a}_2, \cdots,\boldsymbol{a}_k\right]=\left\{\sum_{i=1}^k \alpha_i \boldsymbol{a}_i:\alpha_1, \cdots, \alpha_k \in \mathbb{R}\right\}\]</span></p><p>任意向量集合都能张成一个子空间。</p><h5 id="基">1.2.3.2 基</h5><p>给定子空间 <span class="math inline">\(\mathcal{V}\)</span>，如果存在线性无关的向量集合 <span class="math inline">\(\left\{\boldsymbol{a}_1, \boldsymbol{a}_2, \cdots,\boldsymbol{a}_k\right\} \subset \mathcal{V}\)</span> 使得 <span class="math inline">\(\mathcal{V}=\operatorname{span}\left[\boldsymbol{a}_1,\boldsymbol{a}_2, \cdots, \boldsymbol{a}_k\right]\)</span> ，那么称<span class="math inline">\(\left\{\boldsymbol{a}_1, \boldsymbol{a}_2,\cdots, \boldsymbol{a}_k\right\}\)</span> 是子空间 <span class="math inline">\(\mathcal{V}\)</span> 的一组基。子空间 <span class="math inline">\(\mathcal{V}\)</span>中的所有基都包含相同数量的向量, 这一数量称为 <span class="math inline">\(\mathcal{V}\)</span> 的维数, 记为 <span class="math inline">\(\operatorname{dim} \mathcal{V}\)</span> 。</p><p>如果 <span class="math inline">\(\left\{\boldsymbol{a}_1,\boldsymbol{a}_2, \cdots, \boldsymbol{a}_k\right\}\)</span> 是 <span class="math inline">\(\mathcal{V}\)</span> 的一组基, 那么 <span class="math inline">\(\mathcal{V}\)</span> 中的任一向量 <span class="math inline">\(\boldsymbol{a}\)</span> 可以唯一地表示为 <span class="math display">\[\boldsymbol{a}=\alpha_1 \boldsymbol{a}_1+\alpha_2\boldsymbol{a}_2+\cdots+\alpha_k \boldsymbol{a}_k\]</span></p><p>其中，<span class="math inline">\(\alpha_i \in \mathbb{R}, i=1,2,\cdots, k\)</span> 。</p><p>给定 <span class="math inline">\(\mathcal{V}\)</span> 的一组基 <span class="math inline">\(\left\{\boldsymbol{a}_1, \boldsymbol{a}_2, \cdots,\boldsymbol{a}_k\right\}\)</span> 和向量 <span class="math inline">\(\boldsymbol{a} \in \mathcal{V}\)</span> ，如果<span class="math display">\[\boldsymbol{a}=\alpha_1 \boldsymbol{a}_1+\alpha_2\boldsymbol{a}_2+\cdots+\alpha_k \boldsymbol{a}_k\]</span></p><p>那么系数 <span class="math inline">\(\alpha_i, i=1, \cdots,k\)</span> 称为 <span class="math inline">\(a\)</span> 对应于基 <span class="math inline">\(\left\{\boldsymbol{a}_1, \boldsymbol{a}_2, \cdots,\boldsymbol{a}_k\right\}\)</span> 的坐标。</p><p><span class="math inline">\(\mathbb{R}^n\)</span> 的标准基为 <span class="math display">\[\boldsymbol{e}_1=\left[\begin{array}{l}1 \\0 \\0 \\\vdots \\0\\0\end{array}\right], \boldsymbol{e}_2=\left[\begin{array}{l}0 \\1 \\0\\\vdots \\0 \\0\end{array}\right], \cdots,\boldsymbol{e}_n=\left[\begin{array}{l}0 \\0 \\0 \\\vdots \\0\\1\end{array}\right]\]</span></p><p>在标准基下，向量 <span class="math inline">\(x\)</span> 可表示为<span class="math display">\[\boldsymbol{x}=\left[\begin{array}{llll}x_1 &amp; x_2 &amp; \cdots &amp;x_n\end{array}\right]^T=x_1 \boldsymbol{e}_1+x_2\boldsymbol{e}_2+\cdots+x_n \boldsymbol{e}_n\]</span></p><h3 id="初等变换">1.3 初等变换</h3><p>对矩阵进行以下三种变换的称为行初等变换</p><ul><li><p>对换两行（对换 <span class="math inline">\(i, j\)</span> 两行,记作 <span class="math inline">\(r_i \leftrightarrow r_j\)</span>);</p></li><li><p>以数 <span class="math inline">\(k \neq 0\)</span>乘某一行中所有的元素（第 <span class="math inline">\(i\)</span> 行乘<span class="math inline">\(k\)</span>, 记作 <span class="math inline">\(r_i \times k\)</span> ）;</p></li><li><p>把某一行所有元的 <span class="math inline">\(k\)</span> 倍,加到另一行对应的元上去 (第 <span class="math inline">\(j\)</span> 行的<span class="math inline">\(k\)</span> 倍加到第 <span class="math inline">\(i\)</span> 行上, 记作 <span class="math inline">\(r_i+k r_j\)</span> ).矩阵的行初等变换与列初等变换, 统称为矩阵的初等变换。</p></li></ul><p>对一个矩阵每进行一次初等行变换相当于为这个矩阵左乘了一个初等矩阵，初等列变换相当于右乘一个初等矩阵。</p><h3 id="矩阵的秩">1.4 矩阵的秩</h3><p>矩阵 <span class="math inline">\(\boldsymbol{A}\)</span>中线性无关列的最大数目称为 <span class="math inline">\(\boldsymbol{A}\)</span> 的秩, 记为 <span class="math inline">\(r a n k \boldsymbol{A}\)</span> 。矩阵 <span class="math inline">\(A\)</span> 的秩等于它的非零子式的最高阶数。</p><p>注：对矩阵进行初等变换不改变矩阵的秩。</p><p>如果矩阵 <span class="math inline">\(\boldsymbol{A}\)</span>的行数等于列数, 那么该矩阵称为方阵。行列式是与每个方阵相对应的一个标量,记为 <span class="math inline">\(\operatorname{det}\boldsymbol{A}\)</span> 或 <span class="math inline">\(|\boldsymbol{A}|\)</span> 。</p><p>如果一个 <span class="math inline">\(m \times n(m \geq n)\)</span>矩阵 <span class="math inline">\(A\)</span> 具有非零的 <span class="math inline">\(n\)</span> 阶子式，那么 <span class="math inline">\(A\)</span> 的各列是线性无关的，即 <span class="math inline">\(r a n k \boldsymbol{A}=n\)</span> 。</p><h3 id="内积与范数">1.5 内积与范数</h3><p>对于 <span class="math inline">\(\boldsymbol{x}, \boldsymbol{y} \in\mathbb{R}^n\)</span>, 定义欧式内积为 <span class="math display">\[\langle\boldsymbol{x}, \boldsymbol{y}\rangle=\sum_{i=1}^n x_iy_i=\boldsymbol{x}^T \boldsymbol{y}\]</span></p><p>定义向量 <span class="math inline">\(\boldsymbol{x}\)</span>的欧氏范数为 <span class="math display">\[\|\boldsymbol{x}\|=\sqrt{\langle\boldsymbol{x},\boldsymbol{x}\rangle}=\sqrt{\boldsymbol{x}^T \boldsymbol{x}}\]</span></p><blockquote><p>向量 <span class="math inline">\(x\)</span> 的欧氏范数 <span class="math inline">\(\|x\|\)</span> 具有如下性质:</p><ol type="1"><li>非负性: <span class="math inline">\(\boldsymbol{x}\)</span>的欧氏范数 <span class="math inline">\(\|\boldsymbol{x}\| \geq0\)</span>, 当且仅当 <span class="math inline">\(\boldsymbol{x}=\boldsymbol{0}\)</span> 时, <span class="math inline">\(\|\boldsymbol{x}\|=0\)</span></li><li>齐次性: <span class="math inline">\(\|r\boldsymbol{x}\|=|r|\|\boldsymbol{x}\| \geq 0, r \in\mathbb{R}\)</span></li><li>三角不等式: <span class="math inline">\(\|\boldsymbol{x}+\boldsymbol{y}\|\leq\|\boldsymbol{x}\|+\|\boldsymbol{y}\|\)</span></li></ol></blockquote><h3 id="求方阵的逆">1.6 求方阵的逆</h3><p>设 <span class="math inline">\(\boldsymbol{A}\)</span> 为矩阵,如果存在 <span class="math inline">\(n\)</span> 阶方阵 <span class="math inline">\(\boldsymbol{B}\)</span>, 使得： <span class="math display">\[\boldsymbol{A}\boldsymbol{B}=\boldsymbol{B}\boldsymbol{A}=\boldsymbol{I}\]</span> 则称 <span class="math inline">\(\boldsymbol{A}\)</span>是可逆矩阵, <span class="math inline">\(\boldsymbol{B}\)</span> 是 <span class="math inline">\(\boldsymbol{A}\)</span> 的逆矩阵。</p><blockquote><p><code>定理1</code>如果 <span class="math inline">\(\boldsymbol{A}\)</span> 是一个 <span class="math inline">\(n\)</span> 阶可逆矩阵, 则 <span class="math inline">\(\boldsymbol{A}\)</span> 的逆矩阵是唯一的。</p><p><code>定理2</code><span class="math inline">\(n\)</span> 阶方阵 <span class="math inline">\(\boldsymbol{A}\)</span> 可逆的充分必要条件是行列式<span class="math inline">\(|\boldsymbol{A}| \neq 0\)</span></p></blockquote><h4 id="利用伴随矩阵求方阵的逆">1.6.1 利用伴随矩阵求方阵的逆</h4><p>当 <span class="math inline">\(|\boldsymbol{A}| \neq 0\)</span> 时,<span class="math display">\[\boldsymbol{A}^{-1}=\frac{1}{|\boldsymbol{A}|}\boldsymbol{A}^*=\frac{1}{|\boldsymbol{A}|}\left[\begin{array}{cccc}A_{11}&amp; A_{21} &amp; \cdots &amp; A_{n 1} \\A_{12} &amp; A_{22} &amp;\cdots &amp; A_{n 2} \\\vdots &amp; \vdots &amp; &amp; \vdots \\A_{1 n}&amp; A_{2 n} &amp; \cdots &amp; A n n\end{array}\right]\]</span></p><p>其中 <span class="math inline">\(\boldsymbol{A}^*\)</span> 是 <span class="math inline">\(\boldsymbol{A}\)</span> 的伴随阵, <span class="math inline">\(A_{i j}\)</span> 是 <span class="math inline">\(a_{i j}\)</span> 的代数余子式,注意伴随矩阵的行列关系。</p><h4 id="gauss-jordan方法">1.6.2 <span class="math inline">\(Gauss-Jordan\)</span>方法</h4><p>简而言之, <span class="math inline">\(Gauss-Jordan\)</span>的想法是:如果我们对 <span class="math inline">\(\boldsymbol{A}\)</span>执行一些行操作以获得 <span class="math inline">\(\boldsymbol{I}\)</span>, 那么对 <span class="math inline">\(\boldsymbol{I}\)</span> 执行相同的行操作会得到<span class="math inline">\(\boldsymbol{A^{-1}}\)</span> 。为什么?</p><ul><li><p>行操作对应于从 <span class="math inline">\(\boldsymbol{A}\)</span> 左边乘以一组矩阵 <span class="math inline">\(\boldsymbol{E}=\cdots \boldsymbol{E_2E_1}\)</span></p></li><li><p>所以, 对 <span class="math inline">\(\boldsymbol{A}\)</span>做行操作将其变成 <span class="math inline">\(\boldsymbol{I}\)</span>意思等价于 <span class="math inline">\(\boldsymbol{E}\boldsymbol{A}=\boldsymbol{I}\)</span>, 因此 <span class="math inline">\(\boldsymbol{E}=\boldsymbol{A^{-1}}\)</span>.</p></li><li><p>对 <span class="math inline">\(\boldsymbol{I}\)</span>执行相同的行操作, 相当于 <span class="math inline">\(\boldsymbol{I}\)</span>左乘矩阵 <span class="math inline">\(E\)</span>, 即 <span class="math inline">\(EI\)</span>, 因为 <span class="math inline">\(\boldsymbol{E}\boldsymbol{I}=\boldsymbol{E}\)</span> 并且 <span class="math inline">\(\boldsymbol{E}=\boldsymbol{A^{-1}}\)</span>,所以结果就是 <span class="math inline">\(\boldsymbol{A^{-1}}\)</span>。这就是我们可以用扩展矩阵来进行高斯消除,对 <span class="math inline">\(\boldsymbol{A}\)</span> 和 <span class="math inline">\(\boldsymbol{I}\)</span> 同时执行相同的行操作,即：</p></li></ul><p><span class="math display">\[\left(\begin{array}{ll}\boldsymbol{A} &amp;\boldsymbol{I}\end{array}\right) \underset{\text { row ops}}{\longrightarrow}\left(\begin{array}{ll}\boldsymbol{I} &amp;\boldsymbol{A^{-1}}\end{array}\right)\]</span></p><h3 id="特征值与特征向量">1.7 特征值与特征向量</h3><h4 id="基本概念与一些结论">1.7.1 基本概念与一些结论</h4><p>令 <span class="math inline">\(\boldsymbol{A}\)</span> 是 <span class="math inline">\(n \times n\)</span> 的实数方阵。存在标量 <span class="math inline">\(\lambda\)</span> (可能为复数) 和非零向量 <span class="math inline">\(\boldsymbol{v}\)</span> 满足等式： <span class="math display">\[\boldsymbol{A v}=\lambda \boldsymbol{v}\]</span> <span class="math inline">\(\lambda\)</span> 称为 <span class="math inline">\(\boldsymbol{A}\)</span> 的特征值, <span class="math inline">\(\boldsymbol{v}\)</span> 称为 <span class="math inline">\(\boldsymbol{A}\)</span> 的特征向量。</p><p>已知 <span class="math inline">\(n\)</span> 阶齐次线性方程组 <span class="math inline">\((\lambda \boldsymbol{I}-\boldsymbol{A})\boldsymbol{x}=0\)</span> 有非零解的充分必要条件是系数行列式为 <span class="math inline">\(0\)</span>。即矩阵 <span class="math inline">\(\lambda \boldsymbol{I}-\boldsymbol{A}\)</span> 有<span class="math inline">\(\operatorname{det}[\lambda\boldsymbol{I}-\boldsymbol{A}]=0\)</span>, 于是有 <span class="math inline">\(n\)</span> 次方程成立: <span class="math display">\[\operatorname{det}[\lambda\boldsymbol{I}-\boldsymbol{A}]=\lambda^n+a_{n-1}\lambda^{n-1}+\cdots+a_1 \lambda+a_0=0\]</span> 多项式 <span class="math inline">\(\operatorname{det}[\lambda\boldsymbol{I}-\boldsymbol{A}]\)</span> 称为矩阵 <span class="math inline">\(\boldsymbol{A}\)</span>的特征多项式,上面的方程称为特征方程。由代数的基本原理可知, 特征方程必定有 <span class="math inline">\(n\)</span>个根（可能存在相同的根）,即为<span class="math inline">\(\boldsymbol{A}\)</span>的<span class="math inline">\(n\)</span>个特征值。若 <span class="math inline">\(\boldsymbol{A}\)</span> 有 <span class="math inline">\(n\)</span> 个相异的特征值，那么它也有 <span class="math inline">\(n\)</span>个线性无关的特征向量。</p><h4 id="矩阵对角化">1.7.2 矩阵对角化</h4><p>设矩阵 <span class="math inline">\(\boldsymbol{A}\)</span> 为<span class="math inline">\(n\)</span>阶方阵。考虑其特征向量 <span class="math inline">\(\left\{\boldsymbol{v}_1, \boldsymbol{v}_2, \cdots,\boldsymbol{v}_n\right\}\)</span>构成的一组线性无关基。在这一组基下,可对矩阵 <span class="math inline">\(\boldsymbol{A}\)</span> 进行对角化, 即对所有的<span class="math inline">\(i \neq j\)</span>, 对角矩阵的第 <span class="math inline">\((i, j)\)</span> 个元素 <span class="math inline">\(a_{i j}=\)</span> 0 。令 <span class="math display">\[\boldsymbol{T}=\left[\boldsymbol{v}_1, \boldsymbol{v}_2, \cdots,\boldsymbol{v}_n\right]^{-1}\]</span> 则有： <span class="math display">\[\begin{aligned}\boldsymbol{T A T}^{-1} &amp; =\boldsymbol{T A}\left[\boldsymbol{v}_1,\boldsymbol{v}_2, \cdots, \boldsymbol{v}_n\right] \\&amp; =\boldsymbol{T}\left[\boldsymbol{A} \boldsymbol{v}_1,\boldsymbol{A} \boldsymbol{v}_2, \cdots, \boldsymbol{A}\boldsymbol{v}_n\right] \\&amp; =\boldsymbol{T}\left[\lambda_1 \boldsymbol{v}_1, \lambda_2\boldsymbol{v}_2, \cdots, \lambda_n \boldsymbol{v}_n\right] \\&amp;=\boldsymbol{T}\boldsymbol{T}^{-1}\left[\begin{array}{llll}\lambda_1 &amp; &amp; &amp;0 \\&amp; \lambda_2 &amp; &amp; \\&amp; &amp; \ddots &amp; \\0 &amp;&amp; &amp; \lambda_n\end{array}\right] \\&amp; =\left[\begin{array}{llll}\lambda_1 &amp; &amp; &amp; 0 \\&amp;\lambda_2 &amp; &amp; \\&amp; &amp; \ddots &amp; \\0 &amp; &amp; &amp;\lambda_n\end{array}\right]\end{aligned}\]</span></p><blockquote><p><code>定理</code>对于任意 <span class="math inline">\(n \timesn\)</span> 实对称矩阵, 存在 <span class="math inline">\(n\)</span>个相互正交的特征向量。</p></blockquote><blockquote><p>证明：假定 <span class="math inline">\(\boldsymbol{A}\boldsymbol{v}_1=\lambda_1 \boldsymbol{v}_1, \boldsymbol{A}\boldsymbol{v}_2=\lambda_2 \boldsymbol{v}_2\)</span>, 其中 <span class="math inline">\(\lambda_1 \neq \lambda_2\)</span>, 那么有 <span class="math display">\[\boldsymbol{v}_1^T \boldsymbol{A}\boldsymbol{v}_2=\boldsymbol{v}_1^T\left(\boldsymbol{A}\boldsymbol{v}_2\right)=\lambda_2\left(\boldsymbol{v}_1^T\boldsymbol{v}_2\right)\]</span></p><p>根据 <span class="math inline">\(\boldsymbol{A}=\boldsymbol{A}^T\)</span>, 有 <span class="math display">\[\boldsymbol{v}_1^T \boldsymbol{A}\boldsymbol{v}_2=\left(\boldsymbol{v}_1^T \boldsymbol{A}^T\right)\boldsymbol{v}_2=\left(\boldsymbol{A} \boldsymbol{v}_1\right)^T\boldsymbol{v}_2=\lambda_1\left(\boldsymbol{v}_1^T\boldsymbol{v}_2\right)\]</span></p><p>因此, <span class="math display">\[\lambda_1\left(\boldsymbol{v}_1^T\boldsymbol{v}_2\right)=\lambda_2\left(\boldsymbol{v}_1^T\boldsymbol{v}_2\right)\]</span></p><p>由于 <span class="math inline">\(\lambda_1 \neq \lambda_2\)</span>,可以推出 <span class="math display">\[\left(\boldsymbol{v}_1^T \boldsymbol{v}_2\right)=0\]</span> 所以特征向量相互正交。</p></blockquote><h3 id="二次型">1.8 二次型</h3><h4 id="二次型函数">1.8.1 二次型函数</h4><p>设二次型函数 <span class="math inline">\(f: \mathbb{R}^n \rightarrow\mathbb{R}\)</span> 定义为具有如下形式的函数: <span class="math display">\[f(\boldsymbol{x})=\boldsymbol{x}^T \boldsymbol{Q} \boldsymbol{x}\]</span></p><p>其中 <span class="math inline">\(\boldsymbol{Q}\)</span> 是一个 <span class="math inline">\(n \times n\)</span> 实数矩阵。 <span class="math display">\[\begin{aligned}f(\boldsymbol{x}) &amp; =q_{11} x_1^2+q_{12} x_1x_2+\cdots+q_{1 n} x_1 x_n \\&amp; +q_{21} x_2 x_1+q_{22}x_2^2+\cdots+q_{2 n} x_2 x_n \\&amp; +\cdots \\&amp; +q_{n 1} x_nx_1+q_{n 2} x_2^2+\cdots+q_{n n} x_n^2 \\&amp; =\left[x_1, x_2, \cdots,x_n\right]\left[\begin{array}{cccc}q_{11} &amp; q_{12} &amp; \cdots&amp; q_{1 n} \\q_{21} &amp; q_{22} &amp; \cdots &amp; q_{2 n} \\\vdots&amp; \vdots &amp; \vdots &amp; \vdots \\q_{n 1} &amp; q_{n 2} &amp;\cdots &amp; q_{n n}\end{array}\right]\left[\begin{array}{c}x_1 \\x_2\\\vdots \\x_n\end{array}\right]\\&amp;=\boldsymbol{x}^T \boldsymbol{Q}\boldsymbol{x}\end{aligned}\]</span></p><h4 id="正定">1.8.2 正定</h4><p>当对于任一非零向量 <span class="math inline">\(\boldsymbol{x}\)</span>, 都有 <span class="math inline">\(\boldsymbol{x}^T \boldsymbol{Q x}&gt;0\)</span>,则二次型 <span class="math inline">\(\boldsymbol{x^T}\boldsymbol{Q}\boldsymbol{x}\)</span> 是正定的, 若 <span class="math inline">\(\boldsymbol{x^T} \boldsymbol{Q}\boldsymbol{x} \geq0\)</span> 则此二次型是半正定。类似的, <span class="math inline">\(\boldsymbol{x}^T \boldsymbol{Q x}&lt;0\)</span>,或者 <span class="math inline">\(\boldsymbol{x^T}\boldsymbol{Q}\boldsymbol{x} \leq 0\)</span>则说明二次型是负定或半负定的。</p><p>矩阵 <span class="math inline">\(\boldsymbol{Q}\)</span>的顺序主子式为 <span class="math inline">\(\operatorname{det}\boldsymbol{Q}\)</span> 自身以及从矩阵 <span class="math inline">\(\boldsymbol{Q}\)</span>中依次移除最后一行和最后一列获得的所有子式, 即： <span class="math display">\[\begin{aligned}&amp; \Delta_1=q_{11}, \quad \Delta_2=\left[\begin{array}{ll}q_{11}&amp; q_{12} \\q_{21} &amp; q_{22}\end{array}\right] \\&amp; \Delta_3=\operatorname{det}\left[\begin{array}{lll}q_{11} &amp;q_{12} &amp; q_{13} \\q_{21} &amp; q_{22} &amp; q_{23} \\q_{31} &amp;q_{32} &amp; q_{33}\end{array}\right], \cdots,\Delta_n=\operatorname{det} \boldsymbol{Q} \\\end{aligned}\]</span></p><blockquote><p><code>定理1</code>给定二次型 <span class="math inline">\(\boldsymbol{x}^T \boldsymbol{Q}\boldsymbol{x}\)</span> ，其中 <span class="math inline">\(\boldsymbol{Q}=\boldsymbol{Q}^T\)</span>,该二次型是正定的，当且仅当的 <span class="math inline">\(Q\)</span>顺序主子式是正定的。</p><p><code>定理2</code>对称矩阵 <span class="math inline">\(\boldsymbol{Q}\)</span> 是正定（半正定）的,当且仅当 <span class="math inline">\(\boldsymbol{Q}\)</span>的所有特征值是正的 （非负的）。</p></blockquote><h2 id="线段与超平面">2 线段与超平面</h2><h3 id="线段">2.1 线段</h3><p>对于 <span class="math inline">\(n\)</span> 维向量 <span class="math inline">\(\boldsymbol{x}=\left[x_1, x_2, \cdots,x_n\right]^T, \quad \boldsymbol{y}=\left[y_1, y_2, \cdots,y_n\right]^T\)</span>, 两点之间的所有点的集合称为两点之间的线段。如果<span class="math inline">\(z\)</span> 在这条线段上，那么有 <span class="math display">\[\boldsymbol{z}=\boldsymbol{y}+\alpha(\boldsymbol{x}-\boldsymbol{y})\quad\alpha\in[0,1]\]</span> 其中<span class="math inline">\(\boldsymbol{y}\)</span>表示这个线段的起点，<span class="math inline">\(\boldsymbol{x}-\boldsymbol{y}\)</span>表示这个线段的方向，<span class="math inline">\(\alpha\)</span>表示在这个方向上的长度的系数。</p><p>这条线段还可以表示为： <span class="math display">\[\{\alpha \boldsymbol{x}+(1-\alpha) \boldsymbol{y}: \alpha \in[0,1]\}\]</span> <span class="math inline">\(\boldsymbol{x}、\boldsymbol{y}\)</span>前的系数相加为<span class="math inline">\(1\)</span>，易于记忆。</p><h3 id="超平面">2.2 超平面</h3><p>令 <span class="math inline">\(u_1, u_2, \cdots, u_n, v \in\mathbb{R}\)</span>, 其中至少存在一个不为零的 <span class="math inline">\(u_i\)</span> 。由所有满足线性方程 <span class="math display">\[u_1 x_1+u_2 x_2+\cdots+u_n x_n=v\]</span></p><p>的点 <span class="math inline">\(\boldsymbol{x}=\left[x_1, x_2,\cdots, x_n\right]^T\)</span> 组成的集合称为空间 <span class="math inline">\(\mathbb{R}^n\)</span> 的超平面。超平面可以写为：<span class="math display">\[\left\{\boldsymbol{x} \in \mathbb{R}^n: \boldsymbol{u}^T\boldsymbol{x}=v\right\}\]</span></p><p>其中<span class="math inline">\(u=\left[u_1, u_2, \cdots,u_n\right]^T\)</span>。</p><p>注意: 超平面不一定是 <span class="math inline">\(\mathbb{R}^n\)</span> 的子空间,因为超平面通常不包含原点。而且超平面不一定是一个平面,在二维空间中就是一条直线,而三维空间中是一些普通平面。这比较好理解，因为在二维空间中可以写成<span class="math inline">\(ax+by=c\)</span>，这是一条直线；三维空间中为<span class="math inline">\(ax+by+cz=d\)</span>，表示一个平面，可以看到超平面是一个相对于<span class="math inline">\(n\)</span>维空间下的平面。</p><figure><img src="../../../../images/最优化方法知识回顾与拓展/p1.jpg" alt="p1.jpg"><figcaption aria-hidden="true">p1.jpg</figcaption></figure><p>如上图，可以把超平面 <span class="math inline">\(H=\left\{\boldsymbol{x}: u_1 x_1+\cdots+u_nx_n=v\right\}\)</span> 可以换一种形式去表述。在超平面内一点 <span class="math inline">\(\boldsymbol{a}\)</span> 和任一点 <span class="math inline">\(\boldsymbol{x}\)</span>。 <span class="math inline">\(\boldsymbol{u}\)</span> 为点 <span class="math inline">\(\boldsymbol{x}\)</span> 处的法向量，将满足 <span class="math inline">\(\boldsymbol{u^T}(\boldsymbol{x}-\boldsymbol{a})=0\)</span>于是有： <span class="math display">\[H=\left\{\boldsymbol{x} \in \mathbb{R}^n\right. :\left.\boldsymbol{u^T}(\boldsymbol{x}-\boldsymbol{a})=0\right\}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 最优化方法 </category>
          
          <category> 前置基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最优化方法 </tag>
            
            <tag> 矩阵 </tag>
            
            <tag> 线性相关 </tag>
            
            <tag> 正定 </tag>
            
            <tag> 子空间 </tag>
            
            <tag> 基 </tag>
            
            <tag> 特征值 </tag>
            
            <tag> 特征向量 </tag>
            
            <tag> 二次型 </tag>
            
            <tag> 矩阵初等变换 </tag>
            
            <tag> 方阵的逆 </tag>
            
            <tag> 超平面 </tag>
            
            <tag> 多维向量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习基础知识</title>
      <link href="/2024/03/18/shen-du-xue-xi-ji-chu-zhi-shi/"/>
      <url>/2024/03/18/shen-du-xue-xi-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<p>#深度学习基础知识</p>]]></content>
      
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 损失函数 </tag>
            
            <tag> 激活函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp算法题之奇特的迷宫</title>
      <link href="/2024/03/18/cpp-suan-fa-ti-qi-te-de-mi-gong/"/>
      <url>/2024/03/18/cpp-suan-fa-ti-qi-te-de-mi-gong/</url>
      
        <content type="html"><![CDATA[<h1 id="蓝桥算法题奇特的迷宫">蓝桥算法题：奇特的迷宫</h1><p>题目来自蓝桥题库：<a href="https://www.lanqiao.cn/problems/1994/learning/?page=1&amp;first_category_id=1&amp;problem_id=1994">1.奇特的迷宫- 蓝桥云课 (lanqiao.cn)</a></p><h2 id="编号1994">编号：1994</h2><p><strong>题目：</strong></p><p>如以下图(a)所示的15行、15列的迷宫(相当于n=8)，迷宫中每个位置可能为S（表示起始位置）、D（表示目标位置）、1～9的数字，且S和D各只有1个。对于1～9的数字，表示从当前位置出发，可以沿上、下、左、右方向走的方格数（多一个、少一个方格都不行）；图(b)演示的是，数字2表示可以沿上、下、左、右方向走2个方格，到达的位置用星号（*）表示。从S出发，可以沿上、下、左、右方向走1个方格。现在要求从S到D的最少步数。</p><p><img src="/../images/lanqiao1994.jpg"></p><p><strong>输入描述：</strong></p><p>输入文件中包含多个测试数据。每个测试数据的第1行为一个整数n，2≤n≤10，表示迷宫的大小为2n-1行、2n-1列。接下来有2n-1行，为每行各位置上的数字（或者为S、D），第1行有1个字符，第2行有2个字符，…，第n行有n个字符，第n+1行有n-1个字符，…，第2n-1行有1个字符。输入文件中最后一行为0，表示测试数据结束。</p><p><strong>输出描述：</strong></p><p>对每个测试数据，如果能从S走到D，输出最少步数；否则（即从S走不到D），输出0。</p><p><strong>解答：</strong></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> g[<span class="number">2</span> * N][<span class="number">2</span> * N];</span><br><span class="line"><span class="type">int</span> d[<span class="number">2</span> * N][<span class="number">2</span> * N];</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = {{<span class="number">2</span>, <span class="number">0</span>}, {<span class="number">0</span>, <span class="number">2</span>}, {<span class="number">0</span>, <span class="number">-2</span>}, {<span class="number">-2</span>, <span class="number">0</span>}};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">//多组数据</span></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n) {</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="string">'.'</span>, <span class="built_in">sizeof</span>(g));</span><br><span class="line">        <span class="comment">//将地图存入二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">            <span class="type">int</span> l = n - i + <span class="number">1</span>;</span><br><span class="line">            string str;</span><br><span class="line">            cin &gt;&gt; str;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) {</span><br><span class="line">                g[i][l] = str[j];</span><br><span class="line">                l += <span class="number">2</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//将地图存入二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="type">int</span> l = i - n + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> s = n - (i - n);</span><br><span class="line">            string str;</span><br><span class="line">            cin &gt;&gt; str;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s; j++) {</span><br><span class="line">                g[i][l] = str[j];</span><br><span class="line">                l += <span class="number">2</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//将起点和终点下标计算出来</span></span><br><span class="line">        <span class="type">int</span> sx = <span class="number">0</span>, sy = <span class="number">0</span>, ex = <span class="number">0</span>, ey = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * n - <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">'S'</span>) {</span><br><span class="line">                    sx = i;</span><br><span class="line">                    sy = j;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">'D'</span>) {</span><br><span class="line">                    ex = i;</span><br><span class="line">                    ey = j;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//优先队列 存放了x,y,d1   x,y是下标  d1是到达该点的步数</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, vector&lt;pair&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; &gt; pq;</span><br><span class="line">        <span class="comment">//初始化到达所有下标的距离为0x3f3f3f3f表示无穷大无法到达</span></span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">        <span class="comment">//到起点的距离为0  因为开始就在起点</span></span><br><span class="line">        d[sx][sy] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//设置为1，因为从起点可以往上下左右走1步</span></span><br><span class="line">        g[sx][sy]=<span class="string">'1'</span>;</span><br><span class="line">        <span class="comment">//将起点加入到 队列中</span></span><br><span class="line">        pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="built_in">make_pair</span>(sx, sy)));</span><br><span class="line">        <span class="comment">//ans是记录到达终点的距离，初始无穷大，表示无法到达</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//BFS模板</span></span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">auto</span> cur = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> x = cur.second.first, y = cur.second.second, d1 = cur.first;</span><br><span class="line">            <span class="comment">//如果当前是终点，记录答案直接退出</span></span><br><span class="line">            <span class="keyword">if</span> (x == ex &amp;&amp; y == ey) {</span><br><span class="line">                ans = d1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//当前下标可以往上下左右走step步</span></span><br><span class="line">            <span class="type">int</span> step = (<span class="type">int</span>)(g[x][y] - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">                <span class="comment">//nx,ny表示新的下标</span></span><br><span class="line">                <span class="type">int</span> nx = x + dir[i][<span class="number">0</span>] * step;</span><br><span class="line">                <span class="type">int</span> ny = y + dir[i][<span class="number">1</span>] * step; </span><br><span class="line">                <span class="comment">//判断非法和边界情况的下标，不对就不执行下面代码</span></span><br><span class="line">                <span class="keyword">if</span> (nx &lt; <span class="number">1</span> || ny &lt; <span class="number">1</span> || nx &gt;= <span class="number">2</span> * n || ny &gt;= <span class="number">2</span> * n || g[nx][ny] == <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//如果到（nx ny 的步数) 大于 (x,y步数+1) ，表示可以把nx,ny步数更新的更小，同时把nx,ny加入到队列中</span></span><br><span class="line">                <span class="keyword">if</span> (d[nx][ny] &gt; d[x][y] + <span class="number">1</span>) {</span><br><span class="line">                    d[nx][ny] = d[x][y] + <span class="number">1</span>;</span><br><span class="line">                    pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(d[nx][ny], <span class="built_in">make_pair</span>(nx, ny)));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ans是记录到达终点的距离，初始无穷大，表示无法到达 ，如果到最后还是无法到达，输出0</span></span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树基于int类型key与Object类型value简单实现</title>
      <link href="/2024/03/18/binarysearchtree/"/>
      <url>/2024/03/18/binarysearchtree/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉搜索树基于int类型key与object类型value简单实现">二叉搜索树基于int类型key与Object类型value简单实现</h1><p><strong><em>403行代码没有一句废话,写的太累,后续闲下来了再补全注释与思路,后面可能还会实现基于泛型K,Vkey与value的实现</em></strong></p><p>以下只提供代码(部分方法使用递归与非递归两种方法实现):</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BSTree1</span> {</span><br><span class="line">    BSTNode root;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BSTNode</span> {</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        Object value;</span><br><span class="line">        BSTNode left;</span><br><span class="line">        BSTNode right;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BSTNode</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BSTNode</span><span class="params">(<span class="type">int</span> key, Object value)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BSTNode</span><span class="params">(<span class="type">int</span> key, Object value, BSTNode left, BSTNode right)</span> {</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">查找关键字对应的值</span></span><br><span class="line"><span class="comment">递归实现</span></span><br><span class="line"><span class="comment">@param key - 关键字</span></span><br><span class="line"><span class="comment">@return 关键字对应的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*    </span></span><br><span class="line"><span class="comment">      public Object get(int key) {</span></span><br><span class="line"><span class="comment">          return doGet(root, key);</span></span><br><span class="line"><span class="comment">      }</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">      private Object doGet(BSTNode node, int key) {</span></span><br><span class="line"><span class="comment">          if (node == null) {</span></span><br><span class="line"><span class="comment">              return null;</span></span><br><span class="line"><span class="comment">          }</span></span><br><span class="line"><span class="comment">          if (node.key &lt; key) {</span></span><br><span class="line"><span class="comment">              return doGet(node.right, key);</span></span><br><span class="line"><span class="comment">          } else if (key &lt; node.key) {</span></span><br><span class="line"><span class="comment">              return doGet(node.left, key);</span></span><br><span class="line"><span class="comment">          } else {</span></span><br><span class="line"><span class="comment">              return node.value;</span></span><br><span class="line"><span class="comment">          }</span></span><br><span class="line"><span class="comment">      }</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     &lt;h3&gt;查找关键字对应的值&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">     非递归实现</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     <span class="doctag">@param</span> key 关键字</span></span><br><span class="line"><span class="comment">     <span class="doctag">@return</span> 关键字对应的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (node.key &lt; key) {</span><br><span class="line">                node = node.right;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; node.key) {</span><br><span class="line">                node = node.left;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> node.value;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 查找最小关键字对应的值</span></span><br><span class="line"><span class="comment">       * 递归实现</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> 关键字对应的值</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"><span class="comment">//    public Object min() {</span></span><br><span class="line"><span class="comment">//        return doMin(root);</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    private Object doMin(BSTNode node) {</span></span><br><span class="line"><span class="comment">//        if (node == null) {</span></span><br><span class="line"><span class="comment">//            return null;</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line"><span class="comment">//        if (node.left == null) {</span></span><br><span class="line"><span class="comment">//            return node.value;</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line"><span class="comment">//        return doMin(node.left);</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h3&gt;查找最小关键字对应的值&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">     * 非递归实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 关键字对应的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">min</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> min(root);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">min</span><span class="params">(BSTNode node)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="literal">null</span>) {</span><br><span class="line">            p = p.left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> p.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 查找最大关键字对应的值</span></span><br><span class="line"><span class="comment">       * 递归实现</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> 关键字对应的值</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> Object <span class="title function_">max</span><span class="params">()</span> {</span><br><span class="line">          <span class="keyword">return</span> doMax(root);</span><br><span class="line">      }</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">private</span> Object <span class="title function_">doMax</span><span class="params">(BSTNode node)</span>{</span><br><span class="line">          <span class="keyword">if</span> (node == <span class="literal">null</span>){</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">if</span> (node.right == <span class="literal">null</span>){</span><br><span class="line">              <span class="keyword">return</span> node.value;</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">return</span> doMax(node.right);</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h3&gt;查找最大关键字对应的值&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">     * 非递归实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 关键字对应的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">max</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> max(root);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">max</span><span class="params">(BSTNode node)</span> {</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="keyword">while</span> (p.right != <span class="literal">null</span>) {</span><br><span class="line">            p = p.right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> p.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;H3&gt;存储关键字和对应值&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   关键字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, Object value)</span> {</span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) {</span><br><span class="line">            parent = node;</span><br><span class="line">            <span class="keyword">if</span> (node.key &lt; key) {</span><br><span class="line">                node = node.right;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; node.key) {</span><br><span class="line">                node = node.left;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                node.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">null</span>) {</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">BSTNode</span>(key, value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (key &lt; parent.key) {</span><br><span class="line">            parent.left = <span class="keyword">new</span> <span class="title class_">BSTNode</span>(key, value);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            parent.right = <span class="keyword">new</span> <span class="title class_">BSTNode</span>(key, value);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h3&gt;查找关键字的后驱值&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 情况1:节点有右子树,此时后任就是右子树的最小值&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 情况2:节点没有右子树,若离它最近的,自右而来的祖先就是后任</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 关键字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 前驱值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">successor</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">ancestorFromRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//这个循环先查找该key在树中是否存在</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (key &lt; p.key) {</span><br><span class="line">                ancestorFromRight = p;</span><br><span class="line">                p = p.left;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (p.key &lt; key) {</span><br><span class="line">                p = p.right;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (p.right != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> min(p.right);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ancestorFromRight != <span class="literal">null</span> ? ancestorFromRight.value : <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h3&gt;查找关键字的前继值&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 情况1:节点有左子树,此时前任就是左子树的最大值&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 情况2:节点没有左子树,若离它最近的,自左而来的祖先就是前任</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 关键字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 后继值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">predecessor</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            思路:</span></span><br><span class="line"><span class="comment">                先找当当前节点,如果没找到直接返回null</span></span><br><span class="line"><span class="comment">                然后判断第一种情况,当左子树不为null时,找到左子树中最大的并返回</span></span><br><span class="line"><span class="comment">                然后判断第二种情况,创建一个指针用于记录从左而来的祖先节点,最后如果从左而来的祖先节点不为null则返回</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">ancestorFromLeft</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//这个循环先查找该key在树中是否存在</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (key &lt; p.key) {</span><br><span class="line">                p = p.left;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (p.key &lt; key) {</span><br><span class="line">                ancestorFromLeft = p;</span><br><span class="line">                p = p.right;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (p.left != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> max(p.left);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ancestorFromLeft != <span class="literal">null</span> ? ancestorFromLeft.value : <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h3&gt;根据关键字删除&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">     * 非递归实现</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 情况1:删除节点没有左孩子,将右孩子托孤给Parent&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 情况2:删除节点没有右孩子,将左孩子托孤给Parent&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 情况3:删除的是叶子节点,这种情况处理方法可以涵盖到情况1,2中&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 情况4:删除节点的左右孩子都有,可以将它的后继节点(称为S) 托孤给Parent,再称S的父亲为SP,又分两种情况:&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;1:SP就是被删除节点,此时D与S紧邻,只需要将S托孤给Parent&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;2:SP不是被删除节点,此时D与S不相邻,此时需要将S的后代托孤给SP,再将S托孤给Parent&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 关键字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 被删除关键字对应的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">delete</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="comment">//首先也应该先找到该节点与该节点的父节点</span></span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">BSTNode</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//用于记录待删除节点的父亲</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (key &lt; p.key) {</span><br><span class="line">                parent = p;</span><br><span class="line">                p = p.left;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (p.key &lt; key) {</span><br><span class="line">                parent = p;</span><br><span class="line">                p = p.right;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//这是情况1</span></span><br><span class="line">        <span class="keyword">if</span> (p.left == <span class="literal">null</span>) {</span><br><span class="line">            shift(parent, p, p.right);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//这是情况2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.right == <span class="literal">null</span>) {</span><br><span class="line">            shift(parent, p, p.left);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//这是情况4</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//首先找到被删除节点的后继</span></span><br><span class="line">            <span class="type">BSTNode</span> <span class="variable">s</span> <span class="operator">=</span> p.right;</span><br><span class="line">            <span class="type">BSTNode</span> <span class="variable">sParent</span> <span class="operator">=</span> p; <span class="comment">//用来记录后继节点的父亲</span></span><br><span class="line">            <span class="keyword">while</span> (s.left != <span class="literal">null</span>) {</span><br><span class="line">                sParent = s;</span><br><span class="line">                s = s.left;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//循环结束后 s 就是后继节点</span></span><br><span class="line">            <span class="comment">//接下来判断是否需要处理被删除节点的后事</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                思路:</span></span><br><span class="line"><span class="comment">                    如果后继节点的sParent还是被删除节点,那么意味着被删除节点与后继节点紧邻,不用处理后事</span></span><br><span class="line"><span class="comment">                    如果后继节点的sParent不再是被删除节点,那么意味着被删除节点不与后继节点相邻,需要处理后事</span></span><br><span class="line"><span class="comment">                    因此先判断后继节点的sParent还是不是被删除节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//不相邻,处理后继节点的后事</span></span><br><span class="line">            <span class="keyword">if</span> (sParent != p) {</span><br><span class="line">                shift(sParent, s, s.right); <span class="comment">//s的后继节点不可能有左孩子,因为s就是最小的</span></span><br><span class="line">                s.right = p.right; <span class="comment">//改变指针,顶上去的后继节点的右指针应该指向被删除节点的右指针</span></span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//最后让后继节点顶上被删除节点就完成</span></span><br><span class="line">            shift(parent, p, s);</span><br><span class="line">            <span class="comment">//删除后,改变顶上来的节点的左右指针,指向被删除节点的左右孩子</span></span><br><span class="line">            s.left = p.left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> p.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 根据关键字删除</span></span><br><span class="line"><span class="comment">       * &lt;p&gt;递归实现&lt;/p&gt;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> key 关键字</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> 被删除关键字对应的值</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> Object <span class="title function_">delete</span><span class="params">(<span class="type">int</span> key)</span> {</span><br><span class="line">          ArrayList&lt;Object&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//保存被删除节点的值</span></span><br><span class="line">          root = doDelete(root, key, result);</span><br><span class="line">          <span class="keyword">return</span> result.isEmpty() ? <span class="literal">null</span> : result.get(<span class="number">0</span>);</span><br><span class="line">      }</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      /**</span></span><br><span class="line"><span class="comment">       * 用于递归delete方法的内部方法</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * @param node 代表递归删除的起点</span></span><br><span class="line"><span class="comment">       * @param key  关键字</span></span><br><span class="line"><span class="comment">       * @return 被删除节点删除后剩下的孩子节点</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">private</span> BSTNode <span class="title function_">doDelete</span><span class="params">(BSTNode node, <span class="type">int</span> key, ArrayList&lt;Object&gt; result)</span> {</span><br><span class="line">          <span class="comment">//如下三个if条件在于找要删除节点</span></span><br><span class="line">          <span class="keyword">if</span> (node == <span class="literal">null</span>) {</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">if</span> (key &lt; node.key) {</span><br><span class="line">              node.left = doDelete(node.left, key, result);</span><br><span class="line">              <span class="keyword">return</span> node;</span><br><span class="line">          } <span class="keyword">else</span> <span class="keyword">if</span> (node.key &lt; key) {</span><br><span class="line">              node.right = doDelete(node.right, key, result);</span><br><span class="line">              <span class="keyword">return</span> node;</span><br><span class="line">          }</span><br><span class="line">          result.add(node.value);</span><br><span class="line">          <span class="comment">//如果执行到这里,代表已经找到了要删除节点</span></span><br><span class="line">          <span class="comment">//如果被删除节点只有一个孩子</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          if (node.left == null) {</span></span><br><span class="line"><span class="comment">              return node.right;</span></span><br><span class="line"><span class="comment">          }</span></span><br><span class="line"><span class="comment">          if (node.right == null) {</span></span><br><span class="line"><span class="comment">              return node.left;</span></span><br><span class="line"><span class="comment">          }</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          <span class="comment">//如果被删除节点有两个孩子</span></span><br><span class="line">          <span class="comment">//先找到后继节点,也就是右子树中最小的</span></span><br><span class="line"><span class="comment">//        BSTNode s = node.right;</span></span><br><span class="line">          <span class="comment">//一直向左走,走到头就是后继节点</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          while (s.left != null) {</span></span><br><span class="line"><span class="comment">              s = s.left;</span></span><br><span class="line"><span class="comment">          }</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          <span class="comment">//这里已经拿到了后继节点</span></span><br><span class="line">          <span class="comment">//顶上去之后,修改后继节点的指针</span></span><br><span class="line">          <span class="comment">//第四种情况,如果后继节点与被删除节点不相邻,那么应该先处理后继节点的后事</span></span><br><span class="line">          <span class="comment">//再次递归调用</span></span><br><span class="line"><span class="comment">//        s.right = doDelete(node.right, s.key, new ArrayList&lt;&gt;());</span></span><br><span class="line"><span class="comment">//        s.left = node.left;</span></span><br><span class="line">          <span class="comment">//最后返回s,也就是被删除节点剩下的孩子节点</span></span><br><span class="line"><span class="comment">//        return s;</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 托孤方法,用于将被删除节点的子树移交给被删除节点的父节点&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent  被删除节点的父节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> deleted 要被删除的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> child   被顶上去的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">shift</span><span class="params">(BSTNode parent, BSTNode deleted, BSTNode child)</span> {</span><br><span class="line">        <span class="comment">//如果被删除节点本身就是根节点,那么被删除节点没有parent,直接将被删除节点的child变为root</span></span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">null</span>) {</span><br><span class="line">            root = child;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (deleted == parent.left) {</span><br><span class="line">            parent.left = child;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            parent.right = child;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> Java </category>
          
          <category> 二叉搜索树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉搜索树 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个重要的反常积分</title>
      <link href="/2024/03/18/yi-ge-chong-yao-de-fan-chang-ji-fen/"/>
      <url>/2024/03/18/yi-ge-chong-yao-de-fan-chang-ji-fen/</url>
      
        <content type="html"><![CDATA[<h1 id="一个重要的反常积分">一个重要的反常积分</h1><p>本文主要写一下反常积分<span class="math inline">\(\begin{aligned} A&amp; =\int_0^{+\infty} e^{-x^2} dx\end{aligned}\)</span>的结果及他(或变形)的计算方法，<span class="math inline">\(\begin{aligned} \int_0^{+\infty} e^{-x^2} dx\end{aligned}\)</span>是一个非常重要的反常积分，在高数、概率论中有重要的应用。</p><h2 id="方法一二重积分">方法一：二重积分</h2><p><span class="math display">\[\begin{align}A&amp;=\int_0^{+\infty} e^{-x^2} d x \\ &amp;=\sqrt{\left(\int_0^{+\infty} e^{-x^2} d x \cdot \int_0^{+\infty}e^{-x^2} d x\right)} \\ &amp; =\sqrt{\left(\int_0^{+\infty} e^{-x^2} d x\cdot \int_0^{+\infty} e^{-y^2} d y\right)} \\ &amp;=\sqrt{\int_0^{+\infty} \int_0^{+\infty} e^{-\left(x^2+y^2\right)} d x dy}\end{align}\]</span></p><blockquote><p>import 夹逼定理</p></blockquote><p>​这个样子就非常非常像一个二重积分的样子了，可以利用二重积分的计算方法进行计算：</p><figure><img src="../../../../images/一个重要的反常积分/p1.jpg" alt="p1.jpg"><figcaption aria-hidden="true">p1.jpg</figcaption></figure><p>​ 如上图所示，设： <span class="math display">\[\begin{aligned} &amp; D_1=\left\{(x, y) \mid x^2+y^2 \leqslant R^2, x\geqslant 0, y \geqslant 0\right\} \\ &amp; \left.D_2=\{x, y) \midx^2+y^2 \leqslant 2 R^2, x \geqslant 0, y \geqslant 0\right\} \\ &amp;S=\{(x, y) \mid 0 \leqslant x \leqslant R, 0 \leqslant y \leqslantR\}\end{aligned}\]</span> ​ 显然有：<span class="math inline">\(D_1 \subset S \subsetD_2\)</span>。</p><p>​ 因为：<span class="math inline">\(e^{-x^2-y^2}&gt;0\)</span>，所以：<span class="math display">\[\iint_{D_1} e^{-x^2-y^2} d x d y \leq \iint_S e^{-x^2-y^2} d x d y \leq\iint_{D_2} e^{-x^2-y^2} d x d y\]</span> ​ 分别对<span class="math inline">\(S、D_1、D_2\)</span>积分：<span class="math display">\[\left\{\begin{array}{l}\displaystyle I=\iint_S e^{-x^2-y^2} d x d y=\int_0^R e^{-x^2} d x\int_0^R e^{-y^2} d y=\left(\int_0^R e^{-x^2} d x\right)^2\\\displaystyle I_1=\iint_{D_1} e^{-x^2-y^2} d x dy=\frac{\pi}{4}\left(1-e^{-R^2}\right) \\\displaystyle I_2=\iint_{D_2}e^{-x^2-y^2} d x d y=\frac{\pi}{4}\left(1-e^{-2 R^2}\right)\end{array}\right.\]</span> ​ 有不等关系：<span class="math inline">\(I_1&lt;I&lt;I_2\)</span>。</p><p>​ 当<span class="math inline">\(R \rightarrow\infty\)</span> 时, <span class="math inline">\(I_1 \rightarrow \dfrac{\pi}{4}, I_2 \rightarrow\dfrac{\pi}{4}\)</span>，由<mark class="hl-label blue">夹逼定理</mark>  ：</p><p>​ 当<span class="math inline">\(R \rightarrow\infty\)</span> 时, <span class="math inline">\(I\rightarrow \dfrac{\pi}{4}\)</span>。即：<span class="math inline">\(\begin{aligned} \left(\int_0^{+\infty} e^{-x^2} dx\right)^2\end{aligned}=\dfrac{\pi}{4}\)</span>。</p><p>​ 所以<span class="math inline">\(\begin{aligned} A &amp;=\int_0^{+\infty} e^{-x^2} dx\end{aligned}=\dfrac{\sqrt{\pi}}{2}\)</span></p><blockquote><p>import 极坐标</p></blockquote><p>​ 也可以理解成这是在极坐标下对一个半径为<span class="math inline">\(+\infty\)</span>，在第一象限的扇形进行积分，设<span class="math inline">\(r^2=(x^2+y^2)\)</span>，也就是： <span class="math display">\[\begin{align}A^2&amp;= \int_0^{\frac{\pi}{2}} d\theta \int_0^{+\infty} e^{-r^2} r dr\\&amp;= \dfrac{\pi}{2} \int_0^{+\infty} e^{-r^2} r dr \\ &amp;=\dfrac{\pi}{4} \int_0^{+\infty} e^{-u} du \quad(u=r^2) \\&amp;=\dfrac{\pi}{4}\end{align}\]</span> ​ 所以<span class="math inline">\(\begin{aligned} A &amp;=\int_0^{+\infty} e^{-x^2} dx\end{aligned}=\dfrac{\sqrt{\pi}}{2}\)</span></p><h2 id="方法二标准正态分布">方法二：标准正态分布</h2><p>设<span class="math inline">\(r.v.X \simN\left(0,1\right)\)</span>，则<span class="math inline">\(X\)</span>的密度函数为： <span class="math display">\[p(x)=\frac{1}{\sqrt{2 \pi }} e^{-\frac{x^2}{2}},-\infty&lt;x&lt;+\infty\]</span> 由密度函数的正则性： <span class="math display">\[\int_0^{+\infty} \varphi(x) d x=\int_0^{+\infty} \frac{1}{\sqrt{2 \pi}}e^{-\frac{x^2}{2}} d x=\frac{1}{2}\]</span> 移项得：<span class="math inline">\(\begin{aligned} A &amp;=\int_0^{+\infty} e^{-x^2} dx\end{aligned}=\dfrac{\sqrt{\pi}}{2}\)</span></p><h2 id="方法三gamma函数">方法三：<span class="math inline">\(Gamma\)</span>函数</h2><p>​ <span class="math inline">\(Gamma\)</span>函数是一个特殊的函数，它的定义如下：<span class="math display">\[\Gamma(z)=\int_0^{\infty} t^{z-1} e^{-t} \mathrm{~d} t\]</span> ​ 在这里只介绍<span class="math inline">\(Gamma\)</span>函数的几个性质：</p><p>​ <code>性质1.</code><span class="math inline">\(\Gamma(z)\)</span>与阶乘的关系</p><p><span class="math display">\[\begin{aligned} \Gamma(z) &amp; =\int_0^{\infty} t^{z-1} e^{-t} d t \\&amp; =\left.t^{z-1}\left(-e^{-t}\right)\right|_0 ^{\infty}+(z-1)\int_0^{\infty} t^{z-2} e^{-t} d t \\ &amp; =(z-1) \int_0^{\infty}t^{(z-1)-1} e^{-t} d t \\ &amp; =(z-1) \Gamma(z-1)\end{aligned}\]</span> ​ 令<span class="math inline">\(z=1\)</span>有： <span class="math display">\[\Gamma(1)=\int_0^{\infty} e^{-t} \mathrm{~d} t=-\left.e^{-t}\right|_0^{\infty}=1\]</span> ​ <strong>当<span class="math inline">\(z\)</span>为整数时</strong>，有：<span class="math inline">\(\Gamma(z+1)=z\Gamma(z)=z(z-1)\Gamma(z-2)=\cdots=z(z-1)(z-2)\cdots1=z!\)</span></p><p>​ <code>性质2.</code><span class="math inline">\(\Gamma(\dfrac{1}{2})=\sqrt\pi\)</span> <span class="math display">\[\begin{aligned}    \Gamma(1/2)&amp;= \int_0^{+\infty} x^{-1/2} e^{-x} dx \\&amp;=\int_0^{+\infty} t^{-1} e^{-t^2} dt^2 \\ &amp;= \int_0^{+\infty} 2e^{-t^2} dt \\ &amp;= 2\cdot \dfrac{\sqrt\pi}{2} \\ &amp;= \sqrt\pi\end{aligned}\]</span> ​ 利用<span class="math inline">\(Gamma\)</span>函数计算一些变形式子的积分值： <span class="math display">\[\begin{aligned} &amp; \int_0^{+\infty} {x}^3 \mathrm{e}^{-2 {x}}{dx}=\frac{1}{16} \int_0^{+\infty}(2 {x})^3 \mathrm{e}^{-2{x}}\mathrm{d}(2 {x})=\frac{1}{16} \Gamma(3+1)=\frac{3 !}{16}=\frac{3}{8} \\&amp; \int_0^{+\infty} {x}^4 \mathrm{e}^{-{x}^2} {dx}=\frac{1}{2}\int_0^{+\infty}\left({x}^2\right)^{\frac{3}{2}}\mathrm{e}^{-{x}^2}{dx}=\frac{1}{2}\Gamma\left(\frac{3}{2}+1\right)=\frac{1}{2} \frac{3}{2}\Gamma\left(\frac{1}{2}+1\right)=\frac{1}{2} \frac{3}{2} \frac{1}{2}\Gamma\left(\frac{1}{2}\right)=\frac{1}{2} \frac{3}{2} \frac{1}{2}\sqrt{\pi}=\frac{3}{8} \sqrt{\pi}\end{aligned}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 杂但重要的文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反常积分 </tag>
            
            <tag> 二重积分 </tag>
            
            <tag> 夹逼定理 </tag>
            
            <tag> 正态分布 </tag>
            
            <tag> gamma函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一节 多元函数的基本概念</title>
      <link href="/2024/03/17/9-1-duo-yuan-han-shu-de-ji-ben-gai-nian/"/>
      <url>/2024/03/17/9-1-duo-yuan-han-shu-de-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iHV6q1si4t6h">下载PDF点这里</a></p><figure><img src="../../../../images/9-1多元函数的基本概念/39.jpg" alt="39.jpg"><figcaption aria-hidden="true">39.jpg</figcaption></figure><figure><img src="../../../../images/9-1多元函数的基本概念/40.jpg" alt="40.jpg"><figcaption aria-hidden="true">40.jpg</figcaption></figure><figure><img src="../../../../images/9-1多元函数的基本概念/41.jpg" alt="41.jpg"><figcaption aria-hidden="true">41.jpg</figcaption></figure><figure><img src="../../../../images/9-1多元函数的基本概念/42.jpg" alt="42.jpg"><figcaption aria-hidden="true">42.jpg</figcaption></figure><figure><img src="../../../../images/9-1多元函数的基本概念/43.jpg" alt="43.jpg"><figcaption aria-hidden="true">43.jpg</figcaption></figure><figure><img src="../../../../images/9-1多元函数的基本概念/44.jpg" alt="44.jpg"><figcaption aria-hidden="true">44.jpg</figcaption></figure><figure><img src="../../../../images/9-1多元函数的基本概念/45.jpg" alt="45.jpg"><figcaption aria-hidden="true">45.jpg</figcaption></figure><figure><img src="../../../../images/9-1多元函数的基本概念/46.jpg" alt="46.jpg"><figcaption aria-hidden="true">46.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第九章 多元函数微分法及其应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多元函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二节 偏导数</title>
      <link href="/2024/03/17/9-2-pian-dao-shu/"/>
      <url>/2024/03/17/9-2-pian-dao-shu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iiaW51si6lbg">下载PDF点这里</a></p><figure><img src="../../../../images/9-2偏导数/47.jpg" alt="47.jpg"><figcaption aria-hidden="true">47.jpg</figcaption></figure><figure><img src="../../../../images/9-2偏导数/48.jpg" alt="48.jpg"><figcaption aria-hidden="true">48.jpg</figcaption></figure><figure><img src="../../../../images/9-2偏导数/49.jpg" alt="49.jpg"><figcaption aria-hidden="true">49.jpg</figcaption></figure><figure><img src="../../../../images/9-2偏导数/50.jpg" alt="50.jpg"><figcaption aria-hidden="true">50.jpg</figcaption></figure><figure><img src="../../../../images/9-2偏导数/51.jpg" alt="51.jpg"><figcaption aria-hidden="true">51.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 多元微积分 </category>
          
          <category> 第九章 多元函数微分法及其应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多元函数 </tag>
            
            <tag> 偏导数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二节 微积分基本公式</title>
      <link href="/2024/03/17/yi-yuan-wei-ji-fen-5-2-wei-ji-fen-ji-ben-gong-shi/"/>
      <url>/2024/03/17/yi-yuan-wei-ji-fen-5-2-wei-ji-fen-ji-ben-gong-shi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wwb.lanzouj.com/iJ4z91smgcqb">下载PDF点这里</a></p><figure><img src="../../../../images/一元微积分5-2微积分基本公式/104.jpg" alt="104.jpg"><figcaption aria-hidden="true">104.jpg</figcaption></figure><figure><img src="../../../../images/一元微积分5-2微积分基本公式/105.jpg" alt="105.jpg"><figcaption aria-hidden="true">105.jpg</figcaption></figure><figure><img src="../../../../images/一元微积分5-2微积分基本公式/106.jpg" alt="106.jpg"><figcaption aria-hidden="true">106.jpg</figcaption></figure><figure><img src="../../../../images/一元微积分5-2微积分基本公式/107.jpg" alt="107.jpg"><figcaption aria-hidden="true">107.jpg</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
          <category> 一元微积分 </category>
          
          <category> 第五章 定积分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 定积分 </tag>
            
            <tag> 牛顿-莱布尼茨公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零篇 数列递推</title>
      <link href="/2024/03/17/shu-lie-di-tui/"/>
      <url>/2024/03/17/shu-lie-di-tui/</url>
      
        <content type="html"><![CDATA[<h1 id="第零篇-数列递推">第零篇 数列递推</h1><h2 id="partⅰ-一阶常系数线性齐次递推">PartⅠ 一阶常系数线性齐次递推</h2><p>​ 若数列<span class="math inline">\(\{a_n\}\)</span>满足以下形式：<span class="math display">\[a_{n+1}=pa_n+q\quad(p\neq0)\]</span> ​ 其中<span class="math inline">\(p、q\)</span>为给定的实数，数列首项为<span class="math inline">\(a_1\)</span>。</p><p>​ 称这个数列满足一阶常系数线性齐次递推的形式。</p><p>​ 这种数列的通项公式很容易求，可以分成两种情况：</p><p>​ <code>1.</code> 若<span class="math inline">\(p=1\)</span>，则<span class="math inline">\(a_{n+1}=a_{n}+q\)</span>，此时数列为一个公差为<span class="math inline">\(q\)</span>的等差数列，容易推得： <span class="math display">\[a_n=a_1+(n-1)q\]</span></p><p>​ <code>2.</code> 若<span class="math inline">\(p\neq1\)</span>，则可以通过<strong>待定系数法</strong> 来构造等比数列：假设存在一个系数<span class="math inline">\(A\)</span>，使得<span class="math inline">\(a_{n+1}=pa_n+q\)</span>可以写成<span class="math inline">\(a_{n+1}-A=p(a_n-A)\)</span>的形式，这样做的目的是为了转换成一个等比数列的形式，之后就可以进行递推来求解数列通项。</p><p>​ 将<span class="math inline">\(a_{n+1}-A=p(a_n-A)\)</span>展开：<span class="math inline">\(a_{n+1}=pa_n+(1-p)A\)</span>与<span class="math inline">\(a_{n+1}=pa_n+q\)</span>对比，解出系数<span class="math inline">\(A=\dfrac{q}{1-p}\)</span>。</p><p>​ 所以<span class="math inline">\(\left\{a_{n+1}-\dfrac{q}{1-p}\right\}\)</span>是首项为<span class="math inline">\(a_1-\dfrac{q}{1-p}\)</span>，公比为<span class="math inline">\(q\)</span>的等比数列，由等比数列递推公式(累乘)：<span class="math display">\[a_n=\dfrac{a_n}{a_{n-1}}\times\dfrac{a_{n-1}}{a_{n-2}}\times\cdots\times\dfrac{a_2}{a_{1}}\times{a_1}\]</span> ​ 可以推出：<span class="math inline">\(a_n-\dfrac{q}{1-p}=\left(a_1-\dfrac{q}{1-p}\right)q^{n-1}\)</span>，进而求得：<span class="math display">\[a_n=\left(a_1-\dfrac{q}{1-p}\right)p^{n-1}+\dfrac{q}{1-p}\]</span></p><h2 id="partⅱ-二阶常系数线性齐次递推">PartⅡ 二阶常系数线性齐次递推</h2><p>​ 若数列<span class="math inline">\(\{x_n\}\)</span>满足以下形式：<span class="math display">\[x_{n+1}=px_{n}+qx_{n-1}\quad(p、q\neq0)\]</span> ​ 其中<span class="math inline">\(p、q\)</span>为给定的实数，数列第一项和第二项分别为<span class="math inline">\(x_1\)</span>和<span class="math inline">\(x_2\)</span>。</p><p>​ 称这个数列满足二阶常系数线性齐次递推的形式。</p><p>​类比于一阶递推形式中构造等比数列的方法，我们还是尝试<strong>待定系数法</strong>构造这样的等比数列：</p><p>​ 假设存在实数<span class="math inline">\(a、b\)</span>，使得<span class="math inline">\(x_{n+1}=px_{n}+qx_{n-1}\)</span>可以写成<span class="math inline">\(x_{n+1}-ax_{n}=b(x_{n}-ax_{n-1})\)</span>，整理一下：<span class="math inline">\(x_{n+1}=(a+b)x_{n}-abx_{n-1}\)</span>，对比系数有：<span class="math display">\[\left\{\begin{array}{2}a+b=p \\ ab=-q\end{array}\right.\]</span> ​ 这个形式就非常像初中学过的一元二次方程，实数<span class="math inline">\(a、b\)</span>是方程<span class="math inline">\(x^2-px-q=0\)</span>的解。</p><p>​ <code>1.</code>方程解不相等<span class="math inline">\((a\neqb)\)</span>时：</p><p>​ 所以<span class="math inline">\(\{x_{n+1}-ax_n\}\)</span>是公比为<span class="math inline">\(b\)</span>的等比数列，由累乘得到：<span class="math inline">\(x_{n+1}-ax_n=(x_2-ax_1)b^{n-1}\)</span></p><p>​ <span class="math inline">\(x_{n+1}-ax_{n}=b(x_{n}-ax_{n-1})\)</span>还可以写成<span class="math inline">\(x_{n+1}-bx_{n}=a(x_{n}-bx_{n-1})\)</span>的形式，因此<span class="math inline">\(\{x_{n+1}-bx_n\}\)</span>是公比为<span class="math inline">\(a\)</span>的等比数列，累乘得到：<span class="math inline">\(x_{n+1}-bx_n=(x_2-bx_1)a^{n-1}\)</span></p><p>​ 将累乘得到的两个式子相减有： <span class="math display">\[x_n=\dfrac{x_2-bx_1}{a-b}\cdot a^{n-1}+\dfrac{x_2-ax_1}{b-a}\cdotb^{n-1}\]</span> ​ 为了便于记忆，我们令<span class="math inline">\(\left\{\begin{array}{2}\alpha=\dfrac{x_2-bx_1}{a-b}\cdot\dfrac{1}{a}\\\beta=\dfrac{x_2-ax_1}{b-a}\cdot\dfrac{1}{b}\end{array}\right.\)</span>，所以<span class="math inline">\(x_n = \alpha \cdot a^{n}+\beta\cdotb^{n}\)</span>。</p><p>​ 解题时只需要根据数列<span class="math inline">\(\{x_n\}\)</span>的递推公式写出相应的特征方程，得到解<span class="math inline">\(a、b\)</span>，再根据<span class="math inline">\(x_1、x_2\)</span>待定系数求解出<span class="math inline">\(\alpha、\beta\)</span>即可得到该数列通项公式。下面是一个例子：</p><p>​ <span class="math inline">\(Fibonacci\)</span>数列是大家非常熟悉的一个数列，它满足这样的条件：<span class="math inline">\(a_1=a_2=1\)</span>，<span class="math inline">\(a_{n+1}=a_n+a_{n-1}\)</span>，求<span class="math inline">\(Fibonacci\)</span>数列的通项公式。</p><p>​ 由递推关系式：<span class="math inline">\(a_{n+1}=a_n+a_{n-1}\)</span>得到特征方程：<span class="math inline">\(x^2-x-1=0\)</span>。</p><p>​ 这个方程的解为：<span class="math inline">\(a=\dfrac{\sqrt5+1}{2}\)</span>，<span class="math inline">\(b=\dfrac{-\sqrt5+1}{2}\)</span></p><p>​ 所以他的通项公式可以写成：<span class="math inline">\(x_n = \alpha\cdot \left( \dfrac{\sqrt{5}+1}{2} \right)^{n-1} + \beta \cdot \left(\dfrac{-\sqrt{5}+1}{2} \right)^{n-1}\)</span></p><p>​ 代入<span class="math inline">\(a_1=a_2=1\)</span>，解出<span class="math inline">\(\alpha=\dfrac{1}{\sqrt5}\)</span>，<span class="math inline">\(\beta=-\dfrac{1}{\sqrt5}\)</span>。</p><p>​ 所以<span class="math inline">\(Fibonacci\)</span>数列的通项为：$x_n = $</p><p>​</p><p>​ <code>2.</code>方程解相等<span class="math inline">\((a=b)\)</span>时：</p><p>​ <span class="math inline">\(x_{n+1}=px_{n}+qx_{n-1}\)</span>可以写成<span class="math inline">\(x_{n+1}-bx_{n}=b(x_{n}-bx_{n-1})\)</span>，对<span class="math inline">\(\{x_{n+1}-bx_n\}\)</span>​这个数列进行累乘得：<span class="math display">\[x_{n+1}-bx_n=b^{n-1}(x_2-bx_1)\]</span> ​ 两边同时除以<span class="math inline">\(b^{n+1}\)</span>有：</p><p>​<br><span class="math display">\[\dfrac{x_{n+1}}{b^{n+1}}-\dfrac{x_{n}}{b^{n}}=\dfrac{x_{2}}{b^2}-\dfrac{x_1}{b}\]</span> ​ 这说明数列<span class="math inline">\(\left\{\dfrac{x_{n}}{b^{n}}\right\}\)</span>是一个等差数列，公差为<span class="math inline">\(\dfrac{x_{2}}{b^2}-\dfrac{x_1}{b}\)</span>。</p><p>​ 由此可以求得：<span class="math inline">\(\dfrac{x_{n}}{b^{n}}=(n-1)\left(\dfrac{x_{2}}{b^{2}}-\dfrac{x_{1}}{b}\right)+\dfrac{x_{1}}{b}\)</span>，</p><p>​ 所以：<span class="math inline">\(x_n=x_1 \cdotb^{n-1}+(x_2-bx_1)(n-1)\cdot b^{n-2}\)</span>，</p><p>​ 整理一下，<span class="math inline">\(x_n=\left[\left(\dfrac{x_{1}}{b}-\dfrac{x_{2}}{b^2}+\dfrac{1}{b}\right)+\left(\dfrac{-x_{1}}{b}+\dfrac{-x_{2}}{b^2}\right)n\right]b^n\)</span>。</p><p>​ 同理我们可以令<span class="math inline">\(\left\{\begin{array}{2}\alpha=\dfrac{x_{1}}{b}-\dfrac{x_{2}}{b^2}+\dfrac{1}{b}\\\beta=\dfrac{-x_{1}}{b}+\dfrac{-x_{2}}{b^2}\end{array}\right.\)</span>，所以<span class="math inline">\(x_n=(\alpha+\beta n)\cdot b^n\)</span>。</p><p>​ 解题时只需要待定系数求出<span class="math inline">\(\alpha、\beta\)</span>即可得到通项公式。</p><h2 id="partⅲ-从递推到矩阵">PartⅢ 从递推到矩阵</h2><p>​上面都是低阶的问题，如果碰到更高阶的常系数线性齐次递推式子呢？由于是预备知识，在这里不详述，可以先看下面这一篇知乎上的文章↓：</p><p>​ <a href="https://zhuanlan.zhihu.com/p/33854447">二阶常系数齐次线性递推数列- 知乎 (zhihu.com)</a></p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 大学数学预备知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递推 </tag>
            
            <tag> 常系数线性齐次 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第零篇 认识深度学习</title>
      <link href="/2024/03/17/di-ling-pian-ren-shi-shen-du-xue-xi/"/>
      <url>/2024/03/17/di-ling-pian-ren-shi-shen-du-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="第零篇-初识深度学习">第零篇 初识深度学习</h1>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 深度学习简介 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 什么是深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
